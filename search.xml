<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一些c++库的使用总结</title>
      <link href="/posts/b945c282.html"/>
      <url>/posts/b945c282.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍一些c++库的使用。</p><h1 id="gflags"><a href="#gflags" class="headerlink" title="gflags"></a>gflags</h1><h2 id="简单实用"><a href="#简单实用" class="headerlink" title="简单实用"></a>简单实用</h2><p>gflags是一个流行的解析命令行的c++库。用户使用这个库定义的变量，可以通过多种途径进行赋值。</p><p>gflags支持定义多种数据类型，包括bool、int32、int64、uint64、double、string。</p><p>定义一个变量的操作如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_bool(<span class="name">name</span>, <span class="string">"default value"</span>, description)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后在main函数开头添加<code>google::ParseCommandLineFlags(&amp;argc, &amp;argv, true);</code>，在main函数末尾添加<code>google::ShutDownCommandLineFlags();</code>。</p><p>如果需要使用一个已经定义过的flags变量，则需要使用<code>DECLARE_XXX</code>，否则将会提示没有申明过这个变量。</p><p>gflags提供参数校验器，使用RegisterFlagValidator函数注册校验器。</p><p>gflags提供google::SetVersionString()函数设置版本信息(—version时返回的字符)。</p><p>gflags提供gflags::SetUsageMessage函数设置帮助信息（—help时返回的字符）。</p><p>gflags提供–flagfile参数指定配置文件，gflags将从这个配置文件中读取配置信息，同时，这个配置文件中也支持—flagfile读取配置。</p><p>gflags提供—fromenv参数从环境变量中读取配置信息。</p><h2 id="编译实用"><a href="#编译实用" class="headerlink" title="编译实用"></a>编译实用</h2><p>gflags一个比较坑的地方是，默认情况下gflags库的namespace是flags，而一大批依赖这个库的第三方库使用的google名字空间下的gflags。为了解决这个问题，需要在编译时指定名字空间（添加参数-DGFLAGS_NAMESPACE=google)。</p><p>有时候可能把gflags链接到动态链接库中，编译时的flags需要添加-fPIC，解决方法是在gflags中找到CMakeLists.txt中添加add_compile_options(-fPIC) 。</p><p>默认情况下gflags使用Release编译的，为了方便调试，建议设置-DCMAKE_BUILD_TYPE=RelWithDebInfo，即设置-o2 -g</p><h1 id="glog"><a href="#glog" class="headerlink" title="glog"></a>glog</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>又是一个使用方便的日志库，这个库是同步日志的，性能不是特别好，不适合高并发中使用。</p><p>使用起来极其方便，包含头文件(glog/logging.h)，然后直接使用。</p><p>需要注意的是，FATAL日志会出core。</p><p>glog支持DLOG功能，这类日志在添加NDEBUG下不会打印DLOG日志，在没有这个flag下会打印这个日志，方便用户调试。</p><p>glog支持VLOG功能，这类日志划分为多个级别，通过命令行参数控制打印的级别。</p><p>使用时，在main函数开始添加google::InitGoogleLogging(argv[0]);开启使用glog之旅。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>glog依赖gflags库，使用glog的话建议先安装一下gflags，同时名字空间设置成google。</p><p>编译glog之前，先指定gflags路径，使用参数CMAKE_INCLUDE_PATH和CMAKE_LIBRARY_PATH完成。</p><h1 id="rocksdb"><a href="#rocksdb" class="headerlink" title="rocksdb"></a>rocksdb</h1><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p>这个库依赖flags，所以编译前可以指定一下gflags，并添加参数-DWITH_GFLAGS=1指定依赖flags。</p><h1 id="fruit"><a href="#fruit" class="headerlink" title="fruit"></a>fruit</h1><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>这是一个基于元编程实现的依赖注入库。</p><h2 id="编译-2"><a href="#编译-2" class="headerlink" title="编译"></a>编译</h2><p>这个库依赖boost，编译时需要指定boost的目录，使用参数-DBoost_INCLUDE_DIR=指定boost位置。</p><p>这个库编译时建议添加-DBUILD_SHARED_LIBS=OFF关闭动态链接库。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>asio_multithread</title>
      <link href="/posts/aef5c1c6.html"/>
      <url>/posts/aef5c1c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>boost.asio是boost中的一个基于事件的网络库。本文将介绍asio的多线程模型。<br>asio有两种支持多线程的方案：方案一，开启一个线程池，每个线程独占一个io_context，并在各自的线程中运行io_context的run方法；方案二，开启一个线程池，并创建一个全局的io_context，在每个线程中调用io_context的run方法。<br>备注：新版本的asio使用io_context代替io_servvice。</p><h1 id="多io-context方案"><a href="#多io-context方案" class="headerlink" title="多io_context方案"></a>多io_context方案</h1><p>在这个多线程方案中，每个线程拥有一个io_context对象，同一个socket不会在多线程中共享，因此不需要引入同步机制。针对io型服务来说，io_context的数量应与cpu数量保持一致；针对计算型服务，请求阻塞了当前线程，当前线程将无法处理其他事件。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>接着我们来讲一讲这个方案的实现。<br>为了实现线程池中每个线程拥有一个io_context对象，我们需要先实现一个context池，然后供线程池和其他操作使用。幸运的是，asio代码库的example中提供了这样一个<a href="https://github.com/boostorg/asio/tree/develop/example/cpp03/http/server2" target="_blank" rel="noopener">例子</a>。io_context_pool类即是上文提到的context池，其申明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">io_context_pool</span> :</span> <span class="keyword">private</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">io_context_pool</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> pool_size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">  boost::<span class="function">asio::io_context&amp; <span class="title">get_io_context</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;boost::asio::io_context&gt; io_context_ptr;</span><br><span class="line">  <span class="keyword">typedef</span> boost::asio::executor_work_guard&lt;</span><br><span class="line">    boost::asio::io_context::executor_type&gt; io_context_work;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;io_context_ptr&gt; io_contexts_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;io_context_work&gt; work_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> next_io_context_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类中提供了三个方法：</p><ul><li>run方法，创建线程池并在每个线程中运行io_context的run方法</li><li>stop方法，停用所有io_context</li><li>get_io_context方法，使用roundrobin算法获取io_context对象</li></ul><p>接着io_context_pool类对象作为server类的成员变量，在start_accept函数和构造函数中使用。server类的声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span> :</span> <span class="keyword">private</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">server</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; port, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; doc_root, <span class="built_in">std</span>::<span class="keyword">size_t</span> io_context_pool_size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp; e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_stop</span><span class="params">()</span></span>;</span><br><span class="line">  io_context_pool io_context_pool_;</span><br><span class="line">  boost::asio::signal_set signals_;</span><br><span class="line">  boost::asio::ip::tcp::acceptor acceptor_;</span><br><span class="line">  connection_ptr new_connection_;</span><br><span class="line">  request_handler request_handler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="共享io-context方案"><a href="#共享io-context方案" class="headerlink" title="共享io_context方案"></a>共享io_context方案</h1><p>这种方案先创建一个全局的io_context对象，然后开启线程池，在每个线程中调用io_context的run方法。当出现异步事件时，io_context对象会将事件句柄交付给任意线程进行处理。这时io_context不会被某个事件阻塞，但多个线程共享事件循环可能导致socket描述符被多个线程共享，引起竞态条件，为此需要使用asio提供的strand方法来解决io问题。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>这个方案实现起来相对简单，不再需要实现context池，只需要实现一个线程池，并在线程池中执行io_context的run方法即可。在asio库中包含了这个<a href="https://github.com/boostorg/asio/tree/develop/example/cpp03/http/server3" target="_blank" rel="noopener">例子</a>，在线程池中运行全局的io_context的run方法。</p><p>server类的声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span> :</span> <span class="keyword">private</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">server</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; port, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; doc_root, <span class="built_in">std</span>::<span class="keyword">size_t</span> thread_pool_size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_accept</span><span class="params">(<span class="keyword">const</span> boost::system::error_code&amp; e)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handle_stop</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> thread_pool_size_;</span><br><span class="line">  boost::asio::io_context io_context_;</span><br><span class="line">  boost::asio::signal_set signals_;</span><br><span class="line">  boost::asio::ip::tcp::acceptor acceptor_;</span><br><span class="line">  connection_ptr new_connection_;</span><br><span class="line">  request_handler request_handler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从server类的声明中可以看到，全局的io_context对象存储在io_context_变量中，并在run函数和构造函数中进行使用。</p><h1 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h1><p>上面讲了两种方案的实现，这一节做一个简单的性能测试。<br>asio的example提供的两个server实现了基本的http server，本次用于测试的客户端使用brpc的http客户端，进行测试的serer开启六个个线程。这是本次性能测试使用的<a href="https://github.com/phantom9999/asio_benchmarks" target="_blank" rel="noopener">代码库</a>。<br>测试结果显示，这两种方案的峰值qps都在2w左右，性能差不多。<br>这两个server都会进行文件读写操作，一定程度上影响了测试结果，且本文使用的代码并没有进行优化，这也可能无法正确区分两种方案的性能差异。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="The Boost C++ Libraries Chapter 32. Boost.Asio">The Boost C++ Libraries Chapter 32. Boost.Asio</a></li><li><a href="https://www.gamedev.net/blogs/entry/2249317-a-guide-to-getting-started-with-boostasio/" target="_blank" rel="noopener">A guide to getting started with boost::asio</a></li><li><a href="http://www.boost.org/doc/libs/1_59_0/doc/html/boost_asio/overview/core/strands.html" target="_blank" rel="noopener">Strands: Use Threads Without Explicit Locking</a></li><li><a href="http://thisthread.blogspot.com/2012/04/post-on-asio-strand.html" target="_blank" rel="noopener">Post on ASIO strand</a></li><li><a href="https://stackoverflow.com/questions/39097644/how-strands-guarantee-correct-execution-of-pending-events-in-boost-asio" target="_blank" rel="noopener">How strands guarantee correct execution of pending events in boost.asio</a></li><li><a href="https://sourceforge.net/p/asio/mailman/message/19485596/" target="_blank" rel="noopener">asio C++ library</a><br><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3388.pdf" target="_blank" rel="noopener">Using Asio with C++11</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>beast</title>
      <link href="/posts/3347ea06.html"/>
      <url>/posts/3347ea06.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>asio</title>
      <link href="/posts/9d5b3554.html"/>
      <url>/posts/9d5b3554.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/" target="_blank" rel="noopener">Boost.Asio C++ 网络编程</a></li><li><a href="https://segmentfault.com/a/1190000007225464" target="_blank" rel="noopener">基于 Asio 的 C++ 网络编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/37590580" target="_blank" rel="noopener">C++网络编程之ASIO(一)</a></li><li><a href="http://think-async.com/Asio/asio-1.12.2/doc/" target="_blank" rel="noopener">asio文档</a></li><li><a href="http://think-async.com/Asio/boost_asio_1_12_2/doc/html/boost_asio.html" target="_blank" rel="noopener">boost.asio文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v8嵌入式开发--v8js篇</title>
      <link href="/posts/137637df.html"/>
      <url>/posts/137637df.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>v8js是一个特殊的php拓展, 其作用是将v8嵌入到php中, 使得用户可以在php中运行js代码. 同时, 经过作者的努力, 运行在php中的js可以无缝访问并php中的数据结构, 调用php內建的函数, 从而实现”1 + 1 &gt; 2”的目标. 本文将跟随作者的, 领略v8js的风采.</p><h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>使用一个工具是了解这个工具的最好方式, 笔者将在这一节中介绍v8js拓展的功能及使用.</p><p>首先介绍一下v8js的提供的接口, v8js的接口如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V8Js</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* Constants */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> V8_VERSION = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FLAG_NONE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> FLAG_FORCE_ARRAY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> FLAG_PROPAGATE_PHP_EXCEPTIONS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes and starts V8 engine and returns new V8Js object with it's own V8 context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $object_name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $variables</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $extensions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bool $report_uncaught_exceptions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $snapshot_blob</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($object_name = <span class="string">"PHP"</span>, array $variables = [], array $extensions = [], $report_uncaught_exceptions = TRUE, $snapshot_blob = NULL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provide a function or method to be used to load required modules. This can be any valid PHP callable.</span></span><br><span class="line"><span class="comment">     * The loader function will receive the normalised module path and should return Javascript code to be executed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable $loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setModuleLoader</span><span class="params">(callable $loader)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provide a function or method to be used to normalise module paths. This can be any valid PHP callable.</span></span><br><span class="line"><span class="comment">     * This can be used in combination with setModuleLoader to influence normalisation of the module path (which</span></span><br><span class="line"><span class="comment">     * is normally done by V8Js itself but can be overriden this way).</span></span><br><span class="line"><span class="comment">     * The normaliser function will receive the base path of the current module (if any; otherwise an empty string)</span></span><br><span class="line"><span class="comment">     * and the literate string provided to the require method and should return an array of two strings (the new</span></span><br><span class="line"><span class="comment">     * module base path as well as the normalised name).  Both are joined by a '/' and then passed on to the</span></span><br><span class="line"><span class="comment">     * module loader (unless the module was cached before).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable $normaliser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setModuleNormaliser</span><span class="params">(callable $normaliser)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compiles and executes script in object's context with optional identifier string.</span></span><br><span class="line"><span class="comment">     * A time limit (milliseconds) and/or memory limit (bytes) can be provided to restrict execution. These options will throw a V8JsTimeLimitException or V8JsMemoryLimitException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $script</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $identifier</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $flags</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $time_limit in milliseconds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $memory_limit in bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">executeString</span><span class="params">($script, $identifier = <span class="string">''</span>, $flags = V8Js::FLAG_NONE, $time_limit = <span class="number">0</span>, $memory_limit = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compiles a script in object's context with optional identifier string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $script</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $identifier</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> resource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">compileString</span><span class="params">($script, $identifier = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes a precompiled script in object's context.</span></span><br><span class="line"><span class="comment">     * A time limit (milliseconds) and/or memory limit (bytes) can be provided to restrict execution. These options will throw a V8JsTimeLimitException or V8JsMemoryLimitException.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource $script</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $flags</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $time_limit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $memory_limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">executeScript</span><span class="params">($script, $flags = V8Js::FLAG_NONE, $time_limit = <span class="number">0</span> , $memory_limit = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the time limit (in milliseconds) for this V8Js object</span></span><br><span class="line"><span class="comment">     * works similar to the set_time_limit php</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setTimeLimit</span><span class="params">($limit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the memory limit (in bytes) for this V8Js object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setMemoryLimit</span><span class="params">($limit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the average object size (in bytes) for this V8Js object.</span></span><br><span class="line"><span class="comment">     * V8's "amount of external memory" is adjusted by this value for every exported object.  V8 triggers a garbage collection once this totals to 192 MB.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $average_object_size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setAverageObjectSize</span><span class="params">($average_object_size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns uncaught pending exception or null if there is no pending exception.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> V8JsScriptException|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPendingException</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears the uncaught pending exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">clearPendingException</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Static methods **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers persistent context independent global Javascript extension.</span></span><br><span class="line"><span class="comment">     * NOTE! These extensions exist until PHP is shutdown and they need to be registered before V8 is initialized.</span></span><br><span class="line"><span class="comment">     * For best performance V8 is initialized only once per process thus this call has to be done before any V8Js objects are created!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $extension_name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $dependencies</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bool $auto_enable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">registerExtension</span><span class="params">($extension_name, $code, array $dependencies, $auto_enable = FALSE)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns extensions successfully registered with V8Js::registerExtension().</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array|string[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a custom V8 heap snapshot with the provided JavaScript source embedded.</span></span><br><span class="line"><span class="comment">     * Snapshots are supported by V8 4.3.7 and higher.  For older versions of V8 this</span></span><br><span class="line"><span class="comment">     * extension doesn't provide this method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $embed_source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string|false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createSnapshot</span><span class="params">($embed_source)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V8JsScriptException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsFileName</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsLineNumber</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsStartColumn</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsEndColumn</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsSourceLine</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJsTrace</span><span class="params">( )</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V8JsTimeLimitException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V8JsMemoryLimitException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面接口的注释可以知道, 使用v8js拓展执行js代码时, 基本流程是先创建一个V8Js类的对象, 然后执行成员函数executeString, 函数返回的结果即是js的执行结果.</p><p>V8js的成员函数<code>setTimeLimit</code>和<code>setMemoryLimit</code>函数用于设置js执行的时间限制和内存限制.</p><p>使用例子后续补充.</p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><p>接着讲一讲v8js拓展的架构设计. v8js模块包含了一个计时器线程, 计时任务双线队列, 全局变量结构体. 在全局变量结构体中存储了v8的platform. v8js模块中实现了一个名为V8Js的类, 在这个类的构造函数中, v8js会出现一个isolate对象, 并创建一个全局上下文. 那么v8js模块中, 一个V8Js类的对象包含一个独立的isolate对象. 整体架构如下图所示:</p><h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="js代码执行"><a href="#js代码执行" class="headerlink" title="js代码执行"></a>js代码执行</h2><p>v8的源码中提供了一个hello的代码, 如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化周边数据</span></span><br><span class="line">v8::V8::InitializeICUDefaultLocation(argv[<span class="number">0</span>]);</span><br><span class="line">v8::V8::InitializeExternalStartupData(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建platform</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化V8环境</span></span><br><span class="line">v8::V8::InitializePlatform(platform.<span class="built_in">get</span>());</span><br><span class="line">v8::V8::Initialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造参数</span></span><br><span class="line">v8::Isolate::CreateParams create_params;</span><br><span class="line">create_params.array_buffer_allocator = v8::ArrayBuffer::Allocator::NewDefaultAllocator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建isolate对象(v8虚拟机实例)</span></span><br><span class="line">v8::Isolate* isolate = v8::Isolate::New(create_params);</span><br><span class="line">v8::<span class="function">Isolate::Scope <span class="title">isolate_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"><span class="function">v8::HandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文</span></span><br><span class="line">v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate);</span><br><span class="line">v8::<span class="function">Context::Scope <span class="title">context_scope</span><span class="params">(context)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将普通字符串转化为V8的字符串</span></span><br><span class="line">v8::Local&lt;v8::<span class="keyword">String</span>&gt; source = v8::<span class="keyword">String</span>::NewFromUtf8(isolate, <span class="string">"'Hello' + ', World!'"</span>,  v8::NewStringType::kNormal).ToLocalChecked();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line">v8::Local&lt;v8::Script&gt; script = v8::Script::Compile(context, source).ToLocalChecked();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果转化为普通字符串</span></span><br><span class="line">v8::<span class="function"><span class="keyword">String</span>::Utf8Value <span class="title">utf8</span><span class="params">(isolate, result)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *utf8);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁isolate</span></span><br><span class="line">isolate-&gt;Dispose();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁V8环境和platform</span></span><br><span class="line">v8::V8::Dispose();</span><br><span class="line">v8::V8::ShutdownPlatform();</span><br><span class="line"><span class="keyword">delete</span> create_params.array_buffer_allocator;</span><br></pre></td></tr></table></figure><p>从demo可以看到, 运行一个js脚本需要的操作包括:</p><ul><li>创建platform</li><li>创建isolate</li><li>创建context</li><li>字符串编译成script</li><li>运行script</li><li>取出结果</li><li>销毁环境</li></ul><p>v8js拓展将platform创建放在了第一个V8Js类的构造函数中; isolate和context的创建放在了V8Js的构造函数. executeString中执行了编译和运行script的操作. 对象析构的时候销毁isolate对象. 模块退出的时候销毁platform等操作.</p><h2 id="內建函数实现"><a href="#內建函数实现" class="headerlink" title="內建函数实现"></a>內建函数实现</h2><p>在这个部分需要介绍一下v8的template机制以及v8各个元素之间的关系. 下面是v8的常用名词:</p><ul><li>platform 平台, 一个进程中可以有多个, 但是只有一个生效</li><li>isolate v8虚拟机, 可以存在多个, 一个isolate同一时间只允许一个线程访问</li><li>context 运行上下文, 可以有多个, 可以嵌套, 从属于isolate.</li><li>scope 作用域, isolate和context都有scope, 用于垃圾回收处理</li><li>template 模板, 用于创建函数和对象, 从属于isolate</li></ul><p>在v8中, 对象和函数从属于context, 而context在isolate的scope销毁时会被一同销毁, 那么这些对象和函数需要在context创建的时候被不停的创建, 为了省去这部分工作量, v8引入了template, 用于创建对象和函数.</p><p>內建函数的实现就是基于template实现的. 首先V8Js的的构造函数中会创建一个template对象, 然后再这个对象中添加functionTemplate对象, 而这些functionTemplate对象封装了內建函数. 在contenxt创建的时候, 将这个template对象作为实参传入, 那么创建出来的context就包含了內建函数.</p><p>template包含ObjectTemplate和FunctionTemplate两种, 前者创建对象, 后者创建函数. 如果用户想创建一个类呢? 由于js早期并不存在class关键词, 创建一个类的对象都是通过函数实现的. 所以创建一个类需要使用的是FunctionTemplate.</p><p>v8js拓展的內建函数的具体实现在文件”v8js_methods.cc”中, 在<code>v8js_register_methods</code>函数中将这些內建函数添加到template对象中. 这个函数在V8Js类的构造函数中被调用, 位置在contenxt被创建之前.</p><h2 id="commonjs模块实现"><a href="#commonjs模块实现" class="headerlink" title="commonjs模块实现"></a>commonjs模块实现</h2><p>首先讲一下什么是commonjs模块规范. “规范”认为, 每个文件是一个模块(module), 并拥有其自己的作用域. 在这个作用域内声明的变量和函数都是这个作用域私有的. 模块信息存储在module对象中, module提供exports对象用于暴露作用域内的函数/变量. 模块之间通过require函数加载其他的模块.</p><p>为了实现上面规范, 在每个文件的作用域内, 需要提前声明module, exports对象和require函数. 并且module和exports对象存在于模块中, 模块间的module和exports都不同. 参考上文中的template的功能, module和exports可以实现为两个ObjectTemplate, 并注册到主ObjectTemplate. 同样, require也可以类似实现. 这时基于主ObjectTemplate创建context, 并在这个context运行指定文件, 并提取exports, 即可暴露指定的接口(变量和函数).</p><p>考虑到重新创建context成本较大, v8的context支持基于老context创建新的context, 但是基于这种方式就无法使用到template了. nodejs的解决方案是, 创建一个函数, 在函数体中添加模块的代码, 将module/exports/require作为形参传入到. 例如, 模块的代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><p>nodejs编译编译这个代码之前, 将这个模块的代码处理为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value + x;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">module</span>.exports.x = x;</span><br><span class="line">    <span class="built_in">module</span>.exports.addX = addX;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后, 创建module对象, exports对象, reuqire函数, 将这三个作为实参传入到生成的函数中去, 最后提取module和exports对象缓存起来. 当其他的模块reuqire这个模块时, 先查缓存, 命中缓存则直接返回exports对象.<br>v8js借鉴了nodejs的方式实现了一个commonjs模块.<br>由于reuqire一个模块时, 可以指定模块的相对路径, 这就要求reuqire在被调用时能够知道调用reuqire的文件的绝对路径. v8创建函数时支持给函数传递一个meta数据, v8js利用这个特性给require传递了路径数据. “v8js_commonjs.cc”中实现了一套相对路径推算绝对路径的代码, 使用c++17或者boost的话, 可以使用filesystem的canonical函数解决.</p><h2 id="超限功能实现"><a href="#超限功能实现" class="headerlink" title="超限功能实现"></a>超限功能实现</h2><p>前文提到v8js拓展包含一个计时器线程和计时任务队列, v8js依靠它们实现了超限功能.<br>V8Js类的对象在执行js脚本时, v8js会基于isolate/context/超时配置/内存限制创建一个超限任务, 并添加到计时任务队列中.<br>计时器线程会取出队列中的任务, 检查是否超时, 内存是否超限. 对超限的任务, 超时线程将终止任务运行. 在判断内存超限时, 计时器线程需要先解锁isolate, 然后获取堆统计信息, 如果超限就手工gc并终止当前任务.</p><h2 id="js中调用php数据实现"><a href="#js中调用php数据实现" class="headerlink" title="js中调用php数据实现"></a>js中调用php数据实现</h2><p>这部分略</p><h1 id="改进与优化"><a href="#改进与优化" class="headerlink" title="改进与优化"></a>改进与优化</h1><h2 id="isolate归属问题"><a href="#isolate归属问题" class="headerlink" title="isolate归属问题"></a>isolate归属问题</h2><p>在v8js中isolate是V8Js对象级别的, 事实上isolate和全局context的创建成本较大, 并不适合放在对象级别. 基于php单线程运行的特点, isolate和全局context可以存放在线程级别中. 每次执行脚本时, 基于全局context创建新的context.</p><h1 id="学习总结"><a href="#学习总结" class="headerlink" title="学习总结"></a>学习总结</h1><ul><li>学习了js脚本运行的流程</li><li>学习了v8中各个名词之间的关系</li><li>学习了多isolate的使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> v8 </tag>
            
            <tag> js </tag>
            
            <tag> javascript </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-addon-api使用文档</title>
      <link href="/posts/10f6a378.html"/>
      <url>/posts/10f6a378.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>“node-addon-api”是nodejs的”n-api”接口的c++封装, 通过提供c++对象模型和异常异常处理方式, 简化nodejs开发的成本.</p><p>“n-api”是nodejs为原生拓展提供的c语言风格ABI, 它独立于js运行环境, 旨在屏蔽js运行环境的差异, 让拓展能够运行在不同版本的nodejs下.</p><p>“node-addon-api”不作为nodejs的组件发布, 它只是基于nodejs的”n-api”, 这样, “node-addon-api”将于nodejs本身解耦, 基于”node-addon-api”的拓展运行在新nodejs环境时, 不需要重新编译.</p><p>值得注意的是, nodejs的其他接口, 例如<code>libuv</code>等, 并不包含在nodejs的拓展ABI内, 基于这些接口开发的nodejs拓展无法保证在多个版本的nodejs环境中运行. 由于”n-api”是nodejs 6.x之后才出现的, 因此这套ABI只支持nodejs6.x之后的版本.</p><p>当新的api被添加到n-api后, node-addon-api必须马上更新, 否则node-addon-api就无法使用这部分特性.</p><p>本文将数据结构, 异常处理, 与js交互等多个方面介绍node-addon-api.</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>首先是node-addon-api的数据结构, node-addon-api的数据结构是封装的n-api的, 我把它的数据结构分为两类, 一类是js中有直接对应类型的, 另一类是js中没有直接对应的类型, 但node-addon-api中出现的.</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><table><thead><tr><th>js类型</th><th>c++类</th><th>说明</th></tr></thead><tbody><tr><td>string</td><td>String</td><td>字符串, 使用unicode存储</td></tr><tr><td>number</td><td>Number</td><td>数字, 使用浮点存储</td></tr><tr><td>boolean</td><td>Boolean</td><td>布尔值</td></tr><tr><td>bigInt</td><td>BigInt</td><td>大整形, 新引入, 使用uint64数组存储</td></tr><tr><td>object</td><td>Object</td><td>对象</td></tr><tr><td>symbol</td><td>Symbol</td><td>符号</td></tr><tr><td>Buffer</td><td>Buffer</td><td>二进制类型, 不受gc管理</td></tr><tr><td>function</td><td>Function</td><td>函数类型</td></tr><tr><td>arrayBuffer</td><td>ArrayBuffer</td><td>buffer数组类型</td></tr><tr><td>typedArray</td><td>TypedArray</td><td>类型数组</td></tr><tr><td>DataView</td><td>DataView</td><td>视图</td></tr><tr><td>promises</td><td>Promises</td></tr></tbody></table><h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><table><thead><tr><th>特殊类型</th><th>说明</th></tr></thead><tbody><tr><td>Name</td><td>特殊的类型, 可以用来作为类的属性名, 支持字符串和symbol</td></tr><tr><td>Env</td><td>特殊结构, 包含了当前请求的运行环境</td></tr><tr><td>Value</td><td>js类型的c++表现类型, js类型的基类</td></tr><tr><td>CallbackInfo</td><td>特殊结构, 包含函数参数列表和Env对象, 常出现在c++实现的js函数参数表中, , 由nodejs环境生成传递给自定义函数.</td></tr><tr><td>Reference</td><td>特殊引用类型, 类似于c++中的shared_ptr, 创建时不添加计数器. 当计数器为0时, 不负责删除数据, 使用垃圾回收机制回收数据.</td></tr><tr><td>External</td><td>用来包装c++数据的结构, 方便用户管理自定义结构, 这个类提供自定义清理函数接口, 可以让用户制定清理方法.</td></tr><tr><td>ObjectReference</td><td>对象引用类型, 是Reference的子类, 包含引用对象和一个计数器, 相当于shared_ptr.</td></tr><tr><td>PropertyDescriptor</td><td>js对象的属性描述, 可以是函数/变量/访问控制等.</td></tr><tr><td>FunctionReference</td><td></td></tr><tr><td>ObjectWrap</td><td></td></tr><tr><td>ClassPropertyDescriptor</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table><h2 id="对象及引用"><a href="#对象及引用" class="headerlink" title="对象及引用"></a>对象及引用</h2><h1 id="与js交互"><a href="#与js交互" class="headerlink" title="与js交互"></a>与js交互</h1><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><h2 id="js函数调用"><a href="#js函数调用" class="headerlink" title="js函数调用"></a>js函数调用</h2><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="额外类型"><a href="#额外类型" class="headerlink" title="额外类型"></a>额外类型</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><h1 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h1><h1 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="对象生命周期管理"><a href="#对象生命周期管理" class="headerlink" title="对象生命周期管理"></a>对象生命周期管理</h2><h1 id="异步操作-1"><a href="#异步操作-1" class="headerlink" title="异步操作"></a>异步操作</h1><h1 id="promises"><a href="#promises" class="headerlink" title="promises"></a>promises</h1><h1 id="版本管理-1"><a href="#版本管理-1" class="headerlink" title="版本管理"></a>版本管理</h1>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>node-addon-api-example</title>
      <link href="/posts/ebe76269.html"/>
      <url>/posts/ebe76269.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v8_learn</title>
      <link href="/posts/c7657d28.html"/>
      <url>/posts/c7657d28.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>graphviz_learn</title>
      <link href="/posts/3a17fc38.html"/>
      <url>/posts/3a17fc38.html</url>
      
        <content type="html"><![CDATA[<p>参考: <a href="http://blog.jobbole.com/94472/" target="_blank" rel="noopener">graphviz教程</a></p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>boost_learn</title>
      <link href="/posts/a9053cb5.html"/>
      <url>/posts/a9053cb5.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nodejs_ext</title>
      <link href="/posts/58b03904.html"/>
      <url>/posts/58b03904.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日志代码收敛(log4cpp/glog)</title>
      <link href="/posts/b270d3a9.html"/>
      <url>/posts/b270d3a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍某项目中日志代码的收敛工作.<br>这个项目由多个模块组成, 各个模块使用的日志系统不同, 有的模块使用log4cpp, 有的模块使用glog.<br>这给项目的管理带来了一定的困难, 因此需要对整个项目进行改造, 统一日志系统.</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="日志库"><a href="#日志库" class="headerlink" title="日志库"></a>日志库</h2><p>目前c++常用并且开源的日志库包括:</p><ul><li>log4cxx</li><li>log4cpp</li><li>log4cplus</li><li>glog</li><li>g3log</li><li>boost.log</li><li>boost.log v2</li></ul><h3 id="log4cxx"><a href="#log4cxx" class="headerlink" title="log4cxx"></a>log4cxx</h3><p>log4cxx是apache的log4j的官方c++实现, 架构类似于log4j, 使用跟log4j兼容的配置文件.<br>这个项目已经不再更新.<br>在centos的软件库中包含了log4cxx的开发包(log4cxx-devel).</p><h3 id="log4cpp"><a href="#log4cpp" class="headerlink" title="log4cpp"></a>log4cpp</h3><p>log4cpp是log4j的一个非官方实现, 与log4j类似的架构, 并且兼容log4j的配置文件.<br>这个项目最新更新的时间是2017, 并且已经一年没更新了.<br>在centos的软件库中包含了log4cpp的开发包(log4cpp-devel).</p><h3 id="log4cplus"><a href="#log4cplus" class="headerlink" title="log4cplus"></a>log4cplus</h3><p>log4cplus是log4j的另一个非官方实现, 与log4j类似的架构, 并且兼容log4j的配置文件.<br>这个项目一直在更新, 并且已经发布2.0版本.<br>在centos的软件库中包含了log4cplus的开发包(log4cplus)</p><h3 id="glog"><a href="#glog" class="headerlink" title="glog"></a>glog</h3><p>glog是谷歌开源的日志系统, 以简单著称, 支持的功能包括:</p><p>1， 参数设置，以命令行参数的方式设置标志参数来控制日志记录行为；<br>2， 严重性分级，根据日志严重性分级记录日志；<br>3， 可有条件地记录日志信息；<br>4， 条件中止程序。丰富的条件判定宏，可预设程序终止条件；<br>5， 异常信号处理。程序异常情况，可自定义异常处理过程；<br>6， 支持debug功能。可只用于debug模式；<br>7， 自定义日志信息；<br>8， 线程安全日志记录方式；<br>9， 系统级日志记录；<br>10， google perror风格日志信息；<br>11， 精简日志字符串信息。</p><h3 id="g3log"><a href="#g3log" class="headerlink" title="g3log"></a>g3log</h3><p>glog不支持异步日志, 并且性能较差. 于是有开发者基于glog开发了支持异步日志的新日志系统, 命名为g3log.</p><h3 id="boost-log-v1"><a href="#boost-log-v1" class="headerlink" title="boost.log v1"></a>boost.log v1</h3><p>这个日志系统出现较早, 但是一直没有合入到boost套装中.<br>用户如果要使用这个库, 则需要单独编译.</p><h3 id="boost-log-v2"><a href="#boost-log-v2" class="headerlink" title="boost.log v2"></a>boost.log v2</h3><p>从boost 1.54开始, boost.log v2加入boost库, 但是目前centos7的boost版本是1.53.<br>boost将日志系统进行分层, 类似于log4j, 并且同时支持同步和异步日志.</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>目前项目的A模块使用log4cpp作为日志</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spinlock</title>
      <link href="/posts/4a74a9d.html"/>
      <url>/posts/4a74a9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将介绍自旋锁的原理, 并封装linux提供的自旋锁, 最后介绍boost提供的自旋锁.</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理等部分（对于单处理器来说，防止中断处理中的并发可简单采用关闭中断的方式，即在标志寄存器中关闭/打开中断标志位，不需要自旋锁）。</p><p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><p>跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁可能存在两个问题：<br>死锁。试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”,也无法获得资源，从而进入死循环。<br>过多占用cpu资源。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会。<br>由此可见，自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用，而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。<br>上面简要介绍了自旋锁的基本原理，以下将给出具体的例子，进一步阐释自旋锁在实际系统中的应用。上面我们已经讲过自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，下面我们就以SMP为例，来说明为什么要使用自旋锁，以及自旋锁实现的基本算法。</p><p>通俗的讲, 自旋锁是一种不放弃CPU资源的锁.</p><h1 id="自旋锁使用"><a href="#自旋锁使用" class="headerlink" title="自旋锁使用"></a>自旋锁使用</h1><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SpinLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        pthread_spin_lock(&amp;spinlock_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        pthread_spin_unlock(&amp;spinlock_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pthread_spinlock_t spinlock_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SpinLockGuard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SpinLockGuard</span>(<span class="params">SpinLock &amp;spinlock</span>): <span class="title">spinlock_</span>(<span class="params">spinlock</span>)</span> &#123;</span><br><span class="line">        spinlock_.<span class="keyword">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SpinLockGuard() &#123;</span><br><span class="line">        spinlock_.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SpinLock <span class="keyword">lock</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SpinLockGuard <span class="title">guard</span>(<span class="params"><span class="keyword">lock</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="boost版本"><a href="#boost版本" class="headerlink" title="boost版本"></a>boost版本</h1><p>boost中实现了自旋锁功能, 但是没有显示提供, 自旋锁的位置在<code>boost/smarty_ptr/detail/spinlock.hpp</code><br>lockguard在&lt;boost/thread/thread_guard.hpp&gt;.</p><p>使用方法如下:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">using SpinLock = boost::detail::spinlock;</span><br><span class="line">using SpinLockGuard = boost::lock_guard<span class="params">&lt;SpinLock&gt;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SpinLock lock;</span><br><span class="line">&#123;</span><br><span class="line">    SpinLockGuard guard(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spin lock </tag>
            
            <tag> 自旋锁 </tag>
            
            <tag> cpp </tag>
            
            <tag> boost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unite.vim插件使用及配置</title>
      <link href="/posts/b0d02bc6.html"/>
      <url>/posts/b0d02bc6.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要介绍unite.vim的使用与配置.<br>unite.vim是Shougo开发的一款插件, 确切的说, unite就像vim插件里面的vim.<br>这个插件功能繁多, 配置项目较多, 一定程度上怎么了用户的学习成本, 本文将详细介绍这个工具的使用与配置.</p><h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>本文介绍的unite.vim的功能包括unite.vim集成的功能以及第三方插件的功能.<br>unite.vim由于其丰富的功能以及高扩展性, 已经衍生出了多款基于unite.vim的插件.</p><p>unite.vim集成的功能包括:</p><ul><li>bookmark 书签功能</li><li>buffer, buffer_tab buffer浏览功能</li><li>change 列举变动</li><li>command ex命令</li><li>directory, directory/new, directory_mru 目录相关功能</li><li>fie, file/new, file_point, file_rec 文件相关功能</li><li>function 函数相关功能</li><li>grep</li><li>history</li><li>jump, jump_point 跳转相关功能</li><li>launcher</li><li>line, line/fast 行号相关功能</li><li>mapping</li><li>menu</li><li>neocomplete</li><li>output</li><li>process</li><li>resume</li><li>runtimepath</li><li>source</li><li>tab</li><li>vimgrep</li><li>window</li></ul><p>基于unite.vim的插件包括:</p><ul><li>unite-help</li><li>unite-tag</li><li>unite-outline</li><li>unite-colorscheme</li><li>unite-font</li><li>unite-locate</li><li>unite-everything</li><li>unite-mark</li><li>unite-alias</li><li>unite-script</li><li>unite-git_grep</li><li>unite-remotefile</li><li>unite-neco</li><li>unite-rake</li><li>unite-history</li><li>unite-qflist</li><li>unite-gem</li><li>unite-qf</li><li>unite-session</li><li>unite-svn</li><li>unite-rails</li><li>unite-grails</li><li>unite-cake</li><li>unite-zf, unite-sf2</li><li>unite-ack</li><li>unite-launch</li><li>unite-transparency</li><li>quicklearn</li><li>vim_hacks</li><li>haskellimport</li><li>unite-equery</li><li>unite-file-vcs</li><li>unite-radio.vim</li><li>unite-gist</li><li>vim-unite-id</li><li>unite-ref</li></ul><h1 id="buffer功能介绍与配置"><a href="#buffer功能介绍与配置" class="headerlink" title="buffer功能介绍与配置"></a>buffer功能介绍与配置</h1><p>vim中的buffer类似于ide中已经打开的文件, vim将已经打开的文件保存到buffer中, 方便用户去使用.<br>unite.vim内置buffer功能, 使用<code>:Unite source</code>命令可以看到.<br>unite.vim提供的buffer功能包括:</p><ul><li>buffer</li><li>buffer_tab</li></ul><p>其中执行<code>:Unite buffer</code>命令后, 会在新的tab中显示buffer列表, 而执行<code>:Unite buffer_tab</code>后会在当前tab中显示buffer.<br>unite为buffer选择提供了即时搜索的功能, 用户可以搜索关键词, 然后unite查找buffer对应的文件, 然后进行排序. unite查找的内容仅限于路径和文件名.</p><p>vim中有类似功能的插件包括, MinBufExplorer和bufexporer插件.</p><p>bufexporer插件使用简单, 它提供三个命令分别是<code>\be</code>(打开历史文件列表), <code>\bv</code>(水平创建一个tab显示buffer信息), <code>\bs</code>(垂直创建一个tab显示buffer信息).<br>这个插件不需要配置, 加载即可使用. 比较麻烦的是, 快捷键比较逆天, 而且不支持buffer的搜索.</p><p>MinBufExporer会开一个狭小的tab显示buffer列表信息.<br>使用minBufExporer方面, minbufexporer跟bufexporer一样, 不需要配置, 可以直接使用.<br>在minBufExporer使用<code>:bn</code>(下一个buffer), <code>:np</code>(上一个buf), <code>:b”num”</code>,<br><code>:MiniBufExporer</code>(打开tab, 并显示buffer信息), <code>:CMiniBufExporer</code>(关闭buffer的tab).</p><p>与这两个插件相比, unite buffer显得无比强大好用.</p><h1 id="文件查找功能介绍与配置"><a href="#文件查找功能介绍与配置" class="headerlink" title="文件查找功能介绍与配置"></a>文件查找功能介绍与配置</h1><h1 id="outline功能介绍与配置"><a href="#outline功能介绍与配置" class="headerlink" title="outline功能介绍与配置"></a>outline功能介绍与配置</h1>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> unite.vim </tag>
            
            <tag> vim插件 </tag>
            
            <tag> vim配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yaf源码阅读</title>
      <link href="/posts/c1026c5e.html"/>
      <url>/posts/c1026c5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将分别从接口层和实现层解读yaf框架.</p><h1 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>yaf是一个使用c实现的高性能框架. 它以php拓展的形式实现整个php框架.</p><p>它的优点包括:</p><ol><li>用C语言开发的PHP框架, 相比原生的PHP, 几乎不会带来额外的性能开销.</li><li>所有的框架类, 不需要编译, 在PHP启动的时候加载, 并常驻内存.</li><li>更短的内存周转周期, 提高内存利用率, 降低内存占用率.</li><li>灵巧的自动加载. 支持全局和局部两种加载规则, 方便类库共享.</li><li>高性能的视图引擎.</li><li>高度灵活可扩展的框架, 支持自定义视图引擎, 支持插件, 支持自定义路由等等.</li><li>内建多种路由, 可以兼容目前常见的各种路由协议.</li><li>强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失.</li><li>在框架本身,对危险的操作习惯做了禁止.</li><li>更快的执行速度, 更少的内存占用.</li></ol><h2 id="框架执行"><a href="#框架执行" class="headerlink" title="框架执行"></a>框架执行</h2><p>整个框架分为应用程序组件集和其他基础组件集. 在应用程序组件集中包含了, 插件, 分发器, 路由器, 控制器, 启动器等. 基础组件包括, session组件, 注册表组件, 自动加载组件, 配置组件.</p><p>yaf框架包含多个层次, 分别是:</p><ul><li>Application 应用程序, 一个服务作为一个应用程序</li><li>Module 模块, 一个服务包含多个模块</li><li>Controller 控制器, 一个模块包含多个控制器</li><li>Action 动作, 一个控制器包含多个动作</li></ul><p>yaf是传统的php框架, 使用传统的执行流程. 这类执行流程无法上下文复用, 每处理一个请求就要初始化一次框架.</p><p>处理用户请求时, yaf框架先创建应用程序(Application类对象), 应用程序类创建启动器(Bootstrap类对象), 启动器执行分发器加载, 插件加载等操作. 然后应用程序将请求封装成请求对象(Request类对象), 将请求对象交付给分发器, 分发器根据路由器中的路由规则, 获得对应的处理对象. 路由器根据URI信息, 查询路由规则, 找到匹配的路由规则, 根据路由规则获得相应的处理器(Controller类对象), 并将其返回给分发器. 分发器执行处理器, 将处理结果封装成相应对象(Response对象)返回给应用程序. 应用程序将响应对象返回给用户. 框架的执行流程如图所示:</p><p><img src="/images/yaf_sequence.png" alt="yaf执行流程图"></p><h2 id="自动加载组件"><a href="#自动加载组件" class="headerlink" title="自动加载组件"></a>自动加载组件</h2><p>yaf框架为了兼容老版本的php, 提供两种自动加载的策略, 分别是基于下划线的自动加载方案和名字空间加载方案. yaf的加载方案在配置文件中指定.</p><p>yaf中库的分为本地库和全局库, 全局库作用于整个应用程序, 本地库只作用于当前模块(Module), 当当前应用程序中只包含一个模块时, 全局库和本地库的区别只是位置的不同罢了.</p><h3 id="下划线自动加载方案"><a href="#下划线自动加载方案" class="headerlink" title="下划线自动加载方案"></a>下划线自动加载方案</h3><p>这种自动加载方案会对需要加载的类的类名进行处理, 将类名中的下划线(<code>_</code>)替换为替换为斜线(<code>/</code>), 生成类路径, 然后进行库文件查找. 库查找时, 先获得本地库的路径, 接着融合本地库路径和类目录, 得到类文件的绝对路径, 然后判断这个文件是否存在, 如果存在, 则进行加载, 否则进行全局库查找.</p><p>执行的流程如下:</p><div id="flowchart-0" class="flow-chart"></div><h2 id="路由组件"><a href="#路由组件" class="headerlink" title="路由组件"></a>路由组件</h2><h2 id="分发器组件"><a href="#分发器组件" class="headerlink" title="分发器组件"></a>分发器组件</h2><h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><p>从图中可以看到, 整个框架的核心是这个分发器. yaf框架针对分发的执行流程, 在各个执行片段添加了钩子, 并通过这些钩子制作了插件机制.</p><p>yaf的钩子包括:</p><ul><li>routerStartup 在查询路由规则之前执行</li><li>routerShutdown 在查询完路由规则之前执行</li><li>dispatchLoopStart 在分发流程开始前执行</li><li>preDispatch 在分发操作之前执行</li><li>postDispatch 在分发操作完毕执行</li><li>dispatchLoopShutdown 在分发流程结束后执行</li></ul><h1 id="实现层"><a href="#实现层" class="headerlink" title="实现层"></a>实现层</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><script src="https://cdn.bootcss.com/raphael/2.2.7/raphael.min.js"></script><script src="https://cdn.bootcss.com/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display:none">begin=>start: 开始end=>end: 结束get_class_name=>operation: 获得类名process=>operation: 下划线替换为斜线,生成类路径get_global_lib=>operation: 获得全局库绝对路径get_local_lib=>operation: 获得本地库路径merge_global=>operation: 合并全局库路径和类路径, 生成文件绝对路径merge_local=>operation: 合并本地库路径和类路径, 生成文件绝对路径judge_global=>condition: 判断文件是否存在judge_local=>condition: 判断文件是否存在load_error=>operation: 加载失败load_global=>operation: 加载文件load_local=>operation: 加载文件begin->get_class_name->process->get_local_lib->merge_local->judge_localjudge_local(yes)->load_local->endjudge_local(no)->get_global_lib->merge_global->judge_globaljudge_global(yes)->load_global->endjudge_global(no)->load_error->end</textarea><textarea id="flowchart-0-options" style="display:none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)</script></p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> yaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建及优化</title>
      <link href="/posts/121dda.html"/>
      <url>/posts/121dda.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文将介绍基于hexo博客搭建的过程, 包括, 博客搭建, 主题选择, 插件安装以及插件使用等.</p><h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>hexo博客是纯静态的博客, 用户通过编写markdown文件完成博客编写, 然后使用hexo提供的构建工具将md文件生成静态页面.<br>hexo使用主题模板将md渲染成静态html页面. 最后, 用户将这些静态页面部署到服务器中, 完成整个博客的部署.</p><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><p>建议主题:</p><ul><li>next 简约好看</li></ul><h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><p>推荐插件:</p><ul><li>hexo-abbrlink 生成固定链接, 降低url长度</li><li>hexo-all-minifier 压缩html/css/js, js打包到一个文件的功能有问题.</li><li>hexo-deployer-git 自动化部署</li><li>hexo-filter-flowchart markdown支持流程图</li><li>hexo-filter-optimize 将js打包成一个文件, 将main.css内联到html中</li><li>hexo-filter-plantuml markdown支持uml</li><li>hexo-filter-sequence markdown支持时序图</li><li>hexo-generator-baidu-sitemap 生成百度的sitemap</li><li>hexo-generator-search 支持即时搜索</li><li>hexo-generator-sitemap 生成sitemap</li><li>hexo-offline 缓存支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 优化 </tag>
            
            <tag> 博客搭建 </tag>
            
            <tag> github pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用cmake构建yaf框架</title>
      <link href="/posts/4d3b3d24.html"/>
      <url>/posts/4d3b3d24.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文介绍使用cmake构建yaf框架</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="yaf"><a href="#yaf" class="headerlink" title="yaf"></a>yaf</h2><p>yaf是一个使用c语言实现的php框架, 作为php的拓展加载到php中, 具有较高的性能.<br>php的拓展使用phpize构建, 这类构建工具不友好, 本文将改用更加友好的cmake工具.</p><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>cmake是一款较为友好的构建工具, 其拥有自己的配置语法.<br>cmake工具较为友好的一个方面是, 多种集成开发环境对其支持, 包括:</p><ul><li>CLion</li><li>codeblocks</li><li>等等</li></ul><p>比较重要的一点是, CLion使用cmake构建项目, 所以CLion只对能够使用cmake构建的项目友好.<br>这也是phpize不太友好的一点.</p><h1 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h1><p>cmake将CMakeLists.txt作为项目管理文件, 改造的过程变为编写CMakeLists.txt的过程.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>改造之前需要准备的工具包括:</p><ul><li>安装cmake</li><li>安装php开发包</li><li>生成config.h</li></ul><p>执行<code>yum install cmake</code>命令完成cmake的安装.<br>执行<code>yum install php-devel</code>命令完成php开发包的安装</p><p>使用phpize进行构建过程中, 构架工具会生成一个config.h的文件, 这个文件定义了一些重要的宏.<br>为了降低CMakeLists.txt的编写成本, 本文将通过phpize工具生成config.h, 然后直接使用config.h.</p><h2 id="编写CMakeLists-txt"><a href="#编写CMakeLists-txt" class="headerlink" title="编写CMakeLists.txt"></a>编写CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(reading_yaf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找php-config目录</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">DEFINED</span> PHP_CONFIG_DIR)</span><br><span class="line">    <span class="keyword">set</span>(PHP_CONFIG_DIR <span class="string">"$&#123;PHP_CONFIG_DIR&#125;/"</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">set</span>(PHP_CONFIG_DIR <span class="string">""</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取include目录</span></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;PHP_CONFIG_DIR&#125;</span>php-config --<span class="keyword">include</span>-dir</span><br><span class="line">        OUTPUT_VARIABLE PHP_INCLUDE_DIR</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 读取链接库</span></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;PHP_CONFIG_DIR&#125;</span>php-config --libs</span><br><span class="line">        OUTPUT_VARIABLE PHP_LIBS</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 读取链接参数</span></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;PHP_CONFIG_DIR&#125;</span>php-config --ldflags</span><br><span class="line">        OUTPUT_VARIABLE PHP_LDFLAGS</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 获取插件存放目录</span></span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="variable">$&#123;PHP_CONFIG_DIR&#125;</span>php-config --extension-dir</span><br><span class="line">        <span class="comment">#    RESULT_VARIABLE PHP_EXTDIR</span></span><br><span class="line">        OUTPUT_VARIABLE PHP_EXTDIR</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加宏</span></span><br><span class="line"><span class="keyword">add_definitions</span>(</span><br><span class="line">        -DZEND_ENABLE_STATIC_TSRMLS_CACHE=<span class="number">1</span></span><br><span class="line">        -DHAVE_CONFIG_H</span><br><span class="line">        -DPHP_ATOM_INC</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 包含目录, 保持与php-config --includes的结果一致</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">        BEFORE</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span></span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/Zend</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/main</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/TSRM</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/ext</span><br><span class="line">        <span class="variable">$&#123;PHP_INCLUDE_DIR&#125;</span>/ext/date/lib</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加include目录</span></span><br><span class="line"><span class="keyword">include_directories</span>(.)</span><br><span class="line"><span class="keyword">include_directories</span>(configs)</span><br><span class="line"><span class="keyword">include_directories</span>(requests)</span><br><span class="line"><span class="keyword">include_directories</span>(responses)</span><br><span class="line"><span class="keyword">include_directories</span>(routes)</span><br><span class="line"><span class="keyword">include_directories</span>(views)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(configs SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(requests SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(responses SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(routes SRC)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(views SRC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加构建目标</span></span><br><span class="line"><span class="keyword">add_library</span>(yaf SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加安装目录</span></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">        TARGETS yaf</span><br><span class="line">        LIBRARY DESTINATION <span class="variable">$&#123;PHP_EXTDIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置构建产物的命名, 包括</span></span><br><span class="line"><span class="comment"># - 去掉"lib"前缀</span></span><br><span class="line"><span class="comment"># - 统一后缀为".so"</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(</span><br><span class="line">        yaf PROPERTIES</span><br><span class="line">        PREFIX <span class="string">""</span></span><br><span class="line">        SUFFIX <span class="string">".so"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      
      
      <categories>
          
          <category> php-devel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php-devel </tag>
            
            <tag> php </tag>
            
            <tag> cmake </tag>
            
            <tag> yaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境部署</title>
      <link href="/posts/8c50c265.html"/>
      <url>/posts/8c50c265.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> cpp-devel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php面试指南</title>
      <link href="/posts/7a743d7a.html"/>
      <url>/posts/7a743d7a.html</url>
      
        <content type="html"><![CDATA[<p>Ubiquitous…that is definitely one word you could use to describe PHP in relation to the web. It really is everywhere. In terms of server-side programming languages, it is by far the most widely used, powering more than 80% of today’s websites (with the next runner up, ASP.NET, trailing way behind at a mere 17%).</p><p>Why? What makes PHP so popular and widely-used? While there’s no single answer to this question, PHP’s ease of use is certainly a significant contributing factor. PHP newbies can get up-to-speed and build dynamic PHP-based content into their web sites with a minimum of programming expertise required.</p><p>But therein lies much of the challenge of finding highly-skilled PHP developers. PHP’s relatively low barrier-to-entry and 20 year history means that PHP developers have become practically as ubiquitous as the technology itself. Yet while many can legitimately claim to “know” PHP, those who are true experts in the language are capable of producing software that is much more scalable, functional, robust, and maintainable.</p><p>So how do you distinguish those who have real competency in PHP from those with just a cursory knowledge, let alone those who are in the top 1% of candidates?</p><p>Toward that goal, this guide offers a sampling of effective questions to help evaluate the breadth and depth of a candidate’s mastery of PHP. It is important to bear in mind, though, that these sample questions are intended merely as a guide. Not every “A” candidate worth hiring will be able to properly answer them all, nor does answering them all guarantee an “A” candidate. At the end of the day, hiring remains as much of an art as it does a science (see In Search of the Elite Few).</p><p>Note that we have tried to keep this guide focused on modern PHP (i.e., versions 5.3 and beyond), but there are references to concepts and functions that have been around for a long time and should be familiar to any qualified PHP developer.<br>Key PHP Concepts and Paradigms</p><p>There are a number of key concepts and paradigms that are essential for a PHP expert to be well-versed in. Here are some examples.</p><p>Q: Describe a closure in PHP. Provide examples of when, why, and how they can be used.</p><p>Closures become useful when some piece of logic needs to be performed in a limited scope but retain the ability to interact with the environment external to that scope. The first building block of a closure is the anonymous, or lambda style, function which has no name associated with it. For example:</p><h1 id="The-2nd-argument-to-array-walk-is-an-anonymous-function"><a href="#The-2nd-argument-to-array-walk-is-an-anonymous-function" class="headerlink" title="The 2nd argument to array_walk is an anonymous function"></a>The 2nd argument to array_walk is an anonymous function</h1><p>array_walk($array, function($dog) {<br>echo $dog-&gt;bark();<br>});</p><p>Although they themselves have no name associated with them, anonymous functions can be assigned to a variable or passed around as callbacks by higher order functions that require them. For example:</p><h1 id="Define-an-anonymous-function-and-assign-it-to-a-variable"><a href="#Define-an-anonymous-function-and-assign-it-to-a-variable" class="headerlink" title="Define an anonymous function and assign it to a variable"></a>Define an anonymous function and assign it to a variable</h1><h1 id="named-dogs-bark"><a href="#named-dogs-bark" class="headerlink" title="named $dogs_bark."></a>named $dogs_bark.</h1><p>$dogs_bark = function($dog) {<br>echo $dog-&gt;bark();<br>}<br>array_walk($array, $dogs_bark);</p><p>Under the hood in PHP, anonymous functions are implemented using the Closure class.</p><p>The contents of an anonymous function exist within their own scope, independent of the scope in which they were created. However, it is possible to explicitly bind one or more variables from the external scope to be referenceable within the anonymous function via the use clause in the function definition. Let’s illustrate:</p><p>class Dog {<br>public function bark() { echo ‘woof’; }<br>}</p><p>$dogs_bark = function($dog) use (&amp;$collar) { # bind by reference<br>if ($collar == ‘fitsWell’){<br>echo $dog-&gt;bark(); # ‘woof’<br>} else {<br>echo ‘no bark’; # collar is too tight to bark<br>}<br>};</p><p>$dog = new Dog;</p><p>$collar = ‘fitsWell’; # external variable<br>$dogs_bark($dog); # ‘woof’</p><p>$collar = ‘tight’;<br>$dogs_bark($dog); # ‘no bark’</p><p>This ability to access these external variables within a closure becomes particularly useful when using higher order functions. Take for example our array_walk usage from above which, like other functions of this type, operates in a very specific way on the subject variables which it is passed. As the function iterates over the $array, only the current value and key are passed to the anonymous function callback. There is no opportunity to pass in the $collar variable without the closure and it’s use clause . We could use the global keyword, but would needlessly pollute the global namespace with a variable that only makes sense in our very limited scope.</p><p>Closures have additional object oriented uses as well. PHP 5.4 brings new methods to the Closure class’ interface. Specifically, the new bind and bindTo methods can be used to bind to new objects for the closure to operate on, e.g.:</p><p>Closure::bindTo($newthis, $newscope);</p><p>This method will actually duplicate the closure itself and bind its scope to that new object, so $this actually references $newthis in the object context. To help illustrate, let’s modify the $dogs_bark function to use $this and then bind it to a new Dog object:</p><h1 id="define-the-closure-but-not-bound-yet-to-any-object"><a href="#define-the-closure-but-not-bound-yet-to-any-object" class="headerlink" title="define the closure, but not bound yet to any object"></a>define the closure, but not bound yet to any object</h1><p>$dogs_bark = function() {<br>echo $this-&gt;sound; # where this is a property<br>};<br>$new_dog = new Dog();</p><h1 id="now-create-a-new-closure-bound-to-the-new-dog-object"><a href="#now-create-a-new-closure-bound-to-the-new-dog-object" class="headerlink" title="now create a new closure bound to the $new_dog object"></a>now create a new closure bound to the $new_dog object</h1><p>$new_closure = $dogs_bark-&gt;bindTo($new_dog);<br>$new_closure(); # echoes the sound</p><p>The fact that a closure can be assigned to a variable and now has access to $this is quite powerful. In particular, this means that it can become a callable property of another object and essentially become a method of that object. For example:</p><p>$dog = new Dog();<br>$dog-&gt;closure = $dogs_bark;<br>$dog-&gt;closure();</p><p>This makes it possible to change and add to the behavioral capabilities of an object at runtime without the need to alter the defining class signature. Very useful when functionality enhancements are needed, but the actual code cannot be touched or where the need for the enhanced functionality is limited in scope.</p><p>Q: Explain the use and purpose of the global keyword in PHP. Provide an example of a case where its use would be appropriate, as well as one where it would not be.</p><p>In the days of “PHP gone by”, the language’s object oriented implementation was much less sophisticated than it is today. It is therefore not uncommon to find older “legacy” PHP code that makes fairly extensive use of the global keyword. In many ways, overuse of global variables “flies in the face” of modern object-oriented programming (OOP) best practices, as it may lead to intertwined dependencies between classes, difficulty decoupling disparate units of logic from one another, and pollution of the global namespace with variables that have no (or very limited) use in that context.</p><p>Consider the following simple example:</p><p>class Dog {<br>function bark() {<br>global $sounds;<br>return $sounds-&gt;bark();<br>}<br>}</p><p>This introduces a hidden dependency of the Dog class on the global $sounds object. While there may be cases where this would be justified (e.g., a system with one single well-defined set of sounds that is never modified), generally speaking, it would be much better to explicitly pass the relevant $sounds object to the Dog class’ constructor, which would then be stored and used within that instance of the class; e.g.:</p><p>class Dog {<br>protected $sounds;<br>function __construct($sounds) {<br>$this-&gt;sounds = $sounds;<br>}</p><pre><code>public function bark() {    return $this-&gt;getSounds()-&gt;bark();}public function getSounds() {    return $this-&gt;sounds;}</code></pre><p>}</p><p>But as is true with most things in coding, never say never. There are, in fact, a number of robust and stable products out there written in PHP that make heavy use of globals. The Wordpress Codex, which powers roughly 20% of the websites on the web (and rising yearly), Joomla! 1.5 (which is still in wide use), and the iLance Enterprise Auction system are all examples of projects that have been around for years and make use of ‘mature’ globals. Similarly, there may be situations where the use of globals in your code is appropriate, but their use should always be approach with caution.</p><p>Q: Describe namespacing in PHP and why it is useful.</p><p>One of the newer additions to PHP’s support for OOP is the namespace. As the name implies, a namespace defines a scope in a program where class, interface, function, variable, and constant definitions won’t produce name collisions with similarly named items in other namespaces.</p><p>Prior to PHP 5.4, class names would often become quite long in an attempt to match the package hierarchy and avoid name collisions. For example, let’s say we have a Dogs class defined in the model of the Dog_Pound application. Without namespacing, we might feel compelled to provide a verbose name for our class such as the following:</p><p>class Dog_Pound_Model_Dogs { # wow, that’s a mouthful!<br>function getDogs();<br>}</p><p>Namespacing helps alleviate this issue by enabling the developer to explicitly specify the namespace within which all named items (classes, variables, etc.) are to be defined. With namespacing, the above verbose class name could be replaced with:</p><p>namespace dog_pound\model; # specify the current namespace</p><p>class Dogs { # only “Dogs” defined in dog_pound\model<br>function getDogs();<br>}</p><p>$dogs = new Dogs; # unambiguous since only one in this namespace</p><p>Relative namespace references are supported as well. For example, when in the dog_pound namespace, you can use the following to instantiate your class:</p><p>$dogs = new model\Dogs # only one “model” defined in dog_pound</p><p>In addition, named items in other namespaces can be imported in other files and can then be referenced directly. This is done via the use operator as follows:</p><p>namespace this\new\namespace; # our current namespace</p><h1 id="import-Dogs-from-dog-pound-model-namespace-and-reference-it"><a href="#import-Dogs-from-dog-pound-model-namespace-and-reference-it" class="headerlink" title="import Dogs from dog_pound\model namespace and reference it"></a>import Dogs from dog_pound\model namespace and reference it</h1><p>use dog_pound\model\Dogs;</p><p>$dogs = new Dogs;</p><p>Q: What are traits? Describe their major characteristics and why they are useful. Give an example of a trait declaration and a class that uses multiple traits.</p><p>Traits are an excellent addition to PHP 5.4 that allow behaviors to be added to a class, without needing to extend a parent class to inherit the desired functionality (prior to PHP 5.4, this could only be done via a mixin class pattern at runtime). Additionally, you can make use of multiple Traits in a single class. This makes them a powerful aid in the organization and separation of concerns in the codebase and, as such, helps to honor the composition over inheritance design principle.</p><p>Here are a couple of simple trait definition examples:</p><p>trait Movement {<br>public function topSpeed() {<br>$this-&gt;speed = 100;<br>echo “Running at 100 %!” . PHP_EOL;<br>}<br>public function stop() {<br>$this-&gt;speed = 0;<br>echo “Stopped moving!” . PHP_EOL;<br>}<br>}</p><p>trait Speak {<br>public function makeSound(){<br>echo $this-&gt;sound . PHP_EOL;<br>}<br>}</p><p>The use keyword is once again employed, this time for importing from another namespace to include one or more traits in a class definition. For example:</p><p>class Dog {<br>use Movement, Speak; // Dog now has these capabilities!</p><pre><code>protected $sound;function __construct() {    $this-&gt;sound = &apos;bark&apos;;}</code></pre><p>}</p><p>$dog = new Dog();<br>$dog-&gt;topSpeed(); // from Movement trait<br>$dog-&gt;stop(); // from Movement trait<br>$dog-&gt;makeSound(); // from Speak trait</p><p>PHP at Your Fingertips</p><p>Committing to memory what can easily be found in a language specification or API document is no indicator of proficiency. But that said, someone who is intimately familiar with a programming language will have its syntactical and functional details and nuances at his or her fingertips. Here are some questions that help evaluate this dimension of a candidate’s expertise.</p><p>Q: Describe the relationship between php://input and $_POST. How would you access the php://input stream?</p><p>In the simplest terms, the $_POST superglobal is the formatted or parsed content of the body of a request made to the server with the post method.</p><p>POST /php-hiring-guide/php-post.php HTTP/1.1<br>Host: toptal.com<br>Referer: http:///toptal.php/php-hiring-guide/php.php<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 63<br>article_name=PHP Hiring Guide&amp;tag_line=You are hired!&amp;action=Submit</p><p>The body of the request can be accessed through the PHP’s input stream the same as any other file:</p><p>$input = file_get_contents(“php://input”);</p><p>Q: Name and define at least five superglobals that begin with $_. Describe their relationship to the $GLOBALS variable.</p><pre><code>$_POST - a hash of key value pairs sent to the server with the ‘post’ method$_GET - a hash of key value pairs sent to the server with the ‘get’ method$_REQUEST - an amalgamation of $_GET and $_POST$_SERVER - a hash of variables set specifically by the web server, and relevant to the execution of the program$_ENV - a hash of variables related to the host machine and it’s configuration$_SESSION - a hash of variables that are meant to be persisted between page views or separate application executions$_COOKIE - a hash of variables that are to be stored with the client$_FILES - a special type of request hash that holds input data related to an uploaded set of files</code></pre><p>Akin to the global keyword in PHP is the $GLOBALS super global variable. As the name suggests, superglobals are automatic global variables and as such are stored in $GLOBALS. For example, the $_ENV superglobal could alternatively be accessed via $GLOBALS[“_ENV”].</p><p>Q: Explain the purpose and usage of the <strong>get, </strong>set, <strong>isset, </strong>unset, <strong>call, and </strong>callStatic “magic” methods. When, how, and why (and perhaps why not) should each be used?</p><p>The first four methods in our list, <strong>get, </strong>set, <strong>isset, and </strong>unset are used for property overloading of an object. They let us define how the outside world is able to interact with properties that have a private or protected visibility, and properties that don’t even exist in our object.</p><h1 id="‘whiskers’-is-not-defined-in-the-Dog-class-but-is-handled-by"><a href="#‘whiskers’-is-not-defined-in-the-Dog-class-but-is-handled-by" class="headerlink" title="‘whiskers’ is not defined in the Dog class but is handled by"></a>‘whiskers’ is not defined in the Dog class but is handled by</h1><h1 id="the-Dog-class’-get-method-as-follows"><a href="#the-Dog-class’-get-method-as-follows" class="headerlink" title="the Dog class’ __get method as follows:"></a>the Dog class’ __get method as follows:</h1><p>function __get($name) {<br>if ($name == ‘whiskers’) {</p><pre><code>    # only create one whiskersService per instance    if (! isset($this-&gt;whiskersService)) {        $this-&gt;whiskersService = new Whiskers($this);              }    # so calls to &apos;whiskers&apos; will load the wiskersService    return  $this-&gt;whiskersService-&gt;load();}</code></pre><p>}</p><p>A caller can then simply retrieve the whiskers property like so:</p><p>$hairs = $dog-&gt;whiskers;</p><p>By using the __get method to “intercept” this reference to a seemingly public property we are able to obscure the implementation details of one or more of the object’s properties.</p><p>Use of the __set method is similar. For example:</p><p>function __set($name, $value) {<br>if ($name == ‘whiskers’) {<br>if ($value instanceOf Whisker) {<br>$this-&gt;whiskersService-&gt;setData($value);<br>return $this-&gt;whiskersService-&gt;getData();<br>} else {<br>throw new WhiskerException(“That’s not a whisker”);<br>return false;<br>}<br>}<br>}</p><p>A caller can then simply set the whiskers property like so:</p><p>$dog-&gt;whiskers = $hairs;</p><p>This statement automatically invokes the __set method, using ‘whiskers’ as its first argument and the right side of the assignment as the second argument.</p><p>Lastly, the <strong>isset and </strong>unset methods complete the quartet. They each take just one argument, the $name of the property to be evaluated or operated on; e.g.:</p><p>function __isset($name) {<br>if ($name == ‘whiskers’) {<br>return (bool) is_object($this-&gt;whiskersService) &amp;&amp;<br>!empty($this-&gt;whiskersService-&gt;getData());<br>}<br>}</p><p>function __unset($name) {<br>if ($name == ‘whiskers’ &amp;&amp; is_object($this-&gt;whiskersService)) {</p><pre><code>    # we don&apos;t want to completely kill the service:    $this-&gt;whiskersService-&gt;reset();}</code></pre><p>}</p><p>The other two methods, <strong>call and </strong>callStatic, perform a similar function for classes, but give us method overloading. Through their use we can define how a class should react when an undefined, protected, or private method is called.</p><p>In a __call implementation where we want to ensure all “non-visible” method calls get returned the payload from the whiskersService we might do something like:</p><p>public function __call($method, $args) {<br>return $this-&gt;whiskersService-&gt;load();<br>}</p><p>__callStatic has the same arguments, the same functionality and allow for this same interaction, but outside of a specific object context. This means that if we have this method defined we can use the ClassName::notVisibleMethod() syntax; e.g.:</p><p>public function <strong>callStatic($method, $args) {<br>if (!is_object(static::$whiskersService)) {<br>static::$whiskersService = new Whiskers(</strong>CLASS__);<br>}<br>return static::$whiskersService-&gt;load();<br>}</p><p>$hairs = Dog::whiskers();</p><p>In the above set of examples, we have encapsulated the whiskers implementation from the outside world and made it the only available object exposed in this way. The clients of such properties and methods do not need to know anything about the underlying whiskersService or how the Dogs class is storing its data at all.</p><p>Collectively, these methods increase our ability to flexibly compose objects. The opportunity for object abstraction and encapsulation, and thus reusable, more compact code (and ultimately a more manageable system as a result) are also increased.</p><p>Care should be taken, though, in using these convenient methods, as the benefits can come at a cost. They are slower than straight access to an otherwise public property in question, and also slower than defined getters and setters. They also hamper use of certain useful capabilities (such as object reflection, autocomplete in your IDE, automatic documentation utilities like PHPDocumentor, and so on). So if these are facilities you want or need to rely on, you may consider defining methods and properties explicitly instead. As with most things, there’s no across-the-board right answer. The pros and cons should be evaluated on a case-by-case basis.</p><p>Q: Describe one or more Standard PHP Library (SPL) data structures. Give usage examples.</p><p>Most of PHP development deals with getting and processing data from one source or another, such as a local database, local files, a remote API, etc. As such, developers spend a great deal of time getting, organizing, moving, and manipulating that data. In some cases, an array just won’t cut it in terms of memory usage and performance and therefore better data structures are called for.</p><p>Also, with so much talk and focus on frameworks (this page could be filled with names of PHP frameworks!), it could be difficult to find a developer who has a great deal of experience with the particular framework that your project is using. The net effect of a such an active development community is that the distribution of developers working with a particular framework starts to shrink, and could make it harder for you to find that specific skill.</p><p>One area to focus on, and where you be reasonably sure that a PHP expert will have familiarity, is in the use of and general makeup of the Standard PHP Library (SPL). If the candidate has a solid background here, the chances of success for that candidate working into and adding value to your application are greater, regardless of the specific frameworks being used in your environment.</p><p>Specifically, a candidate should be familiar with some or all of the nine SPL data structures listed in the PHP Manual. Many provide highly similar functionality to one another, but the slight variations make each one more perfectly suited to a particular use. Here’s a brief overview:</p><pre><code>SplDoublyLinkedList. Each element in this list holds links to the node before it and the node after it in the list. Picture that you are on line at the bank, but you are only able to see the person in front and the person behind you. That is analogous to the ‘link’ relationship between elements in a SplDoublyLinkedList. Inserting an element into the list is akin to someone cutting in front of you at the bank (but you then suddenly forget who was in front of you, and that person also forgets you entirely). Enables efficient transversal through a dataset and lets you list and add large amounts of data, with no internal need to re-hash.SplQueue and SplStack. Very similar to the SplDoublyLinkedList are the SplQueue and SplStack. Both of these are essentially SplDoublyLinkedLists with different iterator flags (IT_MODE_LIFO is “Last In First Out” and IT_MODE_FIFO is “First In First Out”), which govern which order the elements are read in and what to do with those elements after they have been processed. One other distinction is that the SplQueue API might be considered a bit more intuitive, supplying an enqueue() method (rather than push()) and a dequeue() method (rather than shift()).SplHeap. Represented internally as a binary tree, where each node in the tree has a maximum of two child nodes. It is an abstract class which must be extended to define a compare() method. This method is then used to perform real time sorting whenever a value is inserted into the tree.SplMaxHeap and SplMinHeap. Concrete implementations of the SplHeap abstract class. SplMaxHeap provides a compare() method that maintains values in order from highest to lowest, whereas SplMinHeap provides a compare() method that maintains values in order from lowest to highest.SplPriorityQueue. Similar to an SplHeap, but sorting is done based on an additional “priority” value supplied for each member.SplFixedArray. Similar to a regular array, but indices can only be integers and the length of the array is fixed. It provides improved speed when implementing an array. There is no processing speed benefit over an array, the interface is optimized so that the objects don’t need to be hashed manually when adding elements.SplObjectStorage. Provides an interface for mapping objects to data or simply providing a container for a set of objects. Essentially, it can use an object much like an associative array key to relate that object to some data or to no data at all.</code></pre><p>Q: What will $x be equal to after the statement $x = 3 + “15%” + “$25”?</p><p>The correct answer is 18. Now let’s explain why.</p><p>PHP supports automatic type conversion based on the context in which a variable or value is being used.</p><p>If you perform an arithmetic operation on an expression that contains a string, that string will be interpreted as the appropriate numeric type for the purposes of evaluating the expression. So, if the string begins with one or more numeric characters, the remainder of the string (if any) will be ignored and the numeric value is interpreted as the appropriate numeric type. On the other hand, if the string begins with a non-numeric character, then it will evaluate to zero.</p><p>With that understanding, we can see that “15%” evaluates to the numeric value 15 and “$25” evaluates to the numeric value zero, which explains why the result of the statement $x = 3 + “15%” + “$25” is 18 (i.e., 3 + 15 + 0).</p><p>Depending on who you ask, automatic type conversion is either a great feature or one of the worst pitfalls of the PHP language. On the one hand, when used consciously and properly, it can be very convenient for the developer (e.g., I don’t need to write any code to convert “15” to 15 before using it in an arithmetic operation). On the other hand, it can easily lead to headfakes and hard-to-track-down bugs when it is employed inadvertently, since no error message or warning will be generated.</p><p>Q: Explain the significance of using the static keyword when invoking a method or property, including how it differs from the self keyword? When would you use it and why? Provide an example.</p><p>As of PHP 5.3.0, PHP implements a feature called late static bindings. “Late binding” comes from the fact that static:: will not be resolved using the class where the method is defined but will rather be determined using runtime information and scope. (Incidentally, the term “static” is a bit of a misnomer in that this is not limited to being used with static methods.)</p><p>Consider the following example:</p><p>class Dog {<br>static $whoami = ‘dog’;<br>static $sound = ‘bark’;</p><pre><code>function makeSounds() {    echo self::makeSound() . &apos;, &apos;;    echo static::makeSound() . PHP_EOL;}function makeSound() {    echo static::$whoami . &apos; &apos; . static::$sound;}</code></pre><p>}</p><p>Dog::makeSounds();</p><p>Unsurprisingly, this will output “dog bark, dog bark”.</p><p>But now let’s extend this example to include the following:</p><p>class Puppy extends Dog {<br>static $whoami = ‘puppy’;<br>static $sound = ‘woof’;</p><pre><code>function makeSound(){    echo static::$whoami . &apos; whimper&apos;;}</code></pre><p>}</p><p>Puppy::makeSounds();</p><p>You may be surprised to learn that this will output “puppy woof, puppy whimper”. To understand why, let’s revisit the makeSounds() method in the Dog class.</p><p>The makeSounds() method in the Dog class first invokes self::makeSound(). self:: instructs PHP to always use the scope of the same class (in this case, the Dog class). Therefore, calling self::makeSound() from within Dog’s makeSounds() method will always invoke Dog’s version of makeSound(). This is true even when we call Puppy::makeSounds() since Puppy has no makeSounds() method of its own and instead relies on Dog’s version. This is why the call from Puppy::makeSounds() to self::makeSound() outputs “puppy woof”.</p><p>Next, the makeSounds() method in the Dog class invokes static::makeSound(). static:: behaves differently from self::. static:: instructs PHP to use the version in the scope of the class that invoked the method at runtime (in this case, the Puppy class). Hence, when the call to static::makeSound() is made, it invokes Puppy’s version of that method. This is why the call from Puppy::makeSounds() to static::makeSound() outputs “puppy whimper”.<br>PHP Under-the-Hood</p><p>Understanding how PHP works “under the hood” is one of the primary defining characteristics of a PHP expert. Such a candidate will understand not only how to do something, but the various options available, and the performance and functional ramifications of each.</p><p>Q: How does PHP build an array internally?</p><p>Central to much of PHP development is the array. These are good for most uses where an iterable data structure is needed. Internally in PHP, arrays are stored, like many other data structures, as hash tables. PHP is written in C where there is no such thing as an associative array: arrays in C can only have integer indices. Therefore, a hash function is used to translate PHP array indices (both integer and string) into appropriate numeric indices and the array values are stored at that location or bucket in the hash table.</p><p>The process of finding bucket entries based on a hash of the array keys is of O(1) complexity (using Big O notation). This because no iteration over the hash is needed, since the hash function produces the exact location in the table. (Note that this changes slightly if there is more than one element in the bucket.)</p><p>PHP automatically increases the size of an array “on demand”. Specifically, when an element is added to an array, if addition of the element would cause the array to exceed its currently allocated size, PHP responds by doubling the memory allocation. The corresponding hash table needs to be completely rehashed as a result.</p><p>Let’s consider what that means for just a second: Adding values to an array can in some cases be as complex as iterating over that entire new array, and in that same situation you have doubled the memory footprint of that structure. Given this, where datasets begin to get large and memory is an issue, it may be wise to consider an alternative to an array, where loading the data for processing happens on a more as needed basis.</p><p>Q: What is the difference between the ArrayAccess and ArrayObject?</p><p>ArrayAccess is simply an interface definition that requires any class that implements it to define the following methods: offsetGet, offsetSet, offsetExists, and offsetUnset.</p><p>ArrayObject, on the other hand, is an instantiable class that implements the ArrayAccess interface. A nice usage convenience of an ArrayObject is that its elements can either be accessed the same as a standard array (i.e., via the familiar [] notation; e.g., $dogs[‘sound’]) or via the offsetGet(propertyName) method (e.g., $dogs-&gt;offsetGet(‘sound’)).</p><p>Q: What is a generator? When might you use it instead of an iterator or a plain array. What do yield and send do?</p><p>A generator looks much like any other function in PHP and shares some similarities with closures. When called for the first time in an iterable context (e.g., a foreach statement), the generator returns an object that is an instance of the Generator class, which in turn implements the Iterator interface. The values for iteration are generated in real-time eliminating the need to load an entire data set into memory before hand. That means that the result can be iterated over in much the same way that an array can, but with some important differences; namely they:</p><pre><code>Can only be used in a forward run, meaning that one can’t iterate backwards over the values or start at the beginning. Calling the rewind() method on the generator will throw an exception.Are slower than processing a pre-populated array (the generator is doing extra processing to produce the value).Are extremely memory efficient.</code></pre><p>One of the chief differences between a generator function and other PHP functions or closures is that they don’t make use of return to provide their results. Instead, yield is used to pass values out of the generator (e.g., yield $dog;). In fact, specifying a value on a return statement in a generator will produce a parser error, but an empty return statement will simply stop the generator altogether.</p><p>yield pauses execution and returns the current value to the scope of the structure that is using the generator. That structure has the opportunity to send information back to the generator at that same point in its execution via the send method (e.g., $generator-&gt;send(-1);).</p><p>With that basic explanation, let’s take a look at a simple example of a generator’s use.</p><p>First, let’s define our generator:</p><p>function dog_generator() {<br>foreach (range(0, 2) as $value) {</p><pre><code>    # some fake data source    $dog = DogHelper::getDogFromDataSource($value);    # catch input from send or use $dog    $input = (yield $dog);        if ($input == -1) {        return; // stop the generator    }}</code></pre><p>}</p><p>Note that, in the above example, we are assigning the result of the yield method call to a variable and must therefore wrap the yield in parentheses in order for it to be syntactically valid.</p><p>And now here’s an example of how we would use the above generator:</p><h1 id="Get-an-instance-of-the-generator-and-assign-it-to-a-variable"><a href="#Get-an-instance-of-the-generator-and-assign-it-to-a-variable" class="headerlink" title="Get an instance of the generator and assign it to a variable"></a>Get an instance of the generator and assign it to a variable</h1><p>$generator = dog_generator();</p><p>foreach ($generator as $dog) { # $dog is a result of ‘yield’<br>echo $dog . PHP_EOL;<br>// we wanted to find the terrier<br>if ($dog == ‘Terrier’) {</p><pre><code>    # send an input into the generator via &apos;yield&apos;    $generator-&gt;send(-1);    echo &apos;We found the Terrier, stop the show.&apos;;}</code></pre><p>}</p><p>When we run the above code our example stops when it finds “Terrier”. For example:</p><p>Dalmatian<br>Terrier<br>We found the Terrier, stop the show.</p><p>The key benefits of a generator are ease of implementation, increased readability of code, and overall improved performance and memory usage.</p><p>So generally speaking, it’s best to use a generator where there is no need to rewind or iterate back over the values again in another part of the program. On the other hand, if memory is not a concern, then a simple array of the values is much faster.<br>The Big Picture</p><p>Q: List some of the major differences between (or sequential additions and improvements to) PHP 5.3, PHP 5.4 and PHP 5.5.</p><p>PHP 5.3 was released back in June 2009 but is still in wide circulation. Key new features in this release included: closures, lambda style functions, namespacing, and late static binding.</p><p>PHP 5.4 was released in March 2012, introducing Traits, as well as the ability to declare an array with a shortened [] syntax (e.g., $array = [‘shih tzu’, ‘rottweiler’]). In addition, register_globals was removed in this version.</p><p>PHP 5.5 was released in June 2013 and is the current release. This version adds support for generators (and their related yield and send keywords), as well as adding finally to the try/catch exception handling syntax. APC Cache is gone in favor of OpCache (based on the Zend Optimizer). PHP 5.5 also takes the array literal even further and supports syntax such as [‘shih tzu’, ‘rottweiler’][1] (which returns “rottweiler”) as well as the handy notation of strings interpreted as arrays (e.g., ‘6, 5, 4’[0], which returns “6”).<br>Wrap-up</p><p>Finding PHP developers can be relatively easy, but finding stellar PHP developers is a formidable challenge. The questions presented in this guide can serve as useful tools in your overall recruiting toolbox to better identify those who have mastered the language. Finding such candidates is well worth the effort, as they will undoubtedly have a significant positive impact on your team’s productivity and results.</p>]]></content>
      
      
      <categories>
          
          <category> php-devel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php-devel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本文讲述14个经典的php面试题.</title>
      <link href="/posts/329776f3.html"/>
      <url>/posts/329776f3.html</url>
      
        <content type="html"><![CDATA[<p>本文讲述14个经典的php面试题.</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>考虑下面代码:</p><pre><code>$str1 = &apos;yabadabadoo&apos;;$str2 = &apos;yaba&apos;;if (strpos($str1,$str2)) {    echo &quot;\&quot;&quot; . $str1 . &quot;\&quot; contains \&quot;&quot; . $str2 . &quot;\&quot;&quot;;} else {    echo &quot;\&quot;&quot; . $str1 . &quot;\&quot; does not contain \&quot;&quot; . $str2 . &quot;\&quot;&quot;;}</code></pre><p>输出的结果是什么??为什么会出现这个结果?? 如何处理这种情况??</p><h3 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h3><p>输出结果为:</p><pre><code>&quot;yabadabadoo&quot; does not contain &quot;yaba&quot;</code></pre><p>这个问题考察的是”strpos()”的使用.<br>这个函数返回变量\$str2在\$str1中的位置.<br>如果未找到就返回false.<br>但是, 本次调用时, 这个函数返回的值为0,<br>对于if语句来说, 0等同于false.</p><p>对于这种情况, 需要在if语句中判断函数返回值是否为false, 修改的代码如下:</p><pre><code>$str1 = &apos;yabadabadoo&apos;;$str2 = &apos;yaba&apos;;if (strpos($str1,$str2) !== false) {    echo &quot;\&quot;&quot; . $str1 . &quot;\&quot; contains \&quot;&quot; . $str2 . &quot;\&quot;&quot;;} else {    echo &quot;\&quot;&quot; . $str1 . &quot;\&quot; does not contain \&quot;&quot; . $str2 . &quot;\&quot;&quot;;}</code></pre><p>注意, 在这里我们”!==”操作符, 而不是”!=”操作符.<br>如果我们使用”!=”, 我们就遇到这样一个问题, 0为强制转化为布尔表达式时, 0对应的是false.<br>所以”0 != false”的结果为”false”.</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>下面的代码的输出结果是什么??</p><pre><code>$x = 5;echo $x;echo &quot;&lt;br /&gt;&quot;;echo $x+++$x++;echo &quot;&lt;br /&gt;&quot;;echo $x;echo &quot;&lt;br /&gt;&quot;;echo $x---$x--;echo &quot;&lt;br /&gt;&quot;;echo $x;</code></pre><h3 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h3><p>输出结果是:</p><pre><code>511715</code></pre><p>本题考察”后++”和”后–”的使用与”++”操作符和”+”操作符的优先级.</p><p>“后++”和”后–”先返回数值, 然后执行加一或者减一操作.<br>当同时出现”++”和”+”操作符时, 因为”++”操作符比”+”操作符高, 所以先执行”++”操作, 后执行”+”操作.</p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>执行完下面的代码后, 变量”\$a”和变量”\$b”的值时多少??</p><pre><code>$a = &apos;1&apos;;$b = &amp;$a;$b = &quot;2$b&quot;;</code></pre><h3 id="问题解答-2"><a href="#问题解答-2" class="headerlink" title="问题解答"></a>问题解答</h3><p>变量”\$a”和变量”\$b”的值都将等于字符串”21”.<br>在执行代码”\$b = &amp;\$a;”时, 变量”\$b”就赋值为变量”\$a”的引用, 变量”\$b”修改时, 变量”\$a”的值也将修改.<br>当变量赋值是出现双引号时, php将执行双引号中的表达式, 即”2\$b”的结果实际为字符串”2”和变量”\$b”的连接, 也就是字符串”21”.</p><h2 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>下面各行的输出结果是什么???</p><pre><code>var_dump(0123 == 123);var_dump(&apos;0123&apos; == 123);var_dump(&apos;0123&apos; === 123);</code></pre><h3 id="问题解答-3"><a href="#问题解答-3" class="headerlink" title="问题解答"></a>问题解答</h3><p>运行的结果如下:</p><pre><code>bool(false)bool(true)bool(false)</code></pre><p>对于语句”var_dump(0123 == 123)”, 输出结果为”bool(false)”.<br>因为以0开头的数组在php解释器看来, 是八进制数字.<br>八进制的”123”与十进制的”123”不相等.</p><p>对于语句”var_dump(‘0123’ == 123)”, 其输出结果为”bool(true)”.<br>因为字符串”0123”与数值”123”比较时, 字符串”0123”将自动转化为数值型, 字符串中的”0”将被忽略.<br>所以这个字符串将被转化为数值类型的”123”. 这个数值与数值”123”相等, 最后返回的结果为true.</p><p>对于语句”var_dump(‘0123’ === 123)”, 其输出结果为”bool(false)”.<br>在这个语句中引入了严格比较符”===”, 这个比较符会先比较两个变量的数据类型.<br>对于当前语句而言, 前者为字符串, 后者为数值型, 两个变量的类型不同, 所以返回false.</p><h2 id="问题五"><a href="#问题五" class="headerlink" title="问题五"></a>问题五</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>下面的代码的结果是什么???有什么问题???如何修改??</p><pre><code>$referenceTable = array();$referenceTable[&apos;val1&apos;] = array(1, 2);$referenceTable[&apos;val2&apos;] = 3;$referenceTable[&apos;val3&apos;] = array(4, 5);$testArray = array();$testArray = array_merge($testArray, $referenceTable[&apos;val1&apos;]);var_dump($testArray);$testArray = array_merge($testArray, $referenceTable[&apos;val2&apos;]);var_dump($testArray);$testArray = array_merge($testArray, $referenceTable[&apos;val3&apos;]);var_dump($testArray);</code></pre><h3 id="问题解答-4"><a href="#问题解答-4" class="headerlink" title="问题解答"></a>问题解答</h3><p>输出结果如下所是:</p><pre><code>array(2) { [0]=&gt; int(1) [1]=&gt; int(2) }NULLNULL</code></pre><p>同时将会出现两个警告:</p><pre><code>Warning: array_merge(): Argument #2 is not an arrayWarning: array_merge(): Argument #1 is not an array</code></pre><p>本题的关键是, 如果”array_merge()”函数的两个参数中有一个不是数组类型, 这个函数的返回值将返回”NULL”.<br>在一般逻辑下, 形如语句”array_merge(\$someValidArray, NULL)”的结果为”\$someValidArray”,<br>然而, 这个函数实际的返回结果是”NULL”, 而且, 这一点在php的官方文档中也很少提到.</p><p>As a result, the call to $testArray = array_merge($testArray, $referenceTable[‘val2’]) evaluates<br>to $testArray = array_merge($testArray, 3) and,<br>since 3 is not of type array, this call to array_merge() returns NULL,<br>which in turn ends up setting $testArray equal to NULL.<br>Then, when we get to the next call to array_merge(), $testArray is now NULL<br>so array_merge() again returns NULL.<br>(This also explains why the first warning complains about argument #2<br>and the second warning complains about argument #1.)</p><p>执行语句”\$testArray = array_merge(\$testArray, \$referenceTable[‘val2’])”时,<br>这个语句将转化为”\$testArray = array_merge(\$testArray, 3)”.<br>由于上面提到的原因, 变量”\$testArray”的值被赋值为”NULL”.<br>执行语句”\$testArray = array_merge(\$testArray, \$referenceTable[‘val3’]);”时,<br>这个语句等同于”\$testArray = array_merge(NULL, \$referenceTable[‘val3’]);”.<br>这个语句中, 第一个参数的值为NULL, 不是数组类型, 函数调用的结果为”NULL”.<br>所以, 最后变量”\$testArray”的值为”NULL”.<br>这也说明了, 为什么两个警告中, 一个时参数2, 一个是参数1了.</p><p>面对这种情况, 修改的措施也是简单的.<br>直接对参数进行类型转化, 我们就可以实现原有的要求:</p><pre><code>$testArray = array_merge($testArray, (array)$referenceTable[&apos;val1&apos;]);var_dump($testArray);$testArray = array_merge($testArray, (array)$referenceTable[&apos;val2&apos;]);var_dump($testArray);$testArray = array_merge($testArray, (array)$referenceTable[&apos;val3&apos;]);var_dump($testArray);</code></pre><p>这样的输出结果如下:</p><pre><code>array(2) { [0]=&gt; int(1) [1]=&gt; int(2) }array(3) { [0]=&gt; int(1) [1]=&gt; int(2) [2]=&gt; int(3) }array(5) { [0]=&gt; int(1) [1]=&gt; int(2) [2]=&gt; int(3) [3]=&gt; int(4) [4]=&gt; int(5) }</code></pre><h2 id="问题六"><a href="#问题六" class="headerlink" title="问题六"></a>问题六</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>下面代码输出的结果是什么??为什么??</p><pre><code>$x = true and false;var_dump($x);</code></pre><h3 id="问题解答-5"><a href="#问题解答-5" class="headerlink" title="问题解答"></a>问题解答</h3><p>出乎意料的, 上面的代码将输出”bool(true)”, 看似”and”操作符表现的跟”or”操作符相同 .</p><p>The issue here is that the = operator takes precedence over the and operator in order of operations, so the statement $x = true and false ends up being functionally equivalent to:</p><p>事实上, “=”操作符的优先级比”and”操作符高.<br>因此, 语句”$x = true and false”可以等同下面语句:</p><pre><code>$x = true;       // 将&quot;$x&quot;变量赋值为true, 由于赋值成功, 返回true.true and false;  // 结果是false, 但是这个结果与$x无关.</code></pre><p>为了使自己的表达式更加清晰, 适当添加括号是一个很好的习惯.<br>例如, 形如上面的表达式”\$x = true and false”用”\$x = (true and false)”代替,<br>那么”\$x”就被设置为”false”了.</p><h2 id="问题七"><a href="#问题七" class="headerlink" title="问题七"></a>问题七</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>下面运行下面的语句, 变量”\$x”的值为:</p><pre><code>$x = 3 + &quot;15%&quot; + &quot;$25&quot;</code></pre><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>变量”\$x”的值为18.</p><p>Here’s why:</p><p>PHP supports automatic type conversion based on the context in which a variable or value is being used.</p><p>php支持根据语境自动变量类型转化.</p><p>如果你在一个表达式中使用算术运算, 并且这个表达式中包含字符串.<br>那么这些字符串将被转化为相应的数字, 以完成算术运算.<br>如果一个字符串由数字开头, 那么这个字符串将忽略非数字部分, 将数字部分的字符转化为相应的数值.<br>如果一个字符串以非数字开头, 那么这个字符串将被转化为0.</p><p>基于上面的原因, 字符串”15%”将被转化为”15”, 字符串”$25”将被转化为”0”.<br>那么原来的计算表达式”\$x = 3 + “15%” + “\$25””将转化为”\$x=3+15+0”, 最后的结果为”18”.</p><h2 id="问题八"><a href="#问题八" class="headerlink" title="问题八"></a>问题八</h2><p>执行下面代码后, 变量”\$text”的值是什么, 语句”strlen(\$text)”的返回值是什么??</p><pre><code>$text = &apos;John &apos;;$text[10] = &apos;Doe&apos;;</code></pre><p>执行完上面的代码, 变量”\$text”的值为”John D”, 即字符串”john”后面跟着五个空格, 然后加一个字符”D”.<br>并且代码”strlen(\$text)”的返回值为11.</p><p>这里有两点需要注意:</p><p>首先, 变量”\$text”是一个字符串, 设置这个变量中的一个元素的值, 就是设置这个变量中的一个字符.<br>代码”$text[10] = ‘Doe’”, 用于替换的字符为原字符中的第一个, 即”Doe”中的’D’.</p><p>第二, 代码”\$text[10] = ‘Doe’”运行时, 将修改变量’\$text’的第11个字符, 将其设置为’D’.<br>更重要的是, 原始字符串的长度为5, 对于其他编译器或者解释器而言, 这种操作会出现数组越界情况.<br>但是对于php而言, 这个操作是允许的.<br>php会自动适应这种情况, 并将其他字符位置置空.</p><h2 id="问题九"><a href="#问题九" class="headerlink" title="问题九"></a>问题九</h2><h3 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h3><p>“PHP_INT_MAX”是php的一个常量, 用于标识所支持的最大整数(这个值与php的版本和操作系统的架构有关).</p><p>假设代码”var_dump(PHP_INT_MAX)”的输出值为”9223372036854775807”.</p><p>依据上面这种情况, 下面的代码的运行结果是什么??</p><pre><code>var_dump(PHP_INT_MAX + 1)var_dump((int)(PHP_INT_MAX + 1))</code></pre><h3 id="问题解答-6"><a href="#问题解答-6" class="headerlink" title="问题解答"></a>问题解答</h3><p>代码”var_dump(PHP_INT_MAX + 1)”的结果将被转化为double类型, 在上面的情况中, 输出的结果为”double(9.2233720368548E+18)”.<br>这个问题的关键是考察面试者对于php对于大整数的处理, 即将整型无法处理的数据转化为double类型.</p><p>代码”var_dump((int)(PHP_INT_MAX + 1))”将输出结果为一个负数, 在上面那种情况下, 输出的结果为”int(-9223372036854775808))”.</p><h2 id="问题十"><a href="#问题十" class="headerlink" title="问题十"></a>问题十</h2><h3 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h3><p>如何对一个字符串数组根据值在忽略大小写的情况下进行排序, 并不打乱键与值的关系.<br>例如给出下面的数组:</p><pre><code>array(    &apos;0&apos; =&gt; &apos;z1&apos;,    &apos;1&apos; =&gt; &apos;Z10&apos;,    &apos;2&apos; =&gt; &apos;z12&apos;,    &apos;3&apos; =&gt; &apos;Z2&apos;,    &apos;4&apos; =&gt; &apos;z3&apos;,)</code></pre><p>排序完的结果为:</p><pre><code>array(    &apos;0&apos; =&gt; &apos;z1&apos;,    &apos;3&apos; =&gt; &apos;Z2&apos;,    &apos;4&apos; =&gt; &apos;z3&apos;,    &apos;1&apos; =&gt; &apos;Z10&apos;,    &apos;2&apos; =&gt; &apos;z12&apos;,)</code></pre><p>The trick to solving this problem is to use three special flags with the standard asort() library function:</p><p>解决这个问题的关键是, 在”asort()”库函数中设置特殊的标识:</p><pre><code>asort($arr, SORT_STRING|SORT_FLAG_CASE|SORT_NATURAL)</code></pre><p>函数”asort()”函数是标准函数”sort()”的一个变形, 这个函数会保持原有数据的键值关系.<br>三个标识”SORT_STRING”, “SORT_FLAG_CASE”和”SORT_NATURAL”设置了排序的要求,<br>将元素视为字符串, 忽略大小写, 保持原有的键值关系.</p><p>注意, 使用函数”natcasesort()”并不能得到预期的效果, 因为它会打乱原有的键值关系.</p><h2 id="问题十一"><a href="#问题十一" class="headerlink" title="问题十一"></a>问题十一</h2><h3 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h3><p>在php中, PEAR是什么???</p><h3 id="问题解答-7"><a href="#问题解答-7" class="headerlink" title="问题解答"></a>问题解答</h3><p>PEAR(PHP Extension and Application Repository)是一个可复用的php组件库.<br>这个资源库中包含了各种各样的php代码摘要和库.</p><p>PEAR同时提供了一个自动下载包的命令行工具.</p><h2 id="问题十二"><a href="#问题十二" class="headerlink" title="问题十二"></a>问题十二</h2><p>What are the differences between echo and print in PHP?</p><h3 id="问题描述-10"><a href="#问题描述-10" class="headerlink" title="问题描述"></a>问题描述</h3><p>在php中”echo”和”print”的区别是什么???</p><p>echo and print are largely the same in PHP. Both are used to output data to the screen.</p><h3 id="问题解答-8"><a href="#问题解答-8" class="headerlink" title="问题解答"></a>问题解答</h3><p>在php中, “echo”和”print”有着及其相似的功能.<br>他们都能将数据展现在屏幕上.</p><p>他们的不同如下所是:</p><p>The only differences are as follows:</p><ul><li>“echo”使用时, 没有返回值, 而”print”会返回1. 这也使得”print”可以在表达式中使用.</li><li>“echo”可以接受多个参数, 但是, 这种方式使用很少. “print”只接收一个参数</li><li>“echo”是一个关键字, 而”print”是一个特殊的函数.</li></ul><h2 id="问题十三"><a href="#问题十三" class="headerlink" title="问题十三"></a>问题十三</h2><h3 id="问题描述-11"><a href="#问题描述-11" class="headerlink" title="问题描述"></a>问题描述</h3><p>下面的代码段的结果是什么:</p><pre><code>$v = 1;$m = 2;$l = 3;if( $l &gt; $m &gt; $v){    echo &quot;yes&quot;;}else{    echo &quot;no&quot;;}</code></pre><h3 id="问题解答-9"><a href="#问题解答-9" class="headerlink" title="问题解答"></a>问题解答</h3><p>一般人会认为$3 &gt; 2 &gt; 1$, 那么最后输出的结果为”yes”.<br>事实上, 最后输出的结果为”no”.</p><p>首先, 式子”\$l &gt; \$m”将被执行, 并返回一个布尔值1, 即true.<br>接着比较这个布尔值和一个整型1, 即式子等同于”bool(1) &gt; \$v”, 结果为NULL, 所以最后的结果是”no”.</p><h2 id="问题十四"><a href="#问题十四" class="headerlink" title="问题十四"></a>问题十四</h2><h3 id="问题描述-12"><a href="#问题描述-12" class="headerlink" title="问题描述"></a>问题描述</h3><p>当执行完下面的代码后, 变量”\$x”的值是什么?</p><pre><code>$x = NULL;if (&apos;0xFF&apos; == 255) {    $x = (int)&apos;0xFF&apos;;}</code></pre><h3 id="问题解答-10"><a href="#问题解答-10" class="headerlink" title="问题解答"></a>问题解答</h3><p>最后的答案既不是NULL, 也不是255.<br>最后的结果是”\$x”为0.</p><p>首先, 我们需要判断表达式”‘0xFF’ == 255”的结果是true还是’false’.<br>当一个十六进制的字符串与一个整型数据比较时, 这个字符串将转为一个整型.<br>在内部, php会使用”is_numeric_string”判断这个字符串, 并将它转化为一个整型(因为另一个时参数时整型).<br>在这种情况下, 字符串”0xFF”将转化为255.<br>这时, 255与255比较, 结果为true.<br>这种情况只支持十六进制的字符串, 不支持八进制和二进制的字符串.</p><p>变量’\$x’的值并不是’0xFF’的整型值.<br>在显式的将字符串转化为整型时, 底层将使用”convert_to_long”函数, 而不是”is_numeric_string”函数.<br>函数”convert_to_long”对字符串进行转化时, 从左往右依次转化, 直到遇到第一个非数值字符.<br>对于’0xFF’字符, 第一个非数字字符是’x’.<br>那么整个转化过程的结果为’0’.<br>所以”(int)’0xFF’”的结果是0, 即’\$x’的值为0.</p>]]></content>
      
      
      <categories>
          
          <category> php-devel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php-devel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buggy PHP Code</title>
      <link href="/posts/62d10050.html"/>
      <url>/posts/62d10050.html</url>
      
        <content type="html"><![CDATA[<p>PHP makes it relatively easy to build a web-based system, which is much of the reason for its popularity. But its ease of use notwithstanding, PHP has evolved into quite a sophisticated language with many frameworks, nuances, and subtleties that can bite developers, leading to hours of hair-pulling debugging. This article highlights ten of the more common mistakes that PHP developers need to beware of.</p><p>Common Mistake #1: Leaving dangling array references after foreach loops</p><p>Not sure how to use foreach loops in PHP? Using references in foreach loops can be useful if you want to operate on each element in the array that you are iterating over. For example:</p><p>$arr = array(1, 2, 3, 4);<br>foreach ($arr as &amp;$value) {<br>$value = $value * 2;<br>}<br>// $arr is now array(2, 4, 6, 8)</p><p>The problem is that, if you’re not careful, this can also have some undesirable side effects and consequences. Specifically, in the above example, after the code is executed, $value will remain in scope and will hold a reference to the last element in the array. Subsequent operations involving $value could therefore unintentionally end up modifying the last element in the array.</p><p>The main thing to remember is that foreach does not create a scope. Thus, $value in the above example is a reference within the top scope of the script. On each iteration foreach sets the reference to point to the next element of $array. After the loop completes, therefore, $value still points to the last element of $array and remains in scope.</p><p>Here’s an example of the kind of evasive and confusing bugs that this can lead to:</p><p>$array = [1, 2, 3];<br>echo implode(‘,’, $array), “\n”;</p><p>foreach ($array as &amp;$value) {} // by reference<br>echo implode(‘,’, $array), “\n”;</p><p>foreach ($array as $value) {} // by value (i.e., copy)<br>echo implode(‘,’, $array), “\n”;</p><p>The above code will output the following:</p><p>1,2,3<br>1,2,3<br>1,2,2</p><p>No, that’s not a typo. The last value on the last line is indeed a 2, not a 3.</p><p>Why?</p><p>After going through the first foreach loop, $array remains unchanged but, as explained above, $value is left as a dangling reference to the last element in $array (since that foreach loop accessed $value by reference).</p><p>As a result, when we go through the second foreach loop, “weird stuff” appears to happen. Specifically, since $value is now being accessed by value (i.e., by copy), foreach copies each sequential $array element into $value in each step of the loop. As a result, here’s what happens during each step of the second foreach loop:</p><pre><code>Pass 1: Copies $array[0] (i.e., “1”) into $value (which is a reference to $array[2]), so $array[2] now equals 1. So $array now contains [1, 2, 1].Pass 2: Copies $array[1] (i.e., “2”) into $value (which is a reference to $array[2]), so $array[2] now equals 2. So $array now contains [1, 2, 2].Pass 3: Copies $array[2] (which now equals “2”) into $value (which is a reference to $array[2]), so $array[2] still equals 2. So $array now contains [1, 2, 2].</code></pre><p>To still get the benefit of using references in foreach loops without running the risk of these kinds of problems, call unset() on the variable, immediately after the foreach loop, to remove the reference; e.g.:</p><p>$arr = array(1, 2, 3, 4);<br>foreach ($arr as &amp;$value) {<br>$value = $value * 2;<br>}<br>unset($value); // $value no longer references $arr[3]</p><p>Common Mistake #2: Misunderstanding isset() behavior</p><p>Despite its name, isset() not only returns false if an item does not exist, but also returns false for null values.</p><p>This behavior is more problematic than it might appear at first and is a common source of problems.</p><p>Consider the following:</p><p>$data = fetchRecordFromStorage($storage, $identifier);<br>if (!isset($data[‘keyShouldBeSet’]) {<br>// do something here if ‘keyShouldBeSet’ is not set<br>}</p><p>The author of this code presumably wanted to check if keyShouldBeSet was set in $data. But, as discussed, isset($data[‘keyShouldBeSet’]) will also return false if $data[‘keyShouldBeSet’] was set, but was set to null. So the above logic is flawed.</p><p>Here’s another example:</p><p>if ($_POST[‘active’]) {<br>$postData = extractSomething($_POST);<br>}</p><p>// …</p><p>if (!isset($postData)) {<br>echo ‘post not active’;<br>}</p><p>The above code assumes that if $_POST[‘active’] returns true, then postData will necessarily be set, and therefore isset($postData) will return true. So conversely, the above code assumes that the only way that isset($postData) will return false is if $_POST[‘active’] returned false as well.</p><p>Not.</p><p>As explained, isset($postData) will also return false if $postData was set to null. It therefore is possible for isset($postData) to return false even if $_POST[‘active’] returned true. So again, the above logic is flawed.</p><p>And by the way, as a side point, if the intent in the above code really was to again check if $_POST[‘active’] returned true, relying on isset() for this was a poor coding decision in any case. Instead, it would have been better to just recheck $_POST[‘active’]; i.e.:</p><p>if ($_POST[‘active’]) {<br>$postData = extractSomething($_POST);<br>}</p><p>// …</p><p>if ($_POST[‘active’]) {<br>echo ‘post not active’;<br>}</p><p>For cases, though, where it is important to check if a variable was really set (i.e., to distinguish between a variable that wasn’t set and a variable that was set to null), the array_key_exists() method is a much more robust solution.</p><p>For example, we could rewrite the first of the above two examples as follows:</p><p>$data = fetchRecordFromStorage($storage, $identifier);<br>if (! array_key_exists(‘keyShouldBeSet’, $data)) {<br>// do this if ‘keyShouldBeSet’ isn’t set<br>}</p><p>Moreover, by combining array_key_exists() with get_defined_vars(), we can reliably check whether a variable within the current scope has been set or not:</p><p>if (array_key_exists(‘varShouldBeSet’, get_defined_vars())) {<br>// variable $varShouldBeSet exists in current scope<br>}</p><p>Common Mistake #3: Confusion about returning by reference vs. by value</p><p>Consider this code snippet:</p><p>class Config<br>{<br>private $values = [];</p><pre><code>public function getValues() {    return $this-&gt;values;}</code></pre><p>}</p><p>$config = new Config();</p><p>$config-&gt;getValues()[‘test’] = ‘test’;<br>echo $config-&gt;getValues()[‘test’];</p><p>If you run the above code, you’ll get the following:</p><p>PHP Notice: Undefined index: test in /path/to/my/script.php on line 21</p><p>What’s wrong?</p><p>The issue is that the above code confuses returning arrays by reference with returning arrays by value. Unless you explicitly tell PHP to return an array by reference (i.e., by using&amp;), PHP will by default return the the array “by value”. This means that a copy of the array will be returned and therefore the called function and the caller will not be accessing the same instance of the array.</p><p>So the above call to getValues() returns a copy of the $values array rather than a reference to it. With that in mind, let’s revisit the two key lines from the above the example:</p><p>// getValues() returns a COPY of the $values array, so this adds a ‘test’ element<br>// to a COPY of the $values array, but not to the $values array itself.<br>$config-&gt;getValues()[‘test’] = ‘test’;</p><p>// getValues() again returns ANOTHER COPY of the $values array, and THIS copy doesn’t<br>// contain a ‘test’ element (which is why we get the “undefined index” message).<br>echo $config-&gt;getValues()[‘test’];</p><p>One possible fix would be to save the first copy of the $values array returned by getValues() and then operate on that copy subsequently; e.g.:</p><p>$vals = $config-&gt;getValues();<br>$vals[‘test’] = ‘test’;<br>echo $vals[‘test’];</p><p>That code will work fine (i.e., it will output test without generating any “undefined index” message), but depending on what you’re trying to accomplish, this approach may or may not be adequate. In particular, the above code will not modify the original $values array. So if you do want your modifications (such as adding a ‘test’ element) to affect the original array, you would instead need to modify the getValues() function to return a reference to the $values array itself. This is done by adding a &amp; before the function name, thereby indicating that it should return a reference; i.e.:</p><p>class Config<br>{<br>private $values = [];</p><pre><code>// return a REFERENCE to the actual $values arraypublic function &amp;getValues() {    return $this-&gt;values;}</code></pre><p>}</p><p>$config = new Config();</p><p>$config-&gt;getValues()[‘test’] = ‘test’;<br>echo $config-&gt;getValues()[‘test’];</p><p>The output of this will be test, as expected.</p><p>But to make things more confusing, consider instead the following code snippet:</p><p>class Config<br>{<br>private $values;</p><pre><code>// using ArrayObject rather than arraypublic function __construct() {    $this-&gt;values = new ArrayObject();}public function getValues() {    return $this-&gt;values;}</code></pre><p>}</p><p>$config = new Config();</p><p>$config-&gt;getValues()[‘test’] = ‘test’;<br>echo $config-&gt;getValues()[‘test’];</p><p>If you guessed that this would result in the same “undefined index” error as our earlier array example, you were wrong. In fact, this code will work just fine. The reason is that, unlike arrays, PHP always passes objects by reference. (ArrayObject is an SPL object, which fully mimics arrays usage, but works as an object.)</p><p>As these examples demonstrate, it is not always entirely obvious in PHP whether you are dealing with a copy or a reference. It is therefore essential to understand these default behaviors (i.e., variables and arrays are passed by value; objects are passed by reference) and also to carefully check the API documentation for the function you are calling to see if it is returning a value, a copy of an array, a reference to an array, or a reference to an object.</p><p>All that said, it is important to note that the practice of returning a reference to an array or an ArrayObject is generally something that should be avoided, as it provides the caller with the ability to modify the instance’s private data. This “flies in the face” of encapsulation. Instead, it’s better to use old style “getters” and “setters”, e.g.:</p><p>class Config<br>{<br>private $values = [];</p><pre><code>public function setValue($key, $value) {    $this-&gt;values[$key] = $value;}public function getValue($key) {    return $this-&gt;values[$key];}</code></pre><p>}</p><p>$config = new Config();</p><p>$config-&gt;setValue(‘testKey’, ‘testValue’);<br>echo $config-&gt;getValue(‘testKey’); // echos ‘testValue’</p><p>This approach gives the caller the ability to set or get any value in the array without providing public access to the otherwise-private $values array itself.</p><p>Common Mistake #4: Performing queries in a loop</p><p>It’s not uncommon to come across something like this if your PHP is not working:</p><p>$models = [];</p><p>foreach ($inputValues as $inputValue) {<br>$models[] = $valueRepository-&gt;findByValue($inputValue);<br>}</p><p>While there may be absolutely nothing wrong here, but if you follow the logic in the code, you may find that the innocent looking call above to $valueRepository-&gt;findByValue() ultimately results in a query of some sort, such as:</p><p>$result = $connection-&gt;query(“SELECT <code>x</code>,<code>y</code> FROM <code>values</code> WHERE <code>value</code>=” . $inputValue);</p><p>As a result, each iteration of the above loop would result in a separate query to the database. So if, for example, you supplied an array of 1,000 values to the loop, it would generate 1,000 separate queries to the resource! If such a script is called in multiple threads, it could potentially bring the system to a grinding halt.</p><p>It’s therefore crucial to recognize when queries are being made by your code and, whenever possible, gather the values and then run one query to fetch all the results.</p><p>One example of a fairly common place to encounter querying being done inefficiently (i.e., in a loop) is when a form is posted with a list of values (IDs, for example). Then, to retrieve the full record data for each of the IDs, the code will loop through the array and do a separate SQL query for each ID. This will often look something like this:</p><p>$data = [];<br>foreach ($ids as $id) {<br>$result = $connection-&gt;query(“SELECT <code>x</code>, <code>y</code> FROM <code>values</code> WHERE <code>id</code> = “ . $id);<br>$data[] = $result-&gt;fetch_row();<br>}</p><p>But the same thing can be accomplished much more efficiently in a single SQL query as follows:</p><p>$data = [];<br>if (count($ids)) {<br>$result = $connection-&gt;query(“SELECT <code>x</code>, <code>y</code> FROM <code>values</code> WHERE <code>id</code> IN (“ . implode(‘,’, $ids));<br>while ($row = $result-&gt;fetch_row()) {<br>$data[] = $row;<br>}<br>}</p><p>It’s therefore crucial to recognize when queries are being made, either directly or indirectly, by your code. Whenever possible, gather the values and then run one query to fetch all the results. Yet caution must be exercised there as well, which leads us to our next common PHP mistake…<br>Common Mistake #5: Memory usage headfakes and inefficiencies</p><p>While fetching many records at once is definitely more efficient than running a single query for each row to fetch, such an approach can potentially lead to an “out of memory” condition in libmysqlclient when using PHP’s mysql extension.</p><p>To demonstrate, let’s take a look at a test box with limited resources (512MB RAM), MySQL, and php-cli.</p><p>We’ll bootstrap a database table like this:</p><p>// connect to mysql<br>$connection = new mysqli(‘localhost’, ‘username’, ‘password’, ‘database’);</p><p>// create table of 400 columns<br>$query = ‘CREATE TABLE <code>test</code>(<code>id</code> INT NOT NULL PRIMARY KEY AUTO_INCREMENT’;<br>for ($col = 0; $col &lt; 400; $col++) {<br>$query .= “, <code>col$col</code> CHAR(10) NOT NULL”;<br>}<br>$query .= ‘);’;<br>$connection-&gt;query($query);</p><p>// write 2 million rows<br>for ($row = 0; $row &lt; 2000000; $row++) {<br>$query = “INSERT INTO <code>test</code> VALUES ($row”;<br>for ($col = 0; $col &lt; 400; $col++) {<br>$query .= ‘, ‘ . mt_rand(1000000000, 9999999999);<br>}<br>$query .= ‘)’;<br>$connection-&gt;query($query);<br>}</p><p>OK, now let’s check resources usage:</p><p>// connect to mysql<br>$connection = new mysqli(‘localhost’, ‘username’, ‘password’, ‘database’);<br>echo “Before: “ . memory_get_peak_usage() . “\n”;</p><p>$res = $connection-&gt;query(‘SELECT <code>x</code>,<code>y</code> FROM <code>test</code> LIMIT 1’);<br>echo “Limit 1: “ . memory_get_peak_usage() . “\n”;</p><p>$res = $connection-&gt;query(‘SELECT <code>x</code>,<code>y</code> FROM <code>test</code> LIMIT 10000’);<br>echo “Limit 10000: “ . memory_get_peak_usage() . “\n”;</p><p>Output:</p><p>Before: 224704<br>Limit 1: 224704<br>Limit 10000: 224704</p><p>Cool. Looks like the query is safely managed internally in terms of resources.</p><p>Just to be sure, though, let’s boost the limit one more time and set it to 100,000. Uh-oh. When we do that, we get:</p><p>PHP Warning: mysqli::query(): (HY000/2013):<br>Lost connection to MySQL server during query in /root/test.php on line 11</p><p>What happened?</p><p>The issue here is the way PHP’s mysql module works. It’s really just a proxy for libmysqlclient, which does the dirty work. When a portion of data is selected, it goes directly into memory. Since this memory is not managed by PHP’s manager, memory_get_peak_usage() won’t show any increase in resources utilization as we up the limit in our query. This leads to problems like the one demonstrated above where we’re tricked into complacency thinking that our memory management is fine. But in reality, our memory management is seriously flawed and we can experience problems like the one shown above.</p><p>You can at least avoid the above headfake (although it won’t itself improve your memory utilization) by instead using the mysqlnd module. mysqlnd is compiled as a native PHP extension and it does use PHP’s memory manager.</p><p>Therefore, if we run the above test using mysqlnd rather than mysql, we get a much more realistic picture of our memory utilization:</p><p>Before: 232048<br>Limit 1: 324952<br>Limit 10000: 32572912</p><p>And it’s even worse than that, by the way. According to PHP documentation, mysql uses twice as many resources as mysqlnd to store data, so the original script using mysql really used even more memory than shown here (roughly twice as much).</p><p>To avoid such problems, consider limiting the size of your queries and using a loop with small number of iterations; e.g.:</p><p>$totalNumberToFetch = 10000;<br>$portionSize = 100;</p><p>for ($i = 0; $i &lt;= ceil($totalNumberToFetch / $portionSize); $i++) {<br>$limitFrom = $portionSize * $i;<br>$res = $connection-&gt;query(<br>“SELECT <code>x</code>,<code>y</code> FROM <code>test</code> LIMIT $limitFrom, $portionSize”);<br>}</p><p>When we consider both this PHP mistake and mistake #4 above, we realize that there is a healthy balance that your code ideally needs to achieve between, on the one hand, having your queries being too granular and repetitive, vs. having each of your individual queries be too large. As is true with most things in life, balance is needed; either extreme is not good and can cause problems with PHP not working properly.<br>Common Mistake #6: Ignoring Unicode/UTF-8 issues</p><p>In some sense, this is really more of an issue in PHP itself than something you would run into while debugging PHP, but it has never been adequately addressed. PHP 6’s core was to be made Unicode-aware, but that was put on hold when development of PHP 6 was suspended back in 2010.</p><p>But that by no means absolves the developer from properly handing UTF-8 and avoiding the erroneous assumption that all strings will necessarily be “plain old ASCII”. Code that fails to properly handle non-ASCII strings is notorious for introducing gnarly heisenbugs into your code. Even simple strlen($_POST[‘name’]) calls could cause problems if someone with a last name like “Schrödinger” tried to sign up into your system.</p><p>Here’s a small checklist to avoid such problems in your code:</p><pre><code>If you don’t know much about Unicode and UTF-8, you should at least learn the basics. There’s a great primer here.Be sure to always use the mb_* functions instead of the old string functions (make sure the “multibyte” extension is included in your PHP build).Make sure your database and tables are set to use Unicode (many builds of MySQL still use latin1 by default).Remember that json_encode() converts non-ASCII symbols (e.g., “Schrödinger” becomes “Schr\u00f6dinger”) but serialize() does not.Make sure your PHP code files are also UTF-8 encoded to avoid collisions when concatenating strings with hardcoded or configured string constants.</code></pre><p>A particularly valuable resource in this regard is the UTF-8 Primer for PHP and MySQL post by Francisco Claria on this blog.</p><p>Common Mistake #7: Assuming $_POST will always contain your POST data</p><p>Despite its name, the $_POST array won’t always contain your POST data and can be easily found empty. To understand this, let’s take a look at an example. Assume we make a server request with a jQuery.ajax() call as follows:</p><p>// js<br>$.ajax({<br>url: ‘<a href="http://my.site/some/path&#39;" target="_blank" rel="noopener">http://my.site/some/path&#39;</a>,<br>method: ‘post’,<br>data: JSON.stringify({a: ‘a’, b: ‘b’}),<br>contentType: ‘application/json’<br>});</p><p>(Incidentally, note the contentType: ‘application/json’ here. We send data as JSON, which is quite popular for APIs. It’s the default, for example, for posting in the AngularJS $http service.)</p><p>On the server side of our example, we simply dump the $_POST array:</p><p>// php<br>var_dump($_POST);</p><p>Surprisingly, the result will be:</p><p>array(0) { }</p><p>Why? What happened to our JSON string {a: ‘a’, b: ‘b’}?</p><p>The answer is that PHP only parses a POST payload automatically when it has a content type of application/x-www-form-urlencoded or multipart/form-data. The reasons for this are historical — these two content types were essentially the only ones used years ago when PHP’s $_POST was implemented. So with any other content type (even those that are quite popular today, like application/json), PHP doesn’t automatically load the POST payload.</p><p>Since $_POST is a superglobal, if we override it once (preferably early in our script), the modified value (i.e., including the POST payload) will then be referenceable throughout our code. This is important since $_POST is commonly used by PHP frameworks and almost all custom scripts to extract and transform request data.</p><p>So, for example, when processing a POST payload with a content type of application/json, we need to manually parse the request contents (i.e., decode the JSON data) and override the $_POST variable, as follows:</p><p>// php<br>$_POST = json_decode(file_get_contents(‘php://input’), true);</p><p>Then when we dump the $_POST array, we see that it correctly includes the POST payload; e.g.:</p><p>array(2) { [“a”]=&gt; string(1) “a” [“b”]=&gt; string(1) “b” }</p><p>Common Mistake #8: Thinking that PHP supports a character data type</p><p>Look at this sample piece of code and try guessing what it will print:</p><p>for ($c = ‘a’; $c &lt;= ‘z’; $c++) {<br>echo $c . “\n”;<br>}</p><p>If you answered ‘a’ through ‘z’, you may be surprised to know that you were wrong.</p><p>Yes, it will print ‘a’ through ‘z’, but then it will also print ‘aa’ through ‘yz’. Let’s see why.</p><p>In PHP there’s no char datatype; only string is available. With that in mind, incrementing the string z in PHP yields aa:</p><p>php&gt; $c = ‘z’; echo ++$c . “\n”;<br>aa</p><p>Yet to further confuse matters, aa is lexicographically less than z:</p><p>php&gt; var_export((boolean)(‘aa’ &lt; ‘z’)) . “\n”;<br>true</p><p>That’s why the sample code presented above prints the letters a through z, but then also prints aa through yz. It stops when it reachs za, which is the first value it encounters that it “greater than” z:</p><p>php&gt; var_export((boolean)(‘za’ &lt; ‘z’)) . “\n”;<br>false</p><p>That being the case, here’s one way to properly loop through the values ‘a’ through ‘z’ in PHP:</p><p>for ($i = ord(‘a’); $i &lt;= ord(‘z’); $i++) {<br>echo chr($i) . “\n”;<br>}</p><p>Or alternatively:</p><p>$letters = range(‘a’, ‘z’);</p><p>for ($i = 0; $i &lt; count($letters); $i++) {<br>echo $letters[$i] . “\n”;<br>}</p><p>Common Mistake #9: Ignoring coding standards</p><p>Although ignoring coding standards doesn’t directly lead to needing to debug PHP code, it is still probably one of the most important things to discuss here.</p><p>Ignoring coding standards can cause a whole slew of problems on a project. At best, it results in code that is inconsistent (since every developer is “doing their own thing”). But at worst, it produces PHP code that does not work or can be difficult (sometimes almost impossible) to navigate, making it extremely difficult to debug, enhance, maintain. And that means reduced productivity for your team, including lots of wasted (or at least unnecessary) effort.</p><p>Fortunately for PHP developers, there is the PHP Standards Recommendation (PSR), comprised of the following five standards:</p><pre><code>PSR-0: Autoloading StandardPSR-1: Basic Coding StandardPSR-2: Coding Style GuidePSR-3: Logger InterfacePSR-4: Autoloader</code></pre><p>PSR was originally created based on inputs from maintainers of the most recognized platforms on the market. Zend, Drupal, Symfony, Joomla and others contributed to these standards, and are now following them. Even PEAR, which attempted to be a standard for years before that, participates in PSR now.</p><p>In some sense, it almost doesn’t matter what your coding standard is, as long as you agree on a standard and stick to it, but following the PSR is generally a good idea unless you have some compelling reason on your project to do otherwise. More and more teams and projects are conforming with the PSR. Tt’s definitely recognized at this point as “the” standard by the majority of PHP developers, so using it will help ensure that new developers are familiar and comfortable with your coding standard when they join your team.<br>Common Mistake #10: Misusing empty()</p><p>Some PHP developers like using empty() for boolean checks for just about everything. There are case, though, where this can lead to confusion.</p><p>First, let’s come back to arrays and ArrayObject instances (which mimic arrays). Given their similarity, it’s easy to assume that arrays and ArrayObject instances will behave identically. This proves, however, to be a dangerous assumption. For example, in PHP 5.0:</p><p>// PHP 5.0 or later:<br>$array = [];<br>var_dump(empty($array)); // outputs bool(true)<br>$array = new ArrayObject();<br>var_dump(empty($array)); // outputs bool(false)<br>// why don’t these both produce the same output?</p><p>And to make matters even worse, the results would have been different prior to PHP 5.0:</p><p>// Prior to PHP 5.0:<br>$array = [];<br>var_dump(empty($array)); // outputs bool(false)<br>$array = new ArrayObject();<br>var_dump(empty($array)); // outputs bool(false)</p><p>This approach is unfortunately quite popular. For example, this is the way Zend\Db\TableGateway of Zend Framework 2 returns data when calling current() on TableGateway::select() result as the doc suggests. Developer can easily become victim of this mistake with such data.</p><p>To avoid these issues, the better approach to checking for empty array structures is to use count():</p><p>// Note that this work in ALL versions of PHP (both pre and post 5.0):<br>$array = [];<br>var_dump(count($array)); // outputs int(0)<br>$array = new ArrayObject();<br>var_dump(count($array)); // outputs int(0)</p><p>And incidentally, since PHP casts 0 to false, count() can also be used within if () conditions to check for empty arrays. It’s also worth noting that, in PHP, count() is constant complexity (O(1) operation) on arrays, which makes it even clearer that it’s the right choice.</p><p>Another example when empty() can be dangerous is when combining it with the magic class function __get(). Let’s define two classes and have a test property in both.</p><p>First let’s define a Regular class that includes test as a normal property:</p><p>class Regular<br>{<br>public $test = ‘value’;<br>}</p><p>Then let’s define a Magic class that uses the magic __get() operator to access its test property:</p><p>class Magic<br>{<br>private $values = [‘test’ =&gt; ‘value’];</p><pre><code>public function __get($key){    if (isset($this-&gt;values[$key])) {        return $this-&gt;values[$key];    }}</code></pre><p>}</p><p>OK, now let’s see what happens when we attempt to access the test property of each of these classes:</p><p>$regular = new Regular();<br>var_dump($regular-&gt;test); // outputs string(4) “value”<br>$magic = new Magic();<br>var_dump($magic-&gt;test); // outputs string(4) “value”</p><p>Fine so far.</p><p>But now let’s see what happens when we call empty() on each of these:</p><p>var_dump(empty($regular-&gt;test)); // outputs bool(false)<br>var_dump(empty($magic-&gt;test)); // outputs bool(true)</p><p>Ugh. So if we rely on empty(), we can be misled into believing that the test property of $magic is empty, whereas in reality it is set to ‘value’.</p><p>Unfortunately, if a class uses the magic __get() function to retrieve a property’s value, there’s no foolproof way to check if that property value is empty or not. Outside of the class’ scope, you can really only check if a null value will be returned, and that doesn’t necessarily mean that the corresponding key is not set, since it actually could have been set to null.</p><p>In contrast, if we attempt to reference a non-existent property of a Regular class instance, we will get a notice similar to the following:</p><p>Notice: Undefined property: Regular::$nonExistantTest in /path/to/test.php on line 10</p><p>Call Stack:<br>0.0012 234704 1. {main}() /path/to/test.php:0</p><p>So the main point here is that the empty() method should be used with care as it can lend itself to confusing – or even potentially misleading – results, if one is not careful.<br>Wrap-up</p><p>PHP’s ease of use can lull developers into a false sense of comfort, leaving themselves vulnerable to lengthy PHP debugging due to some of the nuances and idiosyncrasies of the language. This can result in PHP not working and problems such as those described herein.</p><p>The PHP language has evolved significantly over the course of its 20 year history. Familiarizing oneself with its subtleties is a worthwhile endeavor, as it will help ensure that the software you produce is more scalable, robust, and maintainable.</p>]]></content>
      
      
      <categories>
          
          <category> php-devel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php-devel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20 高级嵌入式</title>
      <link href="/posts/bea5bedf.html"/>
      <url>/posts/bea5bedf.html</url>
      
        <content type="html"><![CDATA[<h1 id="20-高级嵌入式"><a href="#20-高级嵌入式" class="headerlink" title="20 高级嵌入式"></a>20 高级嵌入式</h1><p>php的嵌入式能够提供的可不仅仅是同步的加载和执行脚本. 通过理解php的执行模块 各个部分是怎样组合的, 甚至给出一个脚本还可以回调到你的宿主应用中. 本章将涉及 SAPI层提供的I/O钩子带来的好处, 展开你已经从前面的主题中获取到信息的执行模块进行学习.</p><h1 id="回调到php中"><a href="#回调到php中" class="headerlink" title="回调到php中"></a>回调到php中</h1><p>除了加载外部的脚本, 和你在上⼀章看到的类似, 你的php嵌入式应用, 下面将实现⼀个类似于用户空间eval()的命令.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_eval_string</span><span class="params">(<span class="keyword">char</span> *str, zval *retval_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">char</span> *string_name TSRMLS_DC)</span></span></span><br></pre></td></tr></table></figure><p>这里, str是实际要执行的php脚本代码, 而string_name是⼀个与执行关联的任意描述信息. 如果发生错误, php会将这个描述信息作为错误输出中的”文件名”. retval_ptr, 你应该 已经猜到了, 它将被设置为所传递代码产生的返回值. 试试用下面的代码创建新的项目吧.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sapi/embed/php_embed.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    PHP_EMBED_START_BLOCK(argc, argv)</span><br><span class="line">        zend_eval_string(<span class="string">"echo 'Hello World!';"</span>, <span class="literal">NULL</span>, <span class="string">"Simple Hello World App"</span> TSRMLS_CC);</span><br><span class="line">    PHP_EMBED_END_BLOCK()</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在使用命令或第19章”设置宿主环境”构建它(将Makefile中或命令中的embed1替换为embed2)</p><h4 id="备选方案-脚本文件的包含"><a href="#备选方案-脚本文件的包含" class="headerlink" title="备选方案: 脚本文件的包含"></a>备选方案: 脚本文件的包含</h4><p>可以预见的是, 这使得编译和执行外部脚本文件远比之前的方法更加容易, 因为你的 应用可以将原本复杂的打开/准备/执行的执行序列, 以这种简化但功能更加强大的设计替代:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sapi/embed/php_embed.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>    *filename;</span><br><span class="line">    <span class="keyword">if</span> ( argc &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s &lt;filename.php&gt; &lt;arguments&gt;\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    filename    = argv[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* 忽略第0个参数 */</span> argc --;</span><br><span class="line">argv ++;</span><br><span class="line">    PHP_EMBED_START_BLOCK(argc, argv)</span><br><span class="line">        <span class="keyword">char</span>    *include_script;</span><br><span class="line">        spprintf(&amp;include_script, <span class="number">0</span>, <span class="string">"include '%s';"</span>, filename);</span><br><span class="line">        zend_eval_string(include_script, <span class="literal">NULL</span>, filename TSRMLS_CC);</span><br><span class="line">        efree(include_script);</span><br><span class="line">    PHP_EMBED_END_BLOCK()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 这种特殊的方法必须接受一个缺点, 如果文件名包含单引号, 将导致解析错误. 不过这可以通过使用ext/standard/php_string.h中的php_addslashes()API调用解决. 花一些时间去阅读这个 文件以及附录中的API参考, 你会发现很多的特性, 它们可以让你避免在以后重造轮子.</p><h4 id="调用用户空间函数"><a href="#调用用户空间函数" class="headerlink" title="调用用户空间函数"></a>调用用户空间函数</h4><p>如你看到的加载和执行脚本文件, 在内部有两种方式调用用户空间函数. 现在最明显 的可能是重用zend_eval_string(), 将函数名和所有它的参数组织到⼀个庞大的字符串中, 然后收集返回值.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PHP_EMBED_START_BLOCK(argc, argv)</span><br><span class="line">    <span class="keyword">char</span>    *command;</span><br><span class="line">    zval    retval;</span><br><span class="line">    spprintf(&amp;command, <span class="number">0</span>, <span class="string">"nl2br('%s');"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    zend_eval_string(command, &amp;retval, <span class="string">"nl2br() execution"</span> TSRMLS_CC);</span><br><span class="line">    efree(command);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"out: %s\n"</span>, Z_STRVAL(retval));</span><br><span class="line">    zval_dtor(&amp;retval);</span><br><span class="line">PHP_EMBED_END_BLOCK()</span><br></pre></td></tr></table></figure><p>和前面的include很像, 这个方法有⼀个致命的缺陷: 如果输入参数paramin(译者给出 的例子中是argv[1])给出⼀个错误的数据, 函数将会失败, 或者更糟糕的是导致无法预期的 结果. 解决方案是永远都避免编译代码的运行时片段, 并直接使用call_user_function()API调用函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_user_function</span><span class="params">(HashTable *function_table, zval **object_pp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       zval *function_name, zval *retval_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                       zend_uint param_count, zval *params[] TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p>实际上从引擎外部调用时, function_table总是EG(function_table). 如果调用⼀个对象或类方法, object_pp需要是IS_OBJECT类型的调用实例zval, 或者对于类的静态调用则是 IS_STRING的值. function_name通常是IS_STRING的值, 包含要调用的函数名, 但是它也 可以是IS_ARRAY, 第0个元素包含一个对象或类名, 第1个元素包含方法名.</p><p>这个函数调用的结果是向传入的retval_ptr指向的zval设置返回值. param_count和 params扮演了argc/argv的角色. 也就是说, params[0]包含所传递的第一个参数, params[param_count - 1]包含了所传递的最后一个参数.</p><p>下面是用这种方法重新实现上面的例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PHP_EMBED_START_BLOCK(argc, argv)</span><br><span class="line">    <span class="keyword">char</span>    *command;</span><br><span class="line">    zval    retval;</span><br><span class="line">    spprintf(&amp;command, <span class="number">0</span>, <span class="string">"nl2br('%s');"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    zend_eval_string(command, &amp;retval, <span class="string">"nl2br() execution"</span> TSRMLS_CC);</span><br><span class="line">    efree(command);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"out: %s\n"</span>, Z_STRVAL(retval));</span><br><span class="line">    zval_dtor(&amp;retval);</span><br><span class="line">PHP_EMBED_END_BLOCK()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_user_function</span><span class="params">(HashTable *function_table, zval **object_pp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       zval *function_name, zval *retval_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                       zend_uint param_count, zval *params[] TSRMLS_DC)</span></span>;</span><br><span class="line">PHP_EMBED_START_BLOCK(argc, argv)</span><br><span class="line">    zval    *args[<span class="number">1</span>];</span><br><span class="line">    zval    retval, str, funcname;</span><br><span class="line">    ZVAL_STRING(&amp;funcname, <span class="string">"nl2br"</span>, <span class="number">0</span>);</span><br><span class="line">    args[<span class="number">0</span>] = &amp;str;</span><br><span class="line">    ZVAL_STRINGL(args[<span class="number">0</span>], <span class="string">"HELLO WORLD!"</span>, <span class="keyword">sizeof</span>(<span class="string">"HELLO WORLD!"</span>), <span class="number">1</span>);</span><br><span class="line">    call_user_function(EG(function_table), <span class="literal">NULL</span>, &amp;funcname, &amp;retval, <span class="number">1</span>, args TSRMLS_CC);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"out: %s\n"</span>, Z_STRVAL(retval));</span><br><span class="line">    zval_dtor(args[<span class="number">0</span>]);</span><br><span class="line">    zval_dtor(&amp;retval);</span><br><span class="line">PHP_EMBED_END_BLOCK()</span><br></pre></td></tr></table></figure><p>尽管代码看起来比较长, 但是工作量会显著降低, 因为这里没有要编译的中间代码, 传 递的数据不需要复制, 每个参数都已经在Zend兼容的结构体中. 同时, 要记得原来的例子中 在字符串中包含单引号时会有潜在的错误. 而这个版本没有这个问题.</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>当发生错误时, 比如脚本解析错误, php将会进入到bailout模式. 在你已经看到的简单 的嵌入式例子中, 这表示它将直接跳到PHP_EMBED_END_BLOCK()宏, 并且绕过所有这个块中的剩余代码. 由于多数潜入php解释器的应用, 目的并不只是为了执行php代码, 因 此避免由于php脚本的故障导致整个应用崩溃是有意义的.</p><p>有⼀种方式可以将所有的执行限制到一个非常小的START/END块中, 这样发生崩溃 就只影响当前块. 这种方式的缺点是每个START/END块函数都是独立的PHP请求. 因此比 如下面START/END块, 虽然从语法逻辑上来看两个块是协同工作的, 但实际上它们之间是不共享公共作用域的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHP_EMBED_START_BLOCK(argc, argv)</span><br><span class="line">        zend_eval_string(<span class="string">"$a = 1;"</span>, <span class="literal">NULL</span>, <span class="string">"Script Block 1"</span>);</span><br><span class="line">    PHP_EMBED_END_BLOCK()</span><br><span class="line">    PHP_EMBED_START_BLOCK(argc, argv)</span><br><span class="line"><span class="comment">/* 将打印出"NULL", 因为变量$a在这个请求中并没有定义. */</span></span><br><span class="line">        zend_eval_string(<span class="string">"var_dump($a);"</span>, <span class="literal">NULL</span>, <span class="string">"Script Block 2"</span>);</span><br><span class="line">    PHP_EMBED_END_BLOCK()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种解决方法是将两个zend_eval_string()调用使用Zend特有的伪语言结构 zend_try, zend_catch, zend_end_try进行隔离. 使用这些结构, 你的应用就可以按照想要的方式处理错误. 考虑下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHP_EMBED_START_BLOCK(argc, argv)</span><br><span class="line">        zend_try &#123;</span><br><span class="line"><span class="comment">/* 尝试执行⼀一些可能失败的代码 */</span></span><br><span class="line">            zend_eval_string(<span class="string">"$1a = 1;"</span>, <span class="literal">NULL</span>, <span class="string">"Script Block 1a"</span>);</span><br><span class="line">        &#125; zend_catch &#123;</span><br><span class="line"><span class="comment">/* 发生错误, 则尝试执行另外⼀一部分代码(⼀一般错误的补救或报告等行为) */</span></span><br><span class="line">zend_eval_string(<span class="string">"$a = 1;"</span>, <span class="literal">NULL</span>, <span class="string">"Script Block 1"</span>);</span><br><span class="line">&#125; zend_end_try();</span><br><span class="line"><span class="comment">/* 这里将显示"NULL", 因为变量$a在这个请求中没有定义. */</span> zend_eval_string(<span class="string">"var_dump($a);"</span>, <span class="literal">NULL</span>, <span class="string">"Script Block 2"</span>);</span><br><span class="line">    PHP_EMBED_END_BLOCK()</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>在这个示例的第二个版本中, zend_try块中将发生解析错误, 但它只影响自己的代码 块, 同时在zend_catch块中使用了⼀段好的代码对错误进行了处理. 同样你也可以尝试自 己给var_dump()部分也加上这些块.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">译注: 这里对zend_try/zend_catch/zend_end_try解释的不是很清楚, 因此做以下补充说明. 读 者阅读这一部分内容需要首先了解sigsetjmp()/siglongjmp()的机制(可以参考&lt;Unix环境高级编程&gt; 第<span class="number">10</span>章第<span class="number">15</span>节).</span><br><span class="line">相关的定义如下:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SIGSETJMP#   <span class="meta-keyword">define</span> SETJMP(a) sigsetjmp(a, 0)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> LONGJMP(a,b) siglongjmp(a, b)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> JMP_BUF sigjmp_buf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SETJMP(a) setjmp(a)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> LONGJMP(a,b) longjmp(a, b)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> JMP_BUF jmp_buf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zend_try \</span></span><br><span class="line">&#123;\</span><br><span class="line">JMP_BUF *__orig_bailout = EG(bailout);                  \</span><br><span class="line">    JMP_BUF __bailout;                                      \</span><br><span class="line">                                                                \</span><br><span class="line">    EG(bailout) = &amp;__bailout;                               \</span><br><span class="line">    <span class="keyword">if</span> (SETJMP(__bailout)==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zend_catch                                              \</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                                \</span><br><span class="line">            EG(bailout) = __orig_bailout;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zend_end_try() \ &#125;\ EG(bailout) = __orig_bailout; \</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zend_try{}代码块中的代码是在一个if语句中的, 这个if的条件是SETJMP(<strong>bailout) == 0, SETJMP()是在当前程序执行的点设置一个可回溯的点(保存了当前执行上下文和环境), SETJMP() 的返回比较特殊, 它有两种返回: 1) 直接返回, 此时返回值为0; 2) 调用LONGJMP()返回到对应 </strong>bailout当时调用SETJMP()的位置, 此时返回值非0.</p><p>基于上面的论述, 可以看出, 当zend_try的代码块中调用了LONGJMP()的时候, 程序将回到if ( SETJMP(__bailout) == 0 )的位置开始执行, 并且它的返回值为-1, 因此, 进入到对应的else语句 块, 也就是zend_catch语句块的代码.</p><p>zend_end_try()则只是⼀个结尾的花括号.</p><p>php中的这个伪语言结构正式这种方式实现的异常处理机制, 在系统的关键点调用 zend_bailout()(在Zend/zend.h中定义)即可.</p><p>本例中, 译者增加了zend_bailout()调用, 演示了这个伪语言结构的使用.</p><h1 id="初始化php"><a href="#初始化php" class="headerlink" title="初始化php"></a>初始化php</h1><p>迄今为止, 你看到的PHP_EMBED_START_BLOCK()和 PHP_EMBED_END_BLOCK()宏都用于启动, 执行, 终止一个紧凑的原子的php请求。<br>这样 做的优点是任何导致php bailout的错误顶多影响到PHP_EMBED_END_BLOCK()宏之内 的当前作用域. 通过将你的代码执行放入到这两个宏之间的小块中, php的错误就不会影响到你的整个应用.<br>你刚才已经看到了, 这种短小精悍的方法主要的缺点在于每次你建立一个新的 START/END块的时候, 都需要创建⼀个新的请求, 新的符号表, 因此就失去了所有的持久性语义.<br>要想同时得到两种优点(持久化和错误处理), 就需要将START和END宏分解为它们各 自的组件(译注: 如果不明白可以参考这两个宏的定义). 下面是本章开始给出的embed2.c 程序, 这⼀次, 我们对它进行了分解:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sapi/embed/php_embed.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="keyword">void</span> ***tsrm_ls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">php_embed_init(argc, argv PTSRMLS_CC);</span><br><span class="line">zend_first_try &#123;</span><br><span class="line">zend_eval_string(<span class="string">"echo 'Hello World!';"</span>, <span class="literal">NULL</span>,<span class="string">"Embed 2 Eval'd string"</span> TSRMLS_CC);</span><br><span class="line">&#125; zend_end_try();</span><br><span class="line">php_embed_shutdown(TSRMLS_C);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>它执行和之前⼀样的代码, 只是这一次你可以看到打开和关闭的括号包裹了你的代码, 而不是无法分开的START和END块。<br>将php_embed_init()放到你应用的开始, 将php_embed_shutdown()放到末尾, 你的应用就得到了一个持久的单请求生命周期, 它还可 以使用zend_first_try {} zend_end_try(); 结构捕获所有可能导致你整个包装应用跳出末尾<br>的PHP_EMBED_END_BLOCK()宏的致命错误.<br>为了看看真实世界环境的这种方法的应用, 我们将本章前面⼀些的例子的启动和终止 处理进行了抽象:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sapi/embed/php_embed.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="keyword">void</span> ***tsrm_ls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startup_php</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Create "dummy" argc/argv to hide the arguments</span></span><br><span class="line"><span class="comment"> * meant for our actual application */</span></span><br><span class="line"> <span class="keyword">int</span> argc = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">char</span> *argv[<span class="number">2</span>] = &#123; <span class="string">"embed4"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"> php_embed_init(argc, argv PTSRMLS_CC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown_php</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">php_embed_shutdown(TSRMLS_C);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute_php</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">zend_first_try &#123;</span><br><span class="line"><span class="keyword">char</span> *include_script;</span><br><span class="line">spprintf(&amp;include_script, <span class="number">0</span>, <span class="string">"include '%s';"</span>, filename);</span><br><span class="line">zend_eval_string(include_script, <span class="literal">NULL</span>, filename TSRMLS_CC);</span><br><span class="line">efree(include_script);</span><br><span class="line">&#125; zend_end_try();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Usage: embed4 scriptfile"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">startup_php();</span><br><span class="line">execute_php(argv[<span class="number">1</span>]);</span><br><span class="line">shutdown_php();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的概念也可以应用到处理任意代码的执行以及其他任务. 只需要确认在最外部的 容器上使用zend_first_try, 则里面的每个容器上使用zend_try即可.</p><h1 id="覆写INI-SYSTEM和INI-PERDIR选项"><a href="#覆写INI-SYSTEM和INI-PERDIR选项" class="headerlink" title="覆写INI_SYSTEM和INI_PERDIR选项"></a>覆写INI_SYSTEM和INI_PERDIR选项</h1><p>在上一章中, 你曾经使用zend_alter_ini_setting()修改过⼀些php的ini选项. 由于samp/embed直接将你的脚本推入了运行时模式, 因此许多重要的INI选项在控制返回到你的应用 时并没有被修改. 为了修改这些值, 就需要在主引擎启动之后而请求启动之前执行代码.</p><p>有一种方式是拷贝php_embed_init()的内容到你的应用中, 在你的本地拷贝中做必要 的修改, 接着使用你修改后的版本替代它. 当然这种方式可能会有问题.</p><p>首先也是最重要的, 你实际已经对别人的部分代码做了分支, 然而可能别人还会向其 中添加新的代码. 现在, 你就不再是只维护自己的应用了, 还需要保持分支出来的代码和主 分支保持一致. 幸运的是, 还有几种更简单的方法:</p><h4 id="覆写默认的php-ini文件"><a href="#覆写默认的php-ini文件" class="headerlink" title="覆写默认的php.ini文件"></a>覆写默认的php.ini文件</h4><p>因为嵌入式和其他的php sapi实现一样都是sapi, 它通过⼀个sapi_module_struct挂入 到引擎中. 嵌入式SAPI定义并设置了这个结构体的一个实例, 你的应用可以在调用 php_embed_init()之前访问它.</p><p>在这个结构体中, 有一个名为php_ini_path_override的char *类型字段. 为了让嵌入的 请求使用你的可选文件扩展php和Zend, 只需要在调用php_embed_init()之前将这个字段 设置为NULL终止的字符串. 下面是embed4.c中修改版的startup_php()函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startup_php</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Create "dummy" argc/argv to hide the arguments</span></span><br><span class="line"><span class="comment">     * meant for our actual application */</span></span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *argv[<span class="number">2</span>] = &#123; <span class="string">"embed4"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    php_embed_module.php_ini_path_override = <span class="string">"/etc/php_embed4.ini"</span>;</span><br><span class="line">    php_embed_init(argc, argv PTSRMLS_CC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就使得每个使用嵌入库的应用可以保持自定义, 而不用将自己的配置暴露给别人. 相反, 如果你想要你的应用不使用php.ini, 只需要设置php_embed_module的 php_ini_ignore字段, 这样所有的设置都将使用内建的默认值, 除非由你的应用手动进行修改.</p><h4 id="覆写嵌入启动"><a href="#覆写嵌入启动" class="headerlink" title="覆写嵌入启动"></a>覆写嵌入启动</h4><p>sapi_module_struct结构还包含⼀些回调函数, 下面是其中4个在PHP启动和终止阶段 比较有用的回调:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* From main/SAPI.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sapi_module_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> (*startup)(struct _sapi_module_struct *sapi_module);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">shutdown</span>)(struct _sapi_module_struct *sapi_module);</span><br><span class="line">    <span class="keyword">int</span> (*activate)(TSRMLS_D);</span><br><span class="line">    <span class="keyword">int</span> (*deactivate)(TSRMLS_D);</span><br><span class="line">    ...</span><br><span class="line">&#125; sapi_module_struct;</span><br></pre></td></tr></table></figure><p>这些方法的名字熟悉吗? 它们对应于扩展的MINIT, MSHUTDOWN, RINIT, RSHUTDOWN, 并且和对应在扩展生命周期中的阶段⼀致. 要利用这些钩子, 可以如下修 改embed4中的startup_php()函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*original_embed_startup)</span><span class="params">(struct _sapi_module_struct *sapi_module)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">embed4_startup_callback</span><span class="params">(struct _sapi_module_struct *sapi_module)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 首先调用原来的启动回调, 否则环境未就绪 */</span></span><br><span class="line"><span class="keyword">if</span> (original_embed_startup(sapi_module) == FAILURE) &#123;</span><br><span class="line"><span class="comment">/* 这里可以做应用的失败处理 */</span></span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 调用原来的embed_startup实际上让我们进入到ACTIVATE阶段而不是STARTUP阶段, * 但是我们仍然可以修改多数INI_SYSTEM和INI_PERDIR选项.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    zend_alter_ini_entry(<span class="string">"max_execution_time"</span>, <span class="keyword">sizeof</span>(<span class="string">"max_execution_time"</span>),</span><br><span class="line">                 <span class="string">"15"</span>, <span class="keyword">sizeof</span>(<span class="string">"15"</span>) - <span class="number">1</span>, PHP_INI_SYSTEM, PHP_INI_STAGE_ACTIVATE);</span><br><span class="line">    zend_alter_ini_entry(<span class="string">"safe_mode"</span>, <span class="keyword">sizeof</span>(<span class="string">"safe_mode"</span>),</span><br><span class="line">                 <span class="string">"1"</span>, <span class="keyword">sizeof</span>(<span class="string">"1"</span>) - <span class="number">1</span>, PHP_INI_SYSTEM, PHP_INI_STAGE_ACTIVATE);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startup_php</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 创建假的argc/argv, 隐藏应用实际的参数 */</span> <span class="keyword">int</span> argc = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> *argv[<span class="number">2</span>] = &#123; <span class="string">"embed4"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="comment">/* 使用我们自己的启动函数覆写标准的启动方法, 但是保留了原来的指针, 因此它仍然能够被调用到 */</span> original_embed_startup = php_embed_module.startup;</span><br><span class="line">php_embed_module.startup = embed4_startup_callback;</span><br><span class="line">    php_embed_init(argc, argv PTSRMLS_CC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用safe_mode, open_basedir这样的选项, 以及其他用以限制独立脚本行为的选项, 可以让你的应用更加安全可靠.</p><h1 id="捕获输出"><a href="#捕获输出" class="headerlink" title="捕获输出"></a>捕获输出</h1><p>除非你开发的是非常简单的控制台应用, 否则你应该不希望php脚本代码产生的输出 直接被扔到激活的终端上. 捕获这些输出和你刚才用以覆写启动处理器的方法类似.</p><p>在sapi_module_struct中还有⼀些有用的回调:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">sapi_module_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> (*ub_write)(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_length TSRMLS_DC);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">flush</span>)(<span class="keyword">void</span> *server_context);</span><br><span class="line">    <span class="keyword">void</span> (*sapi_error)(<span class="keyword">int</span> type, <span class="keyword">const</span> <span class="keyword">char</span> *error_msg, ...);</span><br><span class="line">    <span class="keyword">void</span> (*log_message)(<span class="keyword">char</span> *message);</span><br><span class="line">    ...</span><br><span class="line">&#125; sapi_module_struct;</span><br></pre></td></tr></table></figure><h4 id="标准输出-ub-write"><a href="#标准输出-ub-write" class="headerlink" title="标准输出: ub_write"></a>标准输出: ub_write</h4><p>所有用户空间的echo和print语句产生的输出, 以及其他内部通过php_printf()或 PHPWRITE()产生的输出, 最终都将被发送到激活的SAPI的ub_write()方法. 默认情况, 嵌入式SAPI直接将这些数据交给stdout管道, 而不关心你的应用的输出策略.</p><p>假设你的应用想要把所有的输出都发送到⼀个独立的控制台窗口; 你可能需要实现⼀个类似于下面伪代码块所描述的回调:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">embed4_ub_write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_length TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    output_string_to_window(CONSOLE_WINDOW_ID, str, str_length);</span><br><span class="line">    <span class="keyword">return</span> str_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让这个函数能够处理php产生的内容, 你需要在调用php_embed_init()之前对 php_embed_module结构做适当的修改:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_embed_module.ub_write = embed4_ub_write;</span><br></pre></td></tr></table></figure><p>注意: 哪怕你决定你的应用不需要php产生的输出, 也必须为ub_write设置⼀个回调. 将它的值设置为NULL将导致引擎崩溃, 当然, 你的应用也不能幸免.</p><h4 id="缓冲输出-Flush"><a href="#缓冲输出-Flush" class="headerlink" title="缓冲输出: Flush"></a>缓冲输出: Flush</h4><p>你的应用可能会使用缓冲php产生的输出进行优化, sapi层提供了⼀个回调用以通知 你的应用”现在请发送你的缓冲区数据”, 你的应用并没有义务去实施这个通知; 不过, 由于 这个信息通常是由于足够的理由(比如到达请求结束位置)才产生的, 听从这个意见并不会有什么坏处.</p><p>下面的这对回调函数, 以256字节缓冲区缓冲数据由引擎安排执行flush.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> buffer_pos = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">embed4_ubwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_length TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = str;</span><br><span class="line"><span class="keyword">char</span> *d = <span class="built_in">buffer</span> + buffer_pos;</span><br><span class="line"><span class="keyword">int</span> consumed = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 缓冲区够用, 直接追加到缓冲区后面 */</span></span><br><span class="line"><span class="keyword">if</span> (str_length &lt; (<span class="number">256</span> - buffer_pos)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(d, s, str_length);</span><br><span class="line">        buffer_pos += str_length;</span><br><span class="line">        <span class="keyword">return</span> str_length;</span><br><span class="line">&#125;</span><br><span class="line">consumed = <span class="number">256</span> - buffer_pos; <span class="built_in">memcpy</span>(d, s, consumed); embed4_output_chunk(<span class="built_in">buffer</span>, <span class="number">256</span>); str_length -= consumed;</span><br><span class="line">s += consumed;</span><br><span class="line"><span class="comment">/* 消耗整个传入的块 */</span></span><br><span class="line"><span class="keyword">while</span> (str_length &gt;= <span class="number">256</span>) &#123;</span><br><span class="line">        embed4_output_chunk(s, <span class="number">256</span>);</span><br><span class="line">        s += <span class="number">256</span>;</span><br><span class="line">        consumed += <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 重置缓冲区头指针内容 */</span> <span class="built_in">memcpy</span>(<span class="built_in">buffer</span>, s, str_length); buffer_pos = str_length; consumed += str_length;</span><br><span class="line"><span class="keyword">return</span> consumed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">embed4_flush</span><span class="params">(<span class="keyword">void</span> *server_context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buffer_pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* 输出缓冲区中剩下的内容 */</span> embed4_output_chunk(<span class="built_in">buffer</span>, buffer_pos); buffer_pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在startup_php()中增加下面的代码, 这个基础的缓冲机制就就绪了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php_embed_module.ub_write = embed4_ub_write;</span><br><span class="line">php_embed_module.<span class="built_in">flush</span>    = embed4_flush;</span><br></pre></td></tr></table></figure><h4 id="标准错误-log-message"><a href="#标准错误-log-message" class="headerlink" title="标准错误: log_message"></a>标准错误: log_message</h4><p>在启用了log_errors INI设置时, 在启动或执行脚本时如果碰到错误, 将激活 log_message回调. 默认的php错误处理程序会在处理显示(这里是调用log_message回调)之前, 格式化这些错误消息, 使其称为整齐的, 人类可读的内容.</p><p>关于log_message回调, 这里你需要注意的第⼀件事是它并不包含长度参数, 因此它并不是二进制安全的. 也就是说, 它只是按照NULL终止来处理字符串末尾.</p><p>使用它来做错误报告通常不会有什么问题, 实际上, 它可以用于在错误消息的呈现上 做更多的事情. 默认情况下, sapi/embed将会通过这个简单的内建回调, 发送这些错误消息到标准错误管道:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_embed_log_message</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想发送这些消息到日志文件, 则可以使用下面的版本替代:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">embed4_log_message</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *<span class="built_in">log</span>;</span><br><span class="line">    <span class="built_in">log</span> = fopen(<span class="string">"/var/log/embed4.log"</span>, <span class="string">"a"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span> (<span class="built_in">log</span>, <span class="string">"%s\n"</span>, message);</span><br><span class="line">    fclose(<span class="built_in">log</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特殊错误-sapi-error"><a href="#特殊错误-sapi-error" class="headerlink" title="特殊错误: sapi_error"></a>特殊错误: sapi_error</h4><p>少数特殊情况的错误属于某个sapi, 因此将绕过php的主错误处理程序. 这些错误一般 是由于使用不当造成的, 比如非web应用不应该使用header()函数, 上传文件到控制台应用程序等.</p><p>由于这些情况都离你所开发的sapi/embed应用非常遥远, 因此最好保持这个回调为空. 不过, 如果你非要坚持去捕获每种类型错误的源, 也只需要实现⼀个回调函数, 并在调 用php_embed_init()之前覆写它就可以了.</p><h1 id="同时扩展和嵌入"><a href="#同时扩展和嵌入" class="headerlink" title="同时扩展和嵌入"></a>同时扩展和嵌入</h1><p>在你的应用中运行php代码固然不错, 但是此刻, php执行环境仍然和你的主应用是隔离的, 它们并没有在真正意义上的一个层级进行交互.</p><p>现在你应该对php扩展的开发以及构建启用方面比较熟悉了. 你也已经有完成了嵌入 工作的例程, 这样就省去了这份工作. 将扩展代码植入到嵌入式应用中的工作量要比标准扩展小. 下面是⼀个新的嵌入式项目:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sapi/embed/php_embed.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line">    <span class="keyword">void</span> ***tsrm_ls;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Extension bits */</span></span><br><span class="line">zend_module_entry php_mymod_module_entry = &#123;</span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">    <span class="string">"mymod"</span>, <span class="comment">/* extension name */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* function entries */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINFO */</span></span><br><span class="line">    <span class="string">"1.0"</span>, <span class="comment">/* version */</span></span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Embedded bits */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startup_php</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *argv[<span class="number">2</span>] = &#123; <span class="string">"embed5"</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    php_embed_init(argc, argv PTSRMLS_CC);</span><br><span class="line">    zend_startup_module(&amp;php_mymod_module_entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute_php</span><span class="params">(<span class="keyword">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zend_first_try &#123;</span><br><span class="line">        <span class="keyword">char</span> *include_script;</span><br><span class="line">        spprintf(&amp;include_script, <span class="number">0</span>, <span class="string">"include '%s'"</span>, filename);</span><br><span class="line">        zend_eval_string(include_script, <span class="literal">NULL</span>, filename TSRMLS_CC);</span><br><span class="line">        efree(include_script);</span><br><span class="line">    &#125; zend_end_try();</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: embed4 scriptfile"</span>;);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    startup_php();</span><br><span class="line">    execute_php(argv[<span class="number">1</span>]);</span><br><span class="line">    php_embed_shutdown(TSRMLS_CC);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在, 你可以定义function_entry向量, 启动/终止函数, 定义类, 以及所有你想增加的东 西. 现在, 它和你使用用户空间的dl()命令加载这个扩展库一样, 在这⼀个命令中Zend将自 动的处理所有的钩子并对你的模块进行注册, 就绪等待使用.(译注: startup_php()中调用 zend_startup_module(&amp;php_mymod_module_entry)进行了模块注册)</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章你看了一些上一章的⼀些简单的嵌入式示例进行了扩展, 你已经可以将php放入 到各种非线程应用了. 现在你已经掌握了扩展和嵌入式的基础, 并且可以在zval, 类, 资源, HashTable上工作了, 你已经可以真正开始⼀个真正的项目了.</p><p>在剩下的附录中, 你将看到php, zend以及其他扩展暴露的很多API函数. 你将会看到一些常用的代码片段以及近几年数以百计的开源PECL项目, 它们都可以作为你未来项目 的参考.</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19 设置宿主环境</title>
      <link href="/posts/da35cc9a.html"/>
      <url>/posts/da35cc9a.html</url>
      
        <content type="html"><![CDATA[<h1 id="19-设置宿主环境"><a href="#19-设置宿主环境" class="headerlink" title="19 设置宿主环境"></a>19 设置宿主环境</h1><p>现在你已经了解了PHPAPI的世界, 并可以使用zval以及语言内部扩展机制执行很多 工作了, 是时候转移目标用它做它最擅长的事情了: 解释脚本代码.</p><h1 id="嵌入式SAPI"><a href="#嵌入式SAPI" class="headerlink" title="嵌入式SAPI"></a>嵌入式SAPI</h1><p>回顾介绍中, php构建了一个层级系统. 最高层是提供用户空间函数和类库的所有扩 展. 同时, 其下是服务API(SAPI)层, 它扮演了webserver(比如apache, iis以及命令行接口 cli)的接口.</p><p>在这许多sapi实现中有一个特殊的sapi就是嵌入式sapi. 当这个sapi实现被构建时, 将 会创建一个包含所有你已知的php和zend api函数以及变量的库对象, 这个库对象还包含一些额外的帮助函数和宏, 用以简化外部程序的调用.</p><p>生成嵌入式api的库和头文件和其他sapi的编译所执行的动作相同. 只需要传递–enable-embed到./configure命令中即可. 和以前⼀样, 使用–enable-debug对于错误报告和 跟踪很有帮助.</p><p>你可能还需要打开–enable-maintainer-zts, 当然, 理由你已经耳熟能详了, 它将帮助 你注意到代码的错误, 不过, 这里还有其他原因. 假设某个时刻, 你有多个应用使用php嵌入 库执行脚本任务; 其中一个应用是简单的短生命周期的, 它并没有使用线程, 因此为了效率 你可能想要关闭ZTS.</p><p>现在假设第二个应用使用了线程, 比如webserver, 每个线程需要跟踪自己的请求上下 文. 如果ZTS被关闭, 则只有第⼀个应用可以使用这个库; 然而, 如果打开ZTS, 则两个应用 都可以在自己的进程空间使用同⼀个共享对象.</p><p>当然, 你也可以同时构建两个版本, 并给它们不同的名字, 但是这相比于在不需要ZTS 时包括ZTS带来的很小的效率影响更多的问题.<br>默认情况下, 嵌入式库将构建为libphp5.so共享对象, 或者在windows下的动态链接库, 不过, 它也可能使用可选的static关键字(–enable-embed=static)被构建为静态库.</p><p>构建为静态库的版本避免了ZTS/非ZTS的问题, 以及潜在的可能在一个系统中有多个 php版本的情况. 风险在于这就意味着你的结果应用二进制将显著变大, 它将承载整个 ZendEngine和PHP框架, 因此, 选择的时候就需要慎重的考虑你是否需要的是⼀个相对更小的库.</p><p>无论你选择那种构建方式,一旦你执行make install, libphp5都将被拷贝到你的./ configure指定的PREFIX目录下的lib/目录中. 此外还会在PREFIX/include/php/sapi/ embed目录下放入名为php_embed.h的头文件, 以及你在使用php嵌入式库编译程序时需 要的其他几个重要的头文件.</p><h1 id="构建并编译一个宿主应用"><a href="#构建并编译一个宿主应用" class="headerlink" title="构建并编译一个宿主应用"></a>构建并编译一个宿主应用</h1><p>究其本质而言, 库只是⼀个没有目的的代码集合. 为了让它工作, 你需要用以嵌入php 的应用. 首先, 我们来封装⼀个非常简单的应用, 它启动Zend引擎并初始化PHP处理⼀个请求, 接着就回头进行资源的清理.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sapi/embed/php_embed.h&gt;</span></span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;    PHP_EMBED_START_BLOCK(argc,argv)    PHP_EMBED_END_BLOCK()<span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>由于这涉及到了很多头文件, 构建实际上需要的时间要长于这么小的代码片段通常需 要的时间. 如果你使用了不同于默认路径(/usr/local)的PREFIX, 请确认以下面的方式指定 路径:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I /usr/local/php-dev/include/php/ \-I /usr/local/php-dev/include/php/main/ \-I /usr/local/php-dev/include/php/Zend/ \-I /usr/local/php-dev/include/php/TSRM/ \-lphp5 \-o embed1embed1.c</span><br></pre></td></tr></table></figure><p>由于这个命令每次输入都很麻烦, 你可能更原意用一个简单的Makefile替代:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC = gccCFLAGS = -c \    -I /usr/local/php-dev/include/php/ \    -I /usr/local/php-dev/include/php/main/ \    -I /usr/local/php-dev/include/php/Zend/ \    -I /usr/local/php-dev/include/php/TSRM/ \    -Wall -gLDFLAGS = -lphp5all: embed1.c    $(CC) -o embed1.o embed1.c $(CFLAGS)    $(CC) -o embed1 embed1.o $(LDFLAGS)</span><br></pre></td></tr></table></figure><p>这个Makefile和前面提供的命令有⼀些重要的区别. 首先, 它用-Wall开关打开了编译期的警 告, 并且用-g打开了调试信息. 此外它将编译和链接两个阶段分为了两个独立的阶段, 这样在后期 增加更多源文件的时候就相对容易. 请自己重新组装这个Makefile, 不过这里用于对齐的是Tab(水 平制表符)而不是空格.</p><p>现在, 你对embed1.c源文件做修改后, 只需要执行⼀一个make命令就可以构建出新的 embed1可执行程序了.</p><h1 id="通过嵌入包装重新创建cli"><a href="#通过嵌入包装重新创建cli" class="headerlink" title="通过嵌入包装重新创建cli"></a>通过嵌入包装重新创建cli</h1><p>现在php已经可以在你的应用中访问了, 是时候让它做⼀些事情了. 本章剩下的核心就是围绕着在这个测试应用框架中重新创建cli sapi展开的.</p><p>很简单, cli二进制程序最基础的功能就是在命令行指定⼀个脚本的名字, 由php对其解 释执行. 用下面的代码替换你的embed1.c的内容就在你的应用中实现了cli.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sapi/embed/php_embed.h&gt;</span></span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;    zend_file_handle    script;<span class="comment">/* 基本的参数检查 */</span> <span class="keyword">if</span> ( argc &lt;= <span class="number">1</span> ) &#123;        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s &lt;filename.php&gt; &lt;arguments&gt;\n"</span>, argv[<span class="number">0</span>]);<span class="keyword">return</span> <span class="number">-1</span>; &#125;<span class="comment">/* 设置⼀一个文件处理结构 */</span>script.typescript.filenamescript.opened_pathscript.<span class="function">free_filename<span class="title">if</span> <span class="params">( !(script.handle.fp = fopen(script.filename, <span class="string">"rb"</span>)) )</span> </span>&#123;        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Unable to open: %s\n"</span>, argv[<span class="number">1</span>]);<span class="keyword">return</span> <span class="number">-1</span>; &#125;<span class="comment">/* 在将命令行参数注册给php时(php中的$argv/$argc), 忽略第一个命令行参数, 因为它对php脚本无意义 */</span>    argc --;    argv ++;    PHP_EMBED_START_BLOCK(argc, argv)        php_execute_script(&amp;script TSRMLS_CC);    PHP_EMBED_END_BLOCK()<span class="keyword">return</span> <span class="number">0</span>; &#125;译注: 原著中的代码在译者的环境不能直接运行, 上面的代码是经过修改的.</span><br></pre></td></tr></table></figure><p>当然, 你需要⼀个文件测试它, 创建⼀个小的php脚本, 命名为test.php, 在命令行使用你的embed程序执行它:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./embed1 test.php</span><br></pre></td></tr></table></figure><p>如果你给命令行传递了其他参数, 你可以在你的php脚本中使用$_SERVER[‘argc’]/ $_SERVER[‘argv’]看到它们.</p><p>你可能注意到了, 在PHP_EMBED_START_BLOCK()和PHP_EMBED_END_BLOCK()之间 的代码是缩进的. 这个细节是因为这两个宏实际上构成了⼀个C语言的代码块作用域. 也就是说 PHP_EMBED_START_BLOCK()包含⼀个打开的花括号”{“, 在PHP_EMBED_END_BLOCK()中 则有与之对应的关闭花括号”}”. 这样做非常重要的一个问题是它们不能被放入到独立的启动/终止函数中. 下一章你将看到这个问题的解决方案.</p><h1 id="老技术新用"><a href="#老技术新用" class="headerlink" title="老技术新用"></a>老技术新用</h1><p>在PHP_EMBED_START_BLOCK()被调用后, 你的应用处于⼀个php请求周期的开始 位置, 相当于RINIT回调函数完成以后. 此刻你就可以和前面一样执行 php_execute_script()命令, 或者其他任意合法的, 可以在PHP_FUNCTION()或RINIT()块中出现的php/Zend API指令.</p><h4 id="设置初始变量"><a href="#设置初始变量" class="headerlink" title="设置初始变量"></a>设置初始变量</h4><p>第2章”变量的里里外外”中介绍了操纵符号表的概念, 第5至18章则介绍了怎样通过用 户空间脚本调用内部函数使用这些技术. 到这里这些处理也并没有发生变化, 虽然这里并 没有激活的用户空间脚本, 但是你的包装应用仍然可以操纵符号表. 将你的 PHP_EMBED_START_BLOCK()/PHP_EMBED_END_BLOCK()代码块替换为下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP_EMBED_START_BLOCK(argc, argv)    zval    *type;    ALLOC_INIT_ZVAL(type);    ZVAL_STRING(type, <span class="string">"Embedded"</span>, <span class="number">1</span>);    ZEND_SET_SYMBOL(&amp;EG(symbol_table), <span class="string">"type"</span>, type);    php_execute_script(&amp;script TSRMLS_CC);PHP_EMBED_END_BLOCK()</span><br></pre></td></tr></table></figure><p>现在使用make重新构建embed1, 并用下面的测试脚本进行测试:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump($type);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>当然, 这个简单的概念可以很容易的扩展为填充这个类型信息到$_SERVER超级全局变量数组中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PHP_EMBED_START_BLOCK(argc, argv)    zval    **SERVER_PP, *type;<span class="comment">/* 注册$_SERVER超级全局变量 */</span>zend_is_auto_global_quick(<span class="string">"_SERVER"</span>, <span class="keyword">sizeof</span>(<span class="string">"_SERVER"</span>) - <span class="number">1</span>, <span class="number">0</span> TSRMLS_CC);</span><br><span class="line"><span class="comment">/* 查找$_SERVER超级全局变量 */</span></span><br><span class="line">zend_hash_find(&amp;EG(symbol_table), <span class="string">"_SERVER"</span>, <span class="keyword">sizeof</span>(<span class="string">"_SERVER"</span>), (<span class="keyword">void</span> **)&amp;SERVER_PP) ;    <span class="comment">/* $_SERVER['SAPI_TYPE'] = "Embedded"; */</span>    ALLOC_INIT_ZVAL(type);    ZVAL_STRING(type, <span class="string">"Embedded"</span>, <span class="number">1</span>);    ZEND_SET_SYMBOL(Z_ARRVAL_PP(SERVER_PP), <span class="string">"SAPI_TYPE"</span>, type);    php_execute_script(&amp;script TSRMLS_CC);PHP_EMBED_END_BLOCK()译注: 译者的环境中代码运行到zend_hash_find()处$_SERVER尚未注册, 经过跟踪, 发现它 是直到编译用户空间代码的时候, 发现用户空间使用了$_SERVER变量才进行的注册. 因此, 上面 的代码中增加了zend_is_auto_global_quick()的调用, 通过这个调用将完成对$_SERVER的注册.</span><br></pre></td></tr></table></figure><h4 id="覆写INI选项"><a href="#覆写INI选项" class="headerlink" title="覆写INI选项"></a>覆写INI选项</h4><p>在第13章”INI设置”中, 有⼀部分是讲INI修改处理器的, 在那里看到的是INI阶段的处 理. PHP_EMBED_START_BLOCK()宏则将这些代码放到了运行时阶段. 也就是说这个时 候修改某些设置(比如register_globals/magic_quotes_gpc)已经有点迟了.</p><p>不过在内部访问也没有什么不好. 所谓的”管理设置”比如safe_mode在这个略迟的阶 段可以使用下面的zend_alter_ini_entry()命令打开或关闭:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_alter_ini_entry</span><span class="params">(<span class="keyword">char</span> *name, uint name_length,                         <span class="keyword">char</span> *new_value, uint       new_value_length,                         <span class="keyword">int</span> modify_type, <span class="keyword">int</span> stage)</span></span>;</span><br></pre></td></tr></table></figure><p>name, new_value以及它们对应的长度参数的含义正如你所预期的: 修改名为name的 INI设置的值为new_value. 要注意name_length包含了末尾的NULL字节, 然而 new_value_length则不包含; 然而, 无论如何, 两个字符串都必须是NULL终止的.</p><p>modify_type则提供简化的访问控制检查. 回顾每个INI设置都有一个modifiable属性, 它是PHP_INI_SYSTEM, PHP_INI_PERDIR, PHP_INI_USER等常量的组合值. 当使用 zend_alter_ini_entry()修改INI设置时, modify_type参数必须包含至少⼀个INI设置的 modifiable属性值.</p><p>用户空间的ini_set()函数通过传递PHP_INI_USER利用了这个特性, 也就是说只有 modifiable属性包含PHP_INI_USER标记的INI设置才能使用这个函数修改. 当在你的嵌入 式应用中使用这个API调用时, 你可以通过传递PHP_INI_ALL标记短路这个访问控制系统, 它将包含所有的INI访问级别.</p><p>stage必须对应于Zend Engine的当前状态; 对于这些简单的嵌入式示例, 总是 PHP_INI_STAGE_RUNTIME. 如果这是一个扩展或更高端的嵌入式应用, 你可能就需要将 这个值设置为PHP_INI_STAGE_STARTUP或PHP_INI_STAGE_ACTIVE.</p><p>下面是扩展embed1.c源文件, 让它在执行脚本文件之前强制开启safe_mode.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHP_EMBED_START_BLOCK(argc, argv)        zval    **SERVER_PP, *type;<span class="comment">/* 不论php.ini中如何设置都强制开启safe_mode */</span>        zend_alter_ini_entry(<span class="string">"safe_mode"</span>, <span class="keyword">sizeof</span>(<span class="string">"safe_mode"</span>), <span class="string">"1"</span>, <span class="keyword">sizeof</span>(<span class="string">"1"</span>) - <span class="number">1</span>, PHP_INI_ALL,PHP_INI_STAGE_RUNTIME);<span class="comment">/* 注册$_SERVER超级全局变量 */</span>zend_is_auto_global_quick(<span class="string">"_SERVER"</span>, <span class="keyword">sizeof</span>(<span class="string">"_SERVER"</span>) - <span class="number">1</span>, <span class="number">0</span> TSRMLS_CC);<span class="comment">/* 查找$_SERVER超级全局变量 */</span>zend_hash_find(&amp;EG(symbol_table), <span class="string">"_SERVER"</span>, <span class="keyword">sizeof</span>(<span class="string">"_SERVER"</span>), (<span class="keyword">void</span> **)&amp;SERVER_PP) ;        <span class="comment">/* $_SERVER['SAPI_TYPE'] = "Embedded"; */</span>        ALLOC_INIT_ZVAL(type);        ZVAL_STRING(type, <span class="string">"Embedded"</span>, <span class="number">1</span>);        ZEND_SET_SYMBOL(Z_ARRVAL_PP(SERVER_PP), <span class="string">"SAPI_TYPE"</span>, type);        php_execute_script(&amp;script TSRMLS_CC);</span><br><span class="line">PHP_EMBED_END_BLOCK()</span><br></pre></td></tr></table></figure><h4 id="定义附加的超级全局变量"><a href="#定义附加的超级全局变量" class="headerlink" title="定义附加的超级全局变量"></a>定义附加的超级全局变量</h4><p>在第12章”启动, 终止, 以及其中的一些点”中, 你知道了用户空间全局变量以及超级全 局变量可以在启动(MINIT)阶段定义. 同样, 本章介绍的嵌入式直接跳过了启动阶段, 处于 运行时状态. 和覆写INI一样, 这并不会显得太迟.</p><p>超级全局变量的定义实际上只需要在脚本编译之前定义即可, 并且在php的进程生命 周期中它只应该出现⼀次. 在扩展中的正常情况下, MINIT是唯一可以保证这些条件的地方.</p><p>由于你的包装应用现在是在控制中的, 因此可以保证定义用户空间自动全局变量的这 些点位于真正编译脚本源文件的php_execute_script()命令之前. 我们定义⼀个$_EMBED 超级全局变量并给它设置一个初始值来进行测试:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HP_EMBED_START_BLOCK(argc, argv)        zval    **SERVER_PP, *type, *EMBED, *foo;<span class="comment">/* 在全局作用域创建$_EMBED数组 */</span> ALLOC_INIT_ZVAL(EMBED);array_init(EMBED); ZEND_SET_SYMBOL(&amp;EG(symbol_table), <span class="string">"_EMBED"</span>, EMBED);        <span class="comment">/* $_EMBED['foo'] = 'Bar'; */</span>        ALLOC_INIT_ZVAL(foo);        ZVAL_STRING(foo, <span class="string">"Bar"</span>, <span class="number">1</span>);        add_assoc_zval_ex(EMBED, <span class="string">"foo"</span>, <span class="keyword">sizeof</span>(<span class="string">"foo"</span>), foo);<span class="comment">/* 注册超级全局变量$_EMBED */</span>        zend_register_auto_global(<span class="string">"_EMBED"</span>, <span class="keyword">sizeof</span>(<span class="string">"_EMBED"</span>)#ifdef ZEND_ENGINE_2#<span class="keyword">else</span> #endif    , <span class="number">1</span>, <span class="literal">NULL</span> TSRMLS_CC);    , <span class="number">1</span> TSRMLS_CC);<span class="comment">/* 不论php.ini中如何设置都强制开启safe_mode */</span>        zend_alter_ini_entry(<span class="string">"safe_mode"</span>, <span class="keyword">sizeof</span>(<span class="string">"safe_mode"</span>), <span class="string">"1"</span>, <span class="keyword">sizeof</span>(<span class="string">"1"</span>) - <span class="number">1</span>, PHP_INI_ALL,PHP_INI_STAGE_RUNTIME);<span class="comment">/* 注册$_SERVER超级全局变量 */</span>zend_is_auto_global_quick(<span class="string">"_SERVER"</span>, <span class="keyword">sizeof</span>(<span class="string">"_SERVER"</span>) - <span class="number">1</span>, <span class="number">0</span> TSRMLS_CC);<span class="comment">/* 查找$_SERVER超级全局变量 */</span>zend_hash_find(&amp;EG(symbol_table), <span class="string">"_SERVER"</span>, <span class="keyword">sizeof</span>(<span class="string">"_SERVER"</span>), (<span class="keyword">void</span> **)&amp;SERVER_PP) ;        <span class="comment">/* $_SERVER['SAPI_TYPE'] = "Embedded"; */</span>        ALLOC_INIT_ZVAL(type);        ZVAL_STRING(type, <span class="string">"Embedded"</span>, <span class="number">1</span>);        ZEND_SET_SYMBOL(Z_ARRVAL_PP(SERVER_PP), <span class="string">"SAPI_TYPE"</span>, type);        php_execute_script(&amp;script TSRMLS_CC);    PHP_EMBED_END_BLOCK()</span><br></pre></td></tr></table></figure><p>要记住, Zend Engine 2(php 5.0或更高)使用了不同的zend_register_auto_global()元婴, 因此你需要用前面讲php 4兼容时候讲过的#ifdef. 如果你不关心旧版本php的兼容性, 则可以丢弃这些指令让代码变得更加整洁.</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>如你所见, 将完整的Zend Engine和PHP语言嵌入到你的应用中相比如扩展新功能来 说工作量要少. 由于它们共享相同的基础API, 我们可以学习尝试让其他实例可访问.</p><p>通过本章的学习, 你了解了最简单的嵌入式脚本代码格式, 同时还有all-in-one的宏 PHP_EBED_START_BLOCK()和PHP_EMBED_END_BLOCK(). 下⼀章你将回到这些宏 的层的使用, 利用它们将php和你的宿主系统结合起来.</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18 扩展生成</title>
      <link href="/posts/c4e4d9ab.html"/>
      <url>/posts/c4e4d9ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="18-扩展生成"><a href="#18-扩展生成" class="headerlink" title="18 扩展生成"></a>18 扩展生成</h1><p>毫无疑问你已经注意到，每个php扩展都包含一些非常公共的并且非常单调的结构和文件。当开始一个新扩展开发的时候，如果这些公共的结构已经存在, 我们只用考虑填充功 能代码是很有意义的. 为此, 在php中包含了一个简单但是很有用的shell脚本。</p><h1 id="ext-skel"><a href="#ext-skel" class="headerlink" title="ext_skel"></a>ext_skel</h1><p>切换到你的php源代码树下ext/目录中, 执行下面的命令:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdoe@devbox:/<span class="built_in">home</span>/jdoe/cvs/php-src/ext/$ ./ext_skel extname=sample7</span><br></pre></td></tr></table></figure><p>稍等便可, 输出⼀些文本, 你将看到下面的这些输出:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To use your <span class="keyword">new</span> extension, you will have to execute the following steps: <span class="number">1.</span> $cd.. <span class="number">2.</span> $ vi ext/sample7/<span class="built_in">config</span>.m4 <span class="number">3.</span> $ ./buildconf <span class="number">4.</span> $ ./configure [with|enable]-sample7 <span class="number">5.</span> $ make <span class="number">6.</span> $ ./php -f ext/sample7/sample7.php <span class="number">7.</span> $ vi ext/sample7/sample7.c <span class="number">8.</span> $ make Repeat steps <span class="number">3</span><span class="number">-6</span> until you are satisfied with ext/sample7/<span class="built_in">config</span>.m4 <span class="keyword">and</span> <span class="built_in">step</span> <span class="number">6</span> confirms that your <span class="keyword">module</span> is compiled into PHP. Then, start writing code <span class="keyword">and</span> repeat the last two steps as often as necessary.</span><br></pre></td></tr></table></figure><p>此刻观察ext/sample7目录, 你将看到在第5章”你的第一个扩展”中你编写的扩展骨架 代码的注释版本. 只是现在你还不能编译它; 不过只需要对config.m4做少许修改就可以让 它工作了, 这样你就可以避免第5章中你所做的大部分工作.生成函数原型</p><p>####生成函数原型<br>如果你要编写一个对第三方库的包装扩展, 那么你就已经有了⼀个函数原型及基本行 为的机器刻度版本的描述(头文件), 通过传递一个额外的参数给./ext_skel, 它将自动的扫 描你的头文件并创建对应于接口的简单PHP_FUCNTION()块. 下面是使用./ext_skel指令 解析zlib头:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdoe@devbox:/<span class="built_in">home</span>/jdoe/cvs/php-src/ext/$ ./ext_skel extname=sample8 \ proto=/usr/local/include/zlib/zlib.h</span><br></pre></td></tr></table></figure><p></p><p>现在在ext/sample8/sample8.c中, 你就可以看到许多PHP_FUNCTION()定义, 每个 zlib函数对应一个. 要注意, 骨架生成程序会对某些未知资源类型产生警告消息. 你需要对 这些函数特别注意, 并且为了将这些内部的复杂结构体和用户空间可访问的变量关联起来, 可能会需要使用你在第9章”资源数据类型”中学到的知识.</p><h1 id="PECL-Gen"><a href="#PECL-Gen" class="headerlink" title="PECL_Gen"></a>PECL_Gen</h1><p>还有一种更加完善但也更加复杂的代码生成器: PECL_Gen, 可以在PECL(http:// pecl.php.net)中找到它, 使用pear install PECL_Gen命令可以安装它.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">译者注: PECL_Gen已经迁移为CodeGen_PECL(http:<span class="comment">//pear.php.net/package/ CodeGen_PECL). 本章涉及代码测试使用CodeGen_PECL的版本信息为: "php 1.1.3, Copyright (c) 2003-2006 Hartmut Holzgraefe", 如果您的环境使用有问题, 请参考译序中译者的环境配置.</span></span><br></pre></td></tr></table></figure><p>⼀旦安装完成, 它就可以像ext_skel一样运行, 接受相同的输入参数, 产生大致相同的 输出, 或者如果提供了一个完整的xml定义文件, 则产生一个更加健壮和完整可编译版本的 扩展. PECL_Gen并不会节省你编写扩展核心功能的时间; 而是提供⼀种可选的方式高效 的生成扩展骨架代码.</p><h4 id="specfile-xml"><a href="#specfile-xml" class="headerlink" title="specfile.xml"></a>specfile.xml</h4><p>下面是最简单的扩展定义文件:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;extension name="sample9"&gt; &lt;functions&gt;  &lt;function name="sample9_hello_world" role="public"&gt;   &lt;code&gt;&lt;![CDATA[php_printf("Hello World!");]]&gt;   &lt;/code&gt;  &lt;/function&gt; &lt;/functions&gt;&lt;/extension&gt;译注: 请注意, 译者使用的原著中第一行少了后面的问号, 导致不能使用, 加上就OK.</span><br></pre></td></tr></table></figure><p>通过PECL_Gen命令运行这个文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdoe@devbox:/<span class="built_in">home</span>/jdoe/cvs/php-src/ext/$ pecl-gen specfile.xml</span><br></pre></td></tr></table></figure><p>则会产生一个名为sample9的扩展, 并暴露一个用户空间函数sample9_hello_world().</p><p>####关于扩展</p><p>除了你已经熟悉的功能文件, PECL_Gen还会产生⼀个package.xml文件 它可以用于 pear安装. 如果你计划发布包到PECL库, 或者哪怕你只是想要使用pear包系统交付内容, 有这个文件都会很有用.</p><p>总之, 你可以在PECL_Gen的specfile.xml中指定多数package.xml文件的元素.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;&lt;extension name=<span class="string">"sample9"</span>&gt;    &lt;summary&gt;Extension <span class="number">9</span> generated by PECL_Gen&lt;/summary&gt;    &lt;description&gt;Another sample of PHP Extension Writing&lt;/description&gt;    &lt;maintainers&gt;        &lt;maintainer&gt;            &lt;name&gt;John D. Bookreader&lt;/name&gt;            &lt;email&gt;jdb@example.com&lt;/email&gt;            &lt;role&gt;lead&lt;/role&gt;        &lt;/maintainer&gt;    &lt;/maintainers&gt;    &lt;<span class="built_in">release</span>&gt;        &lt;version&gt;<span class="number">0.1</span>&lt;/version&gt;        &lt;date&gt;<span class="number">2006</span><span class="number">-01</span><span class="number">-01</span>&lt;/date&gt;        &lt;state&gt;beta&lt;/state&gt;        &lt;notes&gt;Initial Release&lt;/notes&gt;&lt;/<span class="built_in">release</span>&gt;    ...&lt;/extension&gt;</span><br></pre></td></tr></table></figure><p>当PECL_Gen创建扩展时, 这些信息将被翻译到最终的package.xml文件中. 依赖</p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>如你在第17章”配置和链接”中所见, 依赖可以扫描出来用于config.m4和config.w32文 件. PECL_Gen可以使用<deps>定义各种类型的依赖完成扫描工作. 默认情况下, 列在<deps>标签下的依赖会同时应用到Unix和win32构建中, 除非显式的是否用platform属性 指定某个目标</deps></deps></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;&lt;extension name=<span class="string">"sample9"</span>&gt;    ...    &lt;deps platform=<span class="string">"unix"</span>&gt;        &lt;! UNIX specific dependencies &gt;&lt;/deps&gt;    &lt;deps platform=<span class="string">"win32"</span>&gt;        &lt;! Win32 specific dependencies &gt;    &lt;/deps&gt;    &lt;deps platform=<span class="string">"all"</span>&gt;        &lt;! Dependencies that apply to all platforms &gt;&lt;/deps&gt;    ...&lt;/extension&gt;</span><br></pre></td></tr></table></figure><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>通常, 扩展在配置时使用–enable-extname样式的配置选项. 通过增加⼀个或多个<with>标签到<deps>块中, 则不仅配置选项被修改为–with-extname, 而且同时需要扫描 头文件:</deps></with></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;deps platform=<span class="string">"unix"</span>&gt;    &lt;with defaults=<span class="string">"/usr:/usr/local:/opt"</span>        testfile=<span class="string">"include/zlib/zlib.h"</span>&gt;zlib headers&lt;/with&gt;&lt;/deps&gt;</span><br></pre></td></tr></table></figure><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>必须的库也列在<deps>下, 使用<lib>标签.</lib></deps></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;deps platform=<span class="string">"all"</span>&gt;    &lt;lib name=<span class="string">"ssleay"</span> platform=<span class="string">"win32"</span>/&gt;    &lt;lib name=<span class="string">"crypto"</span> platform=<span class="string">"unix"</span>/&gt;    &lt;lib name=<span class="string">"z"</span> platform=<span class="string">"unix"</span> function=<span class="string">"inflate"</span>/&gt;&lt;/deps&gt;</span><br></pre></td></tr></table></figure><p>在前面两个例子中, 只是检查了库是否存在; 第三个例子中, 库将被真实的加载并扫描 以确认inflate()函数是否定义.</p><p>尽管<deps>标签实际已经命名了目标平台, 但<lib>标签也有⼀个platform属性可以覆盖<deps>标签的platform设置. 当它们混合使用的时候要格外小心.</deps></lib></deps></p><h4><a href="#" class="headerlink"></a><header></header></h4><p>此外, 需要包含的文件也可以通过在<deps>块中使用<header>标签在你的代码中追 加⼀个#include指令列表. 要强制某个头先包含, 可以在<header>标签上增加属性 prepend=”yes”. 和<lib>依赖类似,<header>也可以严格限制平台:</header></lib></header></header></deps></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;deps&gt;    &lt;header name=<span class="string">"sys/types.h"</span> platform=<span class="string">"unix"</span> prepend=<span class="string">"yes"</span>/&gt;    &lt;header name=<span class="string">"zlib/zlib.h"</span>/&gt;&lt;/deps&gt;译注: 经测试, 译者的环境&lt;header&gt;标签不支持platform属性.</span><br></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>用户空间常量使用<constants>块中的一个或多个<constant>标签定义. 每个标签需 要一个name和⼀个value属性, 以及⼀个值必须是int, float, string之一的type属性.</constant></constants></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;constants&gt;    &lt;constant name=<span class="string">"SAMPLE9_APINO"</span> type=<span class="string">"int"</span> value=<span class="string">"20060101"</span>/&gt;    &lt;constant name=<span class="string">"SAMPLE9_VERSION"</span> type=<span class="string">"float"</span> value=<span class="string">"1.0"</span>/&gt;    &lt;constant name=<span class="string">"SAMPLE9_AUTHOR"</span> type=<span class="string">"string"</span> value=<span class="string">"John Doe"</span>/&gt;&lt;/constants&gt;</span><br></pre></td></tr></table></figure><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>线程安全全局变量的定义方式几乎相同. 唯⼀的不同在于type参数需要使用C语言原 型而不是php用户空间描述. ⼀旦定义并构建, 全局变量就可以使用第12章”启动, 终止, 以 及其中的⼀些点”中学习的EXTNAME_G(global_name)的宏用法进行访问. 在这里, value属性表示变量在请求启动时的默认值. 要注意在specfile.xml中这个默认值只能指定为简单 的标量数值. 字符串和其他复杂结构应该在RINIT阶段手动设置.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;globals&gt;    &lt;global name=<span class="string">"greeting"</span> type=<span class="string">"char *"</span>/&gt;    &lt;global name=<span class="string">"greeting_was_issued"</span> type=<span class="string">"zend_bool"</span> value=<span class="string">"1"</span>/&gt;&lt;/globals&gt;</span><br></pre></td></tr></table></figure><h4 id="INI选项"><a href="#INI选项" class="headerlink" title="INI选项"></a>INI选项</h4><p>要绑定线程安全的全局变量到php.ini设置, 则需要使用<phpini>标签而不是<globa>. 这个标签需要两个额外的参数: onupdate=”updatemethod”标识INI的修改应该怎样处理, access=”mode”和第13章”INI设置”中介绍的模式含义相同, “mode”值可以是: all, user, perdir, system.</globa></phpini></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;globals&gt;    &lt;phpini name=<span class="string">"mysetting"</span> type=<span class="string">"int"</span> value=<span class="string">"42"</span> onupdate=<span class="string">"OnUpdateLong"</span> access=<span class="string">"all"</span>/&gt;&lt;/globals&gt;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>你已经看到了最基本的函数定义; 不过,<function>标签在PECL_Gen的specfile中实 际上支持两种不同类型的函数.</function></p><p>两个版本都支持你已经在<extension>级别上使用过的<summary>和<description>属 性; 两种类型都必须的元素是<code>标签, 它包含了将要被放入你的源代码文件中的原文C语言代码.</code></description></summary></extension></p><h4 id="role-”public”"><a href="#role-”public”" class="headerlink" title="role=”public”"></a>role=”public”</h4><p>如你所想, 所有定义为public角色的函数都将包装恰当的PHP_FUNCTION()头和花括 号, 对应到扩展的函数表向量中的条目.</p><p>除了其他函数支持的标签, public类型还允许指定一个<proto>标签. 这个标签的格式 应该匹配php在线手册中的原型展示, 它将被文档生成器解析.</proto></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;functions&gt;        &lt;function role="public" name="sample9_greet_me"&gt;            &lt;summary&gt;Greet a person by name&lt;/summary&gt;            &lt;description&gt;Accept a name parameter as a string and say hello to that person.Returns TRUE.&lt;/description&gt;            &lt;proto&gt;bool sample9_greet_me(string name)&lt;/proto&gt;            &lt;code&gt;            &lt;![CDATA[            char *name;            int name_len;            if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s",                        &amp;name, &amp;name_len) == FAILURE) &#123;return; &#125;            php_printf("Hello ");            PHPWRITE(name, name_len);            php_printf("!\n");            RETURN_TRUE;]]&gt;            &lt;/code&gt;        &lt;/function&gt;    &lt;/functions&gt;</span><br></pre></td></tr></table></figure><h4 id="role-”internal”"><a href="#role-”internal”" class="headerlink" title="role=”internal”"></a>role=”internal”</h4><p>内部函数涉及5个zend_module_entry函数: MINIT, MSHUTDOWN, RINIT, RSHUTDOWN, MINFO. 如果指定的名字不是这5个之一将会产生pecl-gen无法处理的错误.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;functions&gt;    &lt;function role="internal" name="MINFO"&gt;        &lt;code&gt;        &lt;![CDATA[        php_info_print_table_start();        php_info_print_table_header(2, "Column1", "Column2");        php_info_print_table_end();        ]]&gt;        &lt;/code&gt;    &lt;/function&gt;&lt;/functions&gt;</span><br></pre></td></tr></table></figure><h4 id="自定义代码"><a href="#自定义代码" class="headerlink" title="自定义代码"></a>自定义代码</h4><p>所有其他需要存在于你的扩展中的代码都可以使用<code>标签包含. 要放置任意代码 到你的目标文件extname.c中, 使用role=”code”; 或者说使用role=”header”将代码放到目标 文件php_extname.h中. 默认情况下, 代码将放到代码或头文件的底部, 除非指定了 position=”top”属性.</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;code role="header" position="bottom"&gt;&lt;![CDATA[typedef struct _php_sample9_data &#123;    long val;&#125; php_sample9_data;]]&gt;&lt;/code&gt;&lt;code role="code" position="top"&gt;&lt;![CDATA[static php_sample9_data *php_sample9_data_ctor(long value)&#123;    php_sample9_data *ret;    ret = emalloc(sizeof(php_sample9_data));    ret-&gt;val = value;    return ret;&#125;]]&gt; &lt;/code&gt;译注: 译者的环境中不支持原著中&lt;code&gt;标签的name属性.</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>使用本章讨论的工具, 你就可以快速的开发php扩展, 并且让你的代码相比手写更加不 容易产生bug. 现在是时候转向将php嵌入到其他项目了. 剩下的章节中, 你将利用php环境 和强大的php引擎为你的已有项目增加脚本能力, 使它可以为你的客户提供更多更有用的 功能.</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17 配置和链接</title>
      <link href="/posts/d60c2358.html"/>
      <url>/posts/d60c2358.html</url>
      
        <content type="html"><![CDATA[<h1 id="17-配置和链接"><a href="#17-配置和链接" class="headerlink" title="17 配置和链接"></a>17 配置和链接</h1><p>所有前面示例中的代码, 都是你曾经在php用户空间编写过代码的C语言的独立版本. 如果你做的项目需要和php扩展进行粘合, 那么你就至少需要链接一个外部库.</p><h1 id="autoconf"><a href="#autoconf" class="headerlink" title="autoconf"></a>autoconf</h1><p>在一个简单的应用中, 你可能已经在你的Makefile中增加了下面这样的CFLAGS和LDFLAGS.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS = $&#123;CFLAGS&#125; -I/usr/local/foobar/include</span><br><span class="line">LDFLAGS = $&#123;LDFLAGS&#125; -lfoobar -L/usr/local/foobar/lib</span><br></pre></td></tr></table></figure><p>想要构建你的应用却没有libfoobar的人, 或将libfoobar安装到其他位置的人, 将会得到一个处理过的错误消息, 用于帮助他找到错误原因.</p><p>在过去十年开发的多数开发源代码软件(OSS)以及PHP都利用了一个实用工具autoconf, 通过一些简单的宏来生成复杂的configure脚本. 这个产生的脚本会执行查找依赖库已经头文件是否安装的工作. 基于这些信息, 一个包可以自定义构建代码行, 或在编译的时间被浪费之前提供一个有意义的错误消息.</p><p>在构建php扩展时, 无论你是否计划公开发布, 都需要利用这个autoconf机制. 即便你对autoconf已经很熟悉了, 也请花几分钟时间阅读本章, php中引入了一些一般安装的autoconf没有的自定义宏.</p><p>和传统的autoconf步骤(集中的configure.in文件包含了包的所有配置宏)不同, php只是用configure.in管理许多位域源码树下小的config.m4脚本的协调, 包括各个扩展, SAPI, 核心自身, 以及ZendEngine.</p><p>你已经在前面的章节看到了一个简单版本的config.m4. 接下来, 我们将在这个文件中增加其他的autoconf语法, 让你的扩展可以收集到更多的配置时信息.</p><h1 id="库的查找"><a href="#库的查找" class="headerlink" title="库的查找"></a>库的查找</h1><p>config.m4脚本最多是用于检查依赖库是否已安装. 扩展比如mysql, ldap, gmp以及其他设计为php用户空间和c库实现的其他功能之间的粘合层的扩展. 如果它们的依赖库没有安装, 或者安装的版本太旧, 要么会编译错误, 要么会导致产生的二进制无法运行.</p><h2 id="头文件扫描"><a href="#头文件扫描" class="headerlink" title="头文件扫描"></a>头文件扫描</h2><p>对依赖库扫描中最简单的一步就是检查你的脚本中的包含文件, 它们将在链接时使用. 下面的代码尝试在一些常见位置查找zlib.h:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PHP_ARG_WITH(zlib,[<span class="keyword">for</span> zlib Support]</span><br><span class="line">[  with-zlib              Include ZLIB Support])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> test <span class="string">"$PHP_ZLIB"</span> != <span class="string">"no"</span>; then</span><br><span class="line">  <span class="keyword">for</span> i in /usr /usr/local /opt; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> test -f $i/include/zlib/zlib.h; then</span><br><span class="line">      ZLIB_DIR=$i</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> test -z <span class="string">"$ZLIB_DIR"</span>; then</span><br><span class="line">    AC_MSG_ERROR([zlib <span class="keyword">not</span> installed (http:<span class="comment">//www.zlib.org)])</span></span><br><span class="line">  fi</span><br><span class="line"></span><br><span class="line">  PHP_ADD_LIBRARY_WITH_PATH(z,$ZLIB_DIR/lib, ZLIB_SHARED_LIBADD)</span><br><span class="line">  PHP_ADD_INCLUDE($ZLIB_DIR/include)</span><br><span class="line"></span><br><span class="line">  AC_MSG_RESULT([found in $ZLIB_DIR])</span><br><span class="line">  AC_DEFINE(HAVE_ZLIB,<span class="number">1</span>,[libz found <span class="keyword">and</span> included])</span><br><span class="line"></span><br><span class="line">  PHP_NEW_EXTENSION(zlib, zlib.c, $ext_shared)</span><br><span class="line">  PHP_SUBST(ZLIB_SHARED_LIBADD)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p></p><p>config.m4文件很明显比你迄今为止使用的要大. 幸运的是, 它的语法非常的简单易懂并且如果你熟悉bash脚本, 对它也就不会陌生.</p><p>文件和第5章”你的第一个扩展”中第一次出现的一样, 都是以PHP_ARG_WITH()宏开始. 这个宏的行为和你用过的PHP_ARG_ENABLE()宏一样, 不过它将导致./configure时的选项是–with-extname/–without-extname而不再是–enable-extname/–disable-extname.</p><p>回顾这些宏, 它们的功能是等同的, 不同仅在于是否让终端用户给你的包一些暗示. 你可以在自己创建的私有扩展上使用任意一种方式. 不过, 如果你计划公开发布, 那就应该知道php正式的编码标准, 它指出enable/disable用于哪些不需要链接外部库的扩展, with/without则反之.</p><p>由于我们这里假设的扩展将链接zlib库, 因此你的config.m4脚本要以查找扩展源代码中将包含的zlib.h头文件. 这通过检查一些标准位置/usr, /usr/local, /opt中include/zlib目录下的zlib.h完成对其下两个目录的定位.</p><p>如果找到了zlib.h, 则将基路径设置到临时变量ZLIB_DIR中. 一旦循环完成, config.m4脚本检查ZLIB_DIR是否包含内容来确定是否找到了zlib.h. 如果没有找到, 则产生一个有意义的错误让用户知道./configure不能继续.</p><p>此刻, 脚本假设头文件存在, 对应的库也必须存在, 因此在下面的两行使用它修改构建环境, 最终增加-lz -L$ZLIB_DIR/lib到LDFLAGS以及-I$ZLIB_DIR/include到CFLAGS.</p><p>最终, 输出一个确认消息指示zlib安装已经找到, 并且在编译期间使用它的路径. config.m4的其他部分从前面部分的学习中你应该已经熟悉了. 为config.h定义一个#define, 定义扩展并指定它的源代码文件, 同时标识一个变量完成将扩展附加到构建系统的工作.</p><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>迄今为止, 这个config.m4示例指示查找了需要的头文件. 尽管这已经够用了, 但它仍然不能确保产生的二进制正确的进行链接, 因为可能不存在匹配的库文件, 或者版本不正确.</p><p>最简单的检查zlib.h对应的libz.so库文件是否存在的方式就是检查文件是否存在:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! test -f $ZLIB_DIR/lib/libz.so; then</span><br><span class="line">  AC_MSG_ERROR([zlib.h found, but libz.so <span class="keyword">not</span> present!])</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p></p><p>当然, 这仅仅是问题的一面. 如果安装了其他的同名库但和你要查找的库不兼容怎么办呢? 确保你的扩展可以成功编译的最好方式是测试找到的库实际编译所需的内容. 要这样做就需要在config.m4中PHP_ADD_LIBRARY_WITH_PATH调用之前加入下面代码:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PHP_CHECK_LIBRARY(z, deflateInit,,[</span><br><span class="line">  AC_MSG_ERROR([Invalid zlib extension, gzInit() <span class="keyword">not</span> found])</span><br><span class="line">],-L$ZLIB_DIR/lib)</span><br></pre></td></tr></table></figure><p></p><p>这个工具宏将展开输出一个完整的程序, ./configure将尝试编译它. 如果编译成功, 表示第二个参数定义的符号在第一个参数指定的库中存在. 成功后, 第三个参数中指定的autoconf脚本将会执行; 失败后, 第四个参数中指定的autoconf脚本将执行. 在这个例子中, 第三个参数为空, 因为没有消息就是最好的消息(译注: 应该是unix哲学之一), 第五个参数也就是左后一个参数, 用于指定额外的编译器和链接器标记, 这里, 使用-L致命了一个额外的用于查找库的路径.</p><h2 id="可选功能"><a href="#可选功能" class="headerlink" title="可选功能"></a>可选功能</h2><p>那么现在你已经有正确的库和头文件了, 但依赖的是所安装库的哪个版本呢? 你可能需要某些功能或排斥某些功能. 由于这种类型的变更通常涉及到某些特定入口点的增加或删除, 因此可以重用PHP_CHECK_LIBRARY()宏来检查库的某些能力.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PHP_CHECK_LIBRARY(z, gzgets,[</span><br><span class="line">  AC_DEFINE(HAVE_ZLIB_GETS,<span class="number">1</span>,[Having gzgets indicates zlib &gt;= <span class="number">1.0</span><span class="number">.9</span>])</span><br><span class="line">],[</span><br><span class="line">  AC_MSG_WARN([zlib &lt; <span class="number">1.0</span><span class="number">.9</span> installed, gzgets() will <span class="keyword">not</span> be <span class="built_in">available</span>])</span><br><span class="line">],-L$ZLIB_DIR/lib)</span><br></pre></td></tr></table></figure><p></p><h2 id="测试实际行为"><a href="#测试实际行为" class="headerlink" title="测试实际行为"></a>测试实际行为</h2><p>可能知道某个符号存在也还不能确保你的代码正确编译; 某些库的特定版本可能存在bug需要运行一些测试代码进行检查.</p><p>AC_TRY_RUN()宏可以编译一个小的源代码文件为可执行程序并执行. 依赖于传回给./configure的返回代码, 你的脚本可以设置可选的#define语句或直接输出消息(比如如果bug导致不能工作则提示升级)安全退出. 考虑下面的代码(摘自ext/standard/config.m4):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">AC_TRY_RUN([</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> somefn(<span class="keyword">double</span> n) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">floor</span>(n*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">2</span>) + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  <span class="keyword">return</span> somefn(<span class="number">0.045</span>)/<span class="number">10.0</span> != <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line">],[</span><br><span class="line">  PHP_ROUND_FUZZ=<span class="number">0.5</span></span><br><span class="line">  AC_MSG_RESULT(yes)</span><br><span class="line">],[</span><br><span class="line">  PHP_ROUND_FUZZ=<span class="number">0.50000000001</span></span><br><span class="line">  AC_MSG_RESULT(no)</span><br><span class="line">],[</span><br><span class="line">  PHP_ROUND_FUZZ=<span class="number">0.50000000001</span></span><br><span class="line">  AC_MSG_RESULT(cross compile)</span><br><span class="line">])</span><br><span class="line">AC_DEFINE_UNQUOTED(PHP_ROUND_FUZZ, $PHP_ROUND_FUZZ,</span><br><span class="line">                    [Is <span class="keyword">double</span> precision imprecise?])</span><br></pre></td></tr></table></figure><p>你可以看到, AC_TRY_RUN()的第一个参数是一块C语言代码, 它将被编译执行. 如果这段代码的退出代码是0, 位于第二个参数的autoconf脚本将被执行, 这种情况标识round()函数和期望一样工作, 返回0.5.</p><p>如果代码块返回非0值, 位域第三个参数的autoconf脚本将被执行. 第四个参数(最后一个)在php交叉编译时使用. 这种情况下, 尝试运行示例代码是没有意义的, 因为目标平台不同于扩展编译时使用的平台.</p><h1 id="强制模块依赖"><a href="#强制模块依赖" class="headerlink" title="强制模块依赖"></a>强制模块依赖</h1><p>在php 5.1中, 扩展之间的内部依赖是可以强制性的. 由于扩展可以静态构建到php中, 也可以构建为共享对象动态加载, 因此强制依赖需要在两个地方实现.</p><h2 id="配置时模块依赖"><a href="#配置时模块依赖" class="headerlink" title="配置时模块依赖"></a>配置时模块依赖</h2><p>第一个位置是你在本章课程中刚刚看到的config.m4文件中. 你可以使用PHP_ADD_EXTENSION_DEP(extname, depname[ , optional])宏标识extname这个扩展依赖于depname这个扩展. 当extname以静态方式构建到php中时, ./configure脚本将使用这一行代码确认depname必须首先初始化. optional参数是一个标记, 用来标识depname如果也是静态构建的, 应该在extname之前加载, 不过它并不是必须的依赖.</p><p>这个宏的一个使用示例是pdo驱动, 比如pdo_mysql是可预知依赖于pdo扩展的:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifdef([PHP_ADD_EXTENDION_DEP],</span><br><span class="line">[</span><br><span class="line">  PHP_ADD_EXTENSION_DEP(pdo_mysql, pdo)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><p>要注意PHP_ADD_EXTENSION_DEP()宏被包裹到一个ifdef()结构中. 这是因为pdo和它的驱动在编译大于或等于5.0版本的php时都是存在的, 然而PHP_ADD_EXTENSION_DEP()宏是直到5.1.0版本才出现的.</p><h2 id="运行时模块依赖"><a href="#运行时模块依赖" class="headerlink" title="运行时模块依赖"></a>运行时模块依赖</h2><p>另外一个你需要注册依赖的地方是zend_module_entry结构体中. 考虑下面第5章中你定义的zend_module_entry结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zend_module_entry sample_module_entry = &#123;</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">#endif</span><br><span class="line">    PHP_SAMPLE_EXTNAME,</span><br><span class="line">    php_sample_functions,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINFO */</span></span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    PHP_SAMPLE_EXTVER,</span><br><span class="line">#endif</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>增加运行时模块依赖信息就需要对STANDARD_MOUDLE_HEADER部分进行一些小修改:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zend_module_entry sample_module_entry = &#123;</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">220050617</span></span><br><span class="line">    STANDARD_MODULE_HEADER_EX, <span class="literal">NULL</span>,</span><br><span class="line">    php_sample_deps,</span><br><span class="line">#elif ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">#endif</span><br><span class="line">    PHP_SAMPLE_EXTNAME,</span><br><span class="line">    php_sample_functions,</span><br><span class="line"></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINFO */</span></span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    PHP_SAMPLE_EXTVER,</span><br><span class="line">#endif</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>现在, 如果ZEND_MODULE_API_NO高于php 5.1.0 beta发布版, 则STANDARD_MODULE_HEADER(译注: 这里原著笔误为STANDARD_MODULE_PROPERTIES)将被替换为略微复杂的结构, 它将包含一个指向模块依赖信息的引用.</p><p>这个目标结构体可以在你的zend_module_entry结构体上面定义如下:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_MODULE_API_NO &gt;= 220050617</span></span><br><span class="line"><span class="keyword">static</span> zend_module_dep php_sample_deps[] = &#123;</span><br><span class="line">    ZEND_MODULE_REQUIRED(<span class="string">"zlib"</span>)</span><br><span class="line">    &#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><p>和zend_function_entry向量类似, 这个列表可以有多项依赖, 按照顺序进行检查. 如果尝试加载某个依赖模块未满足, Zend将会中断加载, 报告不满足依赖的名字, 这样, 终端用户就可以通过首先加载其他模块来解决问题.</p><h1 id="Windows方言"><a href="#Windows方言" class="headerlink" title="Windows方言"></a>Windows方言</h1><blockquote><p>由于译者对windows环境不熟悉, 因此略过本节.</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>如果你的扩展将在未知或不可控制的环境构建, 让它足够聪明以应付奇怪的环境就非常重要. 使用php提供的unix和windows上强有力的脚本能力, 你应该可以检测到麻烦并在未知的管理员需要电话求助之前给于她一个解决方案.</p><p>现在你已经有使用php api从头建立php扩展的基础能力了, 你可以准备学习一下使用php提供的扩展开发工具把自己从繁重的重复劳动中解放出来了, 使用它们可以快速, 准确的建立新扩展的原型.</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16 有趣的流</title>
      <link href="/posts/97ca9fe7.html"/>
      <url>/posts/97ca9fe7.html</url>
      
        <content type="html"><![CDATA[<h1 id="16-有趣的流"><a href="#16-有趣的流" class="headerlink" title="16 有趣的流"></a>16 有趣的流</h1><p>php常被提起的一个特性是流上下文. 这个可选的参数甚至在用户空间大多数流创建相关的函数中都可用, 它作为一个泛化的框架用于向给定包装器或流实现传入/传出额外的信息.</p><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><p>每个流的上下文包含两种内部消息类型. 首先最常用的是上下文选项. 这些值被安排在上下文中一个二维数组中, 通常用于改变流包装器的初始化行为. 还有一种则是上下文参数, 它对于包装器是未知的, 当前提供了一种方式用于在流包装层内部的事件通知.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream_context *<span class="title">php_stream_context_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>通过这个API调用可以创建一个上下文, 它将分配一些存储空间并初始化用于保存上下文选项和参数的HashTable. 还会自动的注册为一个请求终止后将被清理的资源.</p><h2 id="设置选项"><a href="#设置选项" class="headerlink" title="设置选项"></a>设置选项</h2><p>设置上下文选项的内部API和用户空间的API是等同的:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_context_set_option</span><span class="params">(php_stream_context *context,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *wrappername, <span class="keyword">const</span> <span class="keyword">char</span> *optionname,</span></span></span><br><span class="line"><span class="function"><span class="params">            zval *optionvalue)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>下面是用户空间的原型:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stream_context_set_option</span><span class="params">(resource $context,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">string</span> $wrapper, <span class="built_in">string</span> $optionname,</span></span></span><br><span class="line"><span class="function"><span class="params">            mixed $value)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>它们的不同仅仅是用户空间和内部需要的数据类型不同.下面的例子就是使用这两个API调用, 通过内建包装器发起一个HTTP请求, 并通过一个上下文选项覆写了user_agent设置.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream  *<span class="title">php_varstream_get_homepage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *alt_user_agent TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_stream_context  *context;</span><br><span class="line">    zval    tmpval;</span><br><span class="line"></span><br><span class="line">    context = php_stream_context_alloc(TSRMLS_C);</span><br><span class="line">    ZVAL_STRING(&amp;tmpval, alt_user_agent, <span class="number">0</span>);</span><br><span class="line">    php_stream_context_set_option(context, <span class="string">"http"</span>, <span class="string">"user_agent"</span>, &amp;tmpval);</span><br><span class="line">    <span class="keyword">return</span> php_stream_open_wrapper_ex(<span class="string">"http://www.php.net"</span>, <span class="string">"rb"</span>, REPORT_ERRORS | ENFORCE_SAFE_MODE, <span class="literal">NULL</span>, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>译者使用的php-5.4.10中php_stream_context_alloc()增加了线程安全控制, 因此相应的对例子进行了修改, 请读者测试时注意.<br>这里要注意的是tmpval并没有分配任何持久性的存储空间, 它的字符串值是通过复制设置的. php_stream_context_set_option()会自动的对传入的zval内容进行一次拷贝.</p></blockquote><h1 id="取回选项"><a href="#取回选项" class="headerlink" title="取回选项"></a>取回选项</h1><p>用于取回上下文选项的API调用正好是对应的设置API的镜像:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_context_get_option</span><span class="params">(php_stream_context *context,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *wrappername, <span class="keyword">const</span> <span class="keyword">char</span> *optionname,</span></span></span><br><span class="line"><span class="function"><span class="params">            zval ***optionvalue)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>回顾前面, 上下文选项存储在一个嵌套的HashTable中, 当从一个HashTable中取回值时, 一般的方法是传递一个指向zval **的指针给zend_hash_find(). 当然, 由于php_stream_context_get_option()是zend_hash_find()的一个特殊代理, 它们的语义是相同的.</p><p>下面是内建的http包装器使用php_stream_context_get_option()设置user_agent的简化版示例:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zval **ua_zval;</span><br><span class="line"><span class="keyword">char</span> *user_agent = <span class="string">"PHP/5.1.0"</span>;</span><br><span class="line"><span class="keyword">if</span> (context &amp;&amp;</span><br><span class="line">    php_stream_context_get_option(context, <span class="string">"http"</span>,</span><br><span class="line">                <span class="string">"user_agent"</span>, &amp;ua_zval) == SUCCESS &amp;&amp;</span><br><span class="line">                Z_TYPE_PP(ua_zval) == IS_STRING) &#123;</span><br><span class="line">    user_agent = Z_STRVAL_PP(ua_zval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这种情况下, 非字符串值将会被丢弃, 因为对用户代理字符串而言, 数值是没有意义的. 其他的上下文选项, 比如max_redirects, 则需要数字值, 由于在字符串的zval中存储数字值并不通用, 所以需要执行一个类型转换以使设置合法.</p><p>不幸的是这些变量是上下文拥有的, 因此它们不能直接转换; 而需要首先进行隔离再进行转换, 最终如果需要还要进行销毁:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> max_redirects = <span class="number">20</span>;</span><br><span class="line">zval **tmpzval;</span><br><span class="line"><span class="keyword">if</span> (context &amp;&amp;</span><br><span class="line">    php_stream_context_get_option(context, <span class="string">"http"</span>,</span><br><span class="line">            <span class="string">"max_redirects"</span>, &amp;tmpzval) == SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE_PP(tmpzval) == IS_LONG) &#123;</span><br><span class="line">        max_redirects = Z_LVAL_PP(tmpzval);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zval copyval = **tmpzval;</span><br><span class="line">        zval_copy_ctor(&amp;copyval);</span><br><span class="line">        convert_to_long(&amp;copyval);</span><br><span class="line">        max_redirects = Z_LVAL(copyval);</span><br><span class="line">        zval_dtor(&amp;copyval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>实际上, 在这个例子中, zval_dtor()并不是必须的. IS_LONG的变量并不需要zval容器之外的存储空间, 因此zval_dtor()实际上不会有真正的操作. 在这个例子中包含它是为了完整性考虑, 对于字符串, 数组, 对象, 资源以及未来可能的其他类型, 就需要这个调用了.</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>虽然用户空间API中看起来参数和上下文选项是类似的, 但实际上在语言内部的php_stream_context结构体中它们被定义为不同的成员.</p><p>目前只支持一个上下文参数: 通知器. php_stream_context结构体中的这个元素可以指向下面的php_stream_notifier结构体:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    php_stream_notification_func func;</span><br><span class="line">    <span class="keyword">void</span> (*dtor)(php_stream_notifier *notifier);</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="keyword">size_t</span> progress, progress_max;</span><br><span class="line">&#125; php_stream_notifier;</span><br></pre></td></tr></table></figure><p></p><p>当将一个php_stream_notifier结构体赋值给context-&gt;notifier时, 它将提供一个回调函数func, 在特定的流上发生下表中的PHP_STREAM_NOTIFY_<em>代码表示的事件时被触发. 每个事件将会对应下面第二张表中的PHP_STREAM_NOTIFY_SEVERITY_</em>的级别:</p><p><table><br><tr><br></tr><tr><td>事件代码</td><td>含义</td></tr><br><tr><td>RESOLVE</td><td>主机地址解析完成. 多数基于套接字的包装器将在连接之前执行这个查询.</td></tr><br><tr><td>CONNECT</td><td>套接字流连接到远程资源完成.</td></tr><br><tr><td>AUTH_REQUIRED</td><td>请求的资源不可用, 原因是访问控制以及缺失授权</td></tr><br><tr><td>MIME_TYPE_IS</td><td>远程资源的mime-type不可用</td></tr><br><tr><td>FILE_SIZE_IS</td><td>远程资源当前可用大小</td></tr><br><tr><td>REDIRECTED</td><td>原来的URL请求导致重定向到其他位置</td></tr><br><tr><td>PROGRESS</td><td>由于额外数据的传输导致php_stream_notifier结构体的progress以及(可能的)progress_max元素被更新(进度信息, 请参考php手册curl_setopt的CURLOPT_PROGRESSFUNCTION和CURLOPT_NOPROGRESS选项)</td></tr><br><tr><td>COMPLETED</td><td>流上没有更多的可用数据</td></tr><br><tr><td>FAILURE</td><td>请求的URL资源不成功或未完成</td></tr><br><tr><td>AUTH_RESULT</td><td>远程系统已经处理了授权认证</td></tr><br></table></p><p><table><br><tr><td>安全码</td><td>&nbsp;</td></tr><br><tr><td>INFO</td><td>信息更新. 等价于一个E_NOTICE错误</td></tr><br><tr><td>WARN</td><td>小的错误条件. 等价于一个E_WARNING错误</td></tr><br><tr><td>ERR</td><td>中断错误条件. 等价于一个E_ERROR错误.</td></tr><br></table><br>通知器实现提供了一个便利指针*ptr用于存放额外数据. 这个指针指向的空间必须在上下文析构时被释放, 因此必须指定一个dtor函数, 在上下文的最后一个引用离开它的作用域时调用这个dtor进行释放.</p><p>mask元素允许事件触发限定特定的安全级别. 如果发生的事件没有包含在mask中, 则通知器函数不会被触发.</p><p>最后两个元素progress和progress_max可以由流实现设置, 然而, 通知器函数应该避免使用这两个值, 除非它接收到PHP_STREAM_NOTIFY_PROGRESS或PHP_STREAM_NOTIFY_FILE_SIZE_IS事件通知.</p><p>下面是一个php_stream_notification_func()回调原型的示例:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample6_notifier</span><span class="params">(php_stream_context *context,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> notifycode, <span class="keyword">int</span> severity, <span class="keyword">char</span> *xmsg, <span class="keyword">int</span> xcode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> bytes_sofar, <span class="keyword">size_t</span> bytes_max,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *ptr TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (notifycode != PHP_STREAM_NOTIFY_FAILURE) &#123;</span><br><span class="line">        <span class="comment">/* 忽略所有通知 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (severity == PHP_STREAM_NOTIFY_SEVERITY_ERR) &#123;</span><br><span class="line">        <span class="comment">/* 分发到错误处理函数 */</span></span><br><span class="line">        php_sample6_theskyisfalling(context, xcode, xmsg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (severity == PHP_STREAM_NOTIFY_SEVERITY_WARN) &#123;</span><br><span class="line">        <span class="comment">/* 日志记录潜在问题 */</span></span><br><span class="line">        php_sample6_logstrangeevent(context, xcode, xmsg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="默认上下文"><a href="#默认上下文" class="headerlink" title="默认上下文"></a>默认上下文</h2><p>在php5.0中, 当用户空间的流创建函数被调用时, 如果没有传递上下文参数, 请求一般会使用默认的上下文. 这个上下文变量存储在文件全局结构中: FG(default_context), 并且它可以和其他所有的php_stream_context变量一样访问. 当在用户空间脚本执行流的创建时, 更好的方式是允许用户指定一个上下文或者至少指定一个默认的上下文. 将用户空间的zval *解码得到php_stream_context可以使用php_steram_context_from_zval()宏完成, 比如下面改编自第14章”访问流”的例子:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample6_fopen)</span><br><span class="line">&#123;</span><br><span class="line">    php_stream *stream;</span><br><span class="line">    <span class="keyword">char</span> *path, *mode;</span><br><span class="line">    <span class="keyword">int</span> path_len, mode_len;</span><br><span class="line">    <span class="keyword">int</span> options = ENFORCE_SAFE_MODE | REPORT_ERRORS;</span><br><span class="line">    zend_bool use_include_path = <span class="number">0</span>;</span><br><span class="line">    zval *zcontext = <span class="literal">NULL</span>;</span><br><span class="line">    php_stream_context *context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,</span><br><span class="line">            <span class="string">"ss|br"</span>, &amp;path, &amp;path_len, &amp;mode, &amp;mode_len,</span><br><span class="line">                &amp;use_include_path, &amp;zcontext) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context = php_stream_context_from_zval(zcontext, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (use_include_path) &#123;</span><br><span class="line">        options |= PHP_FILE_USE_INCLUDE_PATH;</span><br><span class="line">    &#125;</span><br><span class="line">    stream = php_stream_open_wrapper_ex(path, mode, options,</span><br><span class="line">                                    <span class="literal">NULL</span>, context);</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    php_stream_to_zval(stream, return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果zcontext包含一个用户空间的上下文资源, 通过ZEND_FETCH_RESOURCE()调用获取到它关联的指针设置到context中. 否则, 如果zcontext为NULL并且php_stream_context_from_zval()的第二个参数设置为非0值, 这个宏则直接返回NULL. 这个例子以及几乎所有的核心流创建的用户空间函数中, 第二个参数都被设置为0, 此时将使用FG(default_context)的值.</p><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>过滤器作为读写操作的流内容传输过程中的附加阶段. 要注意的是直到php 4.3中才加入了流过滤器, 在php 5.0对流过滤器的API设计做过较大的调整. 本章的内容遵循的是php 5的流过滤器规范.</p><h2 id="在流上应用已有的过滤器"><a href="#在流上应用已有的过滤器" class="headerlink" title="在流上应用已有的过滤器"></a>在流上应用已有的过滤器</h2><p>在一个打开的流上应用一个已有的过滤器只需要几行代码即可:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream *<span class="title">php_sample6_fopen_read_ucase</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path</span></span></span><br><span class="line"><span class="function"><span class="params">                                        TSRMLS_DC)</span> </span>&#123;</span><br><span class="line">    php_stream_filter *filter;</span><br><span class="line">    php_stream *stream;</span><br><span class="line"></span><br><span class="line">    stream = php_stream_open_wrapper_ex(path, <span class="string">"r"</span>,</span><br><span class="line">                        REPORT_ERRORS | ENFORCE_SAFE_MODE,</span><br><span class="line">                        <span class="literal">NULL</span>, FG(default_context));</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filter = php_stream_filter_create(<span class="string">"string.toupper"</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                        <span class="number">0</span> TSRMLS_CC);</span><br><span class="line">    <span class="keyword">if</span> (!filter) &#123;</span><br><span class="line">        php_stream_close(stream);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    php_stream_filter_append(&amp;stream-&gt;readfilters, filter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先来看看这里引入的API函数以及它的兄弟函数:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream_filter *<span class="title">php_stream_filter_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span> *filtername, zval *filterparams,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> persistent TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_stream_filter_prepend</span><span class="params">(php_stream_filter_chain *chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                php_stream_filter *filter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_stream_filter_append</span><span class="params">(php_stream_filter_chain *chain,</span></span></span><br><span class="line"><span class="function"><span class="params">                php_stream_filter *filter)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>php_stream_filter_create()的filterparams参数和用户空间对应的stream_filter_append()和stream_filter_prepend()函数的同名参数含义一致. 要注意, 所有传递到php_stream_filter_create()的zval *数据都不是过滤器所拥有的. 它们只是在过滤器创建期间被借用而已, 因此在调用作用域分配传入的所有内存空间都要手动释放.</p><p>如果过滤器要被应用到一个持久化流, 则必须设置persistent参数为非0值. 如果你不确认你要应用过滤器的流是否持久化的, 则可以使用php_stream_is_persistent()宏进行检查, 它只接受一个php_stream *类型的参数.</p><p>如在前面例子中看到的, 流过滤器被隔离到两个独立的链条中. 一个用于写操作中对php_stream_write()调用响应时的stream-&gt;ops-&gt;write()调用之前. 另外一个用于读操作中对stream-&gt;ops-&gt;read()取回的所有数据进行处理.</p><p>在这个例子中你使用&amp;stream-&gt;readfilters指示读的链条. 如果你想要在写的链条上应用一个过滤器, 则可以使用&amp;stream-&gt;writefilters.</p><h2 id="定义一个过滤器实现"><a href="#定义一个过滤器实现" class="headerlink" title="定义一个过滤器实现"></a>定义一个过滤器实现</h2><p>注册过滤器实现和注册包装器遵循相同的基础规则. 第一步是在MINIT阶段向php中引入你的过滤器, 与之匹配的是在MSHUTDOWN阶段移除它. 下面是需要调用的API原型以及两个注册过滤器工厂的示例:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_filter_register_factory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *filterpattern,</span></span></span><br><span class="line"><span class="function"><span class="params">            php_stream_filter_factory *factory TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_filter_unregister_factory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *filterpattern TSRMLS_DC)</span></span>;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(sample6)</span><br><span class="line">&#123;</span><br><span class="line">    php_stream_filter_register_factory(<span class="string">"sample6"</span>,</span><br><span class="line">            &amp;php_sample6_sample6_factory TSRMLS_CC);</span><br><span class="line">    php_stream_filter_register_factory(<span class="string">"sample.*"</span>,</span><br><span class="line">            &amp;php_sample6_samples_factory TSRMLS_CC);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(sample6)</span><br><span class="line">&#123;</span><br><span class="line">    php_stream_filter_unregister_factory(<span class="string">"sample6"</span> TSRMLS_CC);</span><br><span class="line">    php_stream_filter_unregister_factory(<span class="string">"sample.*"</span></span><br><span class="line">                                        TSRMLS_CC);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里注册的第一个工厂定义了一个具体的过滤器名sample6; 第二个则利用了流包装层内部的基本匹配规则. 为了进行演示, 下面的用户空间代码, 每行都将尝试通过不同的名字实例化php_sample6_samples_factory.<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    stream_filter_append(STDERR, <span class="string">'sample.one'</span>);</span><br><span class="line">    stream_filter_append(STDERR, <span class="string">'sample.3'</span>);</span><br><span class="line">    stream_filter_append(STDERR, <span class="string">'sample.filter.thingymabob'</span>);</span><br><span class="line">    stream_filter_append(STDERR, <span class="string">'sample.whatever'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>php_sample6_samples_factory的定义如下面代码, 你可以将这些代码放到你的MINIT块上面:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ext/standard/php_string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    is_persistent;</span><br><span class="line">    <span class="keyword">char</span>    *tr_from;</span><br><span class="line">    <span class="keyword">char</span>    *tr_to;</span><br><span class="line">    <span class="keyword">int</span>     tr_len;</span><br><span class="line">&#125; php_sample6_filter_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 过滤逻辑 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">php_stream_filter_status_t</span> <span class="title">php_sample6_filter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        php_stream *stream, php_stream_filter *thisfilter,</span></span></span><br><span class="line"><span class="function"><span class="params">        php_stream_bucket_brigade *buckets_in,</span></span></span><br><span class="line"><span class="function"><span class="params">        php_stream_bucket_brigade *buckets_out,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> *bytes_consumed, <span class="keyword">int</span> flags TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_stream_bucket       *bucket;</span><br><span class="line">    php_sample6_filter_data *data       = thisfilter-&gt;abstract;</span><br><span class="line">    <span class="keyword">size_t</span>                  consumed    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( buckets_in-&gt;head ) &#123;</span><br><span class="line">        bucket      = php_stream_bucket_make_writeable(buckets_in-&gt;head TSRMLS_CC);</span><br><span class="line">        php_strtr(bucket-&gt;buf, bucket-&gt;buflen, data-&gt;tr_from, data-&gt;tr_to, data-&gt;tr_len);</span><br><span class="line">        consumed    += bucket-&gt;buflen;</span><br><span class="line">        php_stream_bucket_append(buckets_out, bucket TSRMLS_CC);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> ( bytes_consumed ) &#123;</span><br><span class="line">        *bytes_consumed = consumed;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> PSFS_PASS_ON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 过滤器的释放 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_sample6_filter_dtor</span><span class="params">(php_stream_filter *thisfilter TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_sample6_filter_data *data   = thisfilter-&gt;abstract;</span><br><span class="line">    pefree(data, data-&gt;is_persistent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 流过滤器操作表 */</span></span><br><span class="line"><span class="keyword">static</span> php_stream_filter_ops php_sample6_filter_ops = &#123;</span><br><span class="line">    php_sample6_filter,</span><br><span class="line">    php_sample6_filter_dtor,</span><br><span class="line">    <span class="string">"sample.*"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符翻译使用的表 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_SAMPLE6_ALPHA_UCASE     <span class="meta-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_SAMPLE6_ALPHA_LCASE     <span class="meta-string">"abcdefghijklmnopqrstuvwxyz"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_SAMPLE6_ROT13_UCASE     <span class="meta-string">"NOPQRSTUVWXYZABCDEFGHIJKLM"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_SAMPLE6_ROT13_LCASE     <span class="meta-string">"nopqrstuvwxyzabcdefghijklm"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建流过滤器实例的过程 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> php_stream_filter *<span class="title">php_sample6_filter_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, zval *param, <span class="keyword">int</span> persistent TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_sample6_filter_data *data;</span><br><span class="line">    <span class="keyword">char</span>                    *subname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 安全性检查 */</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(name) &lt; <span class="keyword">sizeof</span>(<span class="string">"sample."</span>) || <span class="built_in">strncmp</span>(name, <span class="string">"sample."</span>, <span class="keyword">sizeof</span>(<span class="string">"sample."</span>) - <span class="number">1</span>) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配流过滤器数据 */</span></span><br><span class="line">    data    = pemalloc(<span class="keyword">sizeof</span>(php_sample6_filter_data), persistent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !data ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置持久性 */</span></span><br><span class="line">    data-&gt;is_persistent = persistent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据调用时的名字, 对过滤器数据进行适当初始化 */</span></span><br><span class="line">    subname = (<span class="keyword">char</span> *)name + <span class="keyword">sizeof</span>(<span class="string">"sample."</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(subname, <span class="string">"ucase"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">        data-&gt;tr_from   = PHP_SAMPLE6_ALPHA_LCASE;</span><br><span class="line">        data-&gt;tr_to     = PHP_SAMPLE6_ALPHA_UCASE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(subname, <span class="string">"lcase"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">        data-&gt;tr_from   = PHP_SAMPLE6_ALPHA_UCASE;</span><br><span class="line">        data-&gt;tr_to     = PHP_SAMPLE6_ALPHA_LCASE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(subname, <span class="string">"rot13"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">        data-&gt;tr_from   = PHP_SAMPLE6_ALPHA_LCASE</span><br><span class="line">                        PHP_SAMPLE6_ALPHA_UCASE;;</span><br><span class="line">        data-&gt;tr_to     = PHP_SAMPLE6_ROT13_LCASE</span><br><span class="line">                        PHP_SAMPLE6_ROT13_UCASE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 不支持 */</span></span><br><span class="line">        pefree(data, persistent);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 节省未来使用时每次的计算 */</span></span><br><span class="line">    data-&gt;tr_len    = <span class="built_in">strlen</span>(data-&gt;tr_from);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配一个php_stream_filter结构并按指定参数初始化 */</span></span><br><span class="line">    <span class="keyword">return</span> php_stream_filter_alloc(&amp;php_sample6_filter_ops, data, persistent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 流过滤器工厂, 用于创建流过滤器实例(php_stream_filter_append/prepend的时候) */</span></span><br><span class="line"><span class="keyword">static</span> php_stream_filter_factory php_sample6_samples_factory = &#123;</span><br><span class="line">    php_sample6_filter_create</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>译注: 下面是译者对整个流程的分析</p></blockquote><blockquote><p>一. MINIT阶段的register操作将在stream_filters_hash这个HashTable中注册一个php_stream_filter_factory结构, 它只有一个成员create_filter, 用来创建过滤器实例.</p></blockquote><blockquote><p>二. 用户空间代码stream_filter_append(STDERR, ‘sapmple.one’);在内部的实现是apply_filter_to_stream()函数(ext/standard/streamsfuncs.c中), 这里有两步操作, 首先创建过滤器, 然后将过滤器按照参数追加到流的readfilters/writefilters相应链中;</p></blockquote><blockquote><p>二.一 创建过滤器(php_stream_filter_create()): 首先直接按照传入的名字精确的从stream_filters_hash(或FG(stream_filters))中查找, 如果没有, 从右向左替换句点后面的内容为星号”*”进行查找, 直到找到注册的过滤器工厂或错误返回. 一旦找到注册的过滤器工厂, 就调用它的create_filter成员, 创建流过滤器实例.</p></blockquote><blockquote><p>二.二 直接按照参数描述放入流的readfilters/writefilters相应位置.</p></blockquote><blockquote><p>三. 用户向该流进行写入或读取操作时(以写为例): 此时内部将调用_php_stream_write(), 在这个函数中, 如果流的writefilters非空, 则调用流过滤器的fops-&gt;filter()执行过滤, 并根据返回状态做相应处理.</p></blockquote><blockquote><p>四. 当流的生命周期结束, 流被释放的时候, 将会检查流的readfilters/writefilters是否为空, 如果非空, 相应的调用php_stream_filter_remove()进行释放, 其中就调用了fops-&gt;fdtor对流过滤器进行释放.</p></blockquote><p>上一章我们已经熟悉了流包装器的实现, 你可能能够识别这里的基本结构. 工厂函数(php_sample6_samples_filter_create)被调用分配一个过滤器实例, 并赋值给一个操作集合和抽象数据. 这上面的例子中, 你的工厂为所有的过滤器类型赋值了相同的ops结构, 但使用了不同的初始化数据.</p><p>调用作用域将得到这里分配的过滤器, 并将它赋值给流的readfilters链或writefilters链. 接着, 当流的读/写操作被调用时, 过滤器链将数据放入到一个或多个php_stream_bucket结构体, 并将这些bucket组织到一个队列php_stream_bucket_brigade中传递给过滤器.</p><p>这里, 你的过滤器实现是前面的php_sample6_filter, 它取出输入队列bucket中的数据, 使用php_sample6_filter_create中确定的字符表执行字符串翻译, 并将修改后的bucket放入到输出队列.</p><p>由于这个过滤器的实现并没有其他内部缓冲, 因此几乎不可能出错, 因此它总是返回PSFS_PASS_ON, 告诉流包装层有数据被过滤器存放到了输出队列中. 如果过滤器执行了内部缓冲消耗了所有的输入数据而没有产生输出, 就需要返回PSFS_FEED_ME标识过滤器循环周期在没有其他输入数据时暂时停止. 如果过滤器碰到了关键性的错误, 它应该返回PSFS_ERR_FATAL, 它将指示流包装层, 过滤器链处于不稳定状态. 这将导致流被关闭.</p><p>用于维护bucket和bucket队列的API函数如下:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream_bucket *<span class="title">php_stream_bucket_new</span><span class="params">(php_stream *stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">int</span> own_buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> buf_persistent TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>创建一个php_stream_bucket用于存放到输出队列. 如果own_buf被设置为非0值, 流包装层可以并且通常都会修改它的内容或在某些点释放分配的内存. buf_persistent的非0值标识buf使用的内存是否持久分配的:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_bucket_split</span><span class="params">(php_stream_bucket *in,</span></span></span><br><span class="line"><span class="function"><span class="params">        php_stream_bucket **left, php_stream_bucket **right,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> length TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>这个函数将in这个bucket的内容分离到两个独立的bucket对象中. left这个bucket将包含in中的前length个字符, 而right则包含剩下的所有字符.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_stream_bucket_delref</span><span class="params">(php_stream_bucket *bucket</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_stream_bucket_addref</span><span class="params">(php_stream_bucket *bucket)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>Bucket使用和zval以及资源相同的引用计数系统. 通常, 一个bucket仅属于一个上下文, 也就是它依附的队列.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_stream_bucket_prepend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                    php_stream_bucket_brigade *brigade,</span></span></span><br><span class="line"><span class="function"><span class="params">                    php_stream_bucket *bucket TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_stream_bucket_append</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        php_stream_bucket_brigade *brigade,</span></span></span><br><span class="line"><span class="function"><span class="params">        php_stream_bucket *bucket TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>这两个函数扮演了过滤器子系统的苦力, 用于附加bucket到队列的开始(prepend)或末尾(append)<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_stream_bucket_unlink</span><span class="params">(php_stream_bucket *bucket</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>在过滤器逻辑应用处理完成后, 旧的bucket必须使用这个函数从它的输入队列删除(unlink).<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream_bucket *<span class="title">php_stream_bucket_make_writeable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        php_stream_bucket *bucket TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>将一个bucket从它所依附的队列中移除, 并且如果需要, 赋值bucket-&gt;buf的内部缓冲区, 这样就使得它的内容可修改. 在某些情况下, 比如当输入bucket的引用计数大于1时, 返回的bucket将会是不同的实例, 而不是传入的实例. 因此, 我们要保证在调用作用域使用的是返回的bucket, 而不是传入的bucket.</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>过滤器和上下文可以让普通的流类型行为被修改, 或通过INI设置影响整个请求, 而不需要直接的代码修改. 使用本章设计的计数, 你可以使你自己的包装器实现更加强大, 并且可以对其他包装器产生的数据进行改变.</p><p>接下来, 我们将离开PHPAPI背后的工作, 回到php构建系统的机制, 产生更加复杂的扩展链接到其他应用, 找到更加容易的方法, 使用工具集处理重复的工作.</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15 流的实现</title>
      <link href="/posts/34b479c3.html"/>
      <url>/posts/34b479c3.html</url>
      
        <content type="html"><![CDATA[<h1 id="15-流的实现"><a href="#15-流的实现" class="headerlink" title="15 流的实现"></a>15 流的实现</h1><p>php的流最强力的特性之一是它可以访问众多数据源: 普通文件, 压缩文件, 网络透明 通道, 加密网络, 命名管道以及域套接字, 它们对于用户空间以及内部都是统⼀的API.</p><h1 id="15-1-php流的表象之下"><a href="#15-1-php流的表象之下" class="headerlink" title="15.1 php流的表象之下"></a>15.1 php流的表象之下</h1><p>对于给定的流实例, 比如文件流和网络流, 它们的不同在于上一章你使用的流创建函数返回的php_stream结构体中的ops成员.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">php_stream</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">php_stream_ops *ops;</span><br><span class="line">...</span><br><span class="line">&#125; php_stream;</span><br></pre></td></tr></table></figure><p></p><p>php_stream_ops结构体定义的是一个函数指针集合以及一个描述标记.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">php_stream_ops</span> &#123;</span></span><br><span class="line"><span class="keyword">size_t</span> (*<span class="built_in">write</span>)(php_stream *stream, <span class="keyword">const</span> <span class="keyword">char</span> *buf,</span><br><span class="line"><span class="keyword">size_t</span> count TSRMLS_DC);</span><br><span class="line"><span class="keyword">size_t</span> (*<span class="built_in">read</span>)(php_stream *stream, <span class="keyword">char</span> *buf,</span><br><span class="line"><span class="keyword">size_t</span> count TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span>    (*<span class="built_in">close</span>)(php_stream *stream, <span class="keyword">int</span> close_handle</span><br><span class="line">TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span>    (*<span class="built_in">flush</span>)(php_stream *stream TSRMLS_DC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *label;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*<span class="built_in">seek</span>)(php_stream *stream, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence,</span><br><span class="line"><span class="keyword">off_t</span> *newoffset TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span> (*cast)(php_stream *stream, <span class="keyword">int</span> castas, <span class="keyword">void</span> **ret</span><br><span class="line">TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span> (*stat)(php_stream *stream, php_stream_statbuf *ssb</span><br><span class="line">TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span> (*set_option)(php_stream *stream, <span class="keyword">int</span> option,<span class="keyword">int</span> value,</span><br><span class="line"><span class="keyword">void</span> *ptrparam TSRMLS_DC);</span><br><span class="line">&#125; php_stream_ops;</span><br></pre></td></tr></table></figure><p></p><p>当流访问函数比如php_stream_read()被调用时, 流包装层实际上解析调用了stream-&gt;ops中对应的函数, 这样实际调用的就是当前流类型特有的read实现. 比如, 普通文件的流ops结构体中的read函数实现如下(实际的该实现比下面的示例复杂一点):<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">php_stdio_read</span><span class="params">(php_stream *stream, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> count TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">php_stdio_stream_data *data =</span><br><span class="line">(php_stdio_stream_data*)stream-&gt;abstract;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">read</span>(data-&gt;fd, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>而compress.zlib流使用的ops结构体中则read则指向的是如下的函数:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">php_zlib_read</span><span class="params">(php_stream *stream, <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> count TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">php_gz_stream_data_t</span> *<span class="title">data</span> =</span></span><br><span class="line"><span class="class">(<span class="title">struct</span> <span class="title">php_gz_stream_data_t</span> *) <span class="title">stream</span>-&gt;<span class="title">abstract</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> gzread(data-&gt;gz_file, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里第一点需要注意的是ops结构体指向的函数指针常常是对数据源真正的读取函数的一个瘦代理. 在上面两个例子中, 标准I/O流使用posix的read()函数, 而zlib流使用的是libz的gzread()函数.</p><p>你可能还注意到了, 这里使用了stream-&gt;abstract元素. 这是流实现的一个便利指针, 它可以被用于获取各种相关的捆绑信息. 在上面的例子中, 指向自定义结构体的指针, 用于存储底层read函数要使用的文件描述符.</p><p>还有一件你可能注意到的事情是php_stream_ops结构体中的每个函数都期望一个已有的流实例, 但是怎样得到实例呢? abstract成员是怎样设置的以及什么时候流指示使用哪个ops结构体? 答案就在你在上一章使用过的第一个打开流的函数(php_stream_open_wrapper())中.</p><p>当这个函数被调用时, php的流包装层尝试基于传递的URL中的scheme://部分确定请求的是什么协议. 这样它就可以在已注册的php包装器中查找对应的php_stream_wrapper项. 每个php_stream_wrapper结构体都可以取到自己的ops元素, 它指向一个php_stream_wrapper_ops结构体:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">php_stream_wrapper_ops</span> &#123;</span></span><br><span class="line">php_stream *(*stream_opener)(php_stream_wrapper *wrapper,</span><br><span class="line"><span class="keyword">char</span> *filename, <span class="keyword">char</span> *mode,</span><br><span class="line"><span class="keyword">int</span> options, <span class="keyword">char</span> **opened_path,</span><br><span class="line">php_stream_context *context</span><br><span class="line">STREAMS_DC TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span> (*stream_closer)(php_stream_wrapper *wrapper,</span><br><span class="line">php_stream *stream TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span> (*stream_stat)(php_stream_wrapper *wrapper,</span><br><span class="line">php_stream *stream,</span><br><span class="line">php_stream_statbuf *ssb</span><br><span class="line">TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span> (*url_stat)(php_stream_wrapper *wrapper,</span><br><span class="line"><span class="keyword">char</span> *url, <span class="keyword">int</span> flags,</span><br><span class="line">php_stream_statbuf *ssb,</span><br><span class="line">php_stream_context *context</span><br><span class="line">TSRMLS_DC);</span><br><span class="line">php_stream *(*dir_opener)(php_stream_wrapper *wrapper,</span><br><span class="line"><span class="keyword">char</span> *filename, <span class="keyword">char</span> *mode,</span><br><span class="line"><span class="keyword">int</span> options, <span class="keyword">char</span> **opened_path,</span><br><span class="line">php_stream_context *context</span><br><span class="line">STREAMS_DC TSRMLS_DC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *label;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*unlink)(php_stream_wrapper *wrapper, <span class="keyword">char</span> *url,</span><br><span class="line"><span class="keyword">int</span> options,</span><br><span class="line">php_stream_context *context</span><br><span class="line">TSRMLS_DC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*rename)(php_stream_wrapper *wrapper,</span><br><span class="line"><span class="keyword">char</span> *url_from, <span class="keyword">char</span> *url_to,</span><br><span class="line"><span class="keyword">int</span> options,</span><br><span class="line">php_stream_context *context</span><br><span class="line">TSRMLS_DC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*stream_mkdir)(php_stream_wrapper *wrapper,</span><br><span class="line"><span class="keyword">char</span> *url, <span class="keyword">int</span> mode, <span class="keyword">int</span> options,</span><br><span class="line">php_stream_context *context</span><br><span class="line">TSRMLS_DC);</span><br><span class="line"><span class="keyword">int</span> (*stream_rmdir)(php_stream_wrapper *wrapper, <span class="keyword">char</span> *url,</span><br><span class="line"><span class="keyword">int</span> options,</span><br><span class="line">php_stream_context *context</span><br><span class="line">TSRMLS_DC);</span><br><span class="line">&#125; php_stream_wrapper_ops;</span><br></pre></td></tr></table></figure><p></p><p>这里, 流包装层调用wrapper-&gt;ops-&gt;stream_opener(), 它将执行包装器特有的操作创建流实例, 赋值恰当的php_stream_ops结构体, 绑定相关的抽象数据.</p><p>dir_opener()函数和stream_opener()提供相同的基础服务; 不过, 它是对php_stream_opendir()这个API调用的响应, 并且通常会绑定一个不同的php_stream_ops结构体到返回的实例. stat()和close()函数在这一层上是重复的, 这样做是为了给包装器的这些操作增加协议特有的逻辑.</p><p>其他的函数则允许执行静态流操作而不用实际的创建流实例. 回顾这些流API调用, 它们并不实际返回php_stream对象, 你马上就会看到它们的细节.</p><blockquote><p>尽管在php 4.3中引入流包装层时, url_stat在内部作为一个包装器的ops函数存在, 但直到php 5.0它才开始被使用. 此外, 最后的3个函数, rename(), stream_mkdir()以及stream_rmdir()一直到php 5.0才引入, 在这个版本之前, 它们并不在包装器的ops结构中.</p></blockquote><h1 id="包装器操作"><a href="#包装器操作" class="headerlink" title="包装器操作"></a>包装器操作</h1><p>除了url_stat()函数, 包装器操作中在const char *label元素之前的每个操作都可以用于激活的流实例上. 每个函数的意义如下:</p><table><br><tr><br><td>stream_opener()</td><br><td><br>实例化一个流实例. 当某个用户空间的fopen()函数被调用时, 这个函数将被调用. 这个函数返回的php_stream实例是fopen()函数返回的文件资源句柄的内部表示. 集成函数比如file(), file_get_contents(), file_put_contents(), readfile()等等, 在请求包装资源时, 都使用这个包装器ops.<br></td><br></tr><br><tr><br><td>stream_closer()</td><br><td><br>当一个流实例结束其生命周期时这个函数被调用. stream_opener()时分配的所有资源都应该在这个函数中被释放.<br></td><br></tr><br><tr><br><td>stream_stat()</td><br><td><br>类似于用户空间的fstat()函数, 这个函数应该填充ssb结构体(实际上只包含一个struct statbuf sb结构体成员),<br></td><br></tr><br><tr><br><td>dir_opener()</td><br><td><br>和stream_opener()行为一致, 不过它是调用opendir()一族的用户空间函数时被调用的. 目录流使用的底层流实现和文件流遵循相同的规则;不过目录流只需要返回包含在打开的目录中找到的文件名的记录, 它的大小为struct dirent这个结构体的大小.<br></td><br></tr><br></table><h2 id="静态包装器操作"><a href="#静态包装器操作" class="headerlink" title="静态包装器操作"></a>静态包装器操作</h2><p>包装器操作函数中的其他函数是在URI路径上执行原子操作, 具体取决于包装器协议. 在php4.3的php_stream_wrapper_ops结构体中只有url_stat()和unlink(); 其他的方式是到php 5.0后才定义的, 编码时应该适时的使用#ifdef块说明.</p><table><br><tr><br><td>url_stat()</td><br><td><br>stat()族函数使用, 返回文件元数据, 比如访问授权, 大小, 类型; 以及访问, 修改,创建时间. 尽管这个函数是在php 4.3引入流包装层时出现在php_stream_wrapper_ops结构体中的, 但直到php 5.0才被用户空间的stat()函数使用.<br></td><br></tr><br><tr><br><td>unlink()</td><br><td><br>和posix文件系统的同名函数语义相同, 它执行文件删除. 如果对于当前的包装器删除没有意义, 比如内建的http://包装器, 这个函数应该被定义为NULL, 以便内核去引发适当的错误消息.<br></td><br></tr><br><tr><br><td>rename()</td><br><td><br>当用户空间的rename()函数的参数$from和$to参数指向的是相同的底层包装器实现, php则将这个重命名请求分发到包装器的rename函数.<br></td><br></tr><br><tr><br><td>mkdir() &amp; rmdir()</td><br><td><br>这两个函数直接映射到对应的用户空间函数.<br></td><br></tr><br></table><h1 id="实现一个包装器"><a href="#实现一个包装器" class="headerlink" title="实现一个包装器"></a>实现一个包装器</h1><p>为了演示包装器和流操作的内部工作原理, 我们需要重新实现php手册的stream_wrapper_register()一页示例中的var://包装器.</p><p>此刻, 首先从下面功能完整的变量流包装实现开始. 构建他, 并开始检查每一块的工作原理.</p><blockquote><p>译注: 为了方便大家阅读, 对代码的注释进行了适量补充调整, 此外, 由于phpapi的调整, 原著中的代码不能直接在译者使用的php-5.4.10中运行, 进行了适当的修改. 因此下面代码结构可能和原著略有不同, 请参考阅读.(下面opendir的例子也进行了相应的修改)</p></blockquote><h2 id="config-m4"><a href="#config-m4" class="headerlink" title="config.m4"></a>config.m4</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP_ARG_ENABLE(varstream,whether to enable varstream support,</span><br><span class="line">[  enable-varstream      Enable varstream support])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> test <span class="string">"$PHP_VARSTREAM"</span> = <span class="string">"yes"</span>; then</span><br><span class="line">  AC_DEFINE(HAVE_VARSTREAM,<span class="number">1</span>,[Whether you want varstream])</span><br><span class="line">  PHP_NEW_EXTENSION(varstream, varstream.c, $ext_shared)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="php-varstream-h"><a href="#php-varstream-h" class="headerlink" title="php_varstream.h"></a>php_varstream.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PHP_VARSTREAM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_VARSTREAM_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> zend_module_entry varstream_module_entry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> phpext_varstream_ptr &amp;varstream_module_entry</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PHP_WIN32</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PHP_VARSTREAM_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 4</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PHP_VARSTREAM_API __attribute__ ((visibility(<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PHP_VARSTREAM_API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TSRM.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(varstream);</span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(varstream);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_VARSTREAM_WRAPPER       <span class="meta-string">"var"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_VARSTREAM_STREAMTYPE    <span class="meta-string">"varstream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变量流的抽象数据结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">php_varstream_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">off_t</span>   <span class="built_in">position</span>;</span><br><span class="line">    <span class="keyword">char</span>    *varname;</span><br><span class="line">    <span class="keyword">int</span>     varname_len;</span><br><span class="line">&#125; php_varstream_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARSTREAM_G(v) TSRMG(varstream_globals_id, zend_varstream_globals *, v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARSTREAM_G(v) (varstream_globals.v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="varstream-c"><a href="#varstream-c" class="headerlink" title="varstream.c"></a>varstream.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php_ini.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ext/standard/info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ext/standard/url.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php_varstream.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">php_varstream_write</span><span class="params">(php_stream *stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_data *data = stream-&gt;abstract;</span><br><span class="line">    zval **var;</span><br><span class="line">    <span class="keyword">size_t</span> newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找变量 */</span></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(&amp;EG(symbol_table), data-&gt;varname,</span><br><span class="line">            data-&gt;varname_len + <span class="number">1</span>,(<span class="keyword">void</span>**)&amp;var) == FAILURE) &#123;</span><br><span class="line">        <span class="comment">/* 变量不存在, 直接创建一个字符串类型的变量, 并保存新传递进来的内容 */</span></span><br><span class="line">       zval *newval;</span><br><span class="line">       MAKE_STD_ZVAL(newval);</span><br><span class="line">       ZVAL_STRINGL(newval, buf, count, <span class="number">1</span>);</span><br><span class="line">       <span class="comment">/* 将新的zval *放到变量中 */</span></span><br><span class="line">       zend_hash_add(&amp;EG(symbol_table), data-&gt;varname,</span><br><span class="line">           data-&gt;varname_len + <span class="number">1</span>, (<span class="keyword">void</span>*)&amp;newval,</span><br><span class="line">           <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/* 如果需要, 让变量可写. 这里实际上处理的是写时复制 */</span></span><br><span class="line">    SEPARATE_ZVAL_IF_NOT_REF(var);</span><br><span class="line">    <span class="comment">/* 转换为字符串类型 */</span></span><br><span class="line">    convert_to_string_ex(var);</span><br><span class="line">    <span class="comment">/* 重置偏移量(译注: 相比于正常的文件系统, 这里的处理实际上不支持文件末尾的空洞创建, 读者如果熟悉*nix文件系统, 应该了解译者所说, 否则请略过) */</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;<span class="built_in">position</span> &gt; Z_STRLEN_PP(var)) &#123;</span><br><span class="line">        data-&gt;<span class="built_in">position</span> = Z_STRLEN_PP(var);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/* 计算新的字符串长度 */</span></span><br><span class="line">    newlen = data-&gt;<span class="built_in">position</span> + count;</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; Z_STRLEN_PP(var)) &#123;</span><br><span class="line">        <span class="comment">/* 总长度不变 */</span></span><br><span class="line">        newlen = Z_STRLEN_PP(var);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newlen &gt; Z_STRLEN_PP(var)) &#123;</span><br><span class="line">        <span class="comment">/* 重新调整缓冲区大小以保存新内容 */</span></span><br><span class="line">        Z_STRVAL_PP(var) =erealloc(Z_STRVAL_PP(var),newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 更新字符串长度 */</span></span><br><span class="line">        Z_STRLEN_PP(var) = newlen;</span><br><span class="line">        <span class="comment">/* 确保字符串NULL终止 */</span></span><br><span class="line">        Z_STRVAL_PP(var)[newlen] = <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/* 将数据写入到变量中 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Z_STRVAL_PP(var) + data-&gt;<span class="built_in">position</span>, buf, count);</span><br><span class="line">    data-&gt;<span class="built_in">position</span> += count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">php_varstream_read</span><span class="params">(php_stream *stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_data *data = stream-&gt;abstract;</span><br><span class="line">    zval **var, copyval;</span><br><span class="line">    <span class="keyword">int</span> got_copied = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> toread = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(&amp;EG(symbol_table), data-&gt;varname,</span><br><span class="line">        data-&gt;varname_len + <span class="number">1</span>, (<span class="keyword">void</span>**)&amp;var) == FAILURE) &#123;</span><br><span class="line">        <span class="comment">/* 变量不存在, 读不到数据, 返回0字节长度 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    copyval = **var;</span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE(copyval) != IS_STRING) &#123;</span><br><span class="line">        <span class="comment">/* 对于非字符串类型变量, 创建一个副本进行读, 这样对于只读的变量, 就不会改变其原始类型 */</span></span><br><span class="line">        zval_copy_ctor(&amp;copyval);</span><br><span class="line">        INIT_PZVAL(&amp;copyval);</span><br><span class="line">        got_copied = <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (data-&gt;<span class="built_in">position</span> &gt; Z_STRLEN(copyval)) &#123;</span><br><span class="line">        data-&gt;<span class="built_in">position</span> = Z_STRLEN(copyval);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> ((Z_STRLEN(copyval) - data-&gt;<span class="built_in">position</span>) &lt; toread) &#123;</span><br><span class="line">        <span class="comment">/* 防止读取到变量可用缓冲区外的内容 */</span></span><br><span class="line">        toread = Z_STRLEN(copyval) - data-&gt;<span class="built_in">position</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/* 设置缓冲区 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf, Z_STRVAL(copyval) + data-&gt;<span class="built_in">position</span>, toread);</span><br><span class="line">    data-&gt;<span class="built_in">position</span> += toread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果创建了副本, 则释放副本 */</span></span><br><span class="line">    <span class="keyword">if</span> (got_copied) &#123;</span><br><span class="line">        zval_dtor(&amp;copyval);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回设置到缓冲区的字节数 */</span></span><br><span class="line">    <span class="keyword">return</span> toread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_closer</span><span class="params">(php_stream *stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> close_handle TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_data *data = stream-&gt;abstract;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放内部结构避免泄露 */</span></span><br><span class="line">    efree(data-&gt;varname);</span><br><span class="line">    efree(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_flush</span><span class="params">(php_stream *stream TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_data *data = stream-&gt;abstract;</span><br><span class="line">    zval **var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据不同情况, 重置偏移量 */</span></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(&amp;EG(symbol_table), data-&gt;varname,</span><br><span class="line">                    data-&gt;varname_len + <span class="number">1</span>, (<span class="keyword">void</span>**)&amp;var)</span><br><span class="line">                    == SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Z_TYPE_PP(var) == IS_STRING) &#123;</span><br><span class="line">            data-&gt;<span class="built_in">position</span> = Z_STRLEN_PP(var);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zval copyval = **var;</span><br><span class="line">            zval_copy_ctor(&amp;copyval);</span><br><span class="line">            convert_to_string(&amp;copyval);</span><br><span class="line">            data-&gt;<span class="built_in">position</span> = Z_STRLEN(copyval);</span><br><span class="line">            zval_dtor(&amp;copyval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data-&gt;<span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_seek</span><span class="params">(php_stream *stream, <span class="keyword">off_t</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> whence, <span class="keyword">off_t</span> *newoffset TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_data *data = stream-&gt;abstract;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (whence) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEEK_SET:</span><br><span class="line">            data-&gt;<span class="built_in">position</span> = offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">            data-&gt;<span class="built_in">position</span> += offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEEK_END:</span><br><span class="line">        &#123;</span><br><span class="line">            zval **var;</span><br><span class="line">           <span class="keyword">size_t</span> curlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (zend_hash_find(&amp;EG(symbol_table),</span><br><span class="line">                   data-&gt;varname,    data-&gt;varname_len + <span class="number">1</span>,</span><br><span class="line">                   (<span class="keyword">void</span>**)&amp;var) == SUCCESS) &#123;</span><br><span class="line">              <span class="keyword">if</span> (Z_TYPE_PP(var) == IS_STRING) &#123;</span><br><span class="line">                  curlen = Z_STRLEN_PP(var);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  zval copyval = **var;</span><br><span class="line">                  zval_copy_ctor(&amp;copyval);</span><br><span class="line">                  convert_to_string(&amp;copyval);</span><br><span class="line">                  curlen = Z_STRLEN(copyval);</span><br><span class="line">                  zval_dtor(&amp;copyval);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           data-&gt;<span class="built_in">position</span> = curlen + offset;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 防止随机访问指针移动到缓冲区开始位置之前 */</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;<span class="built_in">position</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        data-&gt;<span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newoffset) &#123;</span><br><span class="line">        *newoffset = data-&gt;<span class="built_in">position</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> php_stream_ops php_varstream_ops = &#123;</span><br><span class="line">    php_varstream_write,</span><br><span class="line">    php_varstream_read,</span><br><span class="line">    php_varstream_closer,</span><br><span class="line">    php_varstream_flush,</span><br><span class="line">    PHP_VARSTREAM_STREAMTYPE,</span><br><span class="line">    php_varstream_seek,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* cast */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* stat */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* set_option */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define the wrapper operations */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> php_stream *<span class="title">php_varstream_opener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            php_stream_wrapper *wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> *filename, <span class="keyword">char</span> *mode, <span class="keyword">int</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> **opened_path, php_stream_context *context</span></span></span><br><span class="line"><span class="function"><span class="params">            STREAMS_DC TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_data *data;</span><br><span class="line">    php_url *url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options &amp; STREAM_OPEN_PERSISTENT) &#123;</span><br><span class="line">        <span class="comment">/* 按照变量流的定义, 是不能持久化的</span></span><br><span class="line"><span class="comment">         * 因为变量在请求结束后将被释放</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"Unable to open %s persistently"</span>,</span><br><span class="line">                                        filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 标准URL解析: scheme://user:pass@host:port/path?query#fragment */</span></span><br><span class="line">    url = php_url_parse(filename);</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"Unexpected error parsing URL"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检查是否有变量流URL必须的元素host, 以及scheme是否是var */</span></span><br><span class="line">    <span class="keyword">if</span> (!url-&gt;host || (url-&gt;host[<span class="number">0</span>] == <span class="number">0</span>) ||</span><br><span class="line">        strcasecmp(<span class="string">"var"</span>, url-&gt;scheme) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Bad URL or wrong wrapper */</span></span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"Invalid URL, must be in the form: "</span></span><br><span class="line">                     <span class="string">"var://variablename"</span>);</span><br><span class="line">        php_url_free(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个数据结构保存协议信息(变量流协议重要是变量名, 变量名长度, 当前偏移量) */</span></span><br><span class="line">    data = emalloc(<span class="keyword">sizeof</span>(php_varstream_data));</span><br><span class="line">    data-&gt;<span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    data-&gt;varname_len = <span class="built_in">strlen</span>(url-&gt;host);</span><br><span class="line">    data-&gt;varname = estrndup(url-&gt;host, data-&gt;varname_len + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 释放前面解析出来的url占用的内存 */</span></span><br><span class="line">    php_url_free(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例化一个流, 为其赋予恰当的流ops, 绑定抽象数据 */</span></span><br><span class="line">    <span class="keyword">return</span> php_stream_alloc(&amp;php_varstream_ops, data, <span class="number">0</span>, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> php_stream_wrapper_ops php_varstream_wrapper_ops = &#123;</span><br><span class="line">    php_varstream_opener, <span class="comment">/* 调用php_stream_open_wrapper(sprintf("%s://xxx", PHP_VARSTREAM_WRAPPER))时执行 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* stream_close */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* stream_stat */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* url_stat */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* dir_opener */</span></span><br><span class="line">    PHP_VARSTREAM_WRAPPER,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* unlink */</span></span><br><span class="line">#<span class="keyword">if</span> PHP_MAJOR_VERSION &gt;= <span class="number">5</span></span><br><span class="line">    <span class="comment">/* PHP &gt;= 5.0 only */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* rename */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* mkdir */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* rmdir */</span></span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> php_stream_wrapper php_varstream_wrapper = &#123;</span><br><span class="line">    &amp;php_varstream_wrapper_ops,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* abstract */</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">/* is_url */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(varstream)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 注册流包装器:</span></span><br><span class="line"><span class="comment">     * 1. 检查流包装器名字是否正确(符合这个正则: /^[a-zA-Z0-9+.-]+$/)</span></span><br><span class="line"><span class="comment">     * 2. 将传入的php_varstream_wrapper增加到url_stream_wrappers_hash这个HashTable中, key为PHP_VARSTREAM_WRAPPER</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (php_register_url_stream_wrapper(PHP_VARSTREAM_WRAPPER,</span><br><span class="line">            &amp;php_varstream_wrapper TSRMLS_CC)==FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(varstream)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 卸载流包装器: 从url_stream_wrappers_hash中删除 */</span></span><br><span class="line">    <span class="keyword">if</span> (php_unregister_url_stream_wrapper(PHP_VARSTREAM_WRAPPER</span><br><span class="line">                                TSRMLS_CC) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zend_module_entry varstream_module_entry = &#123;</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">#endif</span><br><span class="line">    <span class="string">"varstream"</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    PHP_MINIT(varstream),</span><br><span class="line">    PHP_MSHUTDOWN(varstream),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    <span class="string">"0.1"</span>,</span><br><span class="line">#endif</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_DL_VARSTREAM</span></span><br><span class="line">ZEND_GET_MODULE(varstream)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在构建加载扩展后, php就可以处理以var://开始的URL的请求, 它的行为和手册中用户空间实现的行为一致.</p><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>首先你注意到的可能是这个扩展完全没有暴露用户空间函数. 它所做的只是在MINIT函数中调用了一个核心PHPAPI的钩子, 将var协议和我们定义的包装器关联起来:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> php_stream_wrapper php_varstream_wrapper = &#123;</span><br><span class="line">    &amp;php_varstream_wrapper_ops,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* abstract */</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">/* is_url */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>很明显, 最重要的元素就是ops, 它提供了访问特定流包装器的创建以及检查函数. 你可以安全的忽略abstract属性, 它仅在运行时使用, 在初始化定义时, 它只是作为一个占位符. 第三个元素is_url, 它告诉php在使用这个包装器时是否考虑php.ini中的allow_url_fopen选项. 如果这个值非0, 并且将allow_url_fopen设置为false, 则这个包装器不能被脚本使用.</p><p>在本章前面你已经知道, 调用用户空间函数比如fopen将通过这个包装器的ops元素得到php_varstream_wrapper_ops, 这样去调用流的打开函数php_varstream_opener.</p><p>这个函数的第一块代码检查是否请求持久化的流:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options &amp; STREAM_OPEN_PERSISTENT) &#123;</span><br></pre></td></tr></table></figure><p></p><p>对于很多包装器这样的请求是合法的. 然而目前的情况这个行为没有意义. 一方面用户空间变量的定义就是临时的, 另一方面, varstream的实例化代价很低, 这就使得持久化的优势很小.</p><p>像流包装层报告错误很简单, 只需要返回一个NULL值而不是流实例即可. 流包装层透出到用户空间的失败消息并不会说明具体的错误, 只是说明不能打开URL. 要想给开发者暴露更多的错误信息, 可以在返回之前使用php_stream_wrapper_log_error()函数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">    TSRMLS_CC, <span class="string">"Unable to open %s persistently"</span>,</span><br><span class="line">                                filename);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h2><p>实例化varstream的下一步需要一个人类可读的URL, 将它分块放入到一个易管理的结构体中. 幸运的是它使用了和用户空间url_parse()函数相同的机制. 如果URL成功解析, 将会分配一个php_url结构体并设置合适的值. 如果在URL中没有某些值, 在返回的php_url中对应的将被设置为NULL. 这个结构体必须在离开php_varstream_opener函数之前被显式释放, 否则它的内存将会泄露:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">php_url</span> &#123;</span></span><br><span class="line">    <span class="comment">/* scheme://user:pass@host:port/path?query#fragment */</span></span><br><span class="line">    <span class="keyword">char</span> *scheme;</span><br><span class="line">    <span class="keyword">char</span> *user;</span><br><span class="line">    <span class="keyword">char</span> *pass;</span><br><span class="line">    <span class="keyword">char</span> *host;</span><br><span class="line">    <span class="keyword">unsigned</span> short port;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">char</span> *query;</span><br><span class="line">    <span class="keyword">char</span> *fragment;</span><br><span class="line">&#125; php_url;</span><br></pre></td></tr></table></figure><p>最后, varstream包装器创建了一个数据结构, 保存了流指向的变量名, 读取时的当前位置. 这个结构体将在流的读取和写入函数中用于获取变量, 并且将在流结束使用时由php_varstream_close函数释放.</p><h2 id="opendir"><a href="#opendir" class="headerlink" title="opendir()"></a>opendir()</h2><p>读写变量内容的实现可以再次进行扩展. 这里可以加入一个新的特性, 允许使用目录函数读取数组中的key. 在你的php_varstream_wrapper_ops结构体之前增加下面的代码:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">php_varstream_readdir</span><span class="params">(php_stream *stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_stream_dirent *ent = (php_stream_dirent*)buf;</span><br><span class="line">    php_varstream_dirdata *data = stream-&gt;abstract;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">int</span> type, key_len;</span><br><span class="line">    <span class="keyword">long</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找数组中的key */</span></span><br><span class="line">    type = zend_hash_get_current_key_ex(Z_ARRVAL_P(data-&gt;arr),</span><br><span class="line">                    &amp;key, &amp;key_len, &amp;idx, <span class="number">0</span>, &amp;(data-&gt;pos));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符串key */</span></span><br><span class="line">    <span class="keyword">if</span> (type == HASH_KEY_IS_STRING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key_len &gt;= <span class="keyword">sizeof</span>(ent-&gt;d_name)) &#123;</span><br><span class="line">            <span class="comment">/* truncate long keys to maximum length */</span></span><br><span class="line">            key_len = <span class="keyword">sizeof</span>(ent-&gt;d_name) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 设置到目录结构上 */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(ent-&gt;d_name, key, key_len);</span><br><span class="line">        ent-&gt;d_name[key_len] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 数值key */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == HASH_KEY_IS_LONG) &#123;</span><br><span class="line">        <span class="comment">/* 设置到目录结构上 */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(ent-&gt;d_name, <span class="keyword">sizeof</span>(ent-&gt;d_name), <span class="string">"%ld"</span>,idx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 迭代结束 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 移动数组指针(位置记录到流的抽象结构中) */</span></span><br><span class="line">    zend_hash_move_forward_ex(Z_ARRVAL_P(data-&gt;arr),</span><br><span class="line">                                        &amp;data-&gt;pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(php_stream_dirent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_closedir</span><span class="params">(php_stream *stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> close_handle TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_dirdata *data = stream-&gt;abstract;</span><br><span class="line"></span><br><span class="line">    zval_ptr_dtor(&amp;(data-&gt;arr));</span><br><span class="line">    efree(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_dirseek</span><span class="params">(php_stream *stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">off_t</span> *newoffset TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_dirdata *data = stream-&gt;abstract;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (whence == SEEK_SET &amp;&amp; offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 重置数组指针 */</span></span><br><span class="line">        zend_hash_internal_pointer_reset_ex(</span><br><span class="line">                    Z_ARRVAL_P(data-&gt;arr), &amp;(data-&gt;pos));</span><br><span class="line">        <span class="keyword">if</span> (newoffset) &#123;</span><br><span class="line">            *newoffset = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 不支持其他类型的随机访问 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> php_stream_ops php_varstream_dirops = &#123;</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* write */</span></span><br><span class="line">    php_varstream_readdir,</span><br><span class="line">    php_varstream_closedir,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* flush */</span></span><br><span class="line">    PHP_VARSTREAM_DIRSTREAMTYPE,</span><br><span class="line">    php_varstream_dirseek,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* cast */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* stat */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* set_option */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> php_stream *<span class="title">php_varstream_opendir</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            php_stream_wrapper *wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> *filename, <span class="keyword">char</span> *mode, <span class="keyword">int</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span> **opened_path, php_stream_context *context</span></span></span><br><span class="line"><span class="function"><span class="params">            STREAMS_DC TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_varstream_dirdata *data;</span><br><span class="line">    php_url *url;</span><br><span class="line">    zval **var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不支持持久化流 */</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp; STREAM_OPEN_PERSISTENT) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">                TSRMLS_CC, <span class="string">"Unable to open %s persistently"</span>,</span><br><span class="line">                filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析URL */</span></span><br><span class="line">    url = php_url_parse(filename);</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">                TSRMLS_CC, <span class="string">"Unexpected error parsing URL"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检查请求URL的正确性 */</span></span><br><span class="line">    <span class="keyword">if</span> (!url-&gt;host || (url-&gt;host[<span class="number">0</span>] == <span class="number">0</span>) ||</span><br><span class="line">            strcasecmp(<span class="string">"var"</span>, url-&gt;scheme) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Bad URL or wrong wrapper */</span></span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">                TSRMLS_CC, <span class="string">"Invalid URL, must be in the form: "</span></span><br><span class="line">                <span class="string">"var://variablename"</span>);</span><br><span class="line">        php_url_free(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找变量 */</span></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(&amp;EG(symbol_table), url-&gt;host,</span><br><span class="line">                <span class="built_in">strlen</span>(url-&gt;host) + <span class="number">1</span>, (<span class="keyword">void</span>**)&amp;var) == FAILURE) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">                TSRMLS_CC, <span class="string">"Variable $%s not found"</span>, url-&gt;host);</span><br><span class="line">        php_url_free(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查变量类型 */</span></span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE_PP(var) != IS_ARRAY) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">                TSRMLS_CC, <span class="string">"$%s is not an array"</span>, url-&gt;host);</span><br><span class="line">        php_url_free(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 释放前面分配的URL结构 */</span></span><br><span class="line">    php_url_free(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配抽象数据结构 */</span></span><br><span class="line">    data = emalloc(<span class="keyword">sizeof</span>(php_varstream_dirdata));</span><br><span class="line">    <span class="keyword">if</span> ( Z_ISREF_PP(var) &amp;&amp; Z_REFCOUNT_PP(var) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 全拷贝 */</span></span><br><span class="line">        MAKE_STD_ZVAL(data-&gt;arr);</span><br><span class="line">        *(data-&gt;arr) = **var;</span><br><span class="line">        zval_copy_ctor(data-&gt;arr);</span><br><span class="line">        INIT_PZVAL(data-&gt;arr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 写时拷贝 */</span></span><br><span class="line">        data-&gt;arr = *var;</span><br><span class="line">        Z_SET_REFCOUNT_P(data-&gt;arr, Z_REFCOUNT_P(data-&gt;arr) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 重置数组指针 */</span></span><br><span class="line">    zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(data-&gt;arr),</span><br><span class="line">            &amp;data-&gt;pos);</span><br><span class="line">    <span class="keyword">return</span> php_stream_alloc(&amp;php_varstream_dirops,data,<span class="number">0</span>,mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在, 将你的php_varstream_wrapper_ops结构体中的dir_opener的NULL替换成你的php_varstream_opendir函数. 最后, 将下面新定义的类型放入到你的php_varstream.h文件的php_varstream_data定义下面:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_VARSTREAM_DIRSTREAMTYPE    <span class="meta-string">"varstream directory"</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">php_varstream_dirdata</span> &#123;</span></span><br><span class="line">    zval *arr;</span><br><span class="line">    HashPosition pos;</span><br><span class="line">&#125; php_varstream_dirdata;</span><br></pre></td></tr></table></figure><p></p><p>在你基于fopen()实现的varstream包装器中, 你直接使用持久变量名, 每次执行读写操作时从符号表中获取变量. 而这里, opendir()的实现中获取变量时处理了变量不存在或者类型错误的异常. 你还有一个数组变量的拷贝, 这就说明原数组的改变并不会影响后续的readdir()调用的结果. 原来存储变量名的方式也可以正常工作, 这里只是给出另外一种选择作为演示示例.</p><p>由于目录访问是基于成块的目录条目, 而不是字符, 因此这里需要一套独立的流操作. 这个版本中, write没有意义, 因此保持它为NULL. read的实现使用zend_hash_get_current_key_ex()函数将数组映射到目录名. 而随机访问也只是对SEEK_SET有效, 用来响应rewinddir()跳转到数组开始位置.</p><blockquote><p>实际上, 目录流并没有使用SEEK_CUR, SEEK_END, 或者除了0之外的偏移量. 在实现目录流操作时, 最好还是涉及你的函数能以某种方式处理这些情况, 以使得在流包装层变化时能够适应其目录随机访问.</p></blockquote><h1 id="操纵"><a href="#操纵" class="headerlink" title="操纵"></a>操纵</h1><p>5个静态包装器操作中的4个用来处理不是基于I/O的流资源操作. 你已经看到过它们并了解它们的原型; 现在我们看看varstream包装器框架中它们的实现:</p><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>在你的wrapper_ops结构体中增加下面的函数, 它可以让unlink()通过varstream包装器, 拥有和unset()一样的行为:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_unlink</span><span class="params">(php_stream_wrapper *wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">char</span> *filename, <span class="keyword">int</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                        php_stream_context *context</span></span></span><br><span class="line"><span class="function"><span class="params">                        TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;               </span><br><span class="line">    php_url *url;   </span><br><span class="line"></span><br><span class="line">    url = php_url_parse(filename);</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;         </span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"Unexpected error parsing URL"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">if</span> (!url-&gt;host || (url-&gt;host[<span class="number">0</span>] == <span class="number">0</span>) ||</span><br><span class="line">        strcasecmp(<span class="string">"var"</span>, url-&gt;scheme) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* URL不合法 */</span></span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"Invalid URL, must be in the form: "</span></span><br><span class="line">                     <span class="string">"var://variablename"</span>);</span><br><span class="line">        php_url_free(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从符号表删除变量 */</span></span><br><span class="line">    <span class="comment">//zend_hash_del(&amp;EG(symbol_table), url-&gt;host, strlen(url-&gt;host) + 1);</span></span><br><span class="line">    zend_delete_global_variable(url-&gt;host, <span class="built_in">strlen</span>(url-&gt;host) + <span class="number">1</span> TSRMLS_CC);</span><br><span class="line"></span><br><span class="line">    php_url_free(url);                                      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个函数的编码量和php_varstream_opener差不多. 唯一的不同在于这里你需要传递变量名给zend_hash_del()去删除变量.</p><blockquote><p>译注: 译者的php-5.4.10环境中, 使用unlink()删除变量后, 在用户空间再次读取该变量名的值会导致core dump. 因此上面代码中译者进行了修正, 删除变量时使用了zend_delete_global_variable(), 请读者参考阅读zend_delete_global_variable()函数源代码, 考虑为什么直接用zend_hash_del()删除, 会导致core dump. 下面是译者测试用的用户空间代码:</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$fp = fopen(<span class="string">'var://hello'</span>, <span class="string">'r'</span>);</span><br><span class="line">fwrite($fp, <span class="string">'world'</span>);</span><br><span class="line">var_dump($hello);</span><br><span class="line">unlink(<span class="string">'var://hello'</span>);</span><br><span class="line">$a  = $hello;</span><br></pre></td></tr></table></figure><p>这个函数的代码量应该和php_varstream_opener差不多. 唯一的不同是这里是传递变量名给zend_hash_del()去删除变量.</p><h2 id="rename-mkdir-rmdir"><a href="#rename-mkdir-rmdir" class="headerlink" title="rename, mkdir, rmdir"></a>rename, mkdir, rmdir</h2><p>为了一致性, 下面给出rename, mkdir, rmdir函数的实现:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_rename</span><span class="params">(php_stream_wrapper *wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">char</span> *url_from, <span class="keyword">char</span> *url_to, <span class="keyword">int</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">        php_stream_context *context TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_url *from, *to;</span><br><span class="line">    zval **var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 来源URL解析 */</span></span><br><span class="line">    from = php_url_parse(url_from);</span><br><span class="line">    <span class="keyword">if</span> (!from) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"Unexpected error parsing source"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 查找变量 */</span></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(&amp;EG(symbol_table), from-&gt;host,</span><br><span class="line">                <span class="built_in">strlen</span>(from-&gt;host) + <span class="number">1</span>,</span><br><span class="line">                (<span class="keyword">void</span>**)&amp;var) == FAILURE) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"$%s does not exist"</span>, from-&gt;host);</span><br><span class="line">        php_url_free(from);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 目标URL解析 */</span></span><br><span class="line">    to = php_url_parse(url_to);</span><br><span class="line">    <span class="keyword">if</span> (!to) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"Unexpected error parsing dest"</span>);</span><br><span class="line">        php_url_free(from);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 变量的改名 */</span></span><br><span class="line">    Z_SET_REFCOUNT_PP(var, Z_REFCOUNT_PP(var) + <span class="number">1</span>);</span><br><span class="line">    zend_hash_update(&amp;EG(symbol_table), to-&gt;host,</span><br><span class="line">                <span class="built_in">strlen</span>(to-&gt;host) + <span class="number">1</span>, (<span class="keyword">void</span>*)var,</span><br><span class="line">                <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">    zend_hash_del(&amp;EG(symbol_table), from-&gt;host,</span><br><span class="line">                <span class="built_in">strlen</span>(from-&gt;host) + <span class="number">1</span>);</span><br><span class="line">    php_url_free(from);</span><br><span class="line">    php_url_free(to);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_mkdir</span><span class="params">(php_stream_wrapper *wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *url_from, <span class="keyword">int</span> mode, <span class="keyword">int</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                php_stream_context *context TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_url *url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* URL解析 */</span></span><br><span class="line">    url = php_url_parse(url_from);</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">       php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">           TSRMLS_CC, <span class="string">"Unexpected error parsing URL"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查变量是否存在 */</span></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_exists(&amp;EG(symbol_table), url-&gt;host,</span><br><span class="line">                    <span class="built_in">strlen</span>(url-&gt;host) + <span class="number">1</span>)) &#123;</span><br><span class="line">        php_stream_wrapper_log_error(wrapper, options</span><br><span class="line">            TSRMLS_CC, <span class="string">"$%s already exists"</span>, url-&gt;host);</span><br><span class="line">        php_url_free(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* EG(uninitialized_zval_ptr)通常是IS_NULL的zval *, 引用计数无限大 */</span></span><br><span class="line">    zend_hash_add(&amp;EG(symbol_table), url-&gt;host,</span><br><span class="line">            <span class="built_in">strlen</span>(url-&gt;host) + <span class="number">1</span>,</span><br><span class="line">            (<span class="keyword">void</span>*)&amp;EG(uninitialized_zval_ptr),</span><br><span class="line">            <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">    php_url_free(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_varstream_rmdir</span><span class="params">(php_stream_wrapper *wrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">char</span> *url, <span class="keyword">int</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                php_stream_context *context TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 行为等价于unlink() */</span></span><br><span class="line">    wrapper-&gt;wops-&gt;unlink(wrapper, url, options,</span><br><span class="line">                                context TSRMLS_CC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h1><p>并不是所有的流操作都涉及到资源的操纵. 有时候也需要查看活动的流在某个时刻的状态, 或检查潜在可打开的资源的状态.</p><p>这一节流和包装器的ops函数都是在相同的数据结构php_stream_statbuf上工作的, 它只有一个元素: posix标准的struct statbuf. 当本节的某个函数被调用时, 将尝试填充尽可能多的statbuf元素的成员.</p><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>如果设置, 当请求激活流实例的信息时, 将会调用wrapper-&gt;ops-&gt;stream_stat(). 如果没有设置, 则对应的stream-&gt;ops-&gt;stat()将会被调用. 无论哪个函数被调用, 都应该尽可能多的向返回的statbuf结构体ssb-&gt;sb中填充尽可能多流实例的有用信息. 在普通文件I/O的用法中, 它对应fstat()的标准I/O调用.</p><h2 id="url-stat"><a href="#url-stat" class="headerlink" title="url_stat"></a>url_stat</h2><p>在流实例外部调用wrapper-&gt;ops-&gt;url_stat()取到流资源的元数据. 通常来说, 符号链接和重定向都应该被解析, 直到找到一个真正的资源, 对其通过stat()系统调用这样的机制读取统计信息. url_stat的flags参数允许是下面PHP_STREAM_URL_STAT_*系列的常量值(省略PHP_STREAM_URL_STAT_前缀):</p><table><br><tr><br><td>LINK</td><br><td><br>不解析符号链接和重定向. 而是报告它碰到的第一个节点的信息, 无论是连接还是真正的资源.<br></td><br></tr><br><tr><br><td>QUIET</td><br><td><br>不报告错误. 注意, 这和许多其他流函数中的REPORT_ERRORS逻辑恰恰相反.<br></td><br></tr><br></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>无论是暴露远程网络I/O还是本地数据源的流资源, 都允许你的扩展在核心数据上挂在操纵函数的钩子, 避免重新实现单调的描述符管理和I/O缓冲区工作. 这使得它在用户空间环境中更加有用, 更加强大.</p><p>下一章将通过对过滤器和上下文的学习结束流包装层的学习, 过滤器和上下文可以用于选择默认的流行为, 甚至过程中修改数据.</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14 流式访问</title>
      <link href="/posts/75d2edec.html"/>
      <url>/posts/75d2edec.html</url>
      
        <content type="html"><![CDATA[<h1 id="14-流式访问"><a href="#14-流式访问" class="headerlink" title="14 流式访问"></a>14 流式访问</h1><p>PHP用户空间中所有的文件I/O处理都是通过php 4.3引入的php流包装层处理的。在内部，扩展代码可以选择使用stdio或posix文件处理和本地文件系统或伯克利域套接字进行通信，或者也可以调用和用户空间流I/O相同的API。</p><h1 id="14-1-流的概览"><a href="#14-1-流的概览" class="headerlink" title="14.1 流的概览"></a>14.1 流的概览</h1><p>通常, 直接的文件描述符相比调用流包装层消耗更少的CPU和内存; 然而, 这样会将实现某个特定协议的所有工作都堆积到作为扩展开发者的你身上. 通过挂钩到流包装层, 你的扩展代码可以透明的使用各种内建的流包装, 比如HTTP, FTP, 以及它们对应的SSL版本, 另外还有gzip和bzip2压缩包装. 通过include特定的PEAR或PECL模块, 你的代码还可以访问其他协议, 比如SSH2, WebDav, 甚至是Gopher!</p><p>本章将介绍内部基于流工作的基础API. 后面到第16章”有趣的流”中, 我们将看到诸如应用过滤器, 使用上下文选项和参数等高级概念.</p><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>尽管是一个统一的API, 但实际上依赖于所需的流的类型, 有四种不同的路径去打开一个流. 从用户空间角度来看, 这四种不同的类别如下(函数列表只代表示例, 不是完整列表):</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* fopen包装</span></span><br><span class="line"><span class="comment">* 操作文件/URI方式指定远程文件类资源 */</span></span><br><span class="line">$fp = fopen($url, $mode);</span><br><span class="line">$data = file_get_contents($url);</span><br><span class="line">file_put_contents($url, $data);</span><br><span class="line">$lines = file($url);</span><br><span class="line"><span class="comment">/* 传输</span></span><br><span class="line"><span class="comment">* 基于套接字的顺序I/O */</span></span><br><span class="line">$fp = fsockopen($host, $port);</span><br><span class="line">$fp = stream_socket_client($uri);</span><br><span class="line">$fp = stream_socket_server($uri, $options);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录流 */</span></span><br><span class="line">$dir = opendir($url);</span><br><span class="line">$files = scandir($url);</span><br><span class="line">$obj = dir($url);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* "特殊"的流 */</span></span><br><span class="line">$fp = tmpfile();</span><br><span class="line">$fp = popen($cmd);</span><br><span class="line">proc_open($cmd, $pipes);</span><br></pre></td></tr></table></figure><p>无论你打开的是什么类型的流, 它们都存储在一个公共的结构体php_stream中.</p><h2 id="fopen包装"><a href="#fopen包装" class="headerlink" title="fopen包装"></a>fopen包装</h2><p>我们首先从实现fopen()函数开始. 现在你应该已经对创建扩展骨架很熟悉了, 如果还不熟悉, 请回到第5章”你的第一个扩展”复习一下, 下面是我们实现的fopen()函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample5_fopen)</span><br><span class="line">&#123;</span><br><span class="line">    php_stream *stream;</span><br><span class="line">    <span class="keyword">char</span> *path, *mode;</span><br><span class="line">    <span class="keyword">int</span> path_len, mode_len;</span><br><span class="line">    <span class="keyword">int</span> options = ENFORCE_SAFE_MODE | REPORT_ERRORS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"ss"</span>,</span><br><span class="line">        &amp;path, &amp;path_len, &amp;mode, &amp;mode_len) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stream = php_stream_open_wrapper(path, mode, options, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    php_stream_to_zval(stream, return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>php_stream_open_wrapper()的目的应该是完全绕过底层. path指定要读写文件名或URL, 读写行为依赖于mode的值.</p><p>options是位域的标记值集合, 这里是设置为下面介绍的一组固定值:</p><table><br><tr><br><td>USE_PATH</td><br><td>将php.ini文件中的include_path应用到相对路径上. 内建函数fopen()在指定第三个参数为TRUE时将会设置这个选项.</td><br></tr><br><tr><br><td>STREAM_USE_URL</td><br><br><td>设置这个选项后, 将只能打开远端URL. 对于php://, file://, zlib://, bzip2://这些URL包装器并不认为它们是远端URL.</td></tr><br><br><tr><td>ENFORCE_SAFE_MODE</td><br><br><td>尽管这个常量这样命名, 但实际上设置这个选项后仅仅是启用了安全模式(php.ini文件中的safe_mode指令)的强制检查. 如果没有设置这个选项将导致跳过safe_mode的检查(不论INI设置中safe_mode如何设置)</td></tr><br><br><br><tr><td>REPORT_ERRORS</td><br><br><td>在指定的资源打开过程中碰到错误时, 如果设置了这个选项则将产生错误报告.</td></tr><br><br><tr><td>STREAM_MUST_SEEK</td><br><br><td>对于某些流, 比如套接字, 是不可以seek的(随机访问); 这类文件句柄, 只有在特定情况下才可以seek. 如果调用作用域指定这个选项, 并且包装器检测到它不能保证可以seek, 将会拒绝打开这个流.</td></tr><br><br><tr><td>STREAM_WILL_CAST</td><br><br><td>如果调用作用域要求流可以被转换到stdio或posix文件描述符, 则应该给open_wrapper函数传递这个选项, 以保证在I/O操作发生之前就失败</td></tr><br><br><tr><td>STREAM_ONLY_GET_HEADERS</td><br><td>标识只需要从流中请求元数据. 实际上这是用于http包装器, 获取http_response_headers全局变量而不真正的抓取远程文件内容.</td></tr><br><br><tr><td>STREAM_DISABLE_OPEN_BASEDIR</td><br><td>类似safe_mode检查, 不设置这个选项则会检查INI设置open_basedir, 如果指定这个选项则可以绕过这个默认的检查</td></tr><br><br><tr><td>STREAM_OPEN_PERSISTENT</td><br><td>告知流包装层, 所有内部分配的空间都采用持久化分配, 并将关联的资源注册到持久化列表中.</td></tr><br><br><tr><td>IGNORE_PATH</td><br><br><td>如果不指定, 则搜索默认的包含路径. 多数URL包装器都忽略这个选项.</td></tr><br><br><tr><td>IGNORE_URL</td><br><td>提供这个选项时, 流包装层只打开本地文件. 所有的is_url包装器都将被忽略.</td></tr><br></table><p>最后的NULL参数是char **类型, 它最初是用来设置匹配路径, 如果path指向普通文件URL, 则去掉file://部分, 保留直接的文件路径用于传统的文件名操作. 这个参数仅仅是以前引擎内部处理使用的.</p><p>此外, 还有php_stream_open_wrapper()的一个扩展版本:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream *<span class="title">php_stream_open_wrapper_ex</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> *mode, <span class="keyword">int</span> options, <span class="keyword">char</span> **opened_path, php_stream_context *context)</span></span>;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>最后一个参数context允许附加的控制, 并可以得到包装器内的通知. 你将在第16章看到这个参数的细节.</p><h2 id="传输层包装"><a href="#传输层包装" class="headerlink" title="传输层包装"></a>传输层包装</h2><p>尽管传输流和fopen包装流是相同的组件组成的, 但它的注册策略和其他的流不同. 从某种程度上来说, 这是因为用户空间对它们的访问方式的不同造成的, 它们需要实现基于套接字的其他因子.</p><p>从扩展开发者角度来看, 打开传输流的过程是相同的. 下面是对fsockopen()的实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample5_fsockopen)</span><br><span class="line">    php_stream *stream;</span><br><span class="line">    <span class="keyword">char</span> *host, *transport, *errstr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> host_len, transport_len, implicit_tcp = <span class="number">1</span>, errcode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> port =</span><br><span class="line">    <span class="keyword">int</span> options = ENFORCE_SAFE_MODE;</span><br><span class="line">    <span class="keyword">int</span> flags = STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"s|l"</span>,</span><br><span class="line">                &amp;host, &amp;host_len, &amp;port) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (port) &#123;</span><br><span class="line">        <span class="keyword">int</span> implicit_tcp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(host, <span class="string">"://"</span>)) &#123;</span><br><span class="line">            <span class="comment">/* A protocol was specified,</span></span><br><span class="line"><span class="comment">             * no need to fall back on tcp:// */</span></span><br><span class="line">            implicit_tcp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        transport_len = spprintf(&amp;transport, <span class="number">0</span>, <span class="string">"%s%s:%d"</span>,</span><br><span class="line">                implicit_tcp ? <span class="string">"tcp://"</span> : <span class="string">""</span>, host, port);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* When port isn't specified</span></span><br><span class="line"><span class="comment">         * we can safely assume that a protocol was</span></span><br><span class="line"><span class="comment">         * (e.g. unix:// or udg://) */</span></span><br><span class="line">        transport = host;</span><br><span class="line">        transport_len = host_len;</span><br><span class="line">    &#125;</span><br><span class="line">    stream = php_stream_xport_create(transport, transport_len,</span><br><span class="line">            options, flags,</span><br><span class="line">            <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errstr, &amp;errcode);</span><br><span class="line">    <span class="keyword">if</span> (transport != host) &#123;</span><br><span class="line">        efree(transport);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errstr) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING, <span class="string">"[%d] %s"</span>,</span><br><span class="line">                errcode, errstr);</span><br><span class="line">        efree(errstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    php_stream_to_zval(stream, return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的基础构造和前面的fopen示例是一样的. 不同在于host和端口号使用不同的参数指定, 接着为了给出一个传输流URL就必须将它们合并到一起. 在产生了一个有意义的路径后, 将它传递给php_stream_xport_create()函数, 方式和fopen()使用的php_stream_open_wrapper()API一样. php_stream_xport_create()的原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream *<span class="title">php_stream_xport_create</span><span class="params">(<span class="keyword">char</span> *xport, <span class="keyword">int</span> xport_len,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> options, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *persistent_id,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct timeval *timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">    php_stream_context *context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> **errstr, <span class="keyword">int</span> *errcode)</span></span>;</span><br></pre></td></tr></table></figure><p>每个参数的含义如下:</p><table><br><tr><br><td>xport</td><br><td>基于URI的传输描述符. 对于基于inet的套接字流, 它可以是tcp://127.0.0.1:80, udp://10.0.0.1:53, ssl://169.254.13.24:445等. 此外, UNIX域传输协议unix:///path/to/socket,udg:///path/to/dgramsocket等都是合法的. xport_len指定了xport的长度, 因此xport是二进制安全的.</td><br></tr><br><tr><br><td>options</td><br><td>这个值是由前面php_stream_open_wrapper()中介绍的选项通过按位或组成的值.</td><br></tr><br><tr><br><td>flags</td><br><td>由STREAM_XPORT_CLIENT或STREAM_XPORT_SERVER之一与下面另外一张表中将列出的STREAM_XPORT_<em>常量通过按位或组合得到的值.</em></td><br></tr><br><tr><br><td>persistent_id</td><br><td>如果请求的传输流需要在请求间持久化, 调用作用域可以提供一个key名字描述连接. 指定这个值为NULL创建非持久化连接; 指定为唯一的字符串值将尝试首先从持久化池中查找已有的传输流, 或者没有找到时就创建一个新的持久化流.</td><br></tr><br><tr><br><td>timeout</td><br><td>在超时返回失败之前连接的尝试时间. 如果这个值传递为NULL则使用php.ini中指定的默认超时值. 这个参数对服务端传输流没有意义.</td><br></tr><br><tr><br><td>errstr</td><br><td>如果在选定的套接字上创建, 连接, 绑定或监听时发生错误, 这里传递的char 引用值将被设置为一个描述发生错误原因的字符串. errstr初始应该指向的是NULL; 如果在返回时它被设置了值, 则调用作用域有责任去释放这个字符串相关的内存.</td><br></tr><br><tr><br><td>errcode</td><br><td>通过errstr返回的错误消息对应的数值错误代码.php_stream_xport_create()的flags参数中使用了STREAM_XPORT_*一族常量定义如下:<br><table><br><tr><br><td>STREAM_XPORT_CLIENT</td><br><td>本地端将通过传输层和远程资源建立连接. 这个标记通常和STREAM_XPORT_CONNECT或STREAM_XPORT_CONNECT_ASYNC联合使用.</td><br></tr><br><tr><br><td>STREAM_XPORT_SERVER</td><br><td>本地端将通过传输层accept连接. 这个标记通常和STREAM_XPORT_BIND以及STREAM_XPORT_LISTEN一起使用.</td><br></tr><br><tr><br><td>STREAM_XPORT_CONNECT</td><br><td>用以说明建立远程资源连接是传输流创建的一部分. 在创建客户端传输流时省略这个标记是合法的, 但是这样做就要求手动的调用php_stream_xport_connect().</td><br></tr><br><tr><br><td>STREAM_XPORT_CONNECT_ASYNC</td><br><td>尝试连接到远程资源, 但不阻塞。</td><br></tr><br><tr><br><td>STREAM_XPORT_BIND</td><br><td>将传输流绑定到本地资源. 用在服务端传输流时,这将使得accept连接的传输流准备端口, 路径或特定的端点标识符等信息.</td><br></tr><br><tr><br><td>STREAM_XPORT_LISTEN</td><br><td>在已绑定的传输流端点上监听到来的连接. 这通常用于基于流的传输协议, 比如: tcp://, ssl://,unix://.</td><br></tr><br></table><br></td><br></tr><br></table><h2 id="目录访问"><a href="#目录访问" class="headerlink" title="目录访问"></a>目录访问</h2><p>fopen包装器支持目录访问, 比如file://和ftp://, 还有第三种流打开函数也可以用于目录访问, 下面是对opendir()的实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample5_opendir)</span><br><span class="line">&#123;</span><br><span class="line">    php_stream *stream;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> path_len, options = ENFORCE_SAFE_MODE | REPORT_ERRORS;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"s"</span>,</span><br><span class="line">        &amp;path, &amp;path_len) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stream = php_stream_opendir(path, options, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!stream) &#123;</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    php_stream_to_zval(stream, return_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的, 也可以为某个特定目录打开一个流, 比如本地文件系统的目录名或支持目录访问的URL格式资源. 这里我们又看到了options参数, 它和原来的含义一样, 第三个参数NULL原型是php_stream_context类型.</p><p>在目录流打开后, 和文件以及传输流一样, 返回给用户空间.</p><h2 id="特殊流"><a href="#特殊流" class="headerlink" title="特殊流"></a>特殊流</h2><p>还有一些特殊类型的流不能归类到fopen/transport/directory中. 它们中每一个都有自己独有的API:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream *<span class="title">php_stream_fopen_tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">php_stream *<span class="title">php_stream_fopen_temporary_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dir, <span class="keyword">const</span> <span class="keyword">char</span> *pfx, <span class="keyword">char</span> **opened_path)</span></span>;</span><br></pre></td></tr></table></figure><p>创建一个可seek的缓冲区流用于读写. 在关闭时, 这个流使用的所有临时资源, 包括所有的缓冲区(无论是在内存还是磁盘), 都将被释放. 使用这一组API中的后一个函数, 允许临时文件被以特定的格式命名放到指定路径. 这些内部API调用被用户空间的tmpfile()函数隐藏.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream *<span class="title">php_stream_fopen_from_fd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode, <span class="keyword">const</span> <span class="keyword">char</span> *persistent_id)</span></span>;</span><br><span class="line"><span class="function">php_stream *<span class="title">php_stream_fopen_from_file</span><span class="params">(FILE *file, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">php_stream *<span class="title">php_stream_fopen_from_pipe</span><span class="params">(FILE *file, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure><p>这3个API方法接受已经打开的FILE *资源或文件描述符ID, 使用流API的某种操作包装. fd格式的接口不会搜索匹配你前面看到过的fopen函数打开的资源, 但是它会注册持久化的资源, 后续的fopen可以使用到这个持久化资源.</p><h1 id="访问流"><a href="#访问流" class="headerlink" title="访问流"></a>访问流</h1><p>在你打开一个流之后, 就可以在它上面执行I/O操作了. 使用哪种协议包装API创建了流并不重要, 它们都使用相同的访问API.</p><h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>流的读写可以使用下面的API函数组合完成, 它们多数都是遵循POSIX I/O中对应的API规范的:</p><pre><code>int php_stream_getc(php_stream *stream);</code></pre><p>从数据流中接收一个字符. 如果流上再没有数据, 则返回EOF.</p><pre><code>size_t php_stream_read(php_stream *stream, char *buf, size_t count);</code></pre><p>从指定流中读取指定字节的数据. buf必须预分配至少count字节的内存空间. 这个函数将返回从数据流实际读到缓冲区中的数据字节数.</p><p>php_stream_read()不同于其他的流读取函数. 如果使用的流不是普通文件流, 哪怕数据流中有超过请求字节数的数据, 并且当前也可以返回, 它也只会调用过一次底层流实现的read函数. 这是为了兼容基于包(比如UDP)的协议的这种做法.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">php_stream_get_line</span><span class="params">(php_stream *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> maxlen, <span class="keyword">size_t</span> *returned_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">php_stream_gets</span><span class="params">(php_stream *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> maxlen)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数从stream中读取最多maxlen个字符, 直到碰到换行符或流结束. buf可以是一个指向预分配的至少maxlen字节的内存空间的指针, 也可以是NULL, 当它是NULL时,则会自动的创建一个动态大小的缓冲区, 用从流中实际读出的数据填充, 成功后函数返回指向缓冲区的指针, 失败则返回NULL. 如果returned_len传递了非NULL值, 则在返回时它将被设置为实际从流中读取的字节数.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">php_stream_get_record</span><span class="params">(php_stream *stream, <span class="keyword">size_t</span> maxlen, <span class="keyword">size_t</span> *returned_len, <span class="keyword">char</span> *delim, <span class="keyword">size_t</span> delim_len TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p>和php_stream_get_line()类似, 这个函数将读取最多maxlen, 或到达EOF/行结束第一次出现的位置. 但是它也有和php_stream_get_line()的不同指出, 这个函数允许指定任意的停止读取标记.</p><h2 id="读取目录项"><a href="#读取目录项" class="headerlink" title="读取目录项"></a>读取目录项</h2><p>从php流中读取目录项和上面从普通文件中读取普通数据相同. 这些数据放到了固定大小的dirents块中. 内部的php_stream_dirent结构体如下, 它与POSIX定义的dirent结构体一致:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">php_stream_dirent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> d_name[MAXPATHLEN];</span><br><span class="line">&#125; php_stream_dirent;</span><br></pre></td></tr></table></figure><p>实际上你可以直接使用php_stream_read()函数读取数据到这个结构体中:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (php_stream_read(stream, (<span class="keyword">char</span>*)&amp;entry, <span class="keyword">sizeof</span>(entry)) == <span class="keyword">sizeof</span>(entry)) &#123;</span><br><span class="line">        <span class="comment">/* 成功从目录流中读取到一项 */</span></span><br><span class="line">        php_printf(<span class="string">"File: %s\n"</span>, entry.d_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由于从目录流中读取是很常见的操作, php流包装层暴露了一个API, 它将记录大小的检查和类型转换处理封装到了一次调用中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">php_stream_dirent *<span class="title">php_stream_readdir</span><span class="params">(php_stream *dirstream, php_stream_dirent *entry)</span></span>;</span><br></pre></td></tr></table></figure><p>如果成功读取到目录项, 则传入的entry指针将被返回, 否则返回NULL标识错误. 使用这个为目录流特殊构建的函数而不是直接从目录流读取非常重要, 这样做未来流API改变时就不至于和你的代码冲突.</p><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p>和读类似, 向流中写数据只需要传递一个缓冲区和缓冲区长度给流.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">php_stream_write</span><span class="params">(php_stream *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">php_stream_write_string</span><span class="params">(php_stream *stream, <span class="keyword">char</span> *stf)</span></span>;</span><br></pre></td></tr></table></figure><p>write_string的版本实际上是一个提供便利的宏, 它允许写一个NULL终止的字符串,而不用显式的提供长度. 返回的是实际写到流中的字节数. 要特别小心的是尝试写大数据的时候可能导致流阻塞, 比如套接字流, 而如果流被标记为非阻塞, 则实际写入的数据量可能会小于传递给函数的期望大小.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_putc</span><span class="params">(php_stream *stream, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_puts</span><span class="params">(php_string *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>还有一种选择是, 使用php_stream_putc()和php_stream_puts()写入一个字符或一个字符串到流中. 要注意, php_stream_puts()不同于php_stream_write_string(), 虽然它们的原型看起来是一样的, 但是php_stream_puts()会在写出buf中的数据后自动的追加一个换行符.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">php_stream_printf</span><span class="params">(php_stream *stream TSRMLS_DC, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>功能和格式上都类似于fprintf(), 这个API调用允许在写的同时构造字符串而不用去创建临时缓冲区构造数据. 这里我们能够看到的一个明显的不同是它需要TSRMLS_CC宏来保证线程安全.</p><h2 id="随机访问-查看文件偏移量以及缓存的flush"><a href="#随机访问-查看文件偏移量以及缓存的flush" class="headerlink" title="随机访问, 查看文件偏移量以及缓存的flush"></a>随机访问, 查看文件偏移量以及缓存的flush</h2><p>基于文件的流, 以及另外几种流是可以随机访问的. 也就是说, 在流的一个位置读取了一些数据之后, 文件指针可以向前或向后移动, 以非线性顺序读取其他部分.</p><p>如果你的流应用代码预测到底层的流支持随机访问, 在打开的时候就应该传递STREAM_MUST_SEEK选项. 对于那些原本就可随机访问的流来说, 这通常不会有什么影响, 因为流本身就是可随机访问的. 而对于那些原本不可随机访问的流, 比如网络I/O或线性访问文件比如FIFO管道, 这个暗示可以让调用程序有机会在流的数据被消耗掉之前, 优雅的失败.</p><p>在可随机访问的流资源上工作时, 下面的函数可用来将文件指针移动到任意位置:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_seek</span><span class="params">(php_stream *stream, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_rewind</span><span class="params">(php_stream *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>offset是相对于whence表示的流位置的偏移字节数, whence的可选值及含义如下:</p><table><br><tr><br><td>SEEK_SET</td><br><td>offset相对于文件开始位置. php_stream_rewind()API调用实际上是一个宏,展开后是php_stream_seek(stream, 0, SEEK_SET), 表示移动到文件开始位置偏移0字节处. 当使用SEEK_SET时, 如果offset传递负值被认为是错误的, 将会导致未定义行为. 指定的位置超过流的末尾也是未定义的, 不过结果通常是一个错误或文件被扩大以满足指定的偏移量.</td><br></tr><br><tr><br><td>SEEK_CUR</td><br><td>offset相对于文件的当前偏移量. 调用php_stream_seek(steram, offset,SEEK_CUR)一般来说等价于php_stream_seek(stream, php_stream_tell() + offset, SEEK_SET);</td><br></tr><br><tr><br><td>SEEK_END</td><br><td>offset是相对于当前的EOF位置的. 负值的offset表示在EOF之前的位置, 正值和SEEK_SET中描述的是相同的语义, 可能在某些流实现上可以工作.</td><br></tr><br></table><pre><code>int php_stream_rewinddir(php_stream *dirstream);</code></pre><p>在目录流上随机访问时, 只有php_stream_rewinddir()函数可用. 使用php_stream_seek()函数将导致未定义行为. 所有的随机访问一族函数返回0标识成功或者-1标识失败.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">php_stream_tell</span><span class="params">(php_stream *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>如你之前所见, php_stream_tell()将返回当前的文件偏移量.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_flush</span><span class="params">(php_stream *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>调用flush()函数将强制将流过滤器此类内部缓冲区中的数据输出到最终的资源中. 在流被关闭时, flush()函数将自动调用, 并且大多数无过滤流资源虽然不进行任何内部缓冲,但也需要flush. 显式的调用这个函数很少见, 并且通常也是不需要的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_stat</span><span class="params">(php_stream *stream, php_stream_statbuf *ssb)</span></span>;</span><br></pre></td></tr></table></figure><p>调用php_stream_stat()可以获取到流实例的其他信息, 它的行为类似于fstat()函数. 实际上, php_stream_statbuf结构体现在仅包含一一=个元素: struct statbuf sb; 因此,php_stream_stat()调用可以如下面例子一样, 直接用传统的fstat()操作替代, 它只是将posix的stat操作翻译成流兼容的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_sample4_fd_is_fifo</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">statbuf</span> <span class="title">sb</span>;</span></span><br><span class="line">    fstat(fd, &amp;sb);</span><br><span class="line">    <span class="keyword">return</span> S_ISFIFO(sb.st_mode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_sample4_stream_is_fifo</span><span class="params">(php_stream *stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_stream_statbuf ssb;</span><br><span class="line">    php_stream_stat(stream, &amp;ssb);</span><br><span class="line">    <span class="keyword">return</span> S_ISFIFO(ssb.sb.st_mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>所有流的关闭都是通过php_stream_free()函数处理的, 它的原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_free</span><span class="params">(php_stream *stream, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数中的options参数允许的值是PHP_STREAM_FREE_xxx一族常量的按位或的结果, 这一族常量定义如下(下面省略PHP_STREAM_FREE_前缀):</p><table><br><tr><br><td>CALL_DTOR</td><br><td>流实现的析构器应该被调用. 这里提供了一个时机对特定的流进行显式释放.</td><br></tr><br><tr><br><td>RELEASE_STREAM</td><br><td>释放为php_stream结构体分配的内存</td><br></tr><br><tr><br><td>PRESERVE_HANDLE</td><br><td>指示流的析构器不要关闭它的底层描述符句柄</td><br></tr><br><tr><br><td>RSRC_DTOR</td><br><td>流包装层内部管理资源列表的垃圾回收</td><br></tr><br><tr><br><td>PERSISTENT</td><br><td>作用在持久化流上时, 它的行为将是永久的而不局限于当前请求.</td><br></tr><br><tr><br><td>CLOSE</td><br><td>CALL_DTOR和RELEASE_STREAM的联合. 这是关闭非持久化流的一般选项</td><br></tr><br><tr><br><td>CLOSE_CASTED</td><br><td>CLOSE和PRESERVE_HANDLE的联合.</td><br></tr><br><tr><br><td>CLOSE_PERSISTENT</td><br><td>CLOSE和PERSISTENT的联合. 这是永久关闭持久化流的一般选项.</td><br></tr><br></table><p>实际上, 你并不需要直接调用php_stream_free()函数. 而是在关闭流时使用下面两个宏的某个替代:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> php_stream_close(stream) \</span></span><br><span class="line">    php_stream_free((stream), PHP_STREAM_FREE_CLOSE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> php_stream_pclose(stream) \</span></span><br><span class="line">    php_stream_free((stream), PHP_STREAM_FREE_CLOSE_PERSISTENT)</span><br></pre></td></tr></table></figure><h2 id="通过zval交换流"><a href="#通过zval交换流" class="headerlink" title="通过zval交换流"></a>通过zval交换流</h2><p>因为流通常映射到zval上, 反之亦然, 因此提供了一组宏用来简化操作, 并统一编码(格式):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> php_stream_to_zval(stream, pzval) \</span></span><br><span class="line">    ZVAL_RESOURCE((pzval), (stream)-&gt;rsrc_id);</span><br></pre></td></tr></table></figure><p>要注意, 这里并没有调用ZEND_REGISTER_RESOURCE(). 这是因为当流打开的时候, 已经自动的注册为资源了, 这样就可以利用到引擎内建的垃圾回收和shutdown系统的优点. 使用这个宏而不是尝试手动的将流注册为新的资源ID是非常重要的; 这样做的最终结果是导致流被关闭两次以及引擎崩溃.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> php_stream_from_zval(stream, ppzval) \</span></span><br><span class="line">    ZEND_FETCH_RESOURCE2((stream), php_stream*, (ppzval), \</span><br><span class="line">    <span class="number">-1</span>, <span class="string">"stream"</span>, php_file_le_stream(), php_file_le_pstream())</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> php_stream_from_zval_no_verify(stream, ppzval) \</span></span><br><span class="line">    (stream) = (php_stream*)zend_fetch_resource((ppzval) \</span><br><span class="line">    TSRMLS_CC, <span class="number">-1</span>, <span class="string">"stream"</span>, <span class="literal">NULL</span>, <span class="number">2</span>, \</span><br><span class="line">    php_file_le_stream(), php_file_le_pstream())</span><br></pre></td></tr></table></figure><p>从传入的zval <em>中取回php_stream </em>有一个类似的宏. 可以看出, 这个宏只是对资源获取函数(第9章”资源数据类型”)的一个简单封装. 请回顾ZEND_FETCH_RESOURCE2()宏,第一个宏php_stream_from_zval()就是对它的包装, 如果资源类型不匹配, 它将抛出一个警告并尝试从函数实现中返回. 如果你只是想从传入的zval <em>中获取一个php_stream </em>, 而不希望有自动的错误处理, 就需要使用php_stream_from_zval_no_verify()并且需要手动的检查结果值.</p><h1 id="静态资源操作"><a href="#静态资源操作" class="headerlink" title="静态资源操作"></a>静态资源操作</h1><p>一个基于流的原子操作并不需要实际的实例. 下面这些API仅仅使用URL执行这样的操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_stat_path</span><span class="params">(<span class="keyword">char</span> *path, php_stream_statbuf *ssb)</span></span>;</span><br></pre></td></tr></table></figure><p>和前面的php_stream_stat()类似, 这个函数提供了一个对POSIX的stat()函数协议依赖的包装. 要注意, 并不是所有的协议都支持URL记法, 并且即便支持也可能不能报告出statbuf结构体中的所有成员值. 一定要检查php_stream_stat_path()失败时的返回值, 0标识成功, 要知道, 不支持的元素返回时其值将是默认的0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_stat_path_ex</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    php_stream_statbuf *ssb, php_stream_context *context)</span></span>;</span><br></pre></td></tr></table></figure><p>这个php_stream_url_stat()的扩展版本允许传递另外两个参数. 第一个是flags, 它的值可以是下面的PHP_STERAM_URL_STAT_*(下面省略PHP_STREAM_URL_STAT_前缀)一族常量的按位或的结果. 还有一个是context参数, 它在其他的一些流函数中也有出现,我们将在第16章去详细学习.</p><table><br><tr><br><td>LINK</td><br><td>原始的php_stream_stat_path()对于符号链接或目录将会进行解析直到碰到协议定义的结束资源. 传递PHP_STREAM_URL_STAT_LINK标记将导致php_stream_stat_path()返回请求资源的信息而不会进行符号链接的解析.(译注: 我们可以这样理解, 没有这个标记, 底层使用stat(), 如果有这个标记,底层使用lstat(), 关于stat()和lstat()的区别, 请查看*nix手册)</td><br></tr><br><tr><br><td>QUIET</td><br><td>默认情况下, 如果在执行URL的stat操作过程中碰到错误, 包括文件未找到错误, 都将通过php的错误处理机制触发. 传递QUIET标记可以使得php_stream_stat_path()返回而不报告错误.</td><br></tr><br></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_mkdir</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">int</span> mode, <span class="keyword">int</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">    php_stream_context *context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_stream_rmdir</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">int</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">    php_stream_context *context)</span></span>;</span><br></pre></td></tr></table></figure><p>创建和删除目录也会如你期望的工作. 这里的options参数和前面的php_stream_open_wrapper()函数的同名参数含义一致. 对于php_stream_mkdir(), 还有一个参数mode用于指定一个八进制的值表明读写执行权限.</p><p>#小结</p><p>本章中你接触了一些基于流的I/O的内部表象. 下一章将演示做呢样实现自己的协议包装, 甚至是定义自己的流类型.</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13 INI设置</title>
      <link href="/posts/913cde6e.html"/>
      <url>/posts/913cde6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="13-INI设置"><a href="#13-INI设置" class="headerlink" title="13 INI设置"></a>13 INI设置</h1><p>在前面的一章，我们已经学会了MINIT、MSHUTDOWN函数，以及RINIT和RSHUTDOWN等函数的使用，这里我们将介绍并学习ini设置的使用。</p><h1 id="13-1-声明和访问INI设置"><a href="#13-1-声明和访问INI设置" class="headerlink" title="13.1 声明和访问INI设置"></a>13.1 声明和访问INI设置</h1><p>INI条目被定义在一个完整的独立的的块，位于上文中所说的MINIT方法的同一个源文件，并且用下面的一对宏来定义，并在这对宏之间放入一个或者多个条目<code>PHP_INI_BEGIN()</code>和<code>PHP_INI_END()</code></p><p>这些宏方法和上一章所提到的<code>ZEND_BEGIN_MODULE_GLOBALS()</code>和<code>ZEND_END_MODULE_GLOBALS()</code>有着相同的用法。这些结构是用静态数据的实例来声明，而不仅仅是提供一个结构的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_ini_entry ini_entries[] = &#123;</span><br><span class="line">           &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">NULL</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>正如你所看到的，上面定义了<code>zend_ini_entry</code>的一个向量值并以一个空记录来终止。你或许已经多次在<code>function_entry</code>结构的定义之中看到过这种以填充静态向量的方法</p><p>####简单INI设置</p><p>现在你可以使用 INI 结构来声明条目，这个机制是用来注册和销毁一些在机器上的设置，你可以声明一些对你的扩展有用的有实际意义的设置了。</p><p>假设你的扩展的方法就像你在第五章看到的那个例子（<code>Your First Extension</code>）一样，只是输出一个简单的问候，你可能想让你要输出的问候语句是可定制的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample4_hello_world)</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的方法就是定义一个 INI 的设置，让它的默认值为<code>Hello World!</code>，像下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php_ini.h"</span></span></span><br><span class="line">PHP_INI_BEGIN()</span><br><span class="line">PHP_INI_ENTRY(<span class="string">"sample4.greeting"</span>, <span class="string">"Hello World"</span>, PHP_INI_ALL, <span class="literal">NULL</span>)</span><br><span class="line">PHP_INI_END()</span><br></pre></td></tr></table></figure><p>正如你猜测的一样，PHP_INI_ENTRY 这个宏里面设置的前面的两个参数，分别代表着INI设置的名称和它的默认值。第三个参数决定设置是否允许被修改，以及它能被修改的作用域。最后一个参数是一个回调函数，当INI的值被修改时候触发此回调函数。你将会在某些修改事件的地方详细的了解这个参数。</p><p>PHP总共有4个指令配置作用域：（PHP中的每个指令都有自己的作用域，指令只能在其作用域中修改，不是任何地方都能修改配置指令的）</p><table><thead><tr><th>Parameter</th><th>Meaning</th></tr></thead><tbody><tr><td>PHP_INI_PERDIR</td><td>指令可以在php.ini、httpd.conf或.htaccess文件中修改</td></tr><tr><td>PHP_INI_SYSTEM</td><td>指令可以在php.ini 和 httpd.conf 文件中修改</td></tr><tr><td>PHP_INI_USER</td><td>指令可以在用户脚本中修改</td></tr><tr><td>PHP_INI_ALL</td><td>指令可以在任何地方修改</td></tr></tbody></table><p>现在你已经声明了你的INI的设置，你现在准备将它用在你的问候函数之中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample4_hello_world)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *greeting = INI_STR(<span class="string">"sample4.greeting"</span>);</span><br><span class="line">    php_printf(<span class="string">"%s\n"</span>, greeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点很重要：<code>char*</code>类型的值被认为是属于<code>ZEND</code>引擎的，是不能修改的。正因为如此，你将本地变量设置进INI时候，它将在你的方法中被声明为<code>const</code>。并不是所有的INI值都是基于字符串的；也有其他的一些用于整数、浮点数、或布尔值的宏，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lval = INI_INT(<span class="string">"sample4.intval"</span>);</span><br><span class="line"><span class="keyword">double</span> dval = INI_FLT(<span class="string">"sample4.fltval"</span>);</span><br><span class="line">zend_bool bval = INI_BOOL(<span class="string">"sample4.boolval"</span>);</span><br></pre></td></tr></table></figure><p>通常你想知道你当前的<code>INI</code>设置的值；恭喜你，ZEND内核刚好就存在一组这样的宏为你提供查询每种类型的INI的默认值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *strval = INI_ORIG_STR(<span class="string">"sample4.stringval"</span>);</span><br><span class="line"><span class="keyword">long</span> lval = INI_ORIG_INT(<span class="string">"sample4.intval"</span>);</span><br><span class="line"><span class="keyword">double</span> dval = INI_ORIG_FLT(<span class="string">"sample4.fltval"</span>);</span><br><span class="line">zend_bool bval = INI_ORIG_BOOL(<span class="string">"sample4.boolval"</span>);</span><br></pre></td></tr></table></figure><p>#####NOTE<br>在这个例子中，<code>sample4.greeting</code>只是INI设置的一个前缀，用来帮助保证它的设置不会和其他扩展的设置相冲突。这种加前缀的方法不仅仅是用在闭源的扩展上，它更被广泛的用在任何商业或者开源的公开发布的扩展上面。</p><p>####访问级别</p><p>每一个给出的INI值总是有默认值的。在许多情况下，INI都有一个比较合理的默认值；然而，在某些比较特殊的环境或者某个脚本要做一些比较特别的事情的情况下，这些INI值通常会被修改。这些设置可以在任何的三个不同的点被修改，看下表：</p><table><thead><tr><th>Access Level</th><th>Meaning</th></tr></thead><tbody><tr><td>SYSTEM</td><td>设置被放在php.ini中，或者在Apache的http.conf配置文件中的<directory>和<virtualhost>，它在apache启动时候生效，被认为是设置的全局变量</virtualhost></directory></td></tr><tr><td>PERDIR</td><td>一些设置被放在Apache的http.conf的<directory>或者<virtualhost>块中，或者.htaccess文件之中。原文：Any setting found in a<directory>or<virtualhost>block within Apache’s httpd.conf, or settings located in .htaccess files as well as certain other locations not exclusive to Apache are processed just prior to a given request if that request is within the appropriate directory or virtual host.</virtualhost></directory></virtualhost></directory></td></tr><tr><td>USER</td><td>一旦脚本开始执行，唯一的改变INI设置的方法就是利用用户方法：ini_set()</td></tr></tbody></table><p>某些设置，例如safe_mode，如果他们能在任何地方任意修改的话，那它的存在就没意义了。例如，一个恶意脚本的作者可以简单的禁用safe_mode,然后任意读取和修改其他的被禁止的文件。</p><p>同样，一些非安全相关的设置，如：register_globals或magic_quotes_gpc 不能在一个脚本中有效的被改变，因为他们所承担的任务已经过了。<br>Similarly, some non-security related settings such as register_globals or magic_quotes_gpc cannot be effectively changed within a script because the point at which they bear relevance has already passed.</p><p>这些设置是通过<code>PHP_INI_ENTRY()</code>的第三个参数来设置的。在你的设置声明之中，你已经使用了 <code>PHP_INI_ALL</code>, 他们是按位或者<code>PHP_INI_SYSTEM | PHP_INI_PERDIR | PHP_INI_USER</code>的组合来定义的。</p><p>如register_globals和magic_quotes_gpc的设置，反过来，使用<code>PHP_INI_SYSTEM | PHP_INI_PERDIR</code> 来声明。对于这些设置，在任何调用<code>ini_set()</code>的地方排除<code>PHP_INI_USER</code>的话将以失败告终（The exclusion of PHP_INI_USER results in any call to ini_set() for these settings ending in failure）。</p><p>现在你可能会猜测，safe_mode和open_basedir之类的设置只能用<code>PHP_INI_SYSTEM</code>来声明。这种设置可以确保只有系统管理员才能修改这些值，因为只有他们有权限修改php.ini或者http.conf中的值。</p><p>####修改事件</p><p>无论INI设置在什么时候被修改，无论是通过<code>ini_set()</code>方法来修改还是在一个<code>perdir</code>指令执行期间来修改，zend引擎都会通过一个<code>OnModify</code>的回调来检查它。做修改的人可能会通过使用<code>ZEND_INI_MH</code>宏来定义，然后通过<code>OnModify</code>方法的参数来附加到INI设置里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZEND_INI_MH(php_sample4_modify_greeting)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (new_value_length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">PHP_INI_BEGIN()</span><br><span class="line">PHP_INI_ENTRY(<span class="string">"sample4.greeting"</span>, <span class="string">"Hello World"</span>,</span><br><span class="line">    PHP_INI_ALL, php_sample4_modify_greeting)</span><br><span class="line">PHP_INI_END()</span><br></pre></td></tr></table></figure><p>当<code>new_value_length</code>的长度为0的时候返回FAILURE，这样修改者就可以禁止将祝福语句设置为一个空字符串。像下面这样使用<code>ZEND_INI_MH()</code>可以生成整个原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_sample4_modify_greeting</span><span class="params">(zend_ini_entry *entry,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">char</span> *new_value, uint new_value_length,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">void</span> *mh_arg1, <span class="keyword">void</span> *mh_arg2, <span class="keyword">void</span> *mh_arg3,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> stage TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p>#####Table 13.2. INI Setting Modifier Callback Parameters</p><table><thead><tr><th>Parameter</th><th>Meaning</th></tr></thead><tbody><tr><td>enTRy</td><td>指向zend引擎实际存储的INI设置，这种结构提供一些信息，包括现在的值、原始值、拥有模块、还有其他的一些在下面的 Listing 13.1 中的详细信息</td></tr><tr><td>new_value</td><td>关于设置的值。如果处理方法返回SUCCESS，这个值将被填充进 enTRy-&gt;value ，如果 entry-&gt;orig_value 至今没有设置的话，当前的值将被旋转到这个位置，并且也会设置 enTRy-&gt;modified 这个标志。字符串的长度将被填充到 new_value_length。</td></tr><tr><td>mh_arg1,2,3</td><td>这组指针（三个一组）提供了访问数据指针最初给出的INI设置的声明。在实践中，这些值都是通过内部引擎进程来调用的,所以你不需要担心它们</td></tr><tr><td>stage</td><td>ZEND_INI_STAGE_s 这种形式里面有五个值，这五个由s代表的值为STARTUP, SHUTDOWN, ACTIVATE, DEACTIVATE, 或者 RUNTIME，这些常量分别对应 MINIT, MSHUTDOWN, RINIT, RSHUTDOWN 还有 处于活跃状态正在执行的脚本。</td></tr></tbody></table><p>#####Listing 13.1. Core structure: zend_ini_entry</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_ini_entry</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> module_number;</span><br><span class="line">    <span class="keyword">int</span> modifiable;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    uint name_length;</span><br><span class="line">    ZEND_INI_MH((*on_modify));</span><br><span class="line">    <span class="keyword">void</span> *mh_arg1;</span><br><span class="line">    <span class="keyword">void</span> *mh_arg2;</span><br><span class="line">    <span class="keyword">void</span> *mh_arg3;</span><br><span class="line">    <span class="keyword">char</span> *value;</span><br><span class="line">    uint value_length;</span><br><span class="line">    <span class="keyword">char</span> *orig_value;</span><br><span class="line">    uint orig_value_length;</span><br><span class="line">    <span class="keyword">int</span> modified;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ZEND_INI_DISP</span><span class="params">(*displayer)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>####显示INI设置</p><p>在上一章，你已经见过<code>MINFO</code>方法，还有一些其他关于扩展的基础知识。因为输出INI的信息对于一个扩展来说是很正常的，ZEND引擎有一个统一的宏来输出这些内容，它可以被放置在<code>PHP_MINFO_FUNCTION()</code>块中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINFO_FUNCTION(sample4)</span><br><span class="line">&#123;</span><br><span class="line">DISPLAY_INI_ENTRIES();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个宏需要INI设置的值，而这个值早已经在前面定义在了<code>PHP_INI_BEGIN</code>和<code>PHP_INI_END</code>宏之间。INI设置被迭代的显示在一个三列的表单中，这三列分别是INI设置的名字，它的原始（全局）设置，还有通过<code>PERDIR</code>指令或者<code>ini_set()</code>修改过的当前的设置。</p><p>默认情况下，所有的设置的条目都是根据原有的字符串来简单的输出的。(By default, all entries are simply output according to their string representation as-is.)一些类似布尔值和语法高亮显示的颜色的值，在显示的时候会经过特殊的格式化处理。这种特殊格式化的方法是通过每个INI设置自己的显示处理程序来处理的，这个处理程序是通过动态指向一个回调函数来实现的，跟我们前面看到的 OnModify 类似。</p><p>显示处理程序指定使用一个扩展的<code>PHP_INI_ENTRY()</code>宏的版本，<code>PHP_INI_ENTRY()</code>接受一个额外的参数。如果将它设置为NULL，默认的显示处理程序将按照字符串的值原样使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PHP_INI_ENTRY_EX(<span class="string">"sample4.greeting"</span>, <span class="string">"Hello World"</span>, PHP_INI_ALL,</span><br><span class="line">php_sample4_modify_greeting, php_sample4_display_greeting)</span><br></pre></td></tr></table></figure><p>明显的，这个回调需要在INI设置使用之前提前的定义好。与 OnModify 的回调类似，这个用一个包装宏来完成，并且只用少量的代码就能实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SAPI.h"</span> <span class="comment">/* needed for sapi_module */</span></span></span><br><span class="line">PHP_INI_DISP(php_sample4_display_greeting)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *value = ini_entry-&gt;value;</span><br><span class="line"><span class="comment">/* Select the current or original value as appropriate */</span></span><br><span class="line"><span class="keyword">if</span> (type == ZEND_INI_DISPLAY_ORIG &amp;&amp;</span><br><span class="line">ini_entry-&gt;modified)  &#123;</span><br><span class="line">    value = ini_entry-&gt;orig_value;</span><br><span class="line">&#125;                 </span><br><span class="line">    <span class="comment">/* Make the greeting bold (when HTML output is enabled) */</span></span><br><span class="line"><span class="keyword">if</span> (sapi_module.phpinfo_as_text) &#123;</span><br><span class="line">php_printf(<span class="string">"%s"</span>, value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    php_printf(<span class="string">"&lt;b&gt;%s&lt;/b&gt;"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####绑定到扩展的全局设置</p><p>所有的INI条目都在Zend Engine中被给予了存储空间，用来在脚本之中追踪它的改变，并且在请求之外维持全局设置。在这个存储空间之中，所有的INI设置都是以字符串形式保存的。你应该会想到，这些值可以使用<code>INI_INT()</code>,<code>INI_FLT()</code>,和<code>INI_BOOL()</code>这类宏很容易地转换为标量值。</p><p>这个查询和转换过程非常低效的原因有两个，它必须通过名字位于一个hash表之中，所以每次都要重新获取。这种查找方式对于用户空间脚本是非常好的，因为一个脚本只有在运行时才会被编译，但是对于编译型的语言,做这个工作是毫无意义的。</p><p>对于标量来说，这个会导致更加的低效，因为底层的字符串值在每一次被请求时候都必须再转换一次。使用你已经知道的，你可以声明一个线程安全的全局存储介质，并在每次改变的时候使用新值的地址来更新它。然后，任何代码都可以通过在你的线程安全的结构之中查找指针来访问INI设置，这个可以利用编译时优化。</p><p>在php_sample4.h文件中，在<code>MODULE_GLOBALS</code>结构中添加<code>const char *greeting;</code>，然后更新位于 sample4.c中的两个方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ZEND_INI_MH(php_sample4_modify_greeting)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Disallow empty greetings */</span></span><br><span class="line">    <span class="keyword">if</span> (new_value_length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    SAMPLE4_G(greeting) = new_value;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">PHP_FUNCTION(sample4_hello_world)</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"%s\n"</span>, SAMPLE4_G(greeting));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这是一个优化 INI 值存取的非常一般的方法，另一对宏是通过Zend引擎来导出的，将INI设置绑定到全局变量。(Because this is a common approach to optimizing INI access, another pair of macros is exported by the engine that handle binding INI settings to global variables)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STD_PHP_INI_ENTRY_EX(<span class="string">"sample4.greeting"</span>, <span class="string">"Hello World"</span>,</span><br><span class="line">PHP_INI_ALL, OnUpdateStringUnempty, greeting,</span><br><span class="line">    zend_sample4_globals, sample4_globals,</span><br><span class="line">    php_sample4_display_greeting)</span><br></pre></td></tr></table></figure><p>这个条目和刚刚你不需要的回调执行相同的工作。相反，他使用一个通用目的的修饰回调 <code>OnUpdateStringUnempty</code>，并且连同信息在存储空间的存储位置。为了允许空白的问候语，你可以简单的指定 <code>OnUpdateString</code>修饰语，这样就比<code>OnUpdateStringUnempty</code>方法简单。</p><p>类似的方法，比如INI设置可能会被绑定到类似long,double和zend_bool之类的标量上。在你的php_sample4.h中添加三个条目到MODULE_GLOBALS 结构中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> mylong;</span><br><span class="line"><span class="keyword">double</span> mydouble;</span><br><span class="line">zend_bool mybool;</span><br></pre></td></tr></table></figure><p>现在使用<code>STD_PHP_INI_ENTRY()</code>宏在<code>PHP_INI_BEGIN()/PHP_INI_END()</code>块中创建INI条目，不同于它的 <code>_EX</code>版本的仅仅是缺少一个播放者方法以及绑定他们到你的新值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">STD_PHP_INI_ENTRY(<span class="string">"sample4.longval"</span>, <span class="string">"123"</span>,</span><br><span class="line">PHP_INI_ALL, OnUpdateLong, mylong,</span><br><span class="line">    zend_sample4_globals, sample4_globals)</span><br><span class="line">STD_PHP_INI_ENTRY(<span class="string">"sample4.doubleval"</span>, <span class="string">"123.456"</span>,</span><br><span class="line">PHP_INI_ALL, OnUpdateDouble, mydouble,</span><br><span class="line">zend_sample4_globals, sample4_globals)</span><br><span class="line">STD_PHP_INI_ENTRY(<span class="string">"sample4.boolval"</span>, <span class="string">"1"</span>,</span><br><span class="line">PHP_INI_ALL, OnUpdateBool, mybool,</span><br><span class="line">zend_sample4_globals, sample4_globals)</span><br></pre></td></tr></table></figure><p>注意在这一点上，如果<code>DISPLAY_INI_ENTRIES()</code>被调用，”sample4.boolval” 这个布尔类型的INI设置会像其他的设置一样以字符串被显示出来；然而，优先以字符串输出的是”on”或者“off”。为了确认这些显示的值是有意义的，你可以在后面的两个方法之中任选一个，其中一个是切换到<code>STD_PHP_INI_ENTRY_EX()</code>宏创建一个显示的方法，另一个是你可以任意使用可以帮到你的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STD_PHP_INI_BOOLEAN(<span class="string">"sample4.boolval"</span>, <span class="string">"1"</span>,</span><br><span class="line">PHP_INI_ALL, OnUpdateBool, mybool,</span><br><span class="line">zend_sample4_globals *, sample4_globals)</span><br></pre></td></tr></table></figure><p>这种特定类型的宏跟在INI家族中的布尔是不一样的，它仅仅提供一个显示处理者来将开启的设置为“on”，关闭的设置为”off”。</p><h1 id="13-2-小结"><a href="#13-2-小结" class="headerlink" title="13.2 小结"></a>13.2 小结</h1><p>在这章，你探索了PHP中最古老的特性，也可以说是PHP健壮可移植性的最大的问题所在。对于每个有用的INI设置，它对编程的障碍就是随时都会出现它，这让编程越来越复杂。INI设置是一把双刃剑，所以在使用之前一定要深思熟虑，不然造成的后果将是长久的；胡乱使用将使你的系统出现很多不可预测的问题。</p><p>在接下来的三章中，你将专研数据流API，从使用开始，进一步提升到数据流的实现层,包装、环境以及过滤器</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12 启动与终止的那点事</title>
      <link href="/posts/47e30cf4.html"/>
      <url>/posts/47e30cf4.html</url>
      
        <content type="html"><![CDATA[<h1 id="12-启动与终止的那点事"><a href="#12-启动与终止的那点事" class="headerlink" title="12 启动与终止的那点事"></a>12 启动与终止的那点事</h1><p>在前面的章节里，你已经学会了如何使用MINIT函数在PHP加载模块的共享库时来执行初始化任务。在第一章，你还了解到扩展里其他三个函数，<br>和MINIT函数对应的MSHUTDOWN函数，以及一对在每个页面请求开始和结束时候调用的方法–RINIT函数和RSHUTDOWN函数。</p><h1 id="12-1-关于生命周期"><a href="#12-1-关于生命周期" class="headerlink" title="12.1 关于生命周期"></a>12.1 关于生命周期</h1><p>除了在上一节说到的4个函数，还有2个函数只用于处理单个线程的启动和关闭，他们只作用于线程环境。</p><p>首先，建立一个基本扩展，根据你PHP源码树使用下面几个源文件。</p><p>config.m4<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP_ARG_ENABLE(sample4,</span><br><span class="line">    [Whether to enable the <span class="string">"sample4"</span> extension],</span><br><span class="line">    [ enable-sample4 Enable <span class="string">"sample4"</span> extension support])</span><br><span class="line"><span class="keyword">if</span> test $PHP_SAMPLE4 != <span class="string">"no"</span>; then</span><br><span class="line">    PHP_SUBST(SAMPLE4_SHARED_LIBADD)</span><br><span class="line">    PHP_NEW_EXTENSION(sample4, sample4.c, $ext_shared)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p></p><p>php_sample4.h<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PHP_SAMPLE4_H</span></span><br><span class="line"><span class="comment">/* Prevent double inclusion */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_SAMPLE4_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define Extension Properties */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_SAMPLE4_EXTNAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_SAMPLE4_EXTVER</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Import configure options when building outside of the PHP source tree */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Include PHP Standard Header */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define the entry point symbol</span></span><br><span class="line"><span class="comment"> * Zend will use when loading this module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> zend_module_entry sample4_module_entry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> phpext_sample4_ptr &amp;sample4_module_entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PHP_SAMPLE4_H */</span></span></span><br></pre></td></tr></table></figure><p></p><p>sample4.c<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php_sample4.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ext/standard/info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> function_entry php_sample4_functions[] = &#123;</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(sample4)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(sample4) &#123;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_RINIT_FUNCTION(sample4) &#123;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">PHP_RSHUTDOWN_FUNCTION(sample4) &#123;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MINFO_FUNCTION(sample4) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zend_module_entry sample4_module_entry = &#123;</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    STANDARD_MODULE_HEADER,</span><br><span class="line">#endif</span><br><span class="line">    PHP_SAMPLE4_EXTNAME,</span><br><span class="line">    php_sample4_functions,</span><br><span class="line">    PHP_MINIT(sample4),</span><br><span class="line">    PHP_MSHUTDOWN(sample4),</span><br><span class="line">    PHP_RINIT(sample4),</span><br><span class="line">    PHP_RSHUTDOWN(sample4),</span><br><span class="line">    PHP_MINFO(sample4),</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    PHP_SAMPLE4_EXTVER,</span><br><span class="line">#endif</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_DL_SAMPLE4</span></span><br><span class="line">    ZEND_GET_MODULE(sample4)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><p>注意：每个启动或者关闭的方法在return SUCCESS时退出。如果其中任何的函数return FAILURE，PHP为了避免出现严重问题而将请求中止。</p><p>现在你应该对MINIT很熟悉了吧，它会在一个模块第一次加载到进程空间的时候被触发。</p><p>对于多进程的SAPIS(Apache1 &amp; Apache2-prefork)，多个web server进程会fork出多个mod_php实例。每个mod_php实例都必须加载属于这个实例<br>的扩展模块，这意味着MINIT函数会被执行多次。但是，它在每个进程空间中只会执行一次。</p><p>当一个模块被卸载，MSHUTDOWN会被调用，它可以使用该模块的任何资源，比如被占用的内存可能会被释放。</p><p>这里要注意个特性, 某些PHP的SAPI中, 比如Apache Prefork, PHP是作为一个动态库被加载到Apache中的, 而从Apache 1.3以后(如果我没记错的话), Apache做了一个优化, 优化的结果就是首先执行各个动态模块的模块初始化工作, 然后才做fork, 派生Worker子进程, 所以反应到这里, 有的时候会出现MINIT只执行一次, 而MSHUTDOWN会执行多次的现象.</p><p>理论上来说，你可以在MSHUTDOWN中跳过一些资源的清理工作，然而在APACHE 1.3上的时候，你会发现一个有趣的事情，apache会载入mod_php，<br>并且会执行所有的MINIT方法，然后立刻卸载mod_php来触发MSHUTDOWN，接着再次装入，在没有执行MSHUTDOWN的时候，最初使用MINIT加载的<br>资源将被泄露和浪费。</p><p>在多线程的SAPIS中，有时需要为每个线程分配自己独立的资源或跟踪每个请求的计数器。对于这些特殊情况，在每一个线程钩子中，允许额外的启动和关闭<br>要执行的方法。通常情况下，当多进程的SAPIS(Apache2-worker)启动时，它会创建出十几个或者更多的线程，以便能够处理多个并发请求。</p><p>任何可以请求之间共享，但不能由多个线程在同一进程空间同时访问的资源，通常分配在线程的构造和析构方法中以免发生冲突。比如可能包括在<br>EG（ persistent_list ） HashTable中的持久性资源，因为他们往往​​包括网络或文件资源。</p><h1 id="12-2-MINFO与phpinfo"><a href="#12-2-MINFO与phpinfo" class="headerlink" title="12.2 MINFO与phpinfo"></a>12.2 MINFO与phpinfo</h1><p>如果你并不打算做出一个只有你自己使用的扩展，那么你可以需要告诉用户一些关于你的扩展信息。比如：其环境和特定版本的可用功能、版本信息、<br>作者信息以便你在发生问题的时候可以寻求帮助、甚至可以加上一个LOGO等等。</p><p>如果你仔细看过phpinfo()或者 php -i 的输出，相信你已经注意到，所有这些信息会组合成一个格式良好的、易于解析输出。 你的扩展可以轻松地通过<br>MINFO (模块信息)来添加这些块，看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINFO_FUNCTION(sample4) &#123;</span><br><span class="line">    php_info_print_table_start();</span><br><span class="line">    php_info_print_table_row(<span class="number">2</span>, <span class="string">"Sample4 Module"</span>, <span class="string">"enabled"</span>);</span><br><span class="line">    php_info_print_table_row(<span class="number">2</span>, <span class="string">"version"</span>, PHP_SAMPLE4_EXTVER);</span><br><span class="line">    php_info_print_table_end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用这些包装的功能，你的模块的信息将被自动包裹在HTML标签中从一个网络服务器SAPI （如CGI时，IIS ， APACHE，等等）输出，或格式化使<br>用CLI使用时，输出明文和换行符。</p><p>下面我们来介绍一下php_info_*()系列的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">php_info_html_esc</span><span class="params">(<span class="keyword">char</span> *str TSRMLS_DC)</span></span></span><br></pre></td></tr></table></figure><p>这个函数是php_escape_html_entities()的一个封装，htmlentites() 函数的底层实现。该函数返回的字符串通过emalloc()创建，并在使用后必须使用<br>efree()函数释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_info_print_table_start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_info_print_table_end</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><p>输出开/关表格式所需的标签。HTML输出是与CLI输出一样，表现为一个简单的换行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_info_print_table_header</span><span class="params">(<span class="keyword">int</span> cols, ...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_info_print_table_colspan_header</span><span class="params">(<span class="keyword">int</span> cols, <span class="keyword">char</span> *header)</span></span></span><br></pre></td></tr></table></figure><p>输出表头行。第一个函数在可变参数列表中的char *元素外面的每一列都会输出一对th标签，第二个函数会在指定列数外面输出一对th标签。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_info_print_table_row</span><span class="params">(<span class="keyword">int</span> cols, ...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_info_print_table_row_ex</span><span class="params">(<span class="keyword">int</span> cols, <span class="keyword">char</span> *class, ...)</span></span></span><br></pre></td></tr></table></figure><p>第一个函数在可变参数列表中的char *元素外面的每一行都会输出一对td标签，第二个函数会在指定列数外面输出一对td标签；前者会自动添加一个”class=v”属性（到 td标签），后者允许传递一个自定义类名。当不在HTML中<br>输出的时候，两个函数将没有任何差别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_info_print_hr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><p>这种函数将在HTML中输出一个br标签，或者一个表示行开始和结束的水平线</p><p>我们常用的PHPWRITE()和php_printf()函数可以在在MINFO函数中使用，你应该注意正确的信息输出取决于当前的SAPI判断是用纯文本还是HTML的方式输出<br>要做到这一点，只需要检查sapi_module结构中的phpinfo_as_text属性，例子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINFO_FUNCTION(sample4) &#123;</span><br><span class="line">    php_info_print_table_start();</span><br><span class="line">    php_info_print_table_row(<span class="number">2</span>, <span class="string">"Sample4 Module"</span>, <span class="string">"enabled"</span>);</span><br><span class="line">    php_info_print_table_row(<span class="number">2</span>, <span class="string">"version"</span>, PHP_SAMPLE4_EXTVER);</span><br><span class="line">    <span class="keyword">if</span> (sapi_module.phpinfo_as_text) &#123;</span><br><span class="line">        <span class="comment">/* No HTML for you */</span></span><br><span class="line">        php_info_print_table_row(<span class="number">2</span>, <span class="string">"By"</span>,</span><br><span class="line">            <span class="string">"Example Technologies\nhttp://www.example.com"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* HTMLified version */</span></span><br><span class="line">        php_printf(<span class="string">"&lt;tr&gt;"</span></span><br><span class="line">            <span class="string">"&lt;td class=\"v\"&gt;By&lt;/td&gt;"</span></span><br><span class="line">            <span class="string">"&lt;td class=\"v\"&gt;"</span></span><br><span class="line">            <span class="string">"&lt;a href=\"http://www.example.com\""</span></span><br><span class="line">            <span class="string">" alt=\"Example Technologies\"&gt;"</span></span><br><span class="line">            <span class="string">"&lt;img src=\"http://www.example.com/logo.png\" /&gt;"</span></span><br><span class="line">            <span class="string">"&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    php_info_print_table_end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-3-常量"><a href="#12-3-常量" class="headerlink" title="12.3 常量"></a>12.3 常量</h1><p>在脚本中使用扩展的一个方便之处是，人们可以改变自己定义的常量。你可以通过define()函数来定义一个常量。在内核中，我们将会使用REGISTER_*_CONSTANT()的<br>家族函数来使用常量。</p><p>对于你定义的大多数常量来说，你可能希望在程序初始化的时候便定义这些变量。你可能需要在MINIT函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(sample4) &#123;</span><br><span class="line">    REGISTER_STRING_CONSTANT(<span class="string">"SAMPLE4_VERSION"</span>,</span><br><span class="line">            PHP_SAMPLE4_EXTVER, CONST_CS | CONST_PERSISTENT);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数是你要定义的这个常量的名字。在例子中，我们定义了一个名称为SAMPLE4_VERSION的常量。有一点很重要，这里要注意宏REGISTER_<em>_CONSTANT()的<br>使用，这些函数中为了确定常量的名称长度使用了sizeof()。这就意味着，常量的名称只能为文字，大家可以尝试使用一个char </em>的变量，这将导致sizeof计算出错误<br>的字符串长度。</p><p>接下来，我们来看看常量的值。在大多数情况下，它会是一个单一参数的类型，然而在STRINGL的版本中，你会看到在一些情况下会需要使用第二个参数来表明长度。<br>当注册string类型的常量时，字符串的值不会被复制到常量中，而仅仅是一个引用。这意味着，动态创建的字符串需要持久化和在shutdown的阶段被释放掉。</p><p>最后，在最后一个参数，你可以通过两个可以标识位的按位或组合传入。CONST_CS标识是否大小写敏感，一般情况下CONST_CS标识是默认使用的。对于一些特殊的<br>情况，比如TRUE,FALSE,NULL等等，这个参数将被省略。</p><p>在|后的标识位中的标识符说明了该常量的作用域和生命周期。当我们在MINIT中定义常量时，你可能需要在多个请求中使用这个常量，当你在RINIT中定义常量时，这个<br>常量会在当前请求结束的时候销毁。</p><p>下面列出的4个创建常量常用的函数，有一个共同需要注意的地方，常量名称一定要用文字而不是char *类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REGISTER_LONG_CONSTANT(<span class="keyword">char</span> *name, <span class="keyword">long</span> lval, <span class="keyword">int</span> flags)</span><br><span class="line">REGISTER_DOUBLE_CONSTANT(<span class="keyword">char</span> *name, <span class="keyword">double</span> dval, <span class="keyword">int</span> flags)</span><br><span class="line">REGISTER_STRING_CONSTANT(<span class="keyword">char</span> *name, <span class="keyword">char</span> *value, <span class="keyword">int</span> flags)</span><br><span class="line">REGISTER_STRINGL_CONSTANT(<span class="keyword">char</span> *name,<span class="keyword">char</span> *value, <span class="keyword">int</span> value_len, <span class="keyword">int</span> flags)</span><br></pre></td></tr></table></figure><p>如果你没有办法提供文本类型的name，那么你可以尝试使用上面4个函数的底层函数去实现相同的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_register_long_constant</span><span class="params">(<span class="keyword">char</span> *name, uint name_len, <span class="keyword">long</span> lval, <span class="keyword">int</span> flags, <span class="keyword">int</span> module_number TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_register_double_constant</span><span class="params">(<span class="keyword">char</span> *name, uint name_len, <span class="keyword">double</span> dval, <span class="keyword">int</span> flags, <span class="keyword">int</span> module_number TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_register_string_constant</span><span class="params">(<span class="keyword">char</span> *name, uint name_len, <span class="keyword">char</span> *strval, <span class="keyword">int</span> flags, <span class="keyword">int</span> module_number TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_register_stringl_constant</span><span class="params">(<span class="keyword">char</span> *name, uint name_len, <span class="keyword">char</span> *strval, uint <span class="built_in">strlen</span>, <span class="keyword">int</span> flags,<span class="keyword">int</span> module_number TSRMLS_DC)</span></span></span><br></pre></td></tr></table></figure><p>这样就可以由传入name_len而扩大了该族函数的使用范围(比如在循环中)。</p><p>module_number是一个加载扩展或者卸载扩展时的标识。而你不需要关注它，它会自动加载到你扩展中的MINIT和RINIT中，所以在你用上面4个函数声明常量的时候，<br>你可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(sample4) &#123;</span><br><span class="line">    register_string_constant(<span class="string">"SAMPLE4_VERSION"</span>,</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="string">"SAMPLE4_VERSION"</span>),</span><br><span class="line">                    PHP_SAMPLE4_EXTVER,</span><br><span class="line">                    CONST_CS | CONST_PERSISTENT,</span><br><span class="line">                    module_number TSRMLS_CC);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了数组和对象外，其他变量你也可以用来注册一个常量，但是因为没有宏和ZEND API去支持这些声明，所以你必须手动声明一个常量，通过下面一个例子来了解一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample4_register_boolean_constant</span><span class="params">(<span class="keyword">char</span> *name, uint len,</span></span></span><br><span class="line"><span class="function"><span class="params">            zend_bool bval, <span class="keyword">int</span> flags, <span class="keyword">int</span> module_number TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        zend_constant c;</span><br><span class="line"></span><br><span class="line">        ZVAL_BOOL(&amp;c.value, bval);</span><br><span class="line">        c.flags = CONST_CS | CONST_PERSISTENT;</span><br><span class="line">        c.name = zend_strndup(name, len - <span class="number">1</span>);</span><br><span class="line">        c.name_len = len;</span><br><span class="line">        c.module_number = module_number;</span><br><span class="line">        zend_register_constant(&amp;c TSRMLS_CC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-4-PHP扩展中的全局变量"><a href="#12-4-PHP扩展中的全局变量" class="headerlink" title="12.4 PHP扩展中的全局变量"></a>12.4 PHP扩展中的全局变量</h1><p>这一章，我们将学会如何在PHP扩展中使用全局变量。</p><p>在扩展中定义全局变量</p><p>首先，我们需要在扩展的头文件中(默认是php_*.h)中定义所有的全局变量。举个例子，比如我们要定义一个无符号的long类型的全局变量，我们可以这样定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_MODULE_GLOBALS(sample4)</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(sample4)</span><br></pre></td></tr></table></figure><p>用ZEND_BEGIN_MODULE_GLOBALS和ZEND_END_MODULE_GLOBALS宏将定义的全局变量包起来。将上例中的宏展开后，是下面这个样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_sample4_globals</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter;</span><br><span class="line">&#125; zend_sample4_globals;</span><br></pre></td></tr></table></figure><p>如果你还有其他的全局变量需要定义，只需加在两个宏之间就可以了。接下来我们该在simple4.c中声明我们在头文件中定义的这些全局变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZEND_DECLARE_MODULE_GLOBALS(sample4);</span><br></pre></td></tr></table></figure><p>这个宏的内部实现取决于是否启用了线程安全，在非线程安全的环境下，如：Apache1，Apache2-prefork, CGI，CLI…会使用zend_sample4_globals结构来定义<br>全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_sample4_globals sample4_globals;</span><br></pre></td></tr></table></figure><p>我们可以直接通过sample4_globals.counter来获取计数器的值。在线程安全的版本中，另一种方法是声明一个整数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sample4_globals_id;</span><br></pre></td></tr></table></figure><p>填充这个ID就等于定义了扩展中的全局变量。根据其定义的信息，将为每个新线程的独立存储空间分配内存块。我们可以在MINIT中这样定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line">    ts_allocate_id(</span><br><span class="line">            &amp;sample4_globals_id,</span><br><span class="line">            <span class="keyword">sizeof</span>(zend_sample4_globals),</span><br><span class="line">            <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>有一点需要注意这种方法需要包裹在#ifdef中，以防止它在没有启动Zend Thread Safety(ZTS)时执行。因为sample4_globals_id只能在多线程环境中使用。非线程<br>的版本用我们在前面提到的sample4_globals来声明全局变量。</p><p>线程中的初始化和关闭</p><p>在非线程的环境中，会将一个zend_sample4_globals结构的副本保存在指定进程中。你可以指定他的默认值，或者在MINIT或者RINIT中分配资源来初始化它。要记得<br>在对应的MSHUTDOWN或者RSHUTDOWN中及时释放这些资源。</p><p>然而在线程版本中，一个新的结构会在一个新线程spun的时候被分配。为了知道怎样初始化和关闭扩展中的全局变量，需要向ZE引擎提供回调函数。在前面我们在调用<br>ts_allocate_id()的时候是是以NULL来作为这个值的，接下来我们添加2个一会需要在MINIT调用的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_sample4_globals_ctor</span><span class="params">(zend_sample4_globals *sample4_globals TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize a new zend_sample4_globals struct</span></span><br><span class="line"><span class="comment">     * During thread spin-up */</span></span><br><span class="line">     sample4_globals-&gt;counter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_sample4_globals_dtor</span><span class="params">(zend_sample4_globals *sample4_globals TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Any resources allocated during initialization</span></span><br><span class="line"><span class="comment">     * May be freed here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在启用和关闭的时候调用它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(sample4) &#123;</span><br><span class="line">    REGISTER_STRING_CONSTANT(<span class="string">"SAMPLE4_VERSION"</span>, PHP_SAMPLE4_EXTVER, CONST_CS | CONST_PERSISTENT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line">    ts_allocate_id(&amp;sample4_globals_id,</span><br><span class="line">                        <span class="keyword">sizeof</span>(zend_sample4_globals),</span><br><span class="line">                        (ts_allocate_ctor)php_sample4_globals_ctor,</span><br><span class="line">                        (ts_allocate_dtor)php_sample4_globals_dtor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    php_sample4_globals_ctor(&amp;sample4_globals TSRMLS_CC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(sample4) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ZTS</span></span><br><span class="line">    php_sample4_globals_dtor(&amp;sample4_globals TSRMLS_CC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经知道如何在扩展中创建全局变量了，在不是ZTS的环境中，使用它们很简单，我们还来看前面定义的那个计数器的递增功能如何实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample4_counter) &#123;</span><br><span class="line">    RETURN_LONG(++sample4_globals.counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看起来很简单，但是，在线程版本中将无法正常工作。那么我们来看看怎么在线程环境中完成这个功能吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample4_counter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line">        RETURN_LONG(++TSRMG(sample4_globals_id, \</span><br><span class="line">                zend_sample4_globals*, counter));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">/* non-ZTS */</span></span><br><span class="line">        RETURN_LONG(++sample4_globals.counter);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很丑对吗？想象一下，在你的整个代码库中，这些IFDEF指令在每一个线程安全的全局访问时穿插。它会看起来比Perl更糟糕！这就是为什么所有<br>的核心扩展，都有使用一个额外的宏观层抽象这种情况。我们可以在php_sample4.h中找到下面这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TSRM.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMPLE4_G(v) TSRMG(sample4_globals_id, zend_sample4_globals*, v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMPLE4_G(v) (sample4_globals.v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>使用它们会让你的方法看起来更简洁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample4_counter) &#123;</span><br><span class="line">    RETURN_LONG(++SAMPLE4_G(counter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到*G()这样的宏是不是有种似曾相识的感觉？也许以前你看到过EG()、CG()等宏，了解他们会让你对PHP的了解更深一步：</p><table><thead><tr><th>Accessor Macro</th><th>Associated Data</th></tr></thead><tbody><tr><td>EG()</td><td>这个宏可以用来访问符号表，函数，资源信息和常量。</td></tr><tr><td>CG()</td><td>用来访问核心全局变量。</td></tr><tr><td>PG()</td><td>PHP全局变量。我们知道php.ini会映射一个或者多个PHP全局结构。举几个使用这个宏的例子：PG(register_globals), PG(safe_mode), PG(memory_limit)</td></tr><tr><td>FG()</td><td>文件全局变量。大多数文件I/O或相关的全局变量的数据流都塞进标准扩展出口结构。</td></tr></tbody></table><h1 id="12-5-PHP语言中的超级全局变量-Superglobals"><a href="#12-5-PHP语言中的超级全局变量-Superglobals" class="headerlink" title="12.5 PHP语言中的超级全局变量(Superglobals)"></a>12.5 PHP语言中的超级全局变量(Superglobals)</h1><p>在PHP中有一种“特殊”的全局变量，通常我们把它们称作超级全局变量，常见的比如<code>$_GET</code>、<code>$_POST</code>、<code>$_FILE</code>等等。</p><p>他们会在编译之前就声明，所以在普通的脚本中，可能无法定义其它的超级全局变量。在扩展中，最好的使用超级全局变量的是session扩展，它使用<code>$_SESSION</code>来<br>在<code>session_start()</code>和<code>session_write_close()</code>之间存储信息。那么是怎样定义<code>$_SESSION</code>这个超级全局变量的呢？我们来看下session扩展的<code>MINIT</code>函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(session) &#123;</span><br><span class="line">        zend_register_auto_global(<span class="string">"_SESSION"</span>,</span><br><span class="line">                            <span class="keyword">sizeof</span>(<span class="string">"_SESSION"</span>) - <span class="number">1</span>,</span><br><span class="line">                            <span class="literal">NULL</span> TSRMLS_CC);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的第二个参数，<code>sizeof(&quot;_SESSION&quot;) - 1</code>，一定要排除标识字符串结束的\0符。</p><p>我们一起来看下<code>zend_register_auto_global()</code>这个函数在ZE2中的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_register_auto_global</span><span class="params">(<span class="keyword">char</span> *name, uint name_len,</span></span></span><br><span class="line"><span class="function"><span class="params">            zend_auto_global_callback auto_global_callback TSRMLS_DC)</span></span></span><br></pre></td></tr></table></figure><p>在ZE1中，是没有<code>auto_global_callback</code>这个参数的。为了和PHP4兼容，我们仍需要像下面这样声明一个超级全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINIT_FUNCTION(sample4) &#123;</span><br><span class="line">        zend_register_auto_global(<span class="string">"_SAMPLE4"</span>, <span class="keyword">sizeof</span>(<span class="string">"_SAMPLE4"</span>) - <span class="number">1</span></span><br><span class="line">#ifdef ZEND_ENGINE_2</span><br><span class="line">                , <span class="literal">NULL</span></span><br><span class="line">#endif</span><br><span class="line">                TSRMLS_CC);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###全局变量的回调</p><p>在ZE2中，<code>zend_register_auto_global()</code>函数的<code>auto_global_callback</code>参数接受一个自定义函数。在实践中，这样的做法可以用来避免复杂的初始化，我们来<br>看下面这一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zend_bool <span class="title">php_sample4_autoglobal_callback</span><span class="params">(<span class="keyword">char</span> *name, uint name_len TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zval *sample4_val;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    MAKE_STD_ZVAL(sample4_val);</span><br><span class="line">    array_init(sample4_val);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        add_next_index_long(sample4_val, i);</span><br><span class="line">    &#125;</span><br><span class="line">    ZEND_SET_SYMBOL(&amp;EG(symbol_table), <span class="string">"_SAMPLE4"</span>, sample4_val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(sample4) &#123;</span><br><span class="line">    zend_register_auto_global(<span class="string">"_SAMPLE4"</span>, <span class="keyword">sizeof</span>(<span class="string">"_SAMPLE4"</span>) - <span class="number">1</span></span><br><span class="line">#ifdef ZEND_ENGINE_2</span><br><span class="line">                , php_sample4_autoglobal_callback</span><br><span class="line">#endif</span><br><span class="line">                TSRMLS_CC);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这样的设计打破了PHP4和ZE1的规则，它们不支持这样的回调。所以，为了兼容它们，我们要在每个脚本开始的时候去调用我们的回调函数(RINIT)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PHP_RINIT_FUNCTION(sample4) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZEND_ENGINE_2</span></span><br><span class="line">    php_sample4_autoglobal_callback(<span class="string">"_SAMPLE4"</span>,</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="string">"_SAMPLE4"</span>) - <span class="number">1</span>,</span><br><span class="line">                    TSRMLS_CC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-6-小结"><a href="#12-6-小结" class="headerlink" title="12.6 小结"></a>12.6 小结</h1><p>通过本章的课程，我们深入了解了PHP的生命周期，常量、全局变量和超级全局变量的定义和使用。在下一章中，你会学会如何声明和使用的php.ini值。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11 PHP中的面向对象（二）</title>
      <link href="/posts/5c6b7591.html"/>
      <url>/posts/5c6b7591.html</url>
      
        <content type="html"><![CDATA[<h1 id="11-PHP中的面向对象（二）"><a href="#11-PHP中的面向对象（二）" class="headerlink" title="11 PHP中的面向对象（二）"></a>11 PHP中的面向对象（二）</h1><p>上一章里，我们看了一下如何在PHP扩展里定义类与接口，那这一章里我们将入手学习一下如何在PHP扩展中操作类的实例————对象。<br>PHP语言中的面向对象其实是分为三个部分来实现的，class、object、refrence。class就是我们所说的类，可以直观的理解为前面章节中所描述的zend_class_entry。object就是实际的对象。每一个zval并不直接包含具体的object，而是通过一个索引–refrence与其联系。也就是说，每个class都有很多个object实例，并把他们统一的放在一个数组里，每个zval只要记住自己相应的key就行了。如此一来，我们在传递zval时候，实际上传递的是一个索引，而不是内存中具体的对象数据。</p><h1 id="11-1-PHP中的面向对象（二）"><a href="#11-1-PHP中的面向对象（二）" class="headerlink" title="11.1 PHP中的面向对象（二）"></a>11.1 PHP中的面向对象（二）</h1><p>为了操作一个对象，我们需要先获取这个对象的实例，而这肯定会涉及调用对象的构造方法。有关如何在扩展中调用PHP的函数与对象的方法这里不展开描述了。<br>首先我们先了解下一个object在PHP内核中到底是如何实现的。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_object_value</span> &#123;</span></span><br><span class="line">zend_object_handle handle;</span><br><span class="line">zend_object_handlers *handlers;</span><br><span class="line">&#125; zend_object_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此外再回顾一下zval的值value的结构。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value &#123;</span><br><span class="line"><span class="keyword">long</span> lval;<span class="comment">/* long value */</span></span><br><span class="line"><span class="keyword">double</span> dval;<span class="comment">/* double value */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *val;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">&#125; str;</span><br><span class="line">HashTable *ht;<span class="comment">/* hash table value */</span></span><br><span class="line">zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><p></p><p>如果我们有一个zval *tmp，那么tmp-&gt;value.obj来访问到最终保存对象实例的zend_object_value结构体，它包含两个成员：</p><p></p><ul><br><li>zend_object_handle handle：最终实现是一个unsigned int值，Zend会把每个对象放进数组里，这个handle就是此实例的索引。所以我们在把对象当作参数传递时，只不过是传递的handle罢了，这样对性能有利，同时也是对象的引用机制的原理。</li><br><li>zend_object_handlers *handlers：这个里面是一组函数指针，我们可以通过它来对对象进行一些操作，比如：添加引用、获取属性等。此结构体在Zend/zend_object_handlers.h里定义。</li><br></ul><br>下面我给出这个类的PHP语言实现，让我们在扩展中实现它，并生成它。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baby</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"a new baby!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"hello world!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_call</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$obj = <span class="keyword">new</span> baby();</span><br><span class="line">$obj-&gt;hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面我们在扩展中实现以上test_call函数。</p><p><strong>Note:</strong>关于下面walu_call_user_function()的说明：内核中并不存在该函数，可以在<a href="https://github.com/wosiwo/clinq/blob/41c2c32e1837a23231c3b124dd84c29d03922e97/alinq.c" target="_blank" rel="noopener">这里</a>找到该函数的定义，直接拷贝过来用即可。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">zend_class_entry *baby_ce;</span><br><span class="line"></span><br><span class="line">ZEND_FUNCTION(test_call)</span><br><span class="line">&#123;</span><br><span class="line">zval *obj;</span><br><span class="line">MAKE_STD_ZVAL(obj);</span><br><span class="line">object_init_ex(obj, baby_ce);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果确认此类没有构造函数就不用调用了。</span></span><br><span class="line">walu_call_user_function(<span class="literal">NULL</span>, obj, <span class="string">"__construct"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">walu_call_user_function(<span class="literal">NULL</span>, obj, <span class="string">"hello"</span>, <span class="string">""</span>);</span><br><span class="line">zval_ptr_dtor(&amp;obj);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZEND_METHOD(baby, __construct)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a new baby!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZEND_METHOD(baby, hello)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world!!!!!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> zend_function_entry baby_method[]=&#123;</span><br><span class="line">ZEND_ME(baby, __construct, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)</span><br><span class="line">ZEND_ME(baby, hello, <span class="literal">NULL</span>, ZEND_ACC_PUBLIC)</span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ZEND_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">zend_class_entry ce;</span><br><span class="line">INIT_CLASS_ENTRY(ce, <span class="string">"baby"</span>, baby_method);</span><br><span class="line">baby_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重新编译，执行命令查看是否生效~</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">php</span> -r <span class="string">"test_call();"</span></span><br></pre></td></tr></table></figure><h1 id="11-2-PHP中的面向对象（二）"><a href="#11-2-PHP中的面向对象（二）" class="headerlink" title="11.2 PHP中的面向对象（二）"></a>11.2 PHP中的面向对象（二）</h1><p>在上一节里我们已经看了下如何操作一个对象的方法，这一节主要描述与对象属性有关的东西。有关如何对它进行定义的操作我们已经在上一章中描述过了，这里不再叙述，只讲对其的操作。</p><h2 id="读取对象的属性"><a href="#读取对象的属性" class="headerlink" title="读取对象的属性"></a>读取对象的属性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEND_API zval *<span class="title">zend_read_property</span><span class="params">(zend_class_entry *scope, zval *object, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, zend_bool silent TSRMLS_DC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ZEND_API zval *<span class="title">zend_read_static_property</span><span class="params">(zend_class_entry *scope, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, zend_bool silent TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p>zend_read_property函数用于读取对象的属性，而zend_read_static_property则用于读取静态属性。可以看出，静态属性是直接保存在类上的，与具体的对象无关。<br>silent参数：</p><p></p><ul><br><li>0: 如果属性不存在，则抛出一个notice错误。</li><br><li>1: 如果属性不存在，不报错。</li><br></ul><br>如果所查的属性不存在，那么此函数将返回IS_NULL类型的zval。<p></p><h3 id="更新对象的属性"><a href="#更新对象的属性" class="headerlink" title="更新对象的属性"></a>更新对象的属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">zend_update_property</span><span class="params">(zend_class_entry *scope, zval *object, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, zval *value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_update_static_property</span><span class="params">(zend_class_entry *scope, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, zval *value TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p>zend_update_property用来更新对象的属性，zend_update_static_property用来更新类的静态属性。如果对象或者类中没有相关的属性，函数将自动的添加上。</p><h3 id="读写对象与类属性的实例"><a href="#读写对象与类属性的实例" class="headerlink" title="读写对象与类属性的实例"></a>读写对象与类属性的实例</h3><p>假设我们已经在扩展中定义好下面的类：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baby</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $age;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> $area;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($age, $area)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line"><span class="keyword">self</span>::$area = $area;</span><br><span class="line"></span><br><span class="line">var_dump(<span class="keyword">$this</span>-&gt;age, <span class="keyword">self</span>::$area);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZEND_METHOD(baby, __construct)</span><br><span class="line">&#123;</span><br><span class="line">zval *age, *area;</span><br><span class="line">zend_class_entry *ce;</span><br><span class="line">ce = Z_OBJCE_P(getThis());</span><br><span class="line"><span class="keyword">if</span>( zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"zz"</span>, &amp;age, &amp;area) == FAILURE )</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"Error\n"</span>);</span><br><span class="line">RETURN_NULL();</span><br><span class="line">&#125;</span><br><span class="line">zend_update_property(ce, getThis(), <span class="string">"age"</span>, sizeof(<span class="string">"age"</span>)<span class="number">-1</span>, age TSRMLS_CC);</span><br><span class="line">zend_update_static_property(ce, <span class="string">"area"</span>, sizeof(<span class="string">"area"</span>)<span class="number">-1</span>, area TSRMLS_CC);</span><br><span class="line"></span><br><span class="line">age = <span class="keyword">NULL</span>;</span><br><span class="line">area = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">age = zend_read_property(ce, getThis(), <span class="string">"age"</span>, sizeof(<span class="string">"age"</span>)<span class="number">-1</span>, <span class="number">0</span> TSRMLS_DC);</span><br><span class="line">php_var_dump(&amp;age, <span class="number">1</span> TSRMLS_CC);</span><br><span class="line"></span><br><span class="line">area = zend_read_static_property(ce, <span class="string">"area"</span>, sizeof(<span class="string">"area"</span>)<span class="number">-1</span>, <span class="number">0</span> TSRMLS_DC);</span><br><span class="line">php_var_dump(&amp;area, <span class="number">1</span> TSRMLS_CC);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为类添加age 和 area属性</span></span><br><span class="line">PHP_MINIT_FUNCTION(say_hello)</span><br><span class="line">&#123;</span><br><span class="line">    zend_class_entry ce;</span><br><span class="line">    INIT_CLASS_ENTRY(ce,<span class="string">"baby"</span>,myclass_method);</span><br><span class="line">    baby_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);</span><br><span class="line"></span><br><span class="line">    zend_declare_property_null(baby_ce, <span class="string">"age"</span>, strlen(<span class="string">"age"</span>), ZEND_ACC_PUBLIC TSRMLS_CC);</span><br><span class="line">    zend_declare_property_null(baby_ce, <span class="string">"area"</span>, strlen(<span class="string">"area"</span>), ZEND_ACC_STATIC|ZEND_ACC_PUBLIC TSRMLS_CC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><div class="tip-common"><br>感谢 <a href="http://weibo.com/taokuizu" target="_blank" rel="noopener">@看你取的破名</a> 发现的错误。<br></div><p></p><h3 id="一些其它的快捷函数"><a href="#一些其它的快捷函数" class="headerlink" title="一些其它的快捷函数"></a>一些其它的快捷函数</h3><h4 id="更新对象与类的属性"><a href="#更新对象与类的属性" class="headerlink" title="更新对象与类的属性"></a>更新对象与类的属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">zend_update_property_null</span><span class="params">(zend_class_entry *scope, zval *object, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">zend_update_property_bool</span><span class="params">(zend_class_entry *scope, zval *object, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">long</span> value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">zend_update_property_long</span><span class="params">(zend_class_entry *scope, zval *object, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">long</span> value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">zend_update_property_double</span><span class="params">(zend_class_entry *scope, zval *object, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">double</span> value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">zend_update_property_string</span><span class="params">(zend_class_entry *scope, zval *object, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">const</span> <span class="keyword">char</span> *value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">zend_update_property_stringl</span><span class="params">(zend_class_entry *scope, zval *object, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> value_length TSRMLS_DC)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_update_static_property_null</span><span class="params">(zend_class_entry *scope, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_update_static_property_bool</span><span class="params">(zend_class_entry *scope, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">long</span> value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_update_static_property_long</span><span class="params">(zend_class_entry *scope, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">long</span> value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_update_static_property_double</span><span class="params">(zend_class_entry *scope, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">double</span> value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_update_static_property_string</span><span class="params">(zend_class_entry *scope, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">const</span> <span class="keyword">char</span> *value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_update_static_property_stringl</span><span class="params">(zend_class_entry *scope, <span class="keyword">char</span> *name, <span class="keyword">int</span> name_length, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> value_length TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="11-3-PHP中的面向对象（二）"><a href="#11-3-PHP中的面向对象（二）" class="headerlink" title="11.3 PHP中的面向对象（二）"></a>11.3 PHP中的面向对象（二）</h1><p>有关面向对象的资料实在是太多了，我也是才学而已，没有办法给出非常系统、完整的阐述，但以后我会陆陆续续的在博客里写出来的。此外，强烈建议大家看看php官方的这篇wiki。<br><a href="https://wiki.php.net/internals/engine/objects" target="_blank" rel="noopener">internals:engine:objects</a></p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 PHP中的面向对象（一）</title>
      <link href="/posts/9da79ce3.html"/>
      <url>/posts/9da79ce3.html</url>
      
        <content type="html"><![CDATA[<h1 id="10-PHP中的面向对象（一）"><a href="#10-PHP中的面向对象（一）" class="headerlink" title="10 PHP中的面向对象（一）"></a>10 PHP中的面向对象（一）</h1><p>面向对象的概念这里就不再叙述了。原书中把这一部分的知识分开到PHP4和PHP5中来讲的，这里我做了大幅的调整，几乎是进行了重写。前一部分主要介绍了如何定义类、接口等一些声明类的操作。后一部分主要介绍了对象的使用等一些对实例的操作。</p><h1 id="10-1-PHP中的面向对象（一）"><a href="#10-1-PHP中的面向对象（一）" class="headerlink" title="10.1 PHP中的面向对象（一）"></a>10.1 PHP中的面向对象（一）</h1><p>zend_class_entry是内核中定义的一个结构体，是内核实现PHP语言中类与对象的一个非常基础、关键的结构类型。他就相当于我们定义的类的原型。<br>如果我们想获得一个名字为myclass的类该怎么做呢？首先我们定义一个zend_class_entry变量，并为它设置名字，最后注册到runtime中去。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zend_class_entry *myclass_ce;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> zend_function_entry myclass_method[] = &#123;</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ZEND_MINIT_FUNCTION(sample3)</span><br><span class="line">&#123;</span><br><span class="line">    zend_class_entry ce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//"myclass"是这个类的名称。</span></span><br><span class="line">    INIT_CLASS_ENTRY(ce, <span class="string">"myclass"</span>,myclass_method);</span><br><span class="line">    myclass_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样我们便定义了一个类myclass，而且我们可以正常的在PHP语言中使用它，比如：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$obj = <span class="keyword">new</span> myclass();</span><br></pre></td></tr></table></figure><p></p><p>我们上面还定义了一个myclass_ce指针，他是干什么用的呢？当我们在扩展中对这个类进行操作，比如生成实例的时候，会使用到它，它的作用就类似于打开文件的操作句柄。</p><h1 id="10-2-PHP中的面向对象（一）"><a href="#10-2-PHP中的面向对象（一）" class="headerlink" title="10.2 PHP中的面向对象（一）"></a>10.2 PHP中的面向对象（一）</h1><p>在这一节中，我们正式的定义一个类。首先我给出PHP语言的实现：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $public_var;</span><br><span class="line"><span class="keyword">private</span> $private_var;</span><br><span class="line"><span class="keyword">protected</span> $protected_var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> $static_var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"我是__construct方法\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">public_method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"我是public类型的方法\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">private_method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"我是private类型的方法\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">protected_method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"我是protected类型的方法\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">static_var</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"我是static类型的方法\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="定义类对应的zend-class-entry"><a href="#定义类对应的zend-class-entry" class="headerlink" title="定义类对应的zend_class_entry"></a>定义类对应的zend_class_entry</h3><p>定义类的第一步，便是先定义好这个类的zend_class_entry，这一步操作是在MINIT阶段完成的。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_function_entry myclass_method[]=</span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">zend_class_entry ce;</span><br><span class="line">INIT_CLASS_ENTRY(ce,<span class="string">"myclass"</span>,myclass_method);</span><br><span class="line">zend_register_internal_class(&amp;ce TSRMLS_CC);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这就是最简单的一个类，没有属性没有方法，但是可以使用了</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;?php</span></span><br><span class="line"><span class="comment">$obj = new myclass();</span></span><br><span class="line"><span class="comment">var_dump($obj);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//得到：object(myclass)#1 (0) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>某个类的zend_class_entry会经常用到，所以我们一般会把它保存在一个变量里，供扩展中其它地方的程序使用，所以上述的代码组合一般是这样的：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">zend_class_entry *myclass_ce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> zend_function_entry myclass_method[]=&#123;</span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ZEND_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">zend_class_entry ce;</span><br><span class="line">INIT_CLASS_ENTRY(ce,<span class="string">"myclass"</span>,myclass_method);</span><br><span class="line">myclass_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="为类定义属性"><a href="#为类定义属性" class="headerlink" title="为类定义属性"></a>为类定义属性</h3><p>我们可以用zend_declare_property*系列函数来完成这项操作，为某个类定义属性一般会需要三个信息：</p><p></p><ul><br><li>属性的名称</li><br><li>属性的默认值</li><br><li>属性的访问权限等</li><br></ul><br>我们为上面的myclass类定义一个名为“public_var”的属性，默认值为null，访问权限为public。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZEND_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">zend_class_entry ce;</span><br><span class="line">INIT_CLASS_ENTRY(ce,<span class="string">"myclass"</span>,myclass_method);</span><br><span class="line"></span><br><span class="line">myclass_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义属性</span></span><br><span class="line">zend_declare_property_null(myclass_ce, <span class="string">"public_var"</span>, <span class="built_in">strlen</span>(<span class="string">"public_var"</span>), ZEND_ACC_PUBLIC TSRMLS_CC);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>ZEND_ACC_PUBLIC是ZEND_ACC系列掩码中的一个，代表着public，其余的还有ZEND_ACC_PRIVATE,ZEND_ACC_PROTECTED等等，详细描述请见后面的章节。这三个掩码比较简单，就不再叙述了。</p><h3 id="为类定义方法"><a href="#为类定义方法" class="headerlink" title="为类定义方法"></a>为类定义方法</h3><p>为类定义方法比较繁琐一些，首先我们先回顾一下zend_function_entry结构，在以前我们用它来保存我们扩展的函数，通过它把PHP语言中的函数和我们用C语言编写的函数联系起来，在这它也发挥了这么一个桥梁的作用。下面我们实现myclass类的public_method()和构造方法。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先，定义这个函数的C语言部分，不过这一次我们使用的是ZEND_METHOD</span></span><br><span class="line">ZEND_METHOD( myclass , public_method )</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"我是public类型的方法\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZEND_METHOD( myclass , __construct )</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"我是__construct方法\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后，用PHP_METHOD声明public_method和__construct。</span></span><br><span class="line"></span><br><span class="line">PHP_METHOD(myclass, public_method);</span><br><span class="line">PHP_METHOD(myclass, __construct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再定义一个zend_function_entry</span></span><br><span class="line">zend_function_entry myclass_method[]=</span><br><span class="line">&#123;</span><br><span class="line">ZEND_ME(myclass,public_method,<span class="literal">NULL</span>,ZEND_ACC_PUBLIC)</span><br><span class="line">ZEND_ME(myclass,__construct,<span class="literal">NULL</span>,ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)</span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后，在MINIT阶段register internal class的时候将它作为一个参数传递进去</span></span><br><span class="line">ZEND_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">zend_class_entry ce;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里使用了myclass_method这个zend_function_entry</span></span><br><span class="line">INIT_CLASS_ENTRY(ce,<span class="string">"myclass"</span>,myclass_method);</span><br><span class="line"></span><br><span class="line">myclass_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在我们在PHP脚本中调用一下这个方法，看看输出结果：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$obj = <span class="keyword">new</span> myclass();</span><br><span class="line">$obj-&gt;public_method();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">walu<span class="doctag">@walu</span>-ThinkPad-Edge:/cnan/program/php-5.3.6/ext/test$ php test.php</span></span><br><span class="line"><span class="comment">我是__construct方法</span></span><br><span class="line"><span class="comment">我是public_method方法</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>这里在定义__construct方法的时候，使用到了ZEND_ACC_CTOR，它的作用便是声明这个方法是此类的构造函数，而ZEND_ACC_PUBLIC|ZEND_ACC_CTOR是我们常见的掩码或运算，代表它是一个public类型构造函数，:-)。如果我们去掉ZEND_ACC_CTOR标志，那么此构造函数还会起作用吗？在这里的例子中它仍然起作用，但是在别的环境下我就不敢保证了。<br>说到现在，protected和private类型的属性与方法的定义和public的一样。而定义static的属性与方法只是在掩码标志中加入ZEND_ACC_STATIC即可。<br>下面详细的罗列出了所有掩码，fn_flags代表可以在定义方法时使用，zend_property_info.flags代表可以在定义属性时使用，ce_flags代表在定义zend_class_entry时候可用。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_STATIC                     0x01     <span class="comment">/* fn_flags, zend_property_info.flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_ABSTRACT                   0x02     <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_FINAL                      0x04     <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_IMPLEMENTED_ABSTRACT       0x08     <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_IMPLICIT_ABSTRACT_CLASS    0x10     <span class="comment">/* ce_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_EXPLICIT_ABSTRACT_CLASS    0x20     <span class="comment">/* ce_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_FINAL_CLASS                0x40     <span class="comment">/* ce_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_INTERFACE                  0x80     <span class="comment">/* ce_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_INTERACTIVE                0x10     <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_PUBLIC                     0x100    <span class="comment">/* fn_flags, zend_property_info.flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_PROTECTED                  0x200    <span class="comment">/* fn_flags, zend_property_info.flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_PRIVATE                    0x400    <span class="comment">/* fn_flags, zend_property_info.flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_PPP_MASK(ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_CHANGED                    0x800    <span class="comment">/* fn_flags, zend_property_info.flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_IMPLICIT_PUBLIC            0x1000   <span class="comment">/* zend_property_info.flags; unused (1) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_CTOR                       0x2000   <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_DTOR                       0x4000   <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_CLONE                      0x8000   <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_ALLOW_STATIC               0x10000  <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_SHADOW                     0x20000  <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_DEPRECATED                 0x40000  <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_CLOSURE                    0x100000 <span class="comment">/* fn_flags */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ACC_CALL_VIA_HANDLER           0x200000 <span class="comment">/* fn_flags */</span></span></span><br></pre></td></tr></table></figure><p></p><p>ZEND_ACC_CTOR与ZEND_ACC_DTOR是比较特殊的掩码标志，分别代表着构造函数与析构函数，不要将这两个标志位用在其它的方法上面。其它的一些魔术方法，如<strong>get,</strong>call等大都需要arginfo，有关它们的内容将在下一章中描述。</p><h3 id="为类定义常量"><a href="#为类定义常量" class="headerlink" title="为类定义常量"></a>为类定义常量</h3><p>这个内容比较简单，只涉及到一组函数，可以查看Zend/zend_API.h<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_declare_class_constant</span><span class="params">(zend_class_entry *ce, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> name_length, zval *value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_declare_class_constant_null</span><span class="params">(zend_class_entry *ce, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> name_length TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_declare_class_constant_long</span><span class="params">(zend_class_entry *ce, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> name_length, <span class="keyword">long</span> value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_declare_class_constant_bool</span><span class="params">(zend_class_entry *ce, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> name_length, zend_bool value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_declare_class_constant_double</span><span class="params">(zend_class_entry *ce, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> name_length, <span class="keyword">double</span> value TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_declare_class_constant_stringl</span><span class="params">(zend_class_entry *ce, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> name_length, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">size_t</span> value_length TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_declare_class_constant_string</span><span class="params">(zend_class_entry *ce, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> name_length, <span class="keyword">const</span> <span class="keyword">char</span> *value TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><h1 id="10-3-PHP中的面向对象（一）"><a href="#10-3-PHP中的面向对象（一）" class="headerlink" title="10.3 PHP中的面向对象（一）"></a>10.3 PHP中的面向对象（一）</h1><p>定义一个接口还是很方便的，我先给出一个PHP语言中的形式。<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">i_myinterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>那它在扩展中的实现是这样的。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zend_class_entry *i_myinterface_ce;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> zend_function_entry i_myinterface_method[]=&#123;</span><br><span class="line">ZEND_ABSTRACT_ME(i_myinterface, hello, <span class="literal">NULL</span>) <span class="comment">//注意这里的null指的是arginfo</span></span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ZEND_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">zend_class_entry ce;</span><br><span class="line">INIT_CLASS_ENTRY(ce, <span class="string">"i_myinterface"</span>, i_myinterface_method);</span><br><span class="line"></span><br><span class="line">i_myinterface_ce = zend_register_internal_interface(&amp;ce TSRMLS_CC);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们使用ZEND_ABSTRACT_ME()宏函数来为这个接口添加函数，它的作用是声明一个类似虚函数的东西，不用实现。也就是说我们不用为其添加ZEND_METHOD(i_myinterface,hello){…}的实现。但是这个宏函数只能为我们实现public类型函数的声明，如果有其它特殊需要，需要使用ZEND_FENTRY()宏函数来实现，因为ZEND_ABSTRACT_ME只不过是后者的一种封装。<br>下面我们在PHP语言中使用这个接口<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span> <span class="keyword">implements</span> <span class="title">i_myinterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $name = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name.<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> sample();</span><br><span class="line">$obj-&gt;hello();</span><br></pre></td></tr></table></figure><p></p><h1 id="10-4-PHP中的面向对象（一）"><a href="#10-4-PHP中的面向对象（一）" class="headerlink" title="10.4 PHP中的面向对象（一）"></a>10.4 PHP中的面向对象（一）</h1><p>在定义一个类时往往会使其继承某个父类或者实现某个接口，在扩展中实现这个功能非常方便。下面我先给出PHP语言中的代码。<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">i_myinterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">parent_class</span> <span class="keyword">implements</span> <span class="title">i_myinterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Good Morning!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">myclass</span> <span class="keyword">extends</span> <span class="title">parent_class</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">call_hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;hello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码我们已经非常熟悉了，它们在PHP扩展中的实现应该是这样的：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//三个zend_class_entry</span></span><br><span class="line">zend_class_entry *i_myinterface_ce,*parent_class_ce,*myclass_ce;</span><br><span class="line"></span><br><span class="line"><span class="comment">//parent_class的hello方法</span></span><br><span class="line">ZEND_METHOD(parent_class,hello)</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"hello world!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//myclass的call_hello方法</span></span><br><span class="line">ZEND_METHOD(myclass,call_hello)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里涉及到如何调用对象的方法，详细内容下一章叙述</span></span><br><span class="line">zval *this_zval;</span><br><span class="line">this_zval = getThis();</span><br><span class="line">zend_call_method_with_0_params(&amp;this_zval,myclass_ce,<span class="literal">NULL</span>,<span class="string">"hello"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//各自的zend_function_entry</span></span><br><span class="line"><span class="keyword">static</span> zend_function_entry i_myinterface_method[]=&#123;</span><br><span class="line">ZEND_ABSTRACT_ME(i_myinterface,hello,<span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> zend_function_entry parent_class_method[]=&#123;</span><br><span class="line">ZEND_ME(parent_class,hello,<span class="literal">NULL</span>,ZEND_ACC_PUBLIC)</span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> zend_function_entry myclass_method[]=&#123;</span><br><span class="line">ZEND_ME(myclass,call_hello,<span class="literal">NULL</span>,ZEND_ACC_PUBLIC)</span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ZEND_MINIT_FUNCTION(test)</span><br><span class="line">&#123;</span><br><span class="line">zend_class_entry ce,p_ce,i_ce;</span><br><span class="line">INIT_CLASS_ENTRY(i_ce,<span class="string">"i_myinterface"</span>,i_myinterface_method);</span><br><span class="line">i_myinterface_ce = zend_register_internal_interface(&amp;i_ce TSRMLS_CC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义父类，最后使用zend_class_implements函数声明它实现的接口</span></span><br><span class="line">INIT_CLASS_ENTRY(p_ce,<span class="string">"parent_class"</span>,parent_class_method);</span><br><span class="line">parent_class_ce = zend_register_internal_class(&amp;p_ce TSRMLS_CC);</span><br><span class="line">zend_class_implements(parent_class_ce TSRMLS_CC,<span class="number">1</span>,i_myinterface_ce);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类，使用zend_register_internal_class_ex函数</span></span><br><span class="line">INIT_CLASS_ENTRY(ce,<span class="string">"myclass"</span>,myclass_method);</span><br><span class="line">myclass_ce = zend_register_internal_class_ex(&amp;ce,parent_class_ce,<span class="string">"parent_class"</span> TSRMLS_CC);</span><br><span class="line"><span class="comment">//注意：ZEND_ACC_FINAL是用来修饰方法的，而ZEND_ACC_FINAL_CLASS是用来修饰类的</span></span><br><span class="line">myclass_ce-&gt;ce_flags |= ZEND_ACC_FINAL_CLASS;</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样，当我们在PHP语言中进行如下操作时，便会得到预期的输出：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$obj = <span class="keyword">new</span> myclass();</span><br><span class="line">$obj-&gt;hello();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出内容：</span></span><br><span class="line"><span class="comment">walu<span class="doctag">@walu</span>-ThinkPad-Edge:/cnan/program/php-5.3.6/ext/test$ php test.php</span></span><br><span class="line"><span class="comment">hello world!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>这里的ZEND_ABSTRACT_ME()宏函数比较特殊，它会声明一个abstract public类型的函数，这个函数不需要我们实现，因此也就不需要相应的ZEND_METHOD(i_myinterface,hello){…}的实现。一般来说，一个接口是不能设计出某个非public类型的方法的，因为接口暴露给使用者的都应该是一些公开的信息。不过如果你非要这么设计，那也不是办不到，只要别用ZEND_ABSTRACT_ME()宏函数就行了，而用它的底层实现ZEND_FN()宏函数<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它可以对应&lt;?php ...public static function apply_request();...的接口方法声明。</span></span><br><span class="line"><span class="keyword">static</span> zend_function_entry i_myinterface[]=</span><br><span class="line">&#123;</span><br><span class="line">ZEND_FENTRY(apply_request, <span class="literal">NULL</span>, <span class="literal">NULL</span>, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)</span><br><span class="line">&#123;<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>这样，只要掩码中有ZEND_ACC_ABSTRACT，便代表是一个不需要具体实现的方法。ZEND_FENTRY其实是ZEND_ME和ZEND_FE的最终实现，现在我们把这一组宏罗列在这一次展开，供你参考使用。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FENTRY(zend_name, name, arg_info, flags)&#123; #zend_name, name, arg_info, (zend_uint) (sizeof(arg_info)/sizeof(struct _zend_arg_info)-1), flags &#125;,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FN(name) zif_##name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_MN(name) zim_##name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FE(name, arg_info)ZEND_FENTRY(name, ZEND_FN(name), arg_info, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ME(classname, name, arg_info, flags)ZEND_FENTRY(name, ZEND_MN(classname##_##name), arg_info, flags)</span></span><br></pre></td></tr></table></figure><p></p><h1 id="10-5-PHP中的面向对象（一）"><a href="#10-5-PHP中的面向对象（一）" class="headerlink" title="10.5 PHP中的面向对象（一）"></a>10.5 PHP中的面向对象（一）</h1><p>这一章是我自己写的，如果有什么错误，还请大家指正。这章主要介绍了类与接口的定义，在下一章将看一下如何对类进行操作，比如调用方法、修改属性等。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9 PHP中的资源类型</title>
      <link href="/posts/3610f3f6.html"/>
      <url>/posts/3610f3f6.html</url>
      
        <content type="html"><![CDATA[<h1 id="9-PHP中的资源类型"><a href="#9-PHP中的资源类型" class="headerlink" title="9 PHP中的资源类型"></a>9 PHP中的资源类型</h1><p>截止到现在，我们已经熟悉了PHP语言中的字符串、数字、布尔以及数组的数据类型了，接下来，我们将接触另外一种PHP独特的数据类型——资源（Resource）。</p><h1 id="9-1-PHP中的资源类型"><a href="#9-1-PHP中的资源类型" class="headerlink" title="9.1 PHP中的资源类型"></a>9.1 PHP中的资源类型</h1><div class="tip-common"><br>讲述之前，先描述下{资源}类型在内核中的结构：<br></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一个资源都是通过它来实现的。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_rsrc_list_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line"><span class="keyword">int</span> type;</span><br><span class="line"><span class="keyword">int</span> refcount;</span><br><span class="line">&#125;zend_rsrc_list_entry;</span><br></pre></td></tr></table></figure><br><br>在真实世界中，我们经常需要操作一些不好用标量值表现的数据，比如某个文件的句柄，而对于C来说，它也仅仅是个指针而已。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fd;</span><br><span class="line">fd = fopen(<span class="string">"/home/jdoe/.plan"</span>, <span class="string">"r"</span>);</span><br><span class="line">fclose(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>C语言中stdio的文件描述符(file descriptor)是与每个打开的文件相匹配的一个变量，它实际上是一个FILE类型的指针，它将在程序与硬件交互通讯时使用。我们可以使用fopen函数来打开一个文件获取句柄，之后只需把这个句柄传递给feof()、fread()、fwrite()、fclose()之类的函数，便可以对这个文件进行后续操作了。既然这个数据在C语言中就无法直接用标量数据来表示，那我们如何对其进行封装才能保证用户在PHP语言中也能使用到它呢？这便是PHP中资源类型变量的作用了！所以它也是通过一个zval结构来进行封装的。<br>资源类型的实现并不复杂，它的值其实仅仅是一个整数，内核将根据这个整数值去一个类似资源池的地方寻找最终需要的数据。<br>### 资源类型变量的使用<br>资源类型的变量在实现中也是有类型区分的！为了区分不同类型的资源，比如一个是文件句柄，一个是mysql链接，我们需要为其赋予不同的分类名称。首先，我们需要先把这个分类添加到程序中去。这一步的操作可以在MINIT中来做：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_SAMPLE_DESCRIPTOR_RES_NAME <span class="meta-string">"山寨文件描述符"</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> le_sample_descriptor;</span><br><span class="line">ZEND_MINIT_FUNCTION(sample)</span><br><span class="line">&#123;</span><br><span class="line">le_sample_descriptor = zend_register_list_destructors_ex(<span class="literal">NULL</span>, <span class="literal">NULL</span>, PHP_SAMPLE_DESCRIPTOR_RES_NAME,module_number);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//附加资料</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> register_list_destructors(ld, pld) zend_register_list_destructors((void (*)(void *))ld, (void (*)(void *))pld, module_number);</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_register_list_destructors</span><span class="params">(<span class="keyword">void</span> (*ld)(<span class="keyword">void</span> *), <span class="keyword">void</span> (*pld)(<span class="keyword">void</span> *), <span class="keyword">int</span> module_number)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_register_list_destructors_ex</span><span class="params">(<span class="keyword">rsrc_dtor_func_t</span> ld, <span class="keyword">rsrc_dtor_func_t</span> pld, <span class="keyword">char</span> *type_name, <span class="keyword">int</span> module_number)</span></span>;</span><br></pre></td></tr></table></figure><br><br>接下来，我们把定义好的MINIT阶段的函数添加到扩展的module_entry里去，只需要把原来的”NULL, /<em> MINIT </em>/“一行替换掉即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZEND_MINIT(sample), <span class="comment">/* MINIT */</span></span><br></pre></td></tr></table></figure><br><br>ZEND_MINIT_FUNCTION()宏用来帮助我们定义MINIT阶段的函数，这我们已经在第一章里描述过了，但将会在第12章和第三章有更详细的描述。<br>What’s important to know at this juncture is that the MINIT method is executed once when your extension is first loaded and before any requests have been received. Here you’ve used that opportunity to register destructor functionsthe NULL values, which you’ll change soon enoughfor a resource type that will be thereafter known by a unique integer ID.<br>看到zend_register_list_destructors_ex()函数，你肯定会想是不是也存在一个zend_register_list_destructors()函数呢？是的，确实有这么一个函数，它的参数中比前者少了资源类别的名称。那这两这的区别在哪呢？<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eaco $re_1;</span><br><span class="line"><span class="comment">//resource(4) of type (山寨版File句柄)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $re_2;</span><br><span class="line"><span class="comment">//resource(4) of type (Unknown)</span></span><br></pre></td></tr></table></figure><br><br>### 创建资源<br>我们在上面向内核中注册了一种新的资源类型，下一步便可以创建这种类型的资源变量了。接下来让我们简单的重新实现一个fopen函数，现在叫sample_open：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample_fopen)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">char</span> *filename, *mode;</span><br><span class="line"><span class="keyword">int</span> filename_len, mode_len;</span><br><span class="line"><span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"ss"</span>,&amp;filename, &amp;filename_len,&amp;mode, &amp;mode_len) == FAILURE)</span><br><span class="line">    &#123;</span><br><span class="line">RETURN_NULL();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!filename_len || !mode_len)</span><br><span class="line">&#123;</span><br><span class="line">php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Invalid filename or mode length"</span>);</span><br><span class="line">RETURN_FALSE;</span><br><span class="line">&#125;</span><br><span class="line">fp = fopen(filename, mode);</span><br><span class="line"><span class="keyword">if</span> (!fp)</span><br><span class="line">&#123;</span><br><span class="line">php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Unable to open %s using mode %s"</span>,filename, mode);</span><br><span class="line">RETURN_FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将fp添加到资源池中去，并标记它为le_sample_descriptor类型的。</span></span><br><span class="line">ZEND_REGISTER_RESOURCE(return_value,fp,le_sample_descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>如果前面章节的知识你都看过的话，应该可以猜出最后一行代码是干啥的了。它创建了一个新的le_sample_descriptor类型的资源，此资源的值是fp，另外它把这个资源加入到一个存储资源的HashTable中，并把此资源在其中对应的数字Key赋给return_value。<br><div class="tip-common"><br>资源并不局限于文件句柄，我们可以申请一块内存，并且指向它的指针来作为一种资源。所以资源可以对应任意类型的数据。<br></div><br>### 销毁资源<br>世间万物皆有喜有悲，有生有灭，到了我们探讨如何销毁资源的时候了。最简单的一种莫过于仿照fclose写一个sample_close()函数，在它里面实现对某种{资源：专指PHP的资源类型变量代表的值}的释放。<br><br>但是，如果用户端的脚本通过unset()函数来释放某个资源类型的变量会如何呢？它们可不知道它的值最终对应一个FILE<em>指针啊，所以也无法使用fclose()函数来释放它，这个FILE</em>句柄很有可能会一直存在于内存中，直到PHP程序挂掉，由OS来回收。但在一个平常的Web环境中，我们的服务器都会长时间运行的。<br>难道就没有解决方案了吗？当然不是，谜底就在那个NULL参数里，就是我们在上面为了生成新的资源类型，调用的zend_register_list_destructors_ex()函数的第一个参数和第二个参数。这两个参数都各自代表一个回调参数。第一个回调函数会在脚本中的相应类型的资源变量被释放掉的时候触发，比如作用域结束了，或者被unset()掉了。<br><br>第二个回调函数则是用在一个类似于长链接类型的资源上的，也就是这个资源创建后会一直存在于内存中，而不会在request结束后被释放掉。它将会在Web服务器进程终止时调用，相当于在MSHUTDOWN阶段被内核调用。有关persistent resources的事宜，我们将在下一节里详述。<br><br>我们先来定义第一种回调函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_sample_descriptor_dtor</span><span class="params">(zend_rsrc_list_entry *rsrc TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp = (FILE*)rsrc-&gt;ptr;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>然后用它替换掉zend_register_list_destructors_ex()函数的第一个参数NULL：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">le_sample_descriptor = zend_register_list_destructors_ex(</span><br><span class="line">        php_sample_descriptor_dtor,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        PHP_SAMPLE_DESCRIPTOR_RES_NAME,</span><br><span class="line">        module_number);</span><br></pre></td></tr></table></figure><br><br>现在，如果脚本中得到了一个上述类型的资源变量，当它被unset的时候，或者因为作用域执行完被内核释放掉的时候都会被内核调用底层的php_sample_descriptor_dtor来预处理它。这样一来，貌似我们根本就不需要sample_close()函数了！<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $fp = sample_fopen(<span class="string">"/home/jdoe/notes.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">unset</span>($fp);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br><br>unset($fp)执行后，内核会自动的调用php_sample_descriptor_dtor函数来清理这个变量对应的一些数据。<br>当然，事情绝对没有这么简单，让我们先记住这个疑问，继续往下看。<br>### Decoding Resources<br>我们把资源变量比作书签，可如果仅有书签的话绝对没有任何作用啊！我们需要通过书签找到相应的页才行。对于资源变量，我们必须能够通过它找到相应的最终数据才行！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_fwrite)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line">zval *file_resource;</span><br><span class="line"><span class="keyword">char</span> *data;</span><br><span class="line"><span class="keyword">int</span> data_len;</span><br><span class="line"><span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"rs"</span>,&amp;file_resource, &amp;data, &amp;data_len) == FAILURE )</span><br><span class="line">&#123;</span><br><span class="line">RETURN_NULL();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Use the zval* to verify the resource type and</span></span><br><span class="line"><span class="comment"> * retrieve its pointer from the lookup table */</span></span><br><span class="line">ZEND_FETCH_RESOURCE(fp,FILE*,&amp;file_resource,<span class="number">-1</span>,PHP_SAMPLE_DESCRIPTOR_RES_NAME,le_sample_descriptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write the data, and</span></span><br><span class="line"><span class="comment"> * return the number of bytes which were</span></span><br><span class="line"><span class="comment"> * successfully written to the file */</span></span><br><span class="line">RETURN_LONG(fwrite(data, <span class="number">1</span>, data_len, fp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>zend_parse_parameters()函数中的r占位符代表着接收资源类型的变量，它的载体是一个zval<em>。然后让我们看一下ZEND_FETCH_RESOURCE()宏函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FETCH_RESOURCE(rsrc, rsrc_type, passed_id,default_id, resource_type_name, resource_type)</span></span><br><span class="line">    rsrc = (rsrc_type) zend_fetch_resource(passed_id TSRMLS_CC,default_id, resource_type_name, <span class="literal">NULL</span>,<span class="number">1</span>, resource_type);</span><br><span class="line">    ZEND_VERIFY_RESOURCE(rsrc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在我们的例子中，它是这样的：</span></span><br><span class="line">fp = (FILE*) zend_fetch_resource(&amp;file_descriptor TSRMLS_CC, <span class="number">-1</span>,PHP_SAMPLE_DESCRIPTOR_RES_NAME, <span class="literal">NULL</span>,<span class="number">1</span>, le_sample_descriptor);</span><br><span class="line"><span class="keyword">if</span> (!fp)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>zend_fetch_resource()是对zend_hash_find()的一层封装，它使用一个数字key去一个保存各种{资源}的HashTable中寻找最终需要的数据，找到之后，我们用ZEND_VERIFY_RESOURCE()宏函数校验一下这个数据。从上面的代码中我们可以看出，NULL、0是绝对不能作为一种资源的。<br>上面的例子中，zend_fetch_resource()函数首先获取le_sample_descriptor代表的资源类型，如果资源不存在或者接收的zval不是一个资源类型的变量，它便会返回NULL，并抛出相应的错误信息。<br>最后的ZEND_VERIFY_RESOURCE()宏函数如果检测到错误，便会自动返回，使我们可以从错误检测中脱离出来，更加专注于程序的主逻辑。现在我们已经获取到了相应的FILE</em>了，下面就用fwrite()向其中写入点数据吧！。<p><br></p><div class="tip-common"><br>To avoid having zend_fetch_resource() generate an error on failure, simply pass NULL for the resource_type_name parameter. Without a meaningful error message to display, zend_fetch_resource() will fail silently instead.<br></div><p>我们也可以通过另一种方法来获取我们最终想要的数据。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_fwrite)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    zval *file_resource;</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">int</span> data_len, rsrc_type;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"rs"</span>,&amp;file_resource, &amp;data, &amp;data_len) == FAILURE ) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    fp = (FILE*)zend_list_find(Z_RESVAL_P(file_resource),&amp;rsrc_type);</span><br><span class="line">    <span class="keyword">if</span> (!fp || rsrc_type != le_sample_descriptor) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Invalid resource provided"</span>);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    RETURN_LONG(fwrite(data, <span class="number">1</span>, data_len, fp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以根据自己习惯来选择到底使用哪一种形式，不过推荐使用ZEND_FETCH_RESOURCE()宏函数。</p><h3 id="Forcing-Destruction"><a href="#Forcing-Destruction" class="headerlink" title="Forcing Destruction"></a>Forcing Destruction</h3><p>在上面我们还有个疑问没有解决，就是类似于我们上面实现的unset($fp)真的是万能的么？当然不是，看一下下面的代码：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  $fp = sample_fopen(<span class="string">"/home/jdoe/world_domination.log"</span>, <span class="string">"a"</span>);</span><br><span class="line">  $evil_log = $fp;</span><br><span class="line">  <span class="keyword">unset</span>($fp);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>这次，$fp和$evil_log共用一个zval，虽然$fp被释放了，但是它的zval并不会被释放，因为$evil_log还在用着。也就是说，现在$evil_log代表的文件句柄仍然是可以写入的！所以为了避免这种错误，真的需要我们手动来close it！sample_close()函数是必须存在的！<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample_fclose)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    zval *file_resource;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"r"</span>,&amp;file_resource) == FAILURE ) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While it's not necessary to actually fetch the</span></span><br><span class="line"><span class="comment">     * FILE* resource, performing the fetch provides</span></span><br><span class="line"><span class="comment">     * an opportunity to verify that we are closing</span></span><br><span class="line"><span class="comment">     * the correct resource type. */</span></span><br><span class="line">    ZEND_FETCH_RESOURCE(fp, FILE*, &amp;file_resource, <span class="number">-1</span>,PHP_SAMPLE_DESCRIPTOR_RES_NAME, le_sample_descriptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Force the resource into self-destruct mode */</span></span><br><span class="line">    zend_hash_index_del(&amp;EG(regular_list),Z_RESVAL_P(file_resource));</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个删除操作也再次说明了资源数据是保存在HashTable中的。虽然我们可以通过zend_hash_index_find()或者zend_hash_next_index_insert()之类的函数操作这个储存资源的HashTable，但这绝不是一个好主意，因为在后续的版本中，PHP可能会修改有关这一部分的实现方式，到那时上述方法便不起作用了，所以为了更好的兼容性，请使用标准的宏函数或者api函数。<br>当我们在EG(regular_list)这个HashTable中删除数据的时候，回调用一个dtor函数，它根据资源变量的类别来调用相应的dtor函数实现，就是我们调用zend_register_list_destructors_ex()函数时的第一个参数。</p><div class="tip-common">在很多地方，我们都会看到一个专门用来删除的zend_list_delete()宏函数，因为它考虑了资源数据自己的引用计数，所以我们将在后面的章节中介绍它。</div><h1 id="9-2-PHP中的资源类型"><a href="#9-2-PHP中的资源类型" class="headerlink" title="9.2 PHP中的资源类型"></a>9.2 PHP中的资源类型</h1><p>通常情况下，像{资源}这类复合类型的数据都会占用大量的硬件资源，比如内存、CPU以及网络带宽。对于使用频率超级高的数据库链接，我们可以获取一个长链接，使其不会在脚本结束后自动销毁，一旦创建便可以在各个请求中直接使用，从而减少每次创建它的消耗。Mysql的长链接在PHP内核中其实就是一种持久{资源}。<br>Memory Allocation<br>前面的章节里我们接触了emalloc()之类的以e开头的内存管理函数，通过它们申请的内存都会被内核自动的进行垃圾回收的操作。而对于一个持久{资源}来说，我们是绝对不希望它在脚本结束后被回收的。</p><p>假设我们需要在我们的{资源}中同时保存文件名和文件句柄两个数据，现在我们就需要自己定义个结构了：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">php_sample_descriptor_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *filename;</span><br><span class="line">    FILE *fp;</span><br><span class="line">&#125;php_sample_descriptor_data;</span><br></pre></td></tr></table></figure><p></p><p>当然，因为结构变了(之前是个FILE*)，我们之前的代码也需要跟着改动。这里还没有涉及到持久{资源}，仅仅是换了一种{资源}结构<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_sample_descriptor_dtor</span><span class="params">(zend_rsrc_list_entry *rsrc TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_sample_descriptor_data *fdata = (php_sample_descriptor_data*)rsrc-&gt;ptr;</span><br><span class="line">    fclose(fdata-&gt;fp);</span><br><span class="line">    efree(fdata-&gt;filename);</span><br><span class="line">    efree(fdata);</span><br><span class="line">&#125;</span><br><span class="line">PHP_FUNCTION(sample_fopen)</span><br><span class="line">&#123;</span><br><span class="line">    php_sample_descriptor_data *fdata;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *filename, *mode;</span><br><span class="line">    <span class="keyword">int</span> filename_len, mode_len;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"ss"</span>,&amp;filename, &amp;filename_len,&amp;mode, &amp;mode_len) == FAILURE)</span><br><span class="line">    &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!filename_len || !mode_len) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Invalid filename or mode length"</span>);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(filename, mode);</span><br><span class="line">    <span class="keyword">if</span> (!fp)</span><br><span class="line">    &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Unable to open %s using mode %s"</span>,filename, mode);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    fdata = emalloc(<span class="keyword">sizeof</span>(php_sample_descriptor_data));</span><br><span class="line">    fdata-&gt;fp = fp;</span><br><span class="line">    fdata-&gt;filename = estrndup(filename, filename_len);</span><br><span class="line">    ZEND_REGISTER_RESOURCE(return_value, fdata,le_sample_descriptor);</span><br><span class="line">&#125;</span><br><span class="line">PHP_FUNCTION(sample_fwrite)</span><br><span class="line">&#123;</span><br><span class="line">    php_sample_descriptor_data *fdata;</span><br><span class="line">    zval *file_resource;</span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"rs"</span>,&amp;file_resource, &amp;data, &amp;data_len) == FAILURE )</span><br><span class="line">    &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    ZEND_FETCH_RESOURCE(fdata, php_sample_descriptor_data*,&amp;file_resource, <span class="number">-1</span>,PHP_SAMPLE_DESCRIPTOR_RES_NAME, le_sample_descriptor);</span><br><span class="line">    RETURN_LONG(fwrite(data, <span class="number">1</span>, data_len, fdata-&gt;fp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><div class="tip-common">我们这里没有重写sample_fclose()函数，你可以尝试着自己实现它。</div><br>现在编译运行，所有代码的结果都非常正确，我们还可以在内核中获取每个{资源}对应的文件名称了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample_fname)</span><br><span class="line">&#123;</span><br><span class="line">    php_sample_descriptor_data *fdata;</span><br><span class="line">    zval *file_resource;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"r"</span>,&amp;file_resource) == FAILURE )</span><br><span class="line">    &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    ZEND_FETCH_RESOURCE(fdata, php_sample_descriptor_data*,&amp;file_resource, <span class="number">-1</span>,PHP_SAMPLE_DESCRIPTOR_RES_NAME, le_sample_descriptor);</span><br><span class="line">    RETURN_STRING(fdata-&gt;filename, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在，Persistent Resources来了！</p><h3 id="Delayed-Destruction"><a href="#Delayed-Destruction" class="headerlink" title="Delayed Destruction"></a>Delayed Destruction</h3><p>在前面我们删除一个{资源}的时候，其实是去EG(regular_list)中将其删掉，EG(regular_list)存储着所有的只用在当前请求的{资源}。</p><p>持久{资源},存储在另一个HashTable中：EG(persistent_list)。其与EG(regular_list)有个明显的区别，那就是它每个值的索引都是字符串类型的，而且它的每个值也不会在每次请求结束后被释放掉，只能我们手动通过zend_hash_del()来删除，或者在进程结束后类似于MSHUTDOWN阶段将EG(persistent_list)整体清除，最常见的情景便是操作系统关闭了Web Server。<br>EG(persistent_list)对其元素也有自己的dtor回调函数，和EG(regular_list)一样，它将根据其值的类型去调用不同的回调函数，我们这一次注册回调函数的时候，需要用到zend_register_list_destructors_ex()函数的第二个参数，第一个则被赋成NULL。<br>在底层的实现中，持久的和regular{资源}是分别在不同的地方存储的，也分别拥有各自不同的释放函数。但在我们为脚本提供的函数中，却希望能够封装这种差异，从而使我们的用户使用起来更加方便快捷。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> le_sample_descriptor_persist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_sample_descriptor_dtor_persistent</span><span class="params">(zend_rsrc_list_entry *rsrc TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_sample_descriptor_data *fdata = (php_sample_descriptor_data*)rsrc-&gt;ptr;</span><br><span class="line">    fclose(fdata-&gt;fp);</span><br><span class="line">    pefree(fdata-&gt;filename, <span class="number">1</span>);</span><br><span class="line">    pefree(fdata, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(sample)</span><br><span class="line">&#123;</span><br><span class="line">    le_sample_descriptor = zend_register_list_destructors_ex(php_sample_descriptor_dtor, <span class="literal">NULL</span>,PHP_SAMPLE_DESCRIPTOR_RES_NAME, module_number);</span><br><span class="line">    le_sample_descriptor_persist =zend_register_list_destructors_ex(<span class="literal">NULL</span>, php_sample_descriptor_dtor_persistent,PHP_SAMPLE_DESCRIPTOR_RES_NAME, module_number);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们并没有为这两种{资源}起不同的名字，以防使用户产生疑惑。<br>现在我们的PHP扩展中引进了一种新的{资源}，所以我们需要改写一下上面的函数，<b>尽量使</b>用户使用时感觉不到这种差异。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample_fopen()</span></span><br><span class="line">PHP_FUNCTION(sample_fopen)</span><br><span class="line">&#123;</span><br><span class="line">    php_sample_descriptor_data *fdata;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *filename, *mode;</span><br><span class="line">    <span class="keyword">int</span> filename_len, mode_len;</span><br><span class="line">    zend_bool persist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类比一下mysql_connect函数的最后一个参数。</span></span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,<span class="string">"ss|b"</span>,&amp;filename, &amp;filename_len, &amp;mode, &amp;mode_len,&amp;persist) == FAILURE)</span><br><span class="line">    &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!filename_len || !mode_len)</span><br><span class="line">    &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Invalid filename or mode length"</span>);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(filename, mode);</span><br><span class="line">    <span class="keyword">if</span> (!fp)</span><br><span class="line">    &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Unable to open %s using mode %s"</span>,filename, mode);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!persist)</span><br><span class="line">    &#123;</span><br><span class="line">        fdata = emalloc(<span class="keyword">sizeof</span>(php_sample_descriptor_data));</span><br><span class="line">        fdata-&gt;filename = estrndup(filename, filename_len);</span><br><span class="line">        fdata-&gt;fp = fp;</span><br><span class="line">        ZEND_REGISTER_RESOURCE(return_value, fdata,le_sample_descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        list_entry le;</span><br><span class="line">        <span class="keyword">char</span> *hash_key;</span><br><span class="line">        <span class="keyword">int</span> hash_key_len;</span><br><span class="line"></span><br><span class="line">        fdata =pemalloc(<span class="keyword">sizeof</span>(php_sample_descriptor_data),<span class="number">1</span>);</span><br><span class="line">        fdata-&gt;filename = pemalloc(filename_len + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(fdata-&gt;filename, filename, filename_len + <span class="number">1</span>);</span><br><span class="line">        fdata-&gt;fp = fp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在EG(regular_list中存一份)</span></span><br><span class="line">        ZEND_REGISTER_RESOURCE(return_value, fdata,le_sample_descriptor_persist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在EG(persistent_list)中再存一份</span></span><br><span class="line">        le.type = le_sample_descriptor_persist;</span><br><span class="line">        le.ptr = fdata;</span><br><span class="line">        hash_key_len = spprintf(&amp;hash_key, <span class="number">0</span>,<span class="string">"sample_descriptor:%s:%s"</span>, filename, mode);</span><br><span class="line">        zend_hash_update(&amp;EG(persistent_list),hash_key, hash_key_len + <span class="number">1</span>,(<span class="keyword">void</span>*)&amp;le, <span class="keyword">sizeof</span>(list_entry), <span class="literal">NULL</span>);</span><br><span class="line">        efree(hash_key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在持久{资源}时，因为我们在EG(regular_list)中也保存了一份，所以脚本中我们资源类型的变量在实现中仍然是保存着一个resource ID，我们可以用它来进行之前章节所做的工作。<br>将其添加到EG(persistent_list)中时，我们进行的操作流程几乎和ZEND_REGISTER_RESOURCE()宏函数一样，唯一的不同便是索引由之前的数字类型换成了字符串类型。<br>当一个保存在EG(regular_list)中的持久{资源}被脚本释放时，内核会在EG(regular_list)寻找它对应的dtor函数，但它找到的是NULL，因为我们在使用zend_register_list_destructors_ex()函数声明这种资源类型时，第一个参数的值为NULL。所以此时这个{资源}不会被任何dtor函数调用，可以继续存在于内存中，任脚本流逝，请求更迭。<br>当web server的进程执行完毕后，内核会扫描EG(persistent_list)的dtor，并调用我们已经定义好的释放函数。在我们定义的释放函数中，一定要记得使用pfree函数来释放内存，而不是efree。</p><h3 id="Reuse"><a href="#Reuse" class="headerlink" title="Reuse"></a>Reuse</h3><p>创建持久{资源}的目的是为了使用它，而不是让它来浪费内存的，我们再次重写一下sample_open()函数，这一次我们将检测需要创建的资源是否已经在persistent_list中存在了。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample_fopen)</span><br><span class="line">&#123;</span><br><span class="line">    php_sample_descriptor_data *fdata;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> *filename, *mode, *hash_key;</span><br><span class="line">    <span class="keyword">int</span> filename_len, mode_len, hash_key_len;</span><br><span class="line">    zend_bool persist = <span class="number">0</span>;</span><br><span class="line">    list_entry *existing_file;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,<span class="string">"ss|b"</span>,&amp;filename, &amp;filename_len, &amp;mode, &amp;mode_len,&amp;persist) == FAILURE)</span><br><span class="line">    &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filename_len || !mode_len)</span><br><span class="line">    &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Invalid filename or mode length"</span>);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看看是否已经存在，如果已经存在就直接使用，不再创建</span></span><br><span class="line">    hash_key_len = spprintf(&amp;hash_key, <span class="number">0</span>,<span class="string">"sample_descriptor:%s:%s"</span>, filename, mode);</span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(&amp;EG(persistent_list), hash_key,hash_key_len + <span class="number">1</span>, (<span class="keyword">void</span> **)&amp;existing_file) == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//存在一个，直接使用！</span></span><br><span class="line">        ZEND_REGISTER_RESOURCE(return_value,existing_file-&gt;ptr, le_sample_descriptor_persist);</span><br><span class="line">        efree(hash_key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(filename, mode);</span><br><span class="line">    <span class="keyword">if</span> (!fp)</span><br><span class="line">    &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Unable to open %s using mode %s"</span>,filename, mode);</span><br><span class="line">        RETURN_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!persist)</span><br><span class="line">    &#123;</span><br><span class="line">        fdata = emalloc(<span class="keyword">sizeof</span>(php_sample_descriptor_data));</span><br><span class="line">        fdata-&gt;filename = estrndup(filename, filename_len);</span><br><span class="line">        fdata-&gt;fp = fp;</span><br><span class="line">        ZEND_REGISTER_RESOURCE(return_value, fdata,le_sample_descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        list_entry le;</span><br><span class="line">        fdata =pemalloc(<span class="keyword">sizeof</span>(php_sample_descriptor_data),<span class="number">1</span>);</span><br><span class="line">        fdata-&gt;filename = pemalloc(filename_len + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(fdata-&gt;filename, filename, filename_len + <span class="number">1</span>);</span><br><span class="line">        fdata-&gt;fp = fp;</span><br><span class="line">        ZEND_REGISTER_RESOURCE(return_value, fdata,le_sample_descriptor_persist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Store a copy in the persistent_list */</span></span><br><span class="line">        le.type = le_sample_descriptor_persist;</span><br><span class="line">        le.ptr = fdata;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//hash_key在上面已经被创建了</span></span><br><span class="line">        zend_hash_update(&amp;EG(persistent_list),hash_key, hash_key_len + <span class="number">1</span>,(<span class="keyword">void</span>*)&amp;le, <span class="keyword">sizeof</span>(list_entry), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    efree(hash_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为所有的PHP扩展都共用同一个HashTable来保存持久{资源}，所以我们在为{资源}的索引起名时，一定要唯一，同时必须简单，方便我们在其它的函数中构造出来。</p><h3 id="Liveness-Checking-and-Early-Departure"><a href="#Liveness-Checking-and-Early-Departure" class="headerlink" title="Liveness Checking and Early Departure"></a>Liveness Checking and Early Departure</h3><p>一旦我们打开一个本地文件，便可以一直占有它的操作句柄，保证随时可以打开它。但是对于一些存在于远程计算机上的资源，比如mysql链接、http链接，虽然我们仍然握着与服务器的链接，但是这个链接在服务器端可能已经被关闭了，在本地我们就无法再用它来做一些有价值的工作了。</p><p>所以，当我们使用{资源}，尤其是持久{资源}时，一定要保证获取出来的{资源}仍然是有效的、可以使用的。如果它失效了，我们必须将其从persistent list中移除。下面就是一个检测socket有效性的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zend_hash_find(&amp;EG(persistent_list), hash_key,hash_key_len + <span class="number">1</span>, (<span class="keyword">void</span>**)&amp;socket) == SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (php_sample_socket_is_alive(socket-&gt;ptr))</span><br><span class="line">    &#123;</span><br><span class="line">        ZEND_REGISTER_RESOURCE(return_value,socket-&gt;ptr, le_sample_socket);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zend_hash_del(&amp;EG(persistent_list),hash_key, hash_key_len + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，{资源}失效后，我们只要把它从HashTable中删除就行了，这一步操作同样会激活我们设置的回调函数。On completion of this code block, the function will be in the same state it would have been if no resource had been found in the persistent list.</p><h3 id="Agnostic-Retrieval"><a href="#Agnostic-Retrieval" class="headerlink" title="Agnostic Retrieval"></a>Agnostic Retrieval</h3><p>现在我们已经可以创建资源类型并生成新的资源，还能将持久{资源}与平常{资源}使用的差异性封装起来。但是如果用户对一个持久{资源}调用sample_fwrite()时候并不会正常工作，先想一下内核是如何通过一个数字所以在regular_list中获取最终资源的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FETCH_RESOURCE(</span><br><span class="line">fdata,</span><br><span class="line">php_sample_descriptor_data*,</span><br><span class="line">    &amp;file_resource,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    PHP_SAMPLE_DESCRIPTOR_RES_NAME,</span><br><span class="line">    le_sample_descriptor</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>le_sample_descriptor可以保证你获取到的资源确实是这种类型的，绝不会出现你想要一个文件句柄，却返回给你一个mysql链接的情况。这种验证是必须的，但有时你又想绕过这种验证，因为我们放在persistenst_list中的{资源}是le_sample_descruotor_persist类型的，所以当我们把它复制到regular_list中时，它也是le_sample_descructor_persist的，所以如果我们想获取它，貌似只有两种方法，要么修改类型，要么再写一个新的sample_write_persistent函数的实现。或者极端一些，在sample_write函数里进行复杂的判断。但是如果sample_write()函数能同时接收它们两种类型的{资源}多好啊….</p><p>事情没有这么复杂，我们确实可以在sample_write()函数里获取{资源}时候同时指定两种类型。那就是使用ZEND_FETCH_RESOURCE2()宏函数，它与ZEND_FETCH_RESOURCE()宏函数的唯一区别就是它可以接收两种类型参数。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FETCH_RESOURCE2(</span><br><span class="line">fdata,</span><br><span class="line">php_sample_descriptor_data*,</span><br><span class="line">    &amp;file_resource,</span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    PHP_SAMPLE_DESCRIPTOR_RES_NAME,</span><br><span class="line">    le_sample_descriptor,</span><br><span class="line">    le_sample_descriptor_persist</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p>现在，只要resource ID对应的最终资源类型是persistent或者non-persistent的一种便可以正常通过验证了。</p><p>什么，你想设置三种甚至更多的类型？!!那你只能直接使用zend_fetch_resource()函数了。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一种类型的</span></span><br><span class="line">fp = (FILE*) zend_fetch_resource(</span><br><span class="line">&amp;file_descriptor TSRMLS_CC,</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line">PHP_SAMPLE_DESCRIPTOR_RES_NAME,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">le_sample_descriptor</span><br><span class="line">);</span><br><span class="line">ZEND_VERIFY_RESOURCE(fp);</span><br></pre></td></tr></table></figure><p></p><p>想看看ZEND_FETCH_RESOURCE2()宏函数的实现么？<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种类型的</span></span><br><span class="line">fp = (FILE*) zend_fetch_resource(</span><br><span class="line">&amp;file_descriptor TSRMLS_CC,</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line">PHP_SAMPLE_DESCRIPTOR_RES_NAME,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line">le_sample_descriptor,</span><br><span class="line">le_sample_descriptor_persist</span><br><span class="line">);</span><br><span class="line">ZEND_VERIFY_RESOURCE(fp);</span><br></pre></td></tr></table></figure><p></p><p>再给力一些，三种类型的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fp = (FILE*) zend_fetch_resource(</span><br><span class="line">&amp;file_descriptor TSRMLS_CC,</span><br><span class="line"><span class="number">-1</span>,</span><br><span class="line">    PHP_SAMPLE_DESCRIPTOR_RES_NAME,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    le_sample_descriptor,</span><br><span class="line">    le_sample_descriptor_persist,</span><br><span class="line">    le_sample_othertype</span><br><span class="line">);</span><br><span class="line">ZEND_VERIFY_RESOURCE(fp);</span><br></pre></td></tr></table></figure><p>话都说到这份上了，你肯定知道四种、五种、更多种类型的应该怎么调用了。</p><h1 id="9-3-PHP中的资源类型"><a href="#9-3-PHP中的资源类型" class="headerlink" title="9.3 PHP中的资源类型"></a>9.3 PHP中的资源类型</h1><p>zval通过引用计数来节省内存的，这个我们都知道了，但你可能不知道的是，某个zval对应的{资源}在实现时也使用了引用计数这种概念，也就是有了两种引用计数！</p><p>{资源}对应的zval的类型是IS_RESOURCE，它并不保存最终的数据，而只保存一个数字，即EG(regular_list)中的数字索引。</p><p>当{资源}被创建时，比如我们调用sample_fopen()函数：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$a = sample_fopen(<span class="string">'notes.txt'</span>, <span class="string">'r'</span>);</span><br><span class="line"><span class="comment">//此时：var-&gt;refcount__gc = 1, rsrc-&gt;refcount = 1</span></span><br><span class="line"></span><br><span class="line">$b = $a;</span><br><span class="line"><span class="comment">//此时：var-&gt;refcount__gc = 2, rsrc-&gt;refcount = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>($b);</span><br><span class="line"><span class="comment">//此时：var-&gt;refcount__gc = 1, rsrc-&gt;refcount = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 下面来个复杂的！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">$b = $a;</span><br><span class="line">$c = &amp;$a;</span><br><span class="line"><span class="comment">//此时：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bvar-&gt;refcount = 1, bvar-&gt;is_ref = 0</span></span><br><span class="line"><span class="comment">acvar-&gt;refcount = 2, acvar-&gt;is_ref = 1</span></span><br><span class="line"><span class="comment">rsrc-&gt;refcount = 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>现在，如果我们unset($b)，内核只会把rsrc-&gt;refcount的值减1。只有当rsrc-&gt;refcount的值为0时，我们预设的dtor释放函数才会被激活并调用。</p><h1 id="9-4-PHP中的资源类型"><a href="#9-4-PHP中的资源类型" class="headerlink" title="9.4 PHP中的资源类型"></a>9.4 PHP中的资源类型</h1><p>通过这一章介绍的技术，我们已经可以使用PHP中{资源}了，这将使我们更容易的在扩展中使用一些第三方库，比如使用zip扩展时，我们需要把它的一些特殊的量封装成资源供脚本使用。这无疑极大的增强了PHP的威力！{资源}V5!</p><p><br>下一章将会说一下PHP中的对象！原书中分别讲述了PHP4与PHP5的实现，这里我没有参照原书的安排，按照自己的理解完全重写了这一部分，以PHP5为基础讲述，确切的说，是以PHP5.3.6讲述，这个版本问题我也已经在本书开头说明了，因为我私自认为PHP4已经不再重要了。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8 使用HashTable与{数组}</title>
      <link href="/posts/e0f3b7fd.html"/>
      <url>/posts/e0f3b7fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="8-使用HashTable与-数组"><a href="#8-使用HashTable与-数组" class="headerlink" title="8 使用HashTable与{数组}"></a>8 使用HashTable与{数组}</h1><p>在C语言中，我们可以自定义各种各样的数据结构，用来把很多数据保存在一个变量里面，但是每种数据结构都有自己的优缺点，PHP内核规模如此庞大，是否已经找到了一些非常棒的解决方法呢？</p><h1 id="8-1-使用HashTable与-数组"><a href="#8-1-使用HashTable与-数组" class="headerlink" title="8.1 使用HashTable与{数组}"></a>8.1 使用HashTable与{数组}</h1><p>我们在评选各种数据结构时，往往会考虑我们需要处理的数据规模以及需要的性能。下面让我们简要的看一下看C语言中数组和链表的一些事情。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>作者这里用的不是Array，而是Vector，可能指的是C++里的Vector，<br>它与数组几乎是完全一样的，唯一的不同便是可以实现动态存储。<br>本节下文都是用数组一词代替之，请各位注意。数组是内存中一块连续的区域，其每一个元素都具有一个唯一的下标值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>]=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>不仅是整数，其它类型的变量也可以保存在数组中，比如我们上一章用到的zend_get_parameters_array_ex()，便把很多zval**类型的变量保存到一个数组里，为了使其正常工作，我们提前向系统申请了相应大小的内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zval ***args = safe_emalloc(ZEND_NUM_ARGS(), <span class="keyword">sizeof</span>(zval**), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这里我们仍然可以用一个整数来当作下标去数组中取出我们想要的数据，就像var_dump()的实现中通过args[i]来获取参数并把它传递给php_var_dump()函数那样。<br>使用数组最大的好处便是速度！读写都可以在O(1)内完成，因为它每个元素的大小都是一致的，只要知道下标，便可以瞬间计算出其对应的元素在内存中的位置，从而直接取出或者写入。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表也是一种经常被使用的一种数据结构。链表中的每一个元素都至少有两个元素，一个指向它的下一个元素，一个用来存放它自己的数据，就像下面定义的那样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">namelist</span> <span class="title">namelist</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">namelist</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">namelist</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以声明一个其类型的元素：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> namelist *people;</span><br></pre></td></tr></table></figure><p></p><p>假设每一个元素都代表一个人，元素中的name属性便是这个人的名字，我们通过这样的语句来得到它：people-&gt;name; 第二个属性指向后面的一个元素，那我们便可以这样来访问下一个人的名字：people-&gt;next-&gt;name, 或者下一个人的下一个人的名字：people-&gt;next-&gt;next-&gt;name,一次类推，直到next的值是NULL，代表结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过一个循环来遍历这个链表中的所有人～</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_show</span><span class="params">(namelist *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Name: %s\n"</span>, p-&gt;name);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表可以被用来实现FIFO模式，达到先进者先出的目的！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> namelist *people = <span class="literal">NULL</span>, *last_person = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_add</span><span class="params">(namelist *person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!last_person) &#123;</span><br><span class="line">        <span class="comment">/* No one in the list yet */</span></span><br><span class="line">        people = last_person = person;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Append new person to the end of the list */</span></span><br><span class="line">    last_person-&gt;next = person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the list tail */</span></span><br><span class="line">    last_person = person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">namelist *<span class="title">name_pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    namelist *first_person = people;</span><br><span class="line">    <span class="keyword">if</span> (people) &#123;</span><br><span class="line">    people = people-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first_person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们便可以随意的向这个链表中添加或者删除数据，而不像数组那样，谨慎的考虑是否越界等问题。<br>上面实现的结构的学名叫做单向链表，也有地方叫单链表，反正是比较简单的意思～。它有一个致命的缺点，就是我们在插入或者读取某条数据的时候，都需要从这个链表的开始，一个个元素的向下寻找，直到找到这个元素为止。如果链表中的元素比较多，那它很容易成为我们程序中的CPU消耗大户，进而引起性能问题。为了解决这个问题，先人们发明了双向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">namelist</span> <span class="title">namelist</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">namelist *next, *prev;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line">&#125; _namelist;</span><br></pre></td></tr></table></figure><p>改动其实不大，就是在每个元素中都添加了一个prev属性，用来指向它的上一个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_add</span><span class="params">(namelist *person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!last_person)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* No one in the list yet */</span></span><br><span class="line">people = last_person = person;</span><br><span class="line">person-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Append new person to the end of the list */</span></span><br><span class="line">last_person -&gt;next = person;</span><br><span class="line">person-&gt;prev = last_person;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update the list tail */</span></span><br><span class="line">last_person = person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单单通过上面的程序你还体会不到它的好处，但是设想一下，如果现在你有这个链表中其中一个元素的地址，并且想把它从链表中删除，那我们该怎么做呢？如果是单向链表的话，我们只能这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_remove</span><span class="params">(namelist *person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    namelist *p;</span><br><span class="line">    <span class="keyword">if</span> (person == people) &#123;</span><br><span class="line">        <span class="comment">/* Happens to be the first person in the list */</span></span><br><span class="line">        people = person-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (last_person == person) &#123;</span><br><span class="line">            <span class="comment">/* Also happens to be the last person */</span></span><br><span class="line">            last_person = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Search for prior person */</span></span><br><span class="line">    p = people;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next == person) &#123;</span><br><span class="line">            <span class="comment">/* unlink */</span></span><br><span class="line">            p-&gt;next = person-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (last_person == person) &#123;</span><br><span class="line">                <span class="comment">/* This was the last element */</span></span><br><span class="line">                last_person = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Not found in list */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们来看看双向链表是怎样来处理这个问题的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_remove</span><span class="params">(namelist *person)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (people == person) &#123;</span><br><span class="line">        people = person-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_person == person) &#123;</span><br><span class="line">        last_person = person-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (person-&gt;prev) &#123;</span><br><span class="line"></span><br><span class="line">        person-&gt;prev-&gt;next = person-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (person-&gt;next) &#123;</span><br><span class="line">        person-&gt;next-&gt;prev = person-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对元素的遍历查找不见了，取而代之的是一个O(1)的运算，这将极大的提升我们程序的性能。</p><h3 id="王者归来：HashTable才是我们的银弹！"><a href="#王者归来：HashTable才是我们的银弹！" class="headerlink" title="王者归来：HashTable才是我们的银弹！"></a>王者归来：HashTable才是我们的银弹！</h3><p>也许你已经非常喜欢使用数组或者链表了，但我还是要向你推荐一种威力极大的数据结构，有了它之后，你可能会立即抛弃前两者，它就是HashTable.<br>HashTable既具有双向链表的优点，同时具有能与数据匹敌的操作性能，这个数据结构几乎是PHP内核实现的基础，我们在内核代码的任何地方都发现它的痕迹。</p><p>第二章我们接触过，所有的用户端定义的变量保存在一个符号表里，而这个符号表其实就是一个HashTable，它的每一个元素都是一个zval*类型的变量。不仅如此，保存用户定义的函数、类、资源等的容器都是以HashTable的形式在内核中实现的。<br>Zend Engine中HashTable的元素其实是指针，对其的这个改进使得HashTable能够包容各种类型的数据，从小小的标量，到复杂的PHP5中实现的类等复合数据。本章接下来的内容，我们将详细的研究如何使用zend内置的API来操作HashTable这个数据结构。</p><h1 id="8-2-使用HashTable与-数组"><a href="#8-2-使用HashTable与-数组" class="headerlink" title="8.2 使用HashTable与{数组}"></a>8.2 使用HashTable与{数组}</h1><p>Zend把与HashTable有关的API分成了好几类以便于我们寻找，这些API的返回值大多都是常量SUCCESS或者FAILURE。</p><h3 id="创建HashTable"><a href="#创建HashTable" class="headerlink" title="创建HashTable"></a>创建HashTable</h3><blockquote><p>下面在介绍函数原型的时候都使用了ht名称，但是我们在编写扩展的时候，<br>一定不要使用这个名称，因为一些PHP宏展开后会声明这个名称的变量，<br>进而引发命名冲突。</p></blockquote><p>创建并初始化一个HashTable非常简单，只要使用zend_hash_init函数即可，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nSize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">hash_func_t</span> pHashFunction,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">dtor_func_t</span> pDestructor,</span></span></span><br><span class="line"><span class="function"><span class="params">zend_bool persistent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>*ht是指针</strong>，指向一个HashTable，我们既可以&amp;一个已存在的HashTable变量，<br>也可以通过emalloc()、pemalloc()等函数来直接申请一块内存，<br>不过最常用的方法还是用ALLOC_HASHTABLE(ht)宏来让内核自动的替我们完成这项工作。<br>ALLOC_HASHTABLE(ht)所做的工作相当于ht = emalloc(sizeof(HashTable));</li><li><strong>nSize</strong>代表着这个HashTable可以拥有的元素的最大数量(HashTable能够包含任意数量的元素，<br>这个值只是为了提前申请好内存，提高性能，省的不停的进行rehash操作)。<br>在我们添加新的元素时，这个值会根据情况决定是否自动增长，有趣的是，<br>这个值永远都是2的次方，如果你给它的值不是一个2的次方的形式，<br>那它将自动调整成大于它的最小的2的次方值。<br>它的计算方法就像这样：nSize = pow(2, ceil(log(nSize, 2)));</li><li><strong>pHashFunction</strong>是早期的Zend Engine中的一个参数，为了兼容没有去掉它，<br>但它已经没有用处了，所以我们直接赋成NULL就可以了。在原来，<br>它其实是一个钩子，用来让用户自己hook一个散列函数，替换php默认的DJBX33A算法实现。</li><li><strong>pDestructor</strong>也代表着一个回调函数，当我们删除或者修改HashTable中其中一个元素时候便会调用，<br>它的函数原型必须是这样的：void method_name(void <em>pElement);这里的</em>pElement是一个指针，指向HashTable中那么将要被删除或者修改的那个数据，而数据的类型往往也是个指针。</li><li><strong>persistent</strong>是最后一个参数，它的含义非常简单。<br>如果它为true，那么这个HashTable将永远存在于内存中，而不会在RSHUTDOWN阶段自动被注销掉。<br>此时第一个参数ht所指向的地址必须是通过pemalloc()函数申请的。</li></ul><p>举个例子，PHP内核在每个Request请求的头部都调用了这个函数来初始化symbol_table。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_init(&amp;EG(symbol_table), <span class="number">50</span>, <span class="literal">NULL</span>, ZVAL_PTR_DTOR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define ZVAL_PTR_DTOR (void (*)(void *)) zval_ptr_dtor_wrapper</span></span><br></pre></td></tr></table></figure><p>如你所见，每个元素在从符号表里删除的时候(比如执行”&lt;?php unset($foo);”操作)，都会触发ZVAL_PTR_DTOR宏代表的函数来对其进行与引用计数有关的操作。<br>因为50不是2的整数幂形式，所以它会在函数执行时被调成成64。</p><h3 id="添加-amp-amp-修改"><a href="#添加-amp-amp-修改" class="headerlink" title="添加&amp;&amp;修改"></a>添加&amp;&amp;修改</h3><p>我们有四个常用的函数来完成这项操作，它们的原型分别如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_add</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,<span class="comment">//待操作的ht</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">char</span> *arKey,<span class="comment">//索引，如"my_key"</span></span></span></span><br><span class="line"><span class="function"><span class="params">uint nKeyLen,<span class="comment">//字符串索引的长度，如6</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> **pData,<span class="comment">//要插入的数据，注意它是void **类型的。int *p,i=1;p=&amp;i,pData=&amp;p;。</span></span></span></span><br><span class="line"><span class="function"><span class="params">uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *pDest<span class="comment">//如果操作成功，则pDest=*pData;</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_update</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_index_update</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">ulong h,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_next_index_insert</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>前两个函数用户添加带字符串索引的数据到HashTable中，就像我们在PHP中使用的那样:$foo[‘bar’] = ‘baz’;用C来完成便是：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_add(fooHashTbl, <span class="string">"bar"</span>, <span class="keyword">sizeof</span>(<span class="string">"bar"</span>), &amp;barZval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p></p><p>zend_hash_add()和zend_hash_update()唯一的区别就是如果这个key已经存在了，那么zend_hash_add()将返回FAILURE，而不会修改原有数据。<br>接下来的两个函数用于像HT中添加数字索引的数据，zend_hash_next_index_insert()函数则不需要索引值参数，而是自己直接计算出下一个数字索引值.<br>但是如果我们想获取下一个元素的数字索引值，也是有办法的，可以使用zend_hash_next_free_element()函数：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulong nextid = zend_hash_next_free_element(ht);</span><br><span class="line">zend_hash_index_update(ht, nextid, &amp;data, <span class="keyword">sizeof</span>(data), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p></p><p><code>所有这些函数中，如果pDest不为NULL，内核便会修改其值为被操作的那个元素的地址。在下面的代码中这个参数也有同样的功能。</code></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>因为HashTable中有两种类型的索引值，所以需要两个函数来执行find操作。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_find</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *arKey, uint nKeyLength,<span class="keyword">void</span> **pData)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_index_find</span><span class="params">(HashTable *ht, ulong h, <span class="keyword">void</span> **pData)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>第一种就是我们处理PHP语言中字符串索引数组时使用的，第二种是我们处理PHP语言中数字索引数组使用的。Recall from Chapter 2 that when data is added to a HashTable, a new memory block is allocated for it and the data passed in is copied; when the data is extracted back out it is the pointer to that data which is returned. The following code fragment adds data1 to the HashTable, and then extracts it back out such that at the end of the routine, <em>data2 contains the same contents as </em>data1 even though the pointers refer to different memory addresses.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_sample</span><span class="params">(HashTable *ht, sample_data *data1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sample_data *data2;</span><br><span class="line">ulong targetID = zend_hash_next_free_element(ht);</span><br><span class="line"><span class="keyword">if</span> (zend_hash_index_update(ht, targetID,</span><br><span class="line">data1, <span class="keyword">sizeof</span>(sample_data), <span class="literal">NULL</span>) == FAILURE) &#123;</span><br><span class="line"><span class="comment">/* Should never happen */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(zend_hash_index_find(ht, targetID, (<span class="keyword">void</span> **)&amp;data2) == FAILURE) &#123;</span><br><span class="line"><span class="comment">/* Very unlikely since we just added this element */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* data1 != data2, however *data1 == *data2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>除了读取，我们还需要检测某个key是否存在：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_exists</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *arKey, uint nKeyLen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_index_exists</span><span class="params">(HashTable *ht, ulong h)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>这两个函数返回SUCCESS或者FAILURE，分别代表着是否存在：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( zend_hash_exists(EG(active_symbol_table),<span class="string">"foo"</span>, <span class="keyword">sizeof</span>(<span class="string">"foo"</span>)) == SUCCESS )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* $foo is set */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* $foo does not exist */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="提速"><a href="#提速" class="headerlink" title="提速!"></a>提速!</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ulong <span class="title">zend_get_hash_value</span><span class="params">(<span class="keyword">char</span> *arKey, uint nKeyLen)</span></span>;</span><br></pre></td></tr></table></figure><p>当我们需要对同一个字符串的key进行许多操作时候，比如先检测有没，然后插入，然后修改等等，这时我们便可以使用zend_get_hash_value函数来对我们的操作进行加速！这个函数的返回值可以和quick系列函数使用，达到加速的目的(就是不再重复计算这个字符串的散列值，而直接使用已准备好的)！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_quick_add</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">ulong hashval,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_quick_update</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">ulong hashval,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_quick_find</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">ulong hashval,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> **pData</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_quick_exists</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">ulong hashval</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>虽然很意外，但你还是要接受没有zend_hash_quick_del()这个函数。quick类函数会在下面这种场合中用到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample_hash_copy</span><span class="params">(HashTable *hta, HashTable *htb,<span class="keyword">char</span> *arKey, uint nKeyLen TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ulong hashval = zend_get_hash_value(arKey, nKeyLen);</span><br><span class="line">    zval **copyval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_quick_find(hta, arKey, nKeyLen,hashval, (<span class="keyword">void</span>**)&amp;copyval) == FAILURE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//标明不存在这个索引</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个zval已经被其它的Hashtable使用了，这里我们进行引用计数操作。</span></span><br><span class="line">    (*copyval)-&gt;refcount__gc++;</span><br><span class="line">    zend_hash_quick_update(htb, arKey, nKeyLen, hashval,copyval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制与合并-Copy-And-Merge"><a href="#复制与合并-Copy-And-Merge" class="headerlink" title="复制与合并(Copy And Merge)"></a>复制与合并(Copy And Merge)</h3><p>在PHP语言中，我们经常需要进行数组间的Copy与Merge操作，所以php语言中的数组在C语言中的实现HashTable也肯定会经常碰到这种情况。为了简化这一类操作，内核中早已准备好了相应的API供我们使用。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_copy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *target,</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *source,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">copy_ctor_func_t</span> pCopyConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *tmp,</span></span></span><br><span class="line"><span class="function"><span class="params">uint <span class="built_in">size</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p></p><ul><li>*source中的所有元素都会通过pCopyConstructor函数Copy到*target中去，我们还是以PHP语言中的数组举例，pCopyConstructor这个hook使得我们可以在copy变量的时候对他们的ref_count进行加一操作。target中原有的与source中索引位置的数据会被替换掉，而其它的元素则会被保留，原封不动。</li><li>tmp参数是为了兼容PHP4.0.3以前版本的，现在赋值为NULL即可。</li><li>size参数代表每个元素的大小，对于PHP语言中的数组来说，这里的便是sizeof(zval*)了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_merge</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *target,</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *source,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">copy_ctor_func_t</span> pCopyConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *tmp,</span></span></span><br><span class="line"><span class="function"><span class="params">uint <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> overwrite</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>zend_hash_merge()与zend_hash_copy唯一的不同便是多了个int类型的overwrite参数，当其值非0的时候，两个函数的工作是完全一样的；如果overwrite参数为0，则zend_hash_merge函数就不会对target中已有索引的值进行替换了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">zend_bool</span> <span class="params">(*<span class="keyword">merge_checker_func_t</span>)</span><span class="params">(HashTable *target_ht,<span class="keyword">void</span> *source_data, zend_hash_key *hash_key, <span class="keyword">void</span> *pParam)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_merge_ex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *target,</span></span></span><br><span class="line"><span class="function"><span class="params">HashTable *source,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">copy_ctor_func_t</span> pCopyConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">uint <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">merge_checker_func_t</span> pMergeSource,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *pParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数又繁琐了些，与zend_hash_copy相比，其多了两个参数，多出来的pMergeSoure回调函数允许我们选择性的进行merge，而不是全都merge。The final form of this group of functions allows for selective copying using a merge checker function. The following example shows zend_hash_merge_ex() in use to copy only the associatively indexed members of the source HashTable (which happens to be a userspace variable array):<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zend_bool <span class="title">associative_only</span><span class="params">(HashTable *ht, <span class="keyword">void</span> *pData,zend_hash_key *hash_key, <span class="keyword">void</span> *pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果是字符串索引</span></span><br><span class="line">    <span class="keyword">return</span> (hash_key-&gt;arKey &amp;&amp; hash_key-&gt;nKeyLength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_associative</span><span class="params">(HashTable *target, HashTable *source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zend_hash_merge_ex(target, source, zval_add_ref,<span class="keyword">sizeof</span>(zval*), associative_only, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>在PHP语言中，我们有很多方法来遍历一个数组，对于数组的本质HashTable，我们也有很多办法来对其进行遍历操作。首先最简单的一种办法便是使用一种与PHP语言中foreach语句功能类似的函数——zend_hash_apply，它接收一个回调函数，并将HashTable的每一个元素都传递给它。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">apply_func_t</span>)</span><span class="params">(<span class="keyword">void</span> *pDest TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_apply</span><span class="params">(HashTable *ht,<span class="keyword">apply_func_t</span> apply_func TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>下面是另外一种遍历函数：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">apply_func_arg_t</span>)</span><span class="params">(<span class="keyword">void</span> *pDest,<span class="keyword">void</span> *argument TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_apply_with_argument</span><span class="params">(HashTable *ht,<span class="keyword">apply_func_arg_t</span> apply_func, <span class="keyword">void</span> *data TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>通过上面的函数可以在执行遍历时向回调函数传递任意数量的值，这在一些diy操作中非常有用。</p><p>上述函数对传给它们的回调函数的返回值有一个共同的约定，详细介绍下下表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">表格 <span class="number">8.1</span>. 回调函数的返回值</span><br><span class="line">ConstantMeaning</span><br><span class="line"></span><br><span class="line">ZEND_HASH_APPLY_KEEP结束当前请求，进入下一个循环。与PHP语言foreach语句中的一次循环执行完毕或者遇到<span class="keyword">continue</span>关键字的作用一样。</span><br><span class="line">ZEND_HASH_APPLY_STOP跳出，与PHP语言foreach语句中的<span class="keyword">break</span>关键字的作用一样。</span><br><span class="line">ZEND_HASH_APPLY_REMOVE删除当前的元素，然后继续处理下一个。相当于在PHP语言中：unset($foo[$key]);<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>我们来一下PHP语言中的foreach循环：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $val) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value is: $val\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>那我们的回调函数在C语言中应该这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_sample_print_zval</span><span class="params">(zval **val TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重新copy一个zval，防止破坏原数据</span></span><br><span class="line">    zval tmpcopy = **val;</span><br><span class="line">    zval_copy_ctor(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换为字符串</span></span><br><span class="line">    INIT_PZVAL(&amp;tmpcopy);</span><br><span class="line">    convert_to_string(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//开始输出</span></span><br><span class="line">    php_printf(<span class="string">"The value is: "</span>);</span><br><span class="line">    PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));</span><br><span class="line">    php_printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//毁尸灭迹</span></span><br><span class="line">    zval_dtor(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回，继续遍历下一个～</span></span><br><span class="line"><span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历我们的HashTable：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个名为arrht、元素为zval*类型的HashTable</span></span><br><span class="line">zend_hash_apply(arrht, php_sample_print_zval TSRMLS_CC);</span><br></pre></td></tr></table></figure><p></p><blockquote><p>再次提醒，保存在HashTable中的元素并不是真正的最终变量，而是指向它的一个指针。我们的上面的遍历函数接收的是一个zval**类型的参数。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">apply_func_args_t</span>)</span><span class="params">(<span class="keyword">void</span> *pDest,<span class="keyword">int</span> num_args, va_list args, zend_hash_key *hash_key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_apply_with_arguments</span><span class="params">(HashTable *ht,<span class="keyword">apply_func_args_t</span> apply_func, <span class="keyword">int</span> numargs, ...)</span></span>;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>为了能在遍历时同时接收索引的值，我们必须使用第三种形式的zend_hash_apply！就像PHP语言中这样的功能：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $key =&gt; $val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"The value of $key is: $val\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>为了配合zend_hash_apply_with_arguments()函数，我们需要对我们的遍历执行函数做一下小小的改动，使其接受索引作为一个参数：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_sample_print_zval_and_key</span><span class="params">(zval **val,<span class="keyword">int</span> num_args,va_list args,zend_hash_key *hash_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重新copy一个zval，防止破坏原数据</span></span><br><span class="line">zval tmpcopy = **val;</span><br><span class="line"><span class="comment">/* tsrm_ls is needed by output functions */</span></span><br><span class="line">TSRMLS_FETCH();</span><br><span class="line">zval_copy_ctor(&amp;tmpcopy);</span><br><span class="line">INIT_PZVAL(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换为字符串</span></span><br><span class="line">convert_to_string(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行输出</span></span><br><span class="line">php_printf(<span class="string">"The value of "</span>);</span><br><span class="line"><span class="keyword">if</span> (hash_key-&gt;nKeyLength)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//如果是字符串类型的key</span></span><br><span class="line">PHPWRITE(hash_key-&gt;arKey, hash_key-&gt;nKeyLength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果是数字类型的key</span></span><br><span class="line">php_printf(<span class="string">"%ld"</span>, hash_key-&gt;h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">php_printf(<span class="string">" is: "</span>);</span><br><span class="line">PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));</span><br><span class="line">php_printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//毁尸灭迹</span></span><br><span class="line">zval_dtor(&amp;tmpcopy);</span><br><span class="line"><span class="comment">/* continue; */</span></span><br><span class="line"><span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>执行遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_apply_with_arguments(arrht,php_sample_print_zval_and_key, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><div class="tip-common">这个函数通过C语言中的可变参数特性来接收参数。This particular example required no arguments to be passed; for information on extracting variable argument lists from va_list args, see the POSIX documentation pages for va_start(), va_arg(), and va_end().</div><p>当我们检查这个hash_key是字符串类型还是数字类型时，是通过nKeyLength属性来检测的,而不是arKey属性。这是因为内核有时候会留在arKey属性里些脏数据，但nKeyLength属性是安全的，可以安全的使用。甚至对于空字符串索引，它也照样能处理。比如：$foo[‘’] =”Bar”;索引的值是NULL字符，但它的长度却是包括最后这个NULL字符的，所以为1。</p><h3 id="向前遍历HashTable"><a href="#向前遍历HashTable" class="headerlink" title="向前遍历HashTable"></a>向前遍历HashTable</h3><p>有时我们希望不用回调函数也能遍历一个数组的数据，为了实现这个功能，内核特意的为每个HashTable加了个属性：The internal pointer（内部指针）。&lt;/p?<br>我们还是以PHP语言中的数组举例，有以下函数来处理它所对应的那个HashTable的内部指针：reset(), key(), current(), next(), prev(), each(), and end()。</p><p><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $arr = <span class="built_in">array</span>(<span class="string">'a'</span>=&gt;<span class="number">1</span>, <span class="string">'b'</span>=&gt;<span class="number">2</span>, <span class="string">'c'</span>=&gt;<span class="number">3</span>);</span><br><span class="line">    reset($arr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>($key, $val) = each($arr)) &#123;</span><br><span class="line">        <span class="comment">/* Do something with $key and $val */</span></span><br><span class="line">    &#125;</span><br><span class="line">    reset($arr);</span><br><span class="line">    $firstkey = key($arr);</span><br><span class="line">    $firstval = current($arr);</span><br><span class="line">    $bval = next($arr);</span><br><span class="line">    $cval = next($arr);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p></p><p>ZEND内核中有一组操作HashTable的功能与以上函数功能类似的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_internal_pointer_reset</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* key() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_get_current_key</span><span class="params">(HashTable *ht,<span class="keyword">char</span> **strIdx, unit *strIdxLen,ulong *numIdx, zend_bool duplicate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* current() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_get_current_data</span><span class="params">(HashTable *ht, <span class="keyword">void</span> **pData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* next()/each() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_move_forward</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prev() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_move_backwards</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* end() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_internal_pointer_end</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他的...... */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_get_current_key_type</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_has_more_elements</span><span class="params">(HashTable *ht)</span></span>;</span><br></pre></td></tr></table></figure><pre><code>&lt;div class=&quot;tip-common&quot;&gt;PHP语言中的next()、prev()、end()函数在移动完指针之后，都通过调用zend_hash_get_current_data()函数来获取当前所指的元素并返回。而each()虽然和next()很像，却是使用zend_hash_get_current_key()函数的返回值来作为它的返回值。&lt;/div&gt;</code></pre><p>现在我们用另外一种方法来实现上面的foreach：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample_print_var_hash</span><span class="params">(HashTable *arrht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(</span><br><span class="line">    zend_hash_internal_pointer_reset(arrht);</span><br><span class="line">    zend_hash_has_more_elements(arrht) == SUCCESS;</span><br><span class="line">    zend_hash_move_forward(arrht))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *key;</span><br><span class="line">        uint keylen;</span><br><span class="line">        ulong idx;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        zval **ppzval, tmpcopy;</span><br><span class="line"></span><br><span class="line">        type = zend_hash_get_current_key_ex(arrht, &amp;key, &amp;keylen,&amp;idx, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (zend_hash_get_current_data(arrht, (<span class="keyword">void</span>**)&amp;ppzval) == FAILURE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Should never actually fail</span></span><br><span class="line"><span class="comment">             * since the key is known to exist. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新copy一个zval，防止破坏原数据</span></span><br><span class="line">        tmpcopy = **ppzval;</span><br><span class="line">        zval_copy_ctor(&amp;tmpcopy);</span><br><span class="line">        INIT_PZVAL(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">        convert_to_string(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Output */</span></span><br><span class="line">        php_printf(<span class="string">"The value of "</span>);</span><br><span class="line">        <span class="keyword">if</span> (type == HASH_KEY_IS_STRING)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* String Key / Associative */</span></span><br><span class="line">            PHPWRITE(key, keylen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Numeric Key */</span></span><br><span class="line">            php_printf(<span class="string">"%ld"</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        php_printf(<span class="string">" is: "</span>);</span><br><span class="line">        PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));</span><br><span class="line">        php_printf(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">/* Toss out old copy */</span></span><br><span class="line">        zval_dtor(&amp;tmpcopy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码你应该都能看懂了，唯一还没接触到的可能是zend_hash_get_current_key()函数的返回值，它的返回值见表8.2。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConstantMeaning</span><br><span class="line"></span><br><span class="line">HASH_KEY_IS_STRING当前元素的索引是字符串类型的。therefore, a pointer to the element's key name will be populated into strIdx, and its length will be populated into stdIdxLen. If the duplicate flag is set to a nonzero value, the key will be estrndup()'d before being populated into strIdx. The calling application is expected to free this duplicated string.</span><br><span class="line"></span><br><span class="line">HASH_KEY_IS_LONG当前元素的索引是数字型的。</span><br><span class="line">HASH_KEY_NON_EXISTANTHashTable中的内部指针已经移动到尾部，不指向任何元素。</span><br></pre></td></tr></table></figure><p></p><h3 id="Preserving-the-Internal-Pointer"><a href="#Preserving-the-Internal-Pointer" class="headerlink" title="Preserving the Internal Pointer"></a>Preserving the Internal Pointer</h3><p>在我们遍历一个HashTable时，一般是很难陷入死循环的。When iterating through a HashTable, particularly one containing userspace variables, it’s not uncommon to encounter circular references, or at least self-overlapping loops. If one iteration context starts looping through a HashTable and the internal pointer reachesfor examplethe halfway mark, a subordinate iterator starts looping through the same HashTable and would obliterate the current internal pointer position, leaving the HashTable at the end when it arrived back at the first loop.</p><p>The way this is resolvedboth within the zend_hash_apply implementation and within custom move forward usesis to supply an external pointer in the form of a HashPosition variable.</p><p>Each of the zend_hash_<em>() functions listed previously has a zend_hash_</em>_ex() counterpart that accepts one additional parameter in the form of a pointer to a HashPostion data type. Because the HashPosition variable is seldom used outside of a short-lived iteration loop, it’s sufficient to declare it as an immediate variable. You can then dereference it on usage such as in the following variation on the php_sample_print_var_hash() function you saw earlier:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample_print_var_hash</span><span class="params">(HashTable *arrht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashPosition pos;</span><br><span class="line">    <span class="keyword">for</span>(zend_hash_internal_pointer_reset_ex(arrht, &amp;pos);</span><br><span class="line">    zend_hash_has_more_elements_ex(arrht, &amp;pos) == SUCCESS;</span><br><span class="line">    zend_hash_move_forward_ex(arrht, &amp;pos)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *key;</span><br><span class="line">        uint keylen;</span><br><span class="line">        ulong idx;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">        zval **ppzval, tmpcopy;</span><br><span class="line"></span><br><span class="line">        type = zend_hash_get_current_key_ex(arrht,</span><br><span class="line">                                &amp;key, &amp;keylen,</span><br><span class="line">                                &amp;idx, <span class="number">0</span>, &amp;pos);</span><br><span class="line">        <span class="keyword">if</span> (zend_hash_get_current_data_ex(arrht,</span><br><span class="line">                    (<span class="keyword">void</span>**)&amp;ppzval, &amp;pos) == FAILURE) &#123;</span><br><span class="line">            <span class="comment">/* Should never actually fail</span></span><br><span class="line"><span class="comment">             * since the key is known to exist. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Duplicate the zval so that</span></span><br><span class="line"><span class="comment">         * the original's contents are not destroyed */</span></span><br><span class="line">        tmpcopy = **ppzval;</span><br><span class="line">        zval_copy_ctor(&amp;tmpcopy);</span><br><span class="line">        <span class="comment">/* Reset refcount &amp; Convert */</span></span><br><span class="line">        INIT_PZVAL(&amp;tmpcopy);</span><br><span class="line">        convert_to_string(&amp;tmpcopy);</span><br><span class="line">        <span class="comment">/* Output */</span></span><br><span class="line">        php_printf(<span class="string">"The value of "</span>);</span><br><span class="line">        <span class="keyword">if</span> (type == HASH_KEY_IS_STRING) &#123;</span><br><span class="line">            <span class="comment">/* String Key / Associative */</span></span><br><span class="line">            PHPWRITE(key, keylen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Numeric Key */</span></span><br><span class="line">            php_printf(<span class="string">"%ld"</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line">        php_printf(<span class="string">" is: "</span>);</span><br><span class="line">        PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));</span><br><span class="line">        php_printf(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">/* Toss out old copy */</span></span><br><span class="line">        zval_dtor(&amp;tmpcopy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">With these very slight additions, the HashTable's true internal pointer is preserved in whatever state it was initially in on entering the function. When it comes to working with internal pointers of userspace variable HashTables (that is, arrays), this extra step will very likely make the difference between whether the scripter's code works as expected.</span><br><span class="line">### 删除</span><br><span class="line">内核中一共预置了四个删除HashTable元素的函数，头两个是用户删除某个确定索引的数据：</span><br><span class="line">&lt;code c&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_del</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *arKey, uint nKeyLen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_index_del</span><span class="params">(HashTable *ht, ulong h)</span></span>;</span><br></pre></td></tr></table></figure><p>它们两个分别用来删除字符串索引和数字索引的数据，操作完成后都返回SUCCESS或者FAILURE表示成功or失败。<br>回顾一下最上面的叙述，当一个元素被删除时，会激活HashTable的destructor回调函数。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_clean</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_destroy</span><span class="params">(HashTable *ht)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>前者用于将HashTable中的元素全部删除，而后者是将这个HashTable自身也毁灭掉。<br>现在让我们来完整的回顾一下HashTable的创建、添加、删除操作。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sample_strvec_handler</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashTable *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配内存</span></span><br><span class="line">    ALLOC_HASHTABLE(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_init(ht, argc, <span class="literal">NULL</span>,ZVAL_PTR_DTOR, <span class="number">0</span>) == FAILURE) &#123;</span><br><span class="line">        FREE_HASHTABLE(ht);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充数据</span></span><br><span class="line">    <span class="keyword">while</span> (argc) &#123;</span><br><span class="line">        zval *value;</span><br><span class="line">        MAKE_STD_ZVAL(value);</span><br><span class="line">        ZVAL_STRING(value, argv[argc], <span class="number">1</span>);</span><br><span class="line">        argv++;</span><br><span class="line">        <span class="keyword">if</span> (zend_hash_next_index_insert(ht, (<span class="keyword">void</span>**)&amp;value,</span><br><span class="line">                            <span class="keyword">sizeof</span>(zval*)) == FAILURE) &#123;</span><br><span class="line">            <span class="comment">/* Silently skip failed additions */</span></span><br><span class="line">            zval_ptr_dtor(&amp;value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成工作</span></span><br><span class="line">    process_hashtable(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//毁尸灭迹</span></span><br><span class="line">    zend_hash_destroy(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放ht 为什么不在destroy里free呢，求解释！</span></span><br><span class="line">    FREE_HASHTABLE(ht);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="排序、比较and-Going-to-the-Extreme-s"><a href="#排序、比较and-Going-to-the-Extreme-s" class="headerlink" title="排序、比较and Going to the Extreme(s)"></a>排序、比较and Going to the Extreme(s)</h3><p>针对HashTable操作的Zend Api中有很多都需要回调函数。首先让我们来处理一下对HashTable中元素大小比较的问题：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">compare_func_t</span>)</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>这很像PHP语言中usort函数需要的参数，它将比较两个值<em>a与</em>b，如果<em>a&gt;</em>b,则返回1，相等则返回0，否则返回-1。下面是zend_hash_minmax函数的声明，它就需要我们上面声明的那个类型的函数作为回调函数：<br>int zend_hash_minmax(HashTable *ht, compare_func_t compar,int flag, void **pData TSRMLS_DC);<br>这个函数的功能我们从它的名称中便能肯定，它用来比较HashTable中的元素大小。如果flag==0则返回最小值，否则返回最大值！</p><p>下面让我们来利用这个函数来对用户端定义的所有函数根据函数名找到最大值与最小值(大小写不敏感～)。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个比较函数，作为zend_hash_minmax的回调函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fname_compare</span><span class="params">(zend_function *a, zend_function *b TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strcasecmp(a-&gt;common.function_name, b-&gt;common.function_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample_funcname_sort</span><span class="params">(TSRMLS_D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zend_function *fe;</span><br><span class="line">    <span class="keyword">if</span> (zend_hash_minmax(EG(function_table), fname_compare,<span class="number">0</span>, (<span class="keyword">void</span> **)&amp;fe) == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"Min function: %s\n"</span>, fe-&gt;common.function_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zend_hash_minmax(EG(function_table), fname_compare,<span class="number">1</span>, (<span class="keyword">void</span> **)&amp;fe) == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"Max function: %s\n"</span>, fe-&gt;common.function_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>zend_hash_compare()也许要回调函数，它的功能是将HashTable看作一个整体与另一个HashTable做比较，如果前者大于后者返回1，相等返回0，否则返回-1。</p><p></p><p>int zend_hash_compare(HashTable <em>hta, HashTable </em>htb,compare_func_t compar, zend_bool ordered TSRMLS_DC);</p><p>默认情况下它往往是先判断各个HashTable元素的个数，个数多的最大！<br>如果两者的元素一样多，然后就比较它们各自的第一个元素，If the ordered flag is set, it compares keys/indices with the first element of htb string keys are compared first on length, and then on binary sequence using memcmp(). If the keys are equal, the value of the element is compared with the first element of htb using the comparison callback function.<br>If the ordered flag is not set, the data portion of the first element of hta is compared against the element with a matching key/index in htb using the comparison callback function. If no matching element can be found for htb, then hta is considered greater than htb and 1 is returned.<br>If at the end of a given loop, hta and htb are still considered equal, comparison continues with the next element of hta until a difference is found or all elements have been exhausted, in which case 0 is returned.<br>另外一个重要的需要回调函数的API便是排序函数，它需要的回调函数形式是这样的：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sort_func_t</span>)</span><span class="params">(<span class="keyword">void</span> **Buckets, <span class="keyword">size_t</span> numBuckets,<span class="keyword">size_t</span> sizBucket, <span class="keyword">compare_func_t</span> comp TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>This callback will be triggered once, and receive a vector of all the Buckets (elements) in the HashTable as a series of pointers. These Buckets may be swapped around within the vector according to the sort function’s own logic with or without the use of the comparison callback. In practice, sizBucket will always be sizeof(Bucket*).</p><p>Unless you plan on implementing your own alternative bubblesort method, you won’t need to implement a sort function yourself. A predefined sort methodzend_qsortalready exists for use as a callback to zend_hash_sort() leaving you to implement the comparison function only.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_sort</span><span class="params">(HashTable *ht, <span class="keyword">sort_func_t</span> sort_func,<span class="keyword">compare_func_t</span> compare_func, <span class="keyword">int</span> renumber TSRMLS_DC)</span></span>;</span><br></pre></td></tr></table></figure><p>最后一个参数如果为TRUE，则会抛弃HashTable中原有的索引-键关系，将对排列好的新值赋予新的数字键值。PHP语言中的sort函数实现如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_sort(target_hash, zend_qsort,array_data_compare, <span class="number">1</span> TSRMLS_CC);</span><br></pre></td></tr></table></figure><p></p><p>array_data_compare是一个返回compare_func_t类型数据的函数，它将按照HashTable中zval*值的大小进行排序。</p><h1 id="8-3-使用HashTable与-数组"><a href="#8-3-使用HashTable与-数组" class="headerlink" title="8.3 使用HashTable与{数组}"></a>8.3 使用HashTable与{数组}</h1><p>当你在扩展中使用HashTable时候，95%是要存储用户端的变量，就像PHP语言中数组那样。为此，内核中已经准备好了相应的工具，来让我们更加的方便的操作HashTable存储zval*，也就是PHP语言中的数组，即IS_ARRAY常量代表的zval，以下用{数组}来代替PHP语言中的数组这个词。</p><h3 id="创建-数组"><a href="#创建-数组" class="headerlink" title="创建{数组}"></a>创建{数组}</h3><p>创建HashTable有些繁琐，虽然有辅助的宏但还是不能一步完成，而创建{数组}便简单多了，直接使用array_init(zval <em>arrval)函数即可，注意它的参数是zval</em>类型的！<br>这样，我们像用户端返回数组便简单多了：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_array)</span><br><span class="line">&#123;</span><br><span class="line">array_init(return_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return_value是zval*类型的，所以我们直接对它调用array_init()函数即可，即把它初始化成了一个空数组。</span></span><br></pre></td></tr></table></figure><p></p><h3 id="增！"><a href="#增！" class="headerlink" title="增！"></a>增！</h3><p>将{数组}初始化后，接下来就要向其添加元素了。因为PHP语言中有多种类型的变量，所以也对应的有多种类型的add_assoc_<em>()、add_index_</em>、add_next_index_*()函数。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array_init(arrval);</span><br><span class="line"></span><br><span class="line">add_assoc_long(zval *arrval, <span class="keyword">char</span> *key, <span class="keyword">long</span> lval);</span><br><span class="line">add_index_long(zval *arrval, ulong idx, <span class="keyword">long</span> lval);</span><br><span class="line">add_next_index_long(zval *arrval, <span class="keyword">long</span> lval);</span><br></pre></td></tr></table></figure><p>这三个函数的第一个参数都要被操作的{数组}指针，然后是索引值，最后是变量，唯一不同的是add_next_index_long()函数的索引值是其自己计算出来的。根据上一节的内容我们可以知道，这三个函数分别在内部使用了zend_hash_update()、zend_hash_index_update()与zend_hash_next_index_insert函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add_assoc_*系列函数：</span></span><br><span class="line">add_assoc_null(zval *aval, <span class="keyword">char</span> *key);</span><br><span class="line">add_assoc_bool(zval *aval, <span class="keyword">char</span> *key, zend_bool bval);</span><br><span class="line">add_assoc_long(zval *aval, <span class="keyword">char</span> *key, <span class="keyword">long</span> lval);</span><br><span class="line">add_assoc_double(zval *aval, <span class="keyword">char</span> *key, <span class="keyword">double</span> dval);</span><br><span class="line">add_assoc_string(zval *aval, <span class="keyword">char</span> *key, <span class="keyword">char</span> *strval, <span class="keyword">int</span> dup);</span><br><span class="line">add_assoc_stringl(zval *aval, <span class="keyword">char</span> *key,<span class="keyword">char</span> *strval, uint <span class="built_in">strlen</span>, <span class="keyword">int</span> dup);</span><br><span class="line">add_assoc_zval(zval *aval, <span class="keyword">char</span> *key, zval *value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//备注：其实这些函数都是宏，都是对add_assoc_*_ex函数的封装。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add_index_*系列函数：</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_long</span><span class="params">(zval *arg, ulong idx, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_null</span><span class="params">(zval *arg, ulong idx)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_bool</span><span class="params">(zval *arg, ulong idx, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_resource</span><span class="params">(zval *arg, ulong idx, <span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_double</span><span class="params">(zval *arg, ulong idx, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_string</span><span class="params">(zval *arg, ulong idx, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> duplicate)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_stringl</span><span class="params">(zval *arg, ulong idx, <span class="keyword">const</span> <span class="keyword">char</span> *str, uint length, <span class="keyword">int</span> duplicate)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_zval</span><span class="params">(zval *arg, ulong index, zval *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add_next_index_long函数：</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_long</span><span class="params">(zval *arg, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_null</span><span class="params">(zval *arg)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_bool</span><span class="params">(zval *arg, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_resource</span><span class="params">(zval *arg, <span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_double</span><span class="params">(zval *arg, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_string</span><span class="params">(zval *arg, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> duplicate)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_stringl</span><span class="params">(zval *arg, <span class="keyword">const</span> <span class="keyword">char</span> *str, uint length, <span class="keyword">int</span> duplicate)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_zval</span><span class="params">(zval *arg, zval *value)</span></span>;</span><br></pre></td></tr></table></figure><p>每组函数最后的一个，即zend…_zval()函数，允许我们向这个{数组}中添加资源、对象、{数组}等复合类型的PHP变量。下面让我们通过一个例子来演示下它们的用法：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_array)</span><br><span class="line">&#123;</span><br><span class="line">zval *subarray;</span><br><span class="line"></span><br><span class="line">array_init(return_value);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add some scalars */</span></span><br><span class="line">add_assoc_long(return_value, <span class="string">"life"</span>, <span class="number">42</span>);</span><br><span class="line">add_index_bool(return_value, <span class="number">123</span>, <span class="number">1</span>);</span><br><span class="line">add_next_index_double(return_value, <span class="number">3.1415926535</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Toss in a static string, dup'd by PHP */</span></span><br><span class="line">add_next_index_string(return_value, <span class="string">"Foo"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now a manually dup'd string */</span></span><br><span class="line">add_next_index_string(return_value, estrdup(<span class="string">"Bar"</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a subarray */</span></span><br><span class="line">MAKE_STD_ZVAL(subarray);</span><br><span class="line">array_init(subarray);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Populate it with some numbers */</span></span><br><span class="line">add_next_index_long(subarray, <span class="number">1</span>);</span><br><span class="line">add_next_index_long(subarray, <span class="number">20</span>);</span><br><span class="line">add_next_index_long(subarray, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Place the subarray in the parent */</span></span><br><span class="line">add_index_zval(return_value, <span class="number">444</span>, subarray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这时如果我们用户端var_dump这个函数的返回值便会得到：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(sample_array());</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">[<span class="string">"life"</span>]=&gt; int(<span class="number">42</span>)</span><br><span class="line">[<span class="number">123</span>]=&gt; bool(<span class="keyword">true</span>)</span><br><span class="line">[<span class="number">124</span>]=&gt; float(<span class="number">3.1415926535</span>)</span><br><span class="line">[<span class="number">125</span>]=&gt; string(<span class="number">3</span>) <span class="string">"Foo"</span></span><br><span class="line">[<span class="number">126</span>]=&gt; string(<span class="number">3</span>) <span class="string">"Bar"</span></span><br><span class="line">[<span class="number">444</span>]=&gt; <span class="keyword">array</span>(<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">[<span class="number">0</span>]=&gt; int(<span class="number">1</span>)</span><br><span class="line">[<span class="number">1</span>]=&gt; int(<span class="number">20</span>)</span><br><span class="line">[<span class="number">2</span>]=&gt; int(<span class="number">300</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="8-4-使用HashTable与-数组"><a href="#8-4-使用HashTable与-数组" class="headerlink" title="8.4 使用HashTable与{数组}"></a>8.4 使用HashTable与{数组}</h1><p>我们用了很长的篇幅在这一章描述内核中的HashTable结构以及PHP中的数组实现。在接下来的时间中，我们会在它的基础上学习一下内核是怎样实现与管理PHP语言中的资源与类的。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7 函数的参数</title>
      <link href="/posts/bb08f365.html"/>
      <url>/posts/bb08f365.html</url>
      
        <content type="html"><![CDATA[<h1 id="7-函数的参数"><a href="#7-函数的参数" class="headerlink" title="7 函数的参数"></a>7 函数的参数</h1><p>前面的章节我们look了一下如何在扩展中定义函数，它们的实现大都比较简单，但是在实际工作中，肯定会碰到函数接收参数的问题，而它就是我们这一章要讲解的内容。</p><h1 id="7-1-函数的参数"><a href="#7-1-函数的参数" class="headerlink" title="7.1 函数的参数"></a>7.1 函数的参数</h1><p>最简单的获取函数调用者传递过来的参数便是使用zend_parse_parameters()函数。<br>zend_parse_parameters()函数的前几个参数我们直接用内核里宏来生成便可以了，形式为：ZEND_NUM_ARGS() TSRMLS_CC，注意两者之间有个空格，但是没有逗号。从名字可以看出，ZEND_NUM_ARGS()代表着参数的个数。<br>紧接着需要传递给zend_parse_parameters()函数的参数是一个用于格式化的字符串，就像printf的第一个参数一样。下面表示了最常用的几个符号。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type_spec是格式化字符串，其常见的含义如下：</span><br><span class="line">参数   代表着的类型</span><br><span class="line">bBoolean</span><br><span class="line">lInteger 整型</span><br><span class="line">dFloating <span class="built_in">point</span> 浮点型</span><br><span class="line">s<span class="keyword">String</span> 字符串</span><br><span class="line">rResource 资源</span><br><span class="line">aArray 数组</span><br><span class="line">oObject instance 对象</span><br><span class="line">OObject instance of a specified type 特定类型的对象</span><br><span class="line">zNon-specific zval 任意类型～</span><br><span class="line">Zzval**类型</span><br><span class="line">f表示函数、方法名称，PHP5<span class="number">.1</span>里貌似木有... ...</span><br></pre></td></tr></table></figure><p></p><p>这个函数就像printf()函数一样，后面的参数是与格式化字符串里的格式一一对应的。一些基础类型的数据会直接映射成C语言里的类型。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_getlong) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> foo;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,<span class="string">"l"</span>, &amp;foo) == FAILURE)</span><br><span class="line">    &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    php_printf(<span class="string">"The integer value of the parameter is: %ld\n"</span>, foo);</span><br><span class="line">    RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><pre><code>一般来说，int和long这两种数据类型的数据往往是相同的，但也有例外情况。所以我们不应改把long的数组放在一个int里，尤其是在64位平台里，那将引发一些不容易排查的Bug。所以通过zend_parse_parameter()函数接收参数时，我们应该使用内核约定好的那些类型的变量作为载体。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数对应C里的数据类型</span><br><span class="line">bzend_bool</span><br><span class="line">l<span class="keyword">long</span></span><br><span class="line">d<span class="keyword">double</span></span><br><span class="line">s<span class="keyword">char</span>*, <span class="keyword">int</span> 前者接收指针，后者接收长度</span><br><span class="line">rzval*</span><br><span class="line">azval*</span><br><span class="line">ozval*</span><br><span class="line">Ozval*, zend_class_entry*</span><br><span class="line">zzval*</span><br><span class="line">Zzval**</span><br></pre></td></tr></table></figure><p>注意，所有的PHP语言中的复合类型参数都需要zval*类型来作为载体，因为它们都是内核自定义的一些数据结构。我们一定要确认参数和载体的类型一致，如果需要，它可以进行类型转换，比如把array转换成stdClass对象。<br>s和O(字母大写欧)类型需要单独说一些，因为它们都需要两个载体。我们将在接下来的章节里了解php中对象的具体实现。这样我们改写一下我们在第五章定义的一个函数：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample_hello_world</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Hello $name!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在编写扩展时，我们需要用zend_parse_parameters()来接收这个字符串:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_hello_world) &#123;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">int</span> name_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"s"</span>,&amp;name, &amp;name_len) == FAILURE)</span><br><span class="line">&#123;</span><br><span class="line">RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">php_printf(<span class="string">"Hello "</span>);</span><br><span class="line">PHPWRITE(name, name_len);</span><br><span class="line">php_printf(<span class="string">"!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><div class="tip-warning"><br>如果传递给函数的参数数量小于zend_parse_parameters()要接收的参数数量，它便会执行失败，并返回FAILURE。<br></div><br>如果我们需要接收多个参数，可以直接在zend_parse_paramenters()的参数里罗列接收载体便可以了，如：<p></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample_hello_world</span><span class="params">($name, $greeting)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Hello $greeting $name!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">sample_hello_world(<span class="string">'John Smith'</span>, <span class="string">'Mr.'</span>);</span><br></pre></td></tr></table></figure><p>在PHP扩展里应该这样来实现：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_hello_world) &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> name_len;</span><br><span class="line">    <span class="keyword">char</span> *greeting;</span><br><span class="line">    <span class="keyword">int</span> greeting_len;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"ss"</span>,&amp;name, &amp;name_len, &amp;greeting, &amp;greeting_len) == FAILURE) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    php_printf(<span class="string">"Hello "</span>);</span><br><span class="line">    PHPWRITE(greeting, greeting_len);</span><br><span class="line">    php_printf(<span class="string">" "</span>);</span><br><span class="line">    PHPWRITE(name, name_len);</span><br><span class="line">    php_printf(<span class="string">"!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>除了上面定义的参数，还有其它的三个参数来增强我们接收参数的能力,如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type ModifierMeaning</span><br><span class="line">|它之前的参数都是必须的，之后的都是非必须的，也就是有默认值的。</span><br><span class="line">!如果接收了一个PHP语言里的null变量，则直接把其转成C语言里的<span class="literal">NULL</span>，而不是封装成IS_NULL类型的zval。</span><br><span class="line">/如果传递过来的变量与别的变量共用一个zval，而且不是引用，则进行强制分离，新的zval的is_ref__gc==<span class="number">0</span>, <span class="keyword">and</span> refcount__gc==<span class="number">1.</span></span><br></pre></td></tr></table></figure><p></p><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>现在让我们继续改写sample_hello_world(), 接下来我们使用一些参数的默认值，在php语言里就像下面这样：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample_hello_world</span><span class="params">($name, $greeting=<span class="string">'Mr./Ms.'</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Hello $greeting $name!\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">sample_hello_world(<span class="string">'Ginger Rogers'</span>,<span class="string">'Ms.'</span>);</span><br><span class="line">sample_hello_world(<span class="string">'Fred Astaire'</span>);</span><br></pre></td></tr></table></figure><p></p><p>此时即可以只向sample_hello_world中传递一个参数，也可以传递完整的两个参数。<br>那同样的功能我们怎样在扩展函数里实现呢？我们需要借助zend_parse_parameters中的(|)参数，这个参数之前的参数被认为是必须的，之后的便认为是非必须的了,如果没有传递，则不会去修改载体。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_hello_world) &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> name_len;</span><br><span class="line">    <span class="keyword">char</span> *greeting = <span class="string">"Mr./Mrs."</span>;</span><br><span class="line">    <span class="keyword">int</span> greeting_len = <span class="keyword">sizeof</span>(<span class="string">"Mr./Mrs."</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"s|s"</span>,</span><br><span class="line">      &amp;name, &amp;name_len, &amp;greeting, &amp;greeting_len) == FAILURE) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    php_printf(<span class="string">"Hello "</span>);</span><br><span class="line">    PHPWRITE(greeting, greeting_len);</span><br><span class="line">    php_printf(<span class="string">" "</span>);</span><br><span class="line">    PHPWRITE(name, name_len);</span><br><span class="line">    php_printf(<span class="string">"!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果你不传递第二个参数，则扩展函数会被认为默认而不去修改载体。所以，我们需要自己来预先设置有载体的值，它往往是是NULL，或者一个与函数逻辑有关的值。<br>每个zval，包括IS_NULL型的zval，都需要占用一定的内存空间，并且需要cpu的计算资源来为它申请内存、初始化，并在它们完成工作后释放掉。但是很多代码都都没有意识到这一点。有很多代码都会把一个null型的值包裹成zval的IS_NULL类型，在扩展开发里这种操作是可以优化的，我们可以把参数接收成C语言里的NULL。我们就这一个问题看以下代码：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_arg_fullnull) &#123;</span><br><span class="line">    zval *val;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"z"</span>,&amp;val) == FAILURE) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE_P(val) == IS_NULL) &#123;</span><br><span class="line">        val = php_sample_make_defaultval(TSRMLS_C);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">ZEND_FUNCTION(sample_arg_nullok) &#123;</span><br><span class="line">    zval *val;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"z!"</span>,&amp;val) == FAILURE) &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">        val = php_sample_make_defaultval(TSRMLS_C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这两段代码乍看起来并没有什么很大的不同，但是第一段代码确实需要更多的cpu和内存资源。可能这个技巧在平时并没多大用，不过技多不压身，知道总比不知道好。</p><h3 id="Forced-Separation"><a href="#Forced-Separation" class="headerlink" title="Forced Separation"></a>Forced Separation</h3><p>当一个变量被传递给函数时候，无论它是否被引用，它的refcoung__gc属性都会加一，至少成为2。一份是它自己，另一份是传递给函数的copy。在改变这个zval之前，有时会需要提前把它分成实际意义上的两份copy。这就是”/“格式符的作用。它将把写时复制的zval提前分成两个完整独立的copy，从而使我们可以在下面的代码中随意的对其进行操作。否则我们可能需要不停的提醒自己对接收的参数进行分离等操作。Like the NULL flag, this modifier goes after the type it means to impact. Also like the NULL flag, you won’t know you need this feature until you actually have a use for it.</p><h3 id="zend-get-arguments"><a href="#zend-get-arguments" class="headerlink" title="zend_get_arguments()"></a>zend_get_arguments()</h3><p>如果你想让你的扩展能够兼容老版本的PHP，或者你只想以zval<em>为载体来接收参数，便可以考虑使用zend_get_parameters()函数来接收参数。<br>zend_get_parameters()与zend_parse_parameters()不同，从名字上我们便可以看出，它直接获取，而不做解析。首先，它不会自动进行类型转换，所有的参数在扩展实现中的载体都需要是zval</em>类型的，下面让我们来看一个最简单的例子：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_onearg) &#123;</span><br><span class="line">    zval *firstarg;</span><br><span class="line">    <span class="keyword">if</span> (zend_get_parameters(ZEND_NUM_ARGS(), <span class="number">1</span>, &amp;firstarg)== FAILURE) &#123;</span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING,<span class="string">"Expected at least 1 parameter."</span>);</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Do something with firstarg... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其次，zend_get_parameters()在接收失败的时候，并不会自己抛出错误，它也不能方便的处理具有默认值的参数。<br>最后一点与zend_parse_parameters不同的是，它会自动的把所有符合copy-on-write的zval进行强制分离，生成一个崭新的copy送到函数内部。如果你希望用它其它的特性，而唯独不需要这个功能，可以去尝试一下用zend_get_parameters_ex()函数来接收参数。<br>为了不对copy-on-write的变量进行分离操作，zend_get_parameters_ex()的参数是zval*<em>类型的，而不是zval</em>。 这个函数不太经常用，可能只会在你碰到一些极端问题时候才会想到它，而它用起来却很简单：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_onearg) &#123;</span><br><span class="line">    zval **firstarg;</span><br><span class="line">    <span class="keyword">if</span> (zend_get_parameters_ex(<span class="number">1</span>, &amp;firstarg) == FAILURE) &#123;</span><br><span class="line">        WRONG_PARAM_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Do something with firstarg... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><div class="tip-common"><br>注意zend_get_parameters_ex不需要ZEND_NUM_ARGS()作为参数，因为它是在是在后期加入的，那个参数已经不再需要了。<br></div><br>上面例子中还使用了WRONG_PARAM_COUNT宏,它的功能是抛出一个E_WARNING级别的错误信息，并自动return。<p></p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>有两种其它的zend_get_parameter_**函数，专门用来解决参数很多或者无法提前知道参数数目的问题。想一下php语言中var_dump()函数的用法，我们可以向其传递任意数量的参数，它在内核中的实现其实是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(var_dump) &#123;</span><br><span class="line">    <span class="keyword">int</span> i, argc = ZEND_NUM_ARGS();</span><br><span class="line">    zval ***args;</span><br><span class="line"></span><br><span class="line">    args = (zval ***)safe_emalloc(argc, <span class="keyword">sizeof</span>(zval **), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ZEND_NUM_ARGS() == <span class="number">0</span> || zend_get_parameters_array_ex(argc, args) == FAILURE) &#123;</span><br><span class="line">    efree(args);</span><br><span class="line">WRONG_PARAM_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++) &#123;</span><br><span class="line">php_var_dump(args[i], <span class="number">1</span> TSRMLS_CC);</span><br><span class="line">    &#125;</span><br><span class="line">    efree(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先获取参数数量，然后通过safe_emalloc函数申请了相应大小的内存来存放这些zval*<em>类型的参数。这里使用了zend_get_parameters_array_ex()函数来把传递给函数的参数填充到args中。你可能已经立即想到，还存在一个名为zend_get_parameters_array()的函数，唯一不同的是它将zval</em>类型的参数填充到args中，并且需要ZEND_NUM_ARGS()作为参数。</p><h1 id="7-2-函数的参数"><a href="#7-2-函数的参数" class="headerlink" title="7.2 函数的参数"></a>7.2 函数的参数</h1><p>在前面的章节中我们已经介绍过arg info了，下面我们看一下如何通过其实现类型绑定，但这个特性只能在Zend Engine 2也就是PHP5中使用。<br>让我们再回顾一下ZE2’s argument info结构。每一个arg info结构的声明都是通过ZEND_BEGIN_ARG_INFO()或者ZEND_BEGIN_ARG_INFO_EX()宏函数开始的，然后紧跟着几行ZEND_ARG_*INFO()宏函数，最终以ZEND_END_ARG_INFO()宏函数结束。每个宏的基本作用我们可以在第6章的最后一节看到。如果我们想重写一下PHP语言中的count()函数，可以：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_count_array)</span><br><span class="line">&#123;</span><br><span class="line">    zval *arr;</span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"a"</span>,&amp;arr) == FAILURE)</span><br><span class="line">    &#123;</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">    RETURN_LONG(zend_hash_num_elements(Z_ARRVAL_P(arr)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>zend_parse_parameters()本身可以保证传递过来的参数是一个数组。但是如果我们通过zend_get_parameter()函数来接收参数的话就没这么幸运了，需要我们自己进行类型校对。如果想让内核自动完成类型校对，便需要arg_info上场了：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    ZEND_BEGIN_ARG_INFO(php_sample_array_arginfo, <span class="number">0</span>)</span><br><span class="line">        ZEND_ARG_ARRAY_INFO(<span class="number">0</span>, arr, <span class="number">0</span>)</span><br><span class="line">    ZEND_END_ARG_INFO()</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">PHP_FE(sample_count_array, php_sample_array_arginfo)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p></p><p>这样我们便把类型校对的工作交给了Zend Engine，是不是有种如释重负的感觉！You’ve also given your argument a name so that the generated error messages can be more meaningful to script writers attempting to use your API.<br>我们同样可以对参数中的对象进行校验，限制其是继承自某个类或者实现了某个接口等等。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_ARG_INFO(php_sample_class_arginfo, <span class="number">0</span>)</span><br><span class="line">    ZEND_ARG_OBJ_INFO(<span class="number">1</span>, obj, stdClass, <span class="number">0</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是，此时第一个参数的值是数字1，代表着以引用的方式传递。其实这个参数对于对象来说几乎没用，因为ZE2中所有的对象在当作函数参数的时候都是默认以引用的形式传递的。但是我们又必须把这个参数设置为数字1，除非你不想让你的扩展与PHP4兼容。在PHP4中，对象是传递的一个完整Copy，而非通过引用。</p><pre><code>对于数组和对象参数，不要忘记最后的允许为NULL的参数。更多的信息请参考第6章最后一节的有关叙述。</code></pre><p>通过arg info的方式来实现类型绑定的功能只对ZE2有效，也就是PHP5+。如果你想在PHP4上实现相应的功能，那需要用 zend_get_parameters()函数来接收参数，然后通过Z_TYPE_P()宏函数来检测参数的类型或者通过convert_to_type()函数进行类型转换。</p><h1 id="7-3-函数的参数"><a href="#7-3-函数的参数" class="headerlink" title="7.3 函数的参数"></a>7.3 函数的参数</h1><p>现在我们已经可以编写一个更真实的函数了，既可以接收用户传递过来的参数，也可以返回数据给调用者。为了写出高质量的代码，还需要我们多花点心思在zval的写时复制等特殊机制上，否则便会在接收参数和返回数据时留下一些bug。<br>下面的章节里，让我们去看一下PHP语言里强大的数组类型是如何在内核中实现的，去探究内核中的HashTable结构，从而能编写出更强大的PHP扩展。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6 函数返回值</title>
      <link href="/posts/86b5ca08.html"/>
      <url>/posts/86b5ca08.html</url>
      
        <content type="html"><![CDATA[<h1 id="6-函数返回值"><a href="#6-函数返回值" class="headerlink" title="6 函数返回值"></a>6 函数返回值</h1><p>本章目录</p><ul><li><a href="6.1.md">1. 一个特殊的参数：return_value</a></li><li><a href="6.2.md">2. 引用与函数的执行结果</a></li><li><a href="6.3.md">3. 小结</a></li></ul><p>PHP语言中函数的返回值是通过return来完成的，就像下面的程序：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample_long</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">$bar = sample_long();</span><br></pre></td></tr></table></figure><p></p><p>C语言也一样使用return关键字<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sample_long</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bar = sample_long();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>那我们在扩展中编写的PHP函数如何把返回值回馈给用户端的函数调用者呢？看好，这里指的是回馈给，而不是单单的return～</p><h1 id="6-1-函数返回值"><a href="#6-1-函数返回值" class="headerlink" title="6.1 函数返回值"></a>6.1 函数返回值</h1><p>你也许会认为扩展中定义的函数应该直接通过return关键字来返回一个值，比如由你自己来生成一个zval并返回，就像下面这样：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_long_wrong)</span><br><span class="line">&#123;</span><br><span class="line">    zval *retval;</span><br><span class="line"></span><br><span class="line">    MAKE_STD_ZVAL(retval);</span><br><span class="line">    ZVAL_LONG(retval, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但是，上面的写法是无效的！与其让扩展开发员每次都初始化一个zval并return之，zend引擎早就准备好了一个更好的方法。它在每个zif函数声明里加了一个zval*类型的形参，名为return_value，专门来解决返回值这个问题。在前面我们已经知道了ZEND_FUNCTION宏展开后是void name(INTERNAL_FUNCTION_PARAMETERS)的形式，现在是我们展开代表参数声明的INTERNAL_FUNCTION_PARAMETERS宏的时候了。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used TSRMLS_DC</span></span><br></pre></td></tr></table></figure><p></p><ul><br><li>int ht</li><br><li>zval <em>return_value，我们在函数内部修改这个指针，函数执行完成后，内核将把这个指针指向的zval返回给用户端的函数调用者。</em></li><br><li>zval **return_value_ptr，</li><br><li>zval this_ptr，如果此函数是一个类的方法，那么这个指针的含义和PHP语言中$this变量差不多。</li><br><li>int return_value_used，代表用户端在调用此函数时有没有使用到它的返回值。</li><br></ul><br>下面让我们先试验一个非常简单的例子，我先给出PHP语言中的实现，然后给出我们在扩展中用C语言完成相同功能的代码。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample_long</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个函数非常简单.</span></span><br><span class="line"><span class="comment">$a = sample_long();</span></span><br><span class="line"><span class="comment">那此时$a的值便是42了，这个我们大家肯定都明白。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br><br>下面是我们在编写扩展时的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_long)</span><br><span class="line">&#123;</span><br><span class="line">    ZVAL_LONG(return_value, <span class="number">42</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>需要注意的是，ZEND_FUNCTION本身并没有通过return关键字返回任何有价值的东西，它只不过是在运行时修改了return_value指针所指向的变量的值而已，而内核则会把return_value指向的变量作为用户端调用此函数后的得到的返回值。回想一下,ZVAL_LONG()宏是对一类操作的封装，展开后应该就是下面这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Z_TYPE_P(return_value) = IS_LONG;</span><br><span class="line">Z_LVAL_P(return_value) = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更彻底的讲，应该是这样的：</span></span><br><span class="line">return_value-&gt;type = IS_LONG;</span><br><span class="line">return_value-&gt;value.lval = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><br><br><div class="tip-warning">我们千万不要自己去修改return_value的is_ref__gc和refcount__gc属性，这两个属性的值会由PHP内核自动管理。</div><br>现在我们把它加到我们在第五章得到的那个扩展框架里，并把这个函数名称注册到函数入口数组里，就像下面这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_function_entry walu_functions[] = &#123;</span><br><span class="line">    ZEND_FE(walu_hello,        <span class="literal">NULL</span>)</span><br><span class="line">    PHP_FE(sample_long, <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>现在我们编译我们的扩展，便可以在用户端通过调用sample_long函数来得到一个整型的返回值了:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> var_dump(sample_long());<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br><br>### 与return_value有关的宏<br>return_value如此重要，内核肯定早已经为它准备了大量的宏，来简化我们的操作，提高程序的质量。<br>在前几章我们接触的宏大多都是以ZVAL_开头的，而接下来我们要介绍的宏的名字是：RETVAL。<br>再回到上面的那个例子，我们用RETVAL来重写一下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample_long)</span><br><span class="line">&#123;</span><br><span class="line">    RETVAL_LONG(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">//展开后相当与ZVAL_LONG(return_value, 42);</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>大多数情况下，我们在处理完return_value后所做的便是用return语句结束我们的函数执行，帮人帮到底，送佛送到西，为了减少我们的工作量，内核中还提供了RETURN_<em>系列宏来为我们自动补上return;如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(sample_long)</span><br><span class="line">&#123;</span><br><span class="line">    RETURN_LONG(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">//#define RETURN_LONG(l) &#123; RETVAL_LONG(l); return; &#125;</span></span><br><span class="line">    php_printf(<span class="string">"I will never be reached.\n"</span>); <span class="comment">//这一行代码永远不会被执行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>下面，我们给出目前所有的RETVAL_**</em>宏和RETURN_<strong>*宏，供大家查阅使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些宏都定义在Zend/zend_API.h文件里</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_RESOURCE(l)ZVAL_RESOURCE(return_value, l)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_BOOL(b)ZVAL_BOOL(return_value, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_NULL() ZVAL_NULL(return_value)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_LONG(l) ZVAL_LONG(return_value, l)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_DOUBLE(d) ZVAL_DOUBLE(return_value, d)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_STRING(s, duplicate) ZVAL_STRING(return_value, s, duplicate)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_STRINGL(s, l, duplicate) ZVAL_STRINGL(return_value, s, l, duplicate)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_EMPTY_STRING() ZVAL_EMPTY_STRING(return_value)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_ZVAL(zv, copy, dtor)ZVAL_ZVAL(return_value, zv, copy, dtor)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_FALSE  ZVAL_BOOL(return_value, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETVAL_TRUE   ZVAL_BOOL(return_value, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_RESOURCE(l) &#123; RETVAL_RESOURCE(l); return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_BOOL(b) &#123; RETVAL_BOOL(b); return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_NULL() &#123; RETVAL_NULL(); return;&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_LONG(l) &#123; RETVAL_LONG(l); return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_DOUBLE(d) &#123; RETVAL_DOUBLE(d); return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_STRING(s, duplicate) &#123; RETVAL_STRING(s, duplicate); return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_STRINGL(s, l, duplicate) &#123; RETVAL_STRINGL(s, l, duplicate); return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_EMPTY_STRING() &#123; RETVAL_EMPTY_STRING(); return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_ZVAL(zv, copy, dtor)&#123; RETVAL_ZVAL(zv, copy, dtor); return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_FALSE  &#123; RETVAL_FALSE; return; &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_TRUE   &#123; RETVAL_TRUE; return; &#125;</span></span><br></pre></td></tr></table></figure><br><br>其实，除了这些标量类型，还有很多php语言中的复合类型我们需要在函数中返回，如数组和对象，我们可以通过RETVAL_ZVAL与RETURN_ZVAL来操作它们，有关它们的详细介绍我们将在后续章节中叙述。<br>### 不返回值可以么？<br>其实，zend internal function的形参中还有一个比较常用的名为return_value_used的参数，它是干嘛使的呢？它用来标志这个函数的返回值在用户端有没有用到。看下面的代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample_array_range</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $ret = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; <span class="number">1000</span>; $i++) &#123;</span><br><span class="line">        $ret[] = $i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $ret;</span><br><span class="line">&#125;</span><br><span class="line">sample_array_range();</span><br></pre></td></tr></table></figure><br><br>sample_array_range()仅仅是执行了一下而已，并没有使用到函数的返回值。函数的返回值$ret初始化并返回给调用者后根本就没有发挥作用，却白白浪费了很多内存来存储它的1000个元素。虽然这个例子有点极端，但是却提醒了我们，如果返回值没有被用到，我有没有办法在函数中提前知晓并进行一些有利于性能的操作呢？<br>这个想法在PHP脚本语言里简直就是异想天开，肯定是无法实现的。但是如果我们所处的环境是内核，即zif，便可以轻松实现这个愿望了，而我们所需要做的便是充分利用return_value_used这个参数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_array_range)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (return_value_used) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把返回值初始化成一个PHP语言中的数组</span></span><br><span class="line">        array_init(return_value);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//向retrun_value里不断的添加新元素，值为i</span></span><br><span class="line">            add_next_index_long(return_value, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//抛出一个E_NOTICE级错误</span></span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_NOTICE,<span class="string">"猫了个咪的，我就知道你没用我的劳动成果！"</span>);</span><br><span class="line">        RETURN_NULL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 以引用的形式返回值<br>你肯定已经在手册中看到过有关将函数的返回值以引用的形式的返回的技术了。但是因为某些历史原因，在为扩展编写函数时候如果想让返回值以引用的形式返回时一定要慎之又慎，因为在php5.1之前，根本就没法真正的实现这个功能，look一下下面的代码：<br><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//关于PHP语言中引用形式返回值的详述，请参考PHP手册。</span></span><br><span class="line">$a = <span class="string">'china'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> &amp;<span class="title">return_by_ref</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">global</span> $a;</span><br><span class="line"><span class="keyword">return</span> $a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$b = &amp;return_by_ref();</span><br><span class="line">$b = <span class="string">"php"</span>;</span><br><span class="line"><span class="keyword">echo</span> $a;</span><br><span class="line"><span class="comment">//此时程序输出php</span></span><br></pre></td></tr></table></figure><br><br>在上面的代码中，$b其实是$a的一个引用，当最后一行代码执行后，$a和$b都开始寻找‘bar’这个字符串对应的zval，让我们以内核的角度重新观察这一切：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (PHP_MAJOR_VERSION &gt; 5) || (PHP_MAJOR_VERSION == 5 &amp;&amp; PHP_MINOR_VERSION &gt; 0)</span></span><br><span class="line">ZEND_FUNCTION(return_by_ref)</span><br><span class="line">&#123;</span><br><span class="line">zval **a_ptr;</span><br><span class="line">zval *a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查全局作用域中是否有$a这个变量，如果没有则添加一个</span></span><br><span class="line"><span class="comment">//在内核中真的是可以胡作非为啊，:-)</span></span><br><span class="line"><span class="keyword">if</span>(zend_hash_find(&amp;EG(symbol_table) , <span class="string">"a"</span>,<span class="keyword">sizeof</span>(<span class="string">"a"</span>),(<span class="keyword">void</span> **)&amp;a_ptr ) == SUCCESS )</span><br><span class="line">&#123;</span><br><span class="line">a = *a_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ALLOC_INIT_ZVAL(a);</span><br><span class="line">        zend_hash_add(&amp;EG(symbol_table), <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="string">"a"</span>), &amp;a,<span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//废弃return_value,使用return_value_ptr来接替它的工作</span></span><br><span class="line">zval_ptr_dtor(return_value_ptr);</span><br><span class="line"><span class="keyword">if</span>( !a-&gt;is_ref__gc &amp;&amp; a-&gt;refcount__gc &gt; <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">zval *tmp;</span><br><span class="line">MAKE_STD_ZVAL(tmp);</span><br><span class="line">*tmp = *a;</span><br><span class="line">zval_copy_ctor(tmp);</span><br><span class="line">tmp-&gt;is_ref__gc = <span class="number">0</span>;</span><br><span class="line">tmp-&gt;refcount__gc = <span class="number">1</span>;</span><br><span class="line">zend_hash_update(&amp;EG(symbol_table), <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="string">"a"</span>), &amp;tmp,<span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">a = tmp;</span><br><span class="line">&#125;</span><br><span class="line">a-&gt;is_ref__gc = <span class="number">1</span>;</span><br><span class="line">a-&gt;refcount__gc++;</span><br><span class="line">*return_value_ptr = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PHP &gt;= 5.1.0 */</span></span></span><br></pre></td></tr></table></figure><br><br>return_value_ptr是定义zend internal function时的另外一个重要参数，他是一个zval</strong>类型的指针，并且指向函数的返回值。我们调用zval_ptr_dtor()函数后，默认的return_value便被废弃了。这里的$a变量如果是与某个非引用形式的变量共用一个zval的话，便要进行分离。<br>不幸的是，如果你编译上面的代码，使用的时候便会得到一个段错误。为了使它能够正常的工作，需要在源文件中加一些东西：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (PHP_MAJOR_VERSION &gt; 5) || (PHP_MAJOR_VERSION == 5 &amp;&amp; PHP_MINOR_VERSION &gt; 0)</span></span><br><span class="line">    ZEND_BEGIN_ARG_INFO_EX(return_by_ref_arginfo, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    ZEND_END_ARG_INFO ()</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PHP &gt;= 5.1.0 */</span></span></span><br><span class="line"></span><br><span class="line">然后使用下面的代码来申明我们的定义的函数：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (PHP_MAJOR_VERSION &gt; 5) || (PHP_MAJOR_VERSION == 5 &amp;&amp; PHP_MINOR_VERSION &gt; 0)</span></span><br><span class="line">    ZEND_FE(return_by_ref, return_by_ref_arginfo)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PHP &gt;= 5.1.0 */</span></span></span><br></pre></td></tr></table></figure><br><br>arginfo是一种特殊的结构体，用来提前向内核告知此函数具有的一些特定的性质，如本例，其将告诉内核本函数需要引用形式的返回值，所以内核不再通过return_value来获取执行结果，而是通过return_value_ptr。如果没有arginfo，那内核会预先把return_value_ptr置为NULL，当我们对其调用zval_ptr_dtor()函数时便会使程序崩溃。<br><div class="tip-warning">这一些代码都包含在了一个宏里面，只有在php版本大于等于5.1的时候才会被启用。如果没有这些if、endif，那我们的程序将无法在php4下通过编译，在php5.0上也会激活一些无法预测的错误。</div><br><hr><br><ul><br><li>zone(zqx10104#163.com)于2011-10-20提供了一个Bug，:-)</li><br></ul><h1 id="6-2-引用与函数的执行结果"><a href="#6-2-引用与函数的执行结果" class="headerlink" title="6.2 引用与函数的执行结果"></a>6.2 引用与函数的执行结果</h1><p>一个函数的执行结果要返回给调用者，除了使用return功能，还有一种办法，那就是以引用的形式传递参数，然后在内部修改这个参数的值。前一种方法往往只能返回一个值，如果我们的函数执行结果具有多种数据，便需要把这些数据打包到一个数组、类等复合类型的变量中才能得以实现；但后一种方法相比而言就简单一些了。</p><h3 id="运行时传递引用：Call-time-Pass-by-ref"><a href="#运行时传递引用：Call-time-Pass-by-ref" class="headerlink" title="运行时传递引用：Call-time Pass-by-ref"></a>运行时传递引用：Call-time Pass-by-ref</h3><p>标题有点绕口，其实很简单，功能如以下php代码所示：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byref_calltime</span><span class="params">($a)</span> </span>&#123;</span><br><span class="line">    $a = <span class="string">'(modified by ref!)'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$foo = <span class="string">'I am a string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用&amp;传递引用</span></span><br><span class="line">byref_calltime(&amp;$foo);</span><br><span class="line"><span class="keyword">echo</span> $foo;</span><br><span class="line"><span class="comment">//输出'(modified by ref!)'</span></span><br></pre></td></tr></table></figure><p></p><p>我们在传递参数的时候使用&amp;操作符，便可以传递$foo变量的引用过去，而不是copy一份。当我们在函数内核修改这个参数时，函数外部的$foo也跟着被一起修改了。同样的功能我们如何在扩展里实现呢，其实很简单，请看下面的源码：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(byref_calltime)</span><br><span class="line">&#123;</span><br><span class="line">zval *a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将我们接收的参数传给zval *a;</span></span><br><span class="line"><span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"z"</span>, &amp;a) == FAILURE)</span><br><span class="line">&#123;</span><br><span class="line">RETURN_NULL();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果a不是以引用的方式传递的。</span></span><br><span class="line"><span class="keyword">if</span> (!a-&gt;is_ref__gc)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a转成字符串</span></span><br><span class="line">convert_to_string(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改数据</span></span><br><span class="line">ZVAL_STRING(a,<span class="string">" (modified by ref!)"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="编译时的传递引用Compile-time-Pass-by-ref"><a href="#编译时的传递引用Compile-time-Pass-by-ref" class="headerlink" title="编译时的传递引用Compile-time Pass-by-ref"></a>编译时的传递引用Compile-time Pass-by-ref</h3><p>如果每一次都在调用函数时候都对参数加一个&amp;符号真是太罗嗦了，有没有一个简单的办法呢，比如在定义函数的时候便声明这个参数是引用形式的，而不用用户自己加&amp;符号表示引用，而由内核来完成这步操作？这个功能是有的，我们在PHP语言中可以这样实现。<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">在定义函数参数的时候加了引用符</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byref_compiletime</span><span class="params">(&amp;$a)</span> </span>&#123;</span><br><span class="line">    $a = <span class="string">' (modified by ref!)'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$foo = <span class="string">'I am a string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个地方我们没有加&amp;引用符</span></span><br><span class="line">byref_compiletime($foo);</span><br><span class="line"><span class="keyword">echo</span> $foo;</span><br><span class="line"><span class="comment">//输出 (modified by ref!)</span></span><br></pre></td></tr></table></figure><p></p><p>上面的代码中，我们只是把引用符号从函数调用里转移到函数定义里。此功能在扩展里面实现的话就颇费周折了，我们需要提前为它定义一个arginfo结构体来向内核通知此函数的这个特定行为。添加此函数到module_entry里需要这样：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FE(byref_compiletime, byref_compiletime_arginfo)</span><br></pre></td></tr></table></figure><p></p><p>byref_compiletime_arginfo是一个arginfo结构体，我们在前面的章节中已经用过一次了。</p><p></p><div class="tip-common">原书中此处有arginfo在PHP4里的实现，被我略去了。</div><br>在Zend Engine 2 (PHP5+)中，arginfo的数据是由多个zend_arg_info结构体构成的数组，数组的每一个成员即每一个zend_arg_info结构体处理函数的一个参数。zend_arg_info结构体的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_arg_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* 参数的名称*/</span></span><br><span class="line">    zend_uint name_len;<span class="comment">/* 参数名称的长度*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *class_name;<span class="comment">/* 类名 */</span></span><br><span class="line">    zend_uint class_name_len;<span class="comment">/* 类名长度*/</span></span><br><span class="line">    zend_bool array_type_hint;<span class="comment">/* 数组类型提示 */</span></span><br><span class="line">    zend_bool allow_null;<span class="comment">/* 是否允许为NULL　*/</span></span><br><span class="line">    zend_bool pass_by_reference;<span class="comment">/* 是否引用传递 */</span></span><br><span class="line">    zend_bool return_reference;<span class="comment">/* 返回值是否为引用形式 */</span></span><br><span class="line">    <span class="keyword">int</span> required_num_args;  <span class="comment">/* 必要参数的数量 */</span></span><br><span class="line">&#125; zend_arg_info;</span><br></pre></td></tr></table></figure><p></p><p>生成zend_arg_info结构的数组比较繁琐，为了方便PHP扩展开发者，内核已经准备好了相应的宏来专门处理此问题，首先先用一个宏函数来生成头部，然后用第二个宏生成具体的数据，最后用一个宏生成尾部代码。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_BEGIN_ARG_INFO(name, pass_rest_by_reference)ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, ZEND_RETURN_VALUE, -1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, return_reference, required_num_args)\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> zend_arg_info name[] = &#123;\</span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, pass_rest_by_reference, return_reference, required_num_args &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ZEND_ARG_INFO(pass_by_ref, name)&#123; #name, <span class="keyword">sizeof</span>(#name)<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, pass_by_ref, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">#define ZEND_ARG_PASS_INFO(pass_by_ref)&#123; <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, pass_by_ref, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">#define ZEND_ARG_OBJ_INFO(pass_by_ref, name, classname, allow_null) &#123; #name, <span class="keyword">sizeof</span>(#name)<span class="number">-1</span>, #classname, <span class="keyword">sizeof</span>(#classname)<span class="number">-1</span>, <span class="number">0</span>, allow_null, pass_by_ref, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">#define ZEND_ARG_ARRAY_INFO(pass_by_ref, name, allow_null) &#123; #name, <span class="keyword">sizeof</span>(#name)<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, allow_null, pass_by_ref, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ZEND_END_ARG_INFO()&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里我们先看</span></span><br><span class="line">ZEND_BEGIN_ARG_INFO(name, pass_rest_by_reference)</span><br><span class="line">ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, return_reference,required_num_args)</span><br></pre></td></tr></table></figure><p></p><p>这两个宏函数的前两个参数的含义是一样的，name便是这个zend_arg_info数组变量的名字，这里我们定义它为：byref_compiletime_arginfo。pass_rest_by_reference如果被赋值为1，则代表着所有的参数默认都是需要以引用的方式传递的(在arginfo中单独声明的除外)。而对于ZEND_BEGIN_ARG_INFO_EX的后两个参数：</p><p></p><ul><br><li>name和pass_rest_by_reference的含义同上。</li><br><li>return_reference：声明这个函数的返回值需要以引用的形式返回，这个参数已经在前面章节用过了。</li><br><li>required_num_args：函数被调用时，传递参数至少为前N个函数(也就是后面参数都有默认值)，当设置为-1时，必须传递所有参数</li><br></ul><br>接下来让我们看生成具体数据的宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ZEND_ARG_PASS_INFO(by_ref)</span><br><span class="line"><span class="comment">//强制所有参数使用引用的方式传递</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ZEND_ARG_INFO(by_ref, name)</span><br><span class="line"><span class="comment">//如果by_ref为1，则名称为name的参数必须以引用的方式传递，</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ZEND_ARG_ARRAY_INFO(by_ref, name, allow_null)</span><br><span class="line">ZEND_ARG_OBJ_INFO(by_ref, name, classname, allow_null)</span><br><span class="line">这两个宏实现了类型绑定，也就是说我们在传递某个参数时，必须是数组类型或者某个类的实例。如果最后的参数为真，则除了绑定的数据类型，还可以传递一个<span class="literal">NULL</span>数据。</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们组合起来使用：</span></span><br><span class="line">ZEND_BEGIN_ARG_INFO(byref_compiletime_arginfo, <span class="number">0</span>)</span><br><span class="line">    ZEND_ARG_PASS_INFO(<span class="number">1</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br></pre></td></tr></table></figure><p></p><p>为了使我们的扩展能够兼容PHP4，还需要使用#ifdef进行特殊处理。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZEND_ENGINE_2</span></span><br><span class="line">    ZEND_BEGIN_ARG_INFO(byref_compiletime_arginfo, <span class="number">0</span>)</span><br><span class="line">        ZEND_ARG_PASS_INFO(<span class="number">1</span>)</span><br><span class="line">    ZEND_END_ARG_INFO()</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* ZE 1 */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byref_compiletime_arginfo[] =   &#123; <span class="number">1</span>, BYREF_FORCE &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><p>我们copy一份ZEND_FUNCTION(byref_calltime)的实现，并重名成ZEND_FUNCTION(byref_compiletime)就行了。或者直接弄个ZEND_FALIAS就行了：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FALIAS(byref_compiletime,byref_calltime,byref_compiletime_arginfo)</span><br></pre></td></tr></table></figure><p></p><h1 id="6-3-函数返回值"><a href="#6-3-函数返回值" class="headerlink" title="6.3 函数返回值"></a>6.3 函数返回值</h1><p>在这一章里，我们集中讨论了如何把函数执行的结果返回给调用者，通过return语句、引用返回、通过参数返回等等，而且还初步了解了一下zend_arg_info。在下面的章节中，我们将去看一下内核是如何接收调用者传递的参数的。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5 Your First Extension</title>
      <link href="/posts/63ab4ddf.html"/>
      <url>/posts/63ab4ddf.html</url>
      
        <content type="html"><![CDATA[<h1 id="5-Your-First-Extension"><a href="#5-Your-First-Extension" class="headerlink" title="5 Your First Extension"></a>5 Your First Extension</h1><p>每一个PHP扩展都至少需要两个文件：一个配置文件和一个源文件。配置文件用来告诉编译器应该编译哪几个文件，以及编译本扩展是否需要的其它lib。</p><h1 id="5-1-Your-First-Extension"><a href="#5-1-Your-First-Extension" class="headerlink" title="5.1 Your First Extension"></a>5.1 Your First Extension</h1><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>才开始，我们先用最快的(不是最标准的)的方式来建立一个代码最少的扩展。在php源码文件夹的ext目录下创建一个新的文件夹，这里我取的名字叫做walu，它往往就是我们扩展的名字。其实这个文件夹可以放在任何一个位置，但是为了我们在后面介绍win32的编译与静态编译，我们还是把它放在php源码的ext目录下。<br>现在，我们在这个目录下创建一个config.m4文件，并输入以下内容：</p><pre><code>PHP_ARG_ENABLE(walu,    [Whether to enable the &quot;walu&quot; extension],    [  enable-walu        Enable &quot;walu&quot; extension support])if test $PHP_WALU != &quot;no&quot;; then    PHP_SUBST(WALU_SHARED_LIBADD)    PHP_NEW_EXTENSION(walu, walu.c, $ext_shared)fi</code></pre><p>上面PHP_ARG_ENABLE函数有三个参数，第一个参数是我们的扩展名(注意不用加引号)，第二个参数是当我们运行./configure脚本时显示的内容，最后一个参数则是我们在调用./configure –help时显示的帮助信息。</p><blockquote><p>也许有人会问，为什么有的扩展的开启方式是 –enable-extname的形式，有的则是–with-extname的形式呢？其实两者并没有什么本质的不同，只不过enable多代表不依赖外部库便可以直接编译，而with大多需要依赖于第三方的lib。<br>现在，我们的扩展并不需要依赖其它的库文件，所以我们直接使用–enable-walu便可以了。在第17章的时候我们将接触通过CFLAGS和LDFLAGS来配置自己的扩展，使其依赖第三方库文件才能被编译成php扩展。</p></blockquote><p>如果我们显示运行./configure –enable-walu，那么终端环境便会自动将$PHP_WALU变量设置为yes，而PHP_SUBST函数只不过是php官方对autoconf里的AC_SUBST函数的一层封装。<br>最后重要的一点是，PHP_NEW_EXTENSION函数声明了这个扩展的名称、需要的源文件名、此扩展的编译形式。如果我们的扩展使用了多个文件，便可以将这多个文件名罗列在函数的参数里，如：</p><pre><code>PHP_NEW_EXTENSION(sample, sample.c sample2.c sample3.c, $ext_shared)</code></pre><p>最后的$ext_shared参数用来声明这个扩展不是一个静态模块，而是在php运行时动态加载的。</p><p>下面，我们来编写实现扩展主逻辑的源文件walu.c:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载config.h，如果配置了的话</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载php头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> phpext_walu_ptr &amp;walu_module_entry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//module entry</span></span><br><span class="line">zend_module_entry walu_module_entry = &#123;</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">     STANDARD_MODULE_HEADER,</span><br><span class="line">#endif</span><br><span class="line">    <span class="string">"walu"</span>, <span class="comment">//这个地方是扩展名称，往往我们会在这个地方使用一个宏。</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* Functions */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINFO */</span></span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    <span class="string">"2.1"</span>, <span class="comment">//这个地方是我们扩展的版本</span></span><br><span class="line">#endif</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_DL_WALU</span></span><br><span class="line">ZEND_GET_MODULE(walu)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><p>这就是所有的代码了，不过鉴于我们平时的开发习惯，往往会把这一份代码分成两份，一个.h文件，一个.c文件。上面的代码只是生成了一基本的框架，而没有任何实际的用处。<br>紧接着，创建一个zend_module_entry结构体，你肯定已经发现了，依据ZEND_MODULE_API_NO 是否大于等于 20010901，这个结构体需要不同的定义格式。20010901大约代表PHP4.2.0版本，所以我们现在的扩展几乎都要包含STANDARD_MODULE_HEADER这个元素了。<br>其余六个成员我们可以先赋值为NULL，其实看看它们各自后面的注释你就应该大体上了解它们各自是负责哪一方面的工作了。<br>最后，最底下的代码用来标志我们的这个扩展是一个shared module。它是干么的呢？我也说不清楚，反正带上就对了，否则扩展会工作不正常。原文解释：This brief conditional simply adds a reference used by Zend when your extension is loaded dynamically. Don’t worry about what it does or how it does it too much; just make sure that it’s around or the next section won’t work.</p><h3 id="标准一些"><a href="#标准一些" class="headerlink" title="标准一些"></a>标准一些</h3><p>根据我们平时的开发习惯，应该不会把所有代码都写在这一个文件里的，我们需要把上述代码放在两个文件里，一个头文件，一个c文件。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//php_walu.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WALU_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALU_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载config.h，如果配置了的话</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"config.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载php头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> phpext_walu_ptr &amp;walu_module_entry</span></span><br><span class="line"><span class="keyword">extern</span> zend_module_entry walu_module_entry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><p>下面的是c文件<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//walu.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"php_walu.h"</span></span></span><br><span class="line"><span class="comment">//module entry</span></span><br><span class="line">zend_module_entry walu_module_entry = &#123;</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">     STANDARD_MODULE_HEADER,</span><br><span class="line">#endif</span><br><span class="line">    <span class="string">"walu"</span>, <span class="comment">//这个地方是扩展名称，往往我们会在这个地方使用一个宏。</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* Functions */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINFO */</span></span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    <span class="string">"2.1"</span>, <span class="comment">//这个地方是我们扩展的版本</span></span><br><span class="line">#endif</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPILE_DL_WALU</span></span><br><span class="line">ZEND_GET_MODULE(walu)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p></p><h1 id="5-2-编译我们的扩展"><a href="#5-2-编译我们的扩展" class="headerlink" title="5.2 编译我们的扩展"></a>5.2 编译我们的扩展</h1><p>我们已经在上一节准备好了需要编译的源文件，接下来需要的便是把它们编译成目标文件了。因为在*nix平台和win平台下的编译步骤有些差异，所以这个地方需要分成两块介绍，很不幸，win部分还没有整理，请随时关注本项目。</p><h3 id="在-nix下编译"><a href="#在-nix下编译" class="headerlink" title="在*nix下编译"></a>在*nix下编译</h3><p>第一步：我们需要根据config.m4文件生成一个configure脚本、Makefile等文件，这一步有phpize来帮我们做：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ phpize</span><br><span class="line">PHP Api Version: <span class="number">20041225</span></span><br><span class="line">Zend Module Api No: <span class="number">20050617</span></span><br><span class="line">Zend Extension Api No: <span class="number">220050617</span></span><br></pre></td></tr></table></figure><p></p><p>The extra 2 at the start of Zend Extension Api No isn’t a typo; it corresponds to the Zend Engine 2 version and is meant to keep this API number greater than its ZE1 counterpart.</p><p>现在查看一下我们扩展所在的目录，会发现多了许多文件。phpize程序根据config.m4里的信息生成了许多编译php扩展必须的文件，比如生成makefiles等，这为我们省了很多的麻烦。 接下来我们运行./configure脚本，这里我们并不需要再注明enable-maintainer-zts、enable-debug等参数，phpize程序会自动的去已经编译完成的php核心里获取这几个参数的值。 接下来就像我们安装其它程序一样执行make; make test;即可，如果没有错误，那么在module文件夹下面便会生成我们的目标文件 —— walu.so。</p><h3 id="在windows平台下编译"><a href="#在windows平台下编译" class="headerlink" title="在windows平台下编译"></a>在windows平台下编译</h3><p>The config.m4 file you created earlier was actually specific to the *nix build. In order to make your extension compile under Windows, you’ll need to create a separatebut similarconfiguration file for it.<br>Add config.w32 with the following contents to your ext/sample directory:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARG_ENABLE(<span class="string">"sample"</span>, <span class="string">"enable sample extension"</span>, <span class="string">"no"</span>);</span><br><span class="line"><span class="keyword">if</span> (PHP_SAMPLE != <span class="string">"no"</span>) &#123;</span><br><span class="line">    EXTENSION(<span class="string">"sample"</span>, <span class="string">"sample.c"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>As you can see, this file bears a resemblance on a high level to config.m4. The option is declared, tested, and conditionally used to enable the build of your extension.<br>Now you’ll repeat a few of the steps you performed in Chapter 4, “Setting Up a Build Environment,” when you built the PHP core. Start by opening up a build window from the Start menu by selecting All Programs, Microsoft Platform SDK for Windows Server 2003 SP1, Open Build Environment Window, Windows 2000 Build Environment, Set Windows 2000 Build Environment (Debug), and running the C:\Program Files\Microsoft Visual Studio 8\VC\bin\vcvars32.bat batch file.<br>Remember, your installation might require you to select a different build target or run a slightly different batch file. Refer to the notes in the corresponding section of Chapter 4 to refresh your memory.<br>Again, you’ll want to go to the root of your build directory and rebuild the configure script.<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Microsoft Platform SDK&gt; cd \PHPDEV\php<span class="number">-5.1</span><span class="number">.0</span></span><br><span class="line">C:\PHPDEV\php<span class="number">-5.1</span><span class="number">.0</span>&gt; buildconf.bat</span><br><span class="line">Rebuilding configure.js</span><br><span class="line">Now run 'cscript /nologo configure.js help'</span><br></pre></td></tr></table></figure><p></p><p>This time, you’ll run the configure script with an abridged set of options. Because you’ll be focusing on just your extension and not the whole of PHP, you can leave out options pertaining to other extensions; however, unlike the Unix build, you do need to include the enable-debug switch explicitly even though the core build already has it.<br>The only crucial switch you’ll need hereapart from debug of courseis enable-sample=shared. The shared option is required here because configure.js doesn’t know that you’re planning to build sample as a loadable extension. Your configure line should therefore look something like this:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\PHPDEV\php<span class="number">-5.1</span><span class="number">.0</span>&gt; cscript /nologo configure.js \</span><br><span class="line">enable-debug enable-sample=shared</span><br></pre></td></tr></table></figure><p></p><p>Recall that enable-maintainer-zts is not required here as all Win32 builds assume that ZTS must be enabled. Options relating to SAPIssuch as embedare also not required here as the SAPI layer is independent from the extension layer.</p><p>Lastly, you’re ready to build the extension. Because this build is based from the coreunlike the Unix extension build, which was based from the extensionyou’ll need to specify the target name in your build line.<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\PHPDEV\php<span class="number">-5.1</span><span class="number">.0</span>&gt; nmake php_sample.dll</span><br></pre></td></tr></table></figure><p></p><p>Once compilation is complete, you should have a working php_sample.dll binary ready to be used in the next step. Remember, because this book focuses on *nix development, the extension will be referred to as sample.so rather than php_sample.dll in all following text.<br>Loading an Extension Built as a Shared Module</p><h3 id="加载扩展"><a href="#加载扩展" class="headerlink" title="加载扩展"></a>加载扩展</h3><p>为了使PHP能够找到需要的扩展文件，我们需要把编译好的so文件或者dll文件复制到PHP的扩展目录下，它的地址我们可以通过phpinfo()输出的信息找到，也可以在php.ini文件里进行配置找到并配置，名称为：extension_dir的值。默认情况下，php.ini文件位于/usr/local/lib/php.ini或者C:\windows\php.ini(现在由于fastcgi模式居多，在win平台上php.ini越来越多的直接存在于php-cgi.exe程序所在目录下)。如果找不到，我们可以通过php -i 命令或者&lt;?php phpinfo();来查看当前加载的php.ini文件位置。<br>一旦我们设置了extension_dir，便可以在我们的web文件中引用我们的扩展了，我们可以通过dl命令来将我们的扩展加载到内存中来。<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    dl(<span class="string">'sample.so'</span>);</span><br><span class="line">    var_dump(get_loaded_extensions());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>如果在输出中我们没有找到walu.so，那肯定是哪里出问题了。这时候我们需要根据程序的输出信息去查找错误。<br>上面这样每次使用扩展都需要先dl一下真是太麻烦了，其实我们有更好的办法让php运行时自动加载我们的扩展。那就是在php.ini里这样配置：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extension_dir=/usr/local/lib/php/modules/</span><br><span class="line">extension=walu.so</span><br></pre></td></tr></table></figure><p></p><p>这样只要我们把walu.so这个文件放置在extension_dir配置的目录下，php就会在每次启动的时候自动加载了。这样我们就可以像我们平时使用curl、Mysql扩展一样直接使用，而不用麻烦的调用dl函数了。<br>备注： 以下的章节我们都默认使用上面的这种方式来加载我们的扩展，而不是调用dl函数。</p><h1 id="5-3-静态编译"><a href="#5-3-静态编译" class="headerlink" title="5.3 静态编译"></a>5.3 静态编译</h1><p>我们检查一下PHP语言中get_loaded_extensions()函数的输出，会发现有一些扩展并没有php.ini文件中调用，而它们确实也已经加载到PHP里去了，可以让我们在PHP语言中使用，如standard、Reflection、Core等。它们便是静态编译的，它们没有被编译成so或者dll文件供PHP动态调用，而是直接和PHP主程序编译到一起。</p><h3 id="在-nix上执行静态编译"><a href="#在-nix上执行静态编译" class="headerlink" title="在*nix上执行静态编译"></a>在*nix上执行静态编译</h3><p>现在，先让我们执行一下PHP源码根目录下的./configure –help命令。会发现输出信息并没有包含我们的扩展，这是因为这个configure脚本生成的时候，我们的扩展还没有编写呢。(这个configure是PHP官方分发的。)，所以首先我们需要使用buildconf命令生成新的configure脚本。<br>$ ./buildconf –force</p><p></p><div class="tip-common">If you’re using a production release of PHP to do development against, you’ll find that ./buildconf by itself doesn’t actually work. In this case you’ll need to issue: ./buildconf force to bypass some minor protection built into the ./configure command.</div><br>现在当我们再执行./configure –help的时候，便会发现walu扩展的信息已经出现了。现在我们只需要重新走一遍PHP的编译过程，便可以把我们的扩展以静态编译的方式加入到PHP主程序中了。哦，千万不要忘记使用–enable-walu参数开启我们的扩展。<br>当然，对于我们学习如何开发PHP扩展来讲，静态编译可不是一个好主意，因为如果采用静态编译的方式，只要我们的扩展做了改动，便需要重新编译整个PHP才行，这个过程太痛苦了。还是用前一节的方式吧。但是这种方式有利于提高性能，所以如果我们是在部署生产环境，则可以考虑！<p></p><h3 id="Building-Statically-Under-Windows"><a href="#Building-Statically-Under-Windows" class="headerlink" title="Building Statically Under Windows"></a>Building Statically Under Windows</h3><p>Regenerating the configure.js script for Windows follows the same pattern as regenerating the ./configure script for *nix. Navigate to the root of the PHP source tree and reissue buildconf.bat as you did in Chapter 4.<br>The PHP build system will scan for config.w32 files, including the one you just made for ext/sample, and generate a new configure.js script with which to build a static php binary.</p><h1 id="5-4-编写函数"><a href="#5-4-编写函数" class="headerlink" title="5.4 编写函数"></a>5.4 编写函数</h1><p>前面我们已经生成好了一份扩展框架，但它是没有什么实际作用的。一个扩展的作用可大了去了，既可以操作PHP中的变量、常量，还可以定义函数、类、方法、资源等。先让我们从函数说起吧！</p><h3 id="ZEND-FUNCTION-宏函数"><a href="#ZEND-FUNCTION-宏函数" class="headerlink" title="ZEND_FUNCTION()宏函数"></a>ZEND_FUNCTION()宏函数</h3><p>ZEND_FUNCTION()宏函数也可以写成PHP_FUNCTION()，但ZEND_FUNCTION()更前卫、标准一些，但两者是完全相同的。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_FUNCTIONZEND_FUNCTION</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FUNCTION(name)ZEND_NAMED_FUNCTION(ZEND_FN(name))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_NAMED_FUNCTION(name)void name(INTERNAL_FUNCTION_PARAMETERS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FN(name) zif_##name</span></span><br></pre></td></tr></table></figure><p></p><p>其中，zif是zend internal function的意思，zif_前缀是可供PHP语言调用的函数在C语言中的函数名称前缀。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(walu_hello)</span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面定义了一个函数，在C语言中展开后应该是这样的:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zif_walu_hello</span><span class="params">(INTERNAL_FUNCTION_PARAMETERS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    php_printf(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的展开式仅供参考，绝不推荐在编程时使用，我们应该采用宏的形式，来提高程序的兼容性与可读性。<br>上面的代码定义了一个可供用户在PHP语言中调用的函数实现，但现在用户还不能在程序中调用，因为这个函数还没有与用户端建立联系，也就是说虽然我们在C中完成了它的实现，但用户端PHP语言还根本不知道它的存在呢。<br>现在我们回头看一下5.1节中我们为扩展定义的zend_module_entry walu_module_entry（它是联系C扩展与PHP语言的重要纽带）中的“NULL, /<em> Functions </em>/”，当时我们为它赋予了NULL，是因为还没有函数，现在我们已经为它编写了函数了，便可以给它赋予一个新值了，这个值需要是zend_function_entry[]类型的，首先让我们来构造这个重要数据。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_function_entry walu_functions[] = &#123;</span><br><span class="line">    ZEND_FE(walu_hello,        <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是ZEND_FE的定义</span></span><br><span class="line"><span class="comment">#define ZEND_FE(name, arg_info)ZEND_FENTRY(name, ZEND_FN(name), arg_info, 0)</span></span><br><span class="line"><span class="comment">#define ZEND_FENTRY(zend_name, name, arg_info, flags)&#123; #zend_name, name, arg_info, (zend_uint) (sizeof(arg_info)/sizeof(struct _zend_arg_info)-1), flags &#125;,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ZEND_FE(walu_hello,        NULL)展开后便是：</span></span><br><span class="line"><span class="comment">&#123;"walu_hello",zif_walu_hello,NULL, (zend_uint) (sizeof(NULL)/sizeof(struct _zend_arg_info)-1), 0 &#125;,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>其中最后的{NULL,NULL,NULL}是固定不变的。ZEND_FE()宏函数是对我们walu_hello函数的一个声明，如果我们有多个函数，可以直接以类似的形式添加到{NULL,NULL,NULL}之前，注意每个之间不需要加逗号。<br>其中的arg_info我们现在先赋予NULL就行了，我们将在第7章讨论这个参数。确保一切无误后，我们替换掉zend_module_entry里的原有成员，现在应该是这样的：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(walu_hello)</span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> zend_function_entry walu_functions[] = &#123;</span><br><span class="line">    ZEND_FE(walu_hello,        <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zend_module_entry walu_module_entry = &#123;</span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">     STANDARD_MODULE_HEADER,</span><br><span class="line">#endif</span><br><span class="line">    <span class="string">"walu"</span>, <span class="comment">//这个地方是扩展名称，往往我们会在这个地方使用一个宏。</span></span><br><span class="line">    walu_functions, <span class="comment">/* Functions */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RINIT */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* RSHUTDOWN */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* MINFO */</span></span><br><span class="line">#<span class="keyword">if</span> ZEND_MODULE_API_NO &gt;= <span class="number">20010901</span></span><br><span class="line">    <span class="string">"2.1"</span>, <span class="comment">//这个地方是我们扩展的版本</span></span><br><span class="line">#endif</span><br><span class="line">    STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>现在configure、make、make test，复制到extension dir。用下面这个命令来测试下，应该会输出hello world了，如果没有输出，说明你哪个地方做错了，查不出来的话可以给我发mail，看看是不是特例:-)<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php -r 'walu_hello();'</span><br></pre></td></tr></table></figure><p></p><h2 id="Zend-Internal-Functions"><a href="#Zend-Internal-Functions" class="headerlink" title="Zend Internal Functions"></a>Zend Internal Functions</h2><p>zif_前缀在前面我们已经说过了，代表着”Zend Internal Function”，主要用来避免命名冲突，比如PHP语言中有个strlen()函数，而C语言中也有strlen()函数，所以PHP中的strlen在C中的实现不能是strlen，而应改是一个不同的名字。<br>但是有些时候尽管我们加了zif_前缀，还会出现一些冲突问题。比如函数名称本身是一个宏名称从而被编译器替换掉了。在这种情况下，我们需要手动来为我们扩展中的函数命名，这一步操作通过ZEND_NAMED_FUNCTION(diy_walu_hello)来代替ZEND_FUNCTION(hello_hello)。前者由我们指定名称，后者自己加上前缀。<br>如果我们在定义函数时使用了ZEND_NAMED_FUNCTION()，那么在walu_functions[]里，我们需要用ZEND_NAMED_FE()宏来代替ZEND_FE()宏。即：ZEND_NAMED_FE(walu_hello,diy_walu_hello,NULL)<br>上面的技术在ext/standard/file.c用到了，我们可以看fopen()函数的定义：PHP_NAMED_FUNCTION(php_if_fopen)。但是用户端不会感觉到任何变化，还是用fopen函数来使用，因为zend_function_entry中每一项的第一个值代表这此函数在PHP语言中的名称。Internally, however, the function is protected from being mangled by preprocessor macros and over-helpful compilers.（原作者说的这个理由我也没看明白，请知者指点）</p><h2 id="Function-Aliases"><a href="#Function-Aliases" class="headerlink" title="Function Aliases"></a>Function Aliases</h2><p>去PHP手册里查一下pos()函数，会得到这么一条信息：”This function is an alias of: current()”;也就是说，它只是current的一个软链接而已，类似linux中的ln -s命令，理解成win下的快捷方式也成。运行pos函数，其实就是在运行current函数，转接了一下而已。这往往是因为版本升级引起的，新版本中的程序提供了某个功能的新的实现，先为原来的函数改个名，但还需要保留原来的函数名，所以这就用到了alias。这个功能可以在内核中通过ZEND_NAMED_FE宏来实现。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_function_entry walu_functions[] = &#123;</span><br><span class="line">    ZEND_FE(walu_hello,        <span class="literal">NULL</span>)</span><br><span class="line">    ZEND_NAMED_FE(walu_hi,ZEND_FN(walu_hello),<span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ZEND_NAMED_FE也可以写成PHP_NAMED_FE,但推荐用前者</span></span><br><span class="line"><span class="comment">#define ZEND_NAMED_FE(zend_name, name, arg_info)ZEND_FENTRY(zend_name, name, arg_info, 0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>通过ZEND_NAMED_FE的展开式我们了解到，它只是把PHP语言中的两个函数的名字对应到同一个C语言函数而已。<br>其实还有另外一种写法：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_function_entry walu_functions[] = &#123;</span><br><span class="line">    ZEND_FE(walu_hello,        <span class="literal">NULL</span>)</span><br><span class="line">    ZEND_FALIAS(walu_hi,walu_hello,<span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define ZEND_FALIAS(name, alias, arg_info)ZEND_FENTRY(name, ZEND_FN(alias), arg_info, 0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>展开式是一样的，真不清楚官方鼓捣这么多同样的宏干啥。<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">walu_hi();</span><br><span class="line">walu_hello();</span><br></pre></td></tr></table></figure><p></p><h1 id="5-5-Your-First-Extension"><a href="#5-5-Your-First-Extension" class="headerlink" title="5.5 Your First Extension"></a>5.5 Your First Extension</h1><p>在这一章里，我们学会了如何创建一个PHP框架并为其添加函数，并编译到PHP中供用户在PHP语言中调用。在接下来的章节里，我们将陆续看到许多高级的PHP内核特性，从而使我们编写出更好的PHP扩展。<br>编译PHP源码的环境会随着平台与时间的不同而变化，如果本章讲述的知识无法使你顺利的编译PHP，那你可以给我发信，或者去php.net寻找答案，当然最简单的方法是Google，切记的是，万一Google抽风，不要忘了还有Baidu。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4 动手编译PHP</title>
      <link href="/posts/675b1ba5.html"/>
      <url>/posts/675b1ba5.html</url>
      
        <content type="html"><![CDATA[<h1 id="4-动手编译PHP"><a href="#4-动手编译PHP" class="headerlink" title="4 动手编译PHP"></a>4 动手编译PHP</h1><p>到现在为止，你肯定应该在至少一种平台上安装过PHP，并用它来开发你的web程序了。你可能下载的win32平台下的iis或者apache对应的安装包，也可能使用了由第三方提供的linux、bsd等平台下的二进制包。而现在，则是我们动手自己编译PHP的时候了。这也是我们动手开发第一个扩展的最后一项准备知识了。<br>强烈推荐你在Linux下调试本章的程序，因为win部分我还没有翻译，:-)</p><h1 id="4-1-动手编译PHP"><a href="#4-1-动手编译PHP" class="headerlink" title="4.1 动手编译PHP"></a>4.1 动手编译PHP</h1><p>从一个PHP程序猿，到一个想为PHP开发扩展的程序猿，此间的进化有一步是跳不过去的，那就是你必须熟知如何编译PHP的源码。</p><h3 id="nix-Tools"><a href="#nix-Tools" class="headerlink" title="*nix Tools"></a>*nix Tools</h3><p>C语言的编译器是我们使用C语言的必备工具，你的系统应该已经自带了一种C语言的编译器，而且它极有可能是大名鼎鼎的GCC。通过检测你本机gcc或者cc程序的版本，可以很方便的知道你机器上是否已经安装的某种C语言的编译器。<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">walu@walu-ThinkPad-Edge:~$ gcc --version</span><br><span class="line">gcc (Ubuntu/Linaro 4.5.2-8ubuntu4) 4.5.2</span><br><span class="line">Copyright (C) 2010 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure><p></p><p>如果你还没有安装编译器，那你需要安装一个。最简单的办法便是去下载一个与你系统相符的rpm或者deb包，当然你也可以通过以下命令的一种来方便的安装：yum install gcc, apt-get install gcc, pkg-add -r gcc, 或者 emerge gcc.<br>除了编译器，你还需要以下程序：make, autoconf, automake, 和libtool。说实话，我连autoconf现在是啥还不知道(截至到现在，2011年9月6号)，不过除非RP太低，一般系统中都会自备了，而且phpize程序会把这些需要的脚本给生成好的。<br>对于编译需要的程序以及它们的版本我们可以在PHP官网找到最新的答案：</p><p></p><ul><br><li>autoconf: 2.13 (2.59+ for PHP 5.4+)</li><br><li>automake: 1.4+</li><br><li>libtool: 1.4.x+ (except 1.4.2)</li><br><li>bison: 1.28, 1.35, 1.75, 2.0 or higher</li><br><li>flex (PHP 5.2 and earlier): 2.5.4 (not higher)</li><br><li>re2c: 0.13.4+</li><br></ul><br>你千万不要被上面的清单给吓着，其实系统应该给装备好了，除非真RP低，那你出门去买张彩票吧… …<br>当然，我们也可以通过SVN从PHP源码库里导出一份源码，需要注意的是，PHP的svn源码库地址是https协议的。官方推荐我们直接签出它的php-src目录:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn checkout https://svn.php.net/repository/php/php-src --depth immediates php-src</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> php-src</span></span><br></pre></td></tr></table></figure><p></p><p>当然，我们也可以签出特定的版本：</p><p></p><ul><p></p><p></p><li>PHP 5.3: svn checkout <a href="https://svn.php.net/repository/php/php-src/branches/PHP_5_3" target="_blank" rel="noopener">https://svn.php.net/repository/php/php-src/branches/PHP_5_3</a> php-src-5.3</li><p></p><p></p><li>PHP 5.4: svn checkout <a href="https://svn.php.net/repository/php/php-src/branches/PHP_5_4" target="_blank" rel="noopener">https://svn.php.net/repository/php/php-src/branches/PHP_5_4</a> php-src-5.4</li><p></p><p></p><li>PHP HEAD: svn checkout <a href="https://svn.php.net/repository/php/php-src/trunk" target="_blank" rel="noopener">https://svn.php.net/repository/php/php-src/trunk</a> php-src-trunk</li><br></ul><br>最新的大家可以来这查看：<a href="http://php.net/svn.php" target="_blank" rel="noopener">http://php.net/svn.php</a><p></p><h3 id="Win32-Tools"><a href="#Win32-Tools" class="headerlink" title="Win32 Tools"></a>Win32 Tools</h3><p>这里仅代表作者05年的观点，我还没有在win平台下测试过，稍後会把这段修正过来。<br><pre><br>The Win32/PHP5 build system is a complete rewrite and represents a significant leap forward from the PHP4 build system. Instructions for compiling PHP4 under Windows are available on php.net, only the PHP5 build systemwhich requires Windows 2000, Windows 2003, or Windows XPwill be discussed here.</pre></p><p>First, you’ll need to grab libraries and development headers used by many of the core PHP extensions. Fortunately, many of these files are redistributed from php.net as a single .zip file located at <a href="http://www.php.net/extra/win32build.zip" target="_blank" rel="noopener">http://www.php.net/extra/win32build.zip</a>.</p><p>Create a new directory named C:\PHPDEV\ and unzip win32build.zip using your favorite zip management program into this location. The folder structure contained in the zip file will create a subdirectory, C:\PHPDEV\win32build, which will contain further subfolders and files. It’s not necessary to name your root folder PHPDEV; the only important thing is that win32build and the PHP source tree are both children of the same parent folder.</p><p>Next you’ll need a compiler. If you’ve already got Visual C++ .NET you have what you need; otherwise, download Visual C++ Express from Microsoft at <a href="http://lab.msdn.microsoft.com/express/" target="_blank" rel="noopener">http://lab.msdn.microsoft.com/express/</a>.</p><p>The installer, once you’ve downloaded and run it, will display the usual welcome, EULA (End-User License Agreement), and identification dialogs. Read through these screens and proceed using the Next buttons after you’ve agreed to the terms of the EULA and entered any appropriate information.</p><p>Installation location is of course up to you, and a typical installation will work just fine. If you’d like to create a leaner installation, you may deselect the three optional componentsGUI, MSDN, and SQL Server.</p><p>The final package is the Platform SDK, also available for download from Microsoft at <a href="http://www.microsoft.com/downloads/details.aspx?FamilyId=A55B6B43-E24F-4EA3-A93E-40C0EC4F68E5" target="_blank" rel="noopener">http://www.microsoft.com/downloads/details.aspx?FamilyId=A55B6B43-E24F-4EA3-A93E-40C0EC4F68E5</a>. The site currently lists three download options: PSDK-x86.exe, PSDK-ia64.exe, and PSDK-amd64.exe. These options refer to x86 compatible 32bit, Intel64bit, and AMD64bit processors respectively. If you’re not sure which one applies to your processor, select PSDK-x86.exe, which should work cleanly, albeit less efficiently, with both 64 bit variants.</p><p>As before, proceed through the first few screens as you would with any other installer package until you are prompted to select between Typical and Custom installation. A Typical installation includes the Core SDK package, which is sufficient for the purposes of building PHP. Other packages can be deselected by choosing a Custom installation, but if you have the hard disk space to spare, you might as well install it all. The other packages may come in handy later on.</p><p>So unless you’re byte conscious, select Typical and proceed through the next couple of standard issue screens until the installer begins copying and registering files. This process should take a few minutes so grab some popcorn.</p><p>Once installation is complete you’ll have a new item on your Start menuMicrosoft Platform SDK for Windows Server 2003 SP1.<br></p><h3 id="获取PHP源码"><a href="#获取PHP源码" class="headerlink" title="获取PHP源码"></a>获取PHP源码</h3><p>其实你有很多办法安装PHP，最简单的一种就是从你系统的库或者源里通过apt-get、yum install之类的命令直接安装PHP5，这样做的好处你的系统可能会自动处理一些php在它上面的工作时的一些bug，而且你还可以方便的升级与卸载。这样做也有缺点，那就是你的PHP版本永远无法是最新的，通常<a href="http://www.php.net发布数周甚至数月后你才能用上相应的版本。" target="_blank" rel="noopener">www.php.net发布数周甚至数月后你才能用上相应的版本。</a><br>第二种方法：也是推荐使用的一种方法，那就是自行下载php-x.y.z.tar.gz的源码包，然后自行编译安装。这种包一般都是经过了海量的测试后才发布的，而且非常接近最新beta或者alpha版本。<br>此外，你还可以snaps.php.net提供的快照包来下载php进行编译安装，这个站点每几个小时便会从源码库里打包出一份新的PHP。不过从这取得的包可能会因为某个未经完整测试的代码提交而使PHP工作不正常。但是如果你想研究下PHP6.0的进展，这里绝对是你方便获取它的地方。<br>最后，你可以直接从版本库中导出此时此刻的源码。作为一个扩展开发者，从版本库或者snaps中获取php看起来并没有多大的作用，但是如果我们要将这个扩展推送到版本库中时，便需要熟练的掌握checkout和checkin的步骤了。签出的地址在上面已经说过了。</p><h1 id="4-2-动手编译PHP"><a href="#4-2-动手编译PHP" class="headerlink" title="4.2 动手编译PHP"></a>4.2 动手编译PHP</h1><p>第一章我们曾介绍过，PHP编译前的configure有两个特殊的选项，打开它们对我们开发PHP扩展或者进行PHP嵌入式开发时非常有帮助。但是当我们正常使用PHP的时候，则不应该开启这两个选项。</p><h3 id="–enable-debug"><a href="#–enable-debug" class="headerlink" title="–enable-debug"></a>–enable-debug</h3><p>顾名思义，它的作用是激活调试模式。它将激活PHP源码中几个非常关键的函数，最典型的功能便是在每一个请求结束后给出这一次请求中内存的泄漏情况。<br>回顾一下第三章《内存管理》部分，php内核中的ZendMM( Zend Memory Manager)将会在每一个请求结束后强制释放在这个请求中申请的内存。By running a series of aggressive regression tests against newly developed code, leak points can be easily spotted and plugged prior to any public release. Take a look at the following code snippet:<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_value</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *message = emalloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">"The value of n is %d\n"</span>, n);</span><br><span class="line">    php_printf(<span class="string">"%s"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码执行后，将会导致1024B的内存泄漏，但是在ZendMM的帮助下，在请求结束后会被PHP内核自动的释放掉。<br>但是如果你开启了–enable-debug选项，在请求结束后内核便会给出一条信息，告知我们程序猿这次请求的内存泄漏情况。<br>/cvs/php5/ext/sample/sample.c(33) :Freeing 0x084504B8 (1024 bytes), script=-<br><br>=== Total 1 memory leaks detected ===<br>这条提示告知我们在这次请求结束后，ZendMM清理了泄漏的内存以及泄漏的内存位置。在它的帮助下，我们可以很快的定位到有问题的代码，然后通过efree等函数修正这个bug。<br>其实，内存泄漏并不是我们在开发中碰到的唯一错误，还有很多其它的bug很难被检测出来。有时候这些bug是致命的，但很难定位到出问题的代码。很多时候我们忙活了大半个晚上，修改了很多文件，最后make，但是当我们运行脚本的时候却得到下面的段错误。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sapi/cli/php -r 'myext_samplefunc();'</span><br><span class="line">Segmentation Fault</span><br><span class="line"><span class="comment">//如果中文环境，则显示段错误</span></span><br></pre></td></tr></table></figure><p></p><p>Orz…错误出在哪呢？我们遍历myext_samplefuc的所有实现代码也没有发现问题，扔进gdb里也仅仅显示几行无关紧要的信息而已。这种情况下，enable-debug就能帮你大忙了，打开这个选项后，你编译出来的php则会嵌入gdb或其它文件需要的所有调试信息。现在我们重新编译这个扩展，再扔进gdb里调试，便会得到如下的信息：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">0</span> <span class="number">0x1234567</span> php_myext_find_delimiter(str=<span class="number">0x1234567</span> <span class="string">"foo@#(FHVN)@\x98\xE0..."</span>,</span><br><span class="line">                                      <span class="built_in">strlen</span>=<span class="number">3</span>, tsrm_ls=<span class="number">0x1234567</span>)</span><br><span class="line">p = <span class="built_in">strchr</span>(str, <span class="string">','</span>);</span><br></pre></td></tr></table></figure><p></p><p>现在所有的问题都水落石出了，字符串变量str没有以NULL结尾，而我们却把它当作一个参数传给了二进制不安全的字符串处理函数，str将会扫描str知道找到NULL为止，它的扫描肯定是越界了，然后引发了一个段错误。找到问题根源后，我们只要用memchr来替换strchr函数就能修复这个bug了。</p><h3 id="–enable-maintainer-zts"><a href="#–enable-maintainer-zts" class="headerlink" title="–enable-maintainer-zts"></a>–enable-maintainer-zts</h3><p>第二个重要的参数便是激活php的线程安全机制(Thread Safe Resource Manager(TSRM)/Zend Thread Safety(ZTS))，使我们开发出的程序是线程安全的。对于TSRM的介绍大家可以参考第一章的介绍，在平时的开发中，建议打开这个选项。</p><h3 id="–enable-embed"><a href="#–enable-embed" class="headerlink" title="–enable-embed"></a>–enable-embed</h3><p>其实还有一个选项比较重要，那就是enable-embed，它主要用在你做php的嵌入式开发的场景中。平时我们把php作为apache的一个module进行编译，得到libphp5.so，而这个选项便使php编译后得到一个与我们设定的SAPI相对应的结果。</p><h1 id="4-3-Unix-Linux平台下的编译"><a href="#4-3-Unix-Linux平台下的编译" class="headerlink" title="4.3 Unix/Linux平台下的编译"></a>4.3 Unix/Linux平台下的编译</h1><p>编译之前如果需要了解一下php的configure脚本的各个配置，./configure –help一下即可，或者参考一下网络上的资料。当你确定了应该开启哪几个选项，选项都应该赋什么值后，便可以开始正式的编译我们的PHP了。这里假设你下载了php-5.3的源码，而且你将其解压到/php-5.3/目录下。<br>进入终端，通过cd命令进入/php-5.3/目录，执行./configure脚本，然后make,make test,比如：</p><pre class="code">cd /php-5.3./configure --prefix=/walu/php/ --enable-debug --enable-maintainer-ztsmakemake testmake clean //自愿执行，非必须。        </pre>make，尤其是make test命令是个耗时大户，具体执行时间的长短与机器配置有关(<span class="ps">这两个命令做练习可以，如果我们部署<b>开发环境</b>的时候，建议大家用apt-get或者yum来安装现成的</span>)。 # 4.4 在Win32平台上编译PHP 注意，没翻译的这节仅代表作者05年的观点。<pre>As with the UNIX build, the first step to preparing a Windows build is to unpack the source tarball. By default, Windows doesn't know what to do with a .tar.gz file. In fact, if you downloaded PHP using Internet Explorer, you probably noticed that it changed the name of the tarball file to php-5.1.0.tar.tar. This isn't IE craving a plate of fish sticks ordepending on who you aska bug, it's a "feature."Start by renaming the file back to php-5.1.0.tar.gz (if necessary). If you have a program installed that is capable of reading .tar.gz files, you'll notice the icon immediately change. You can now double-click on the file to open up the decompression program. If the icon doesn't change, or if nothing happens when you double-click the icon, it means that you have no tar/gzip compatible decompression program installed. Check your favorite search engine for WinZIP, WinRAR, or any other application that is suitable for extracting .tar.gz archives.Whatever decompression program you use, have it decompress php-5.1.0.tar.gz to the root development folder you created earlier. This section will assume you have extracted it to C:\PHPDEV\ which, because the zip file contains a folder structure, will result in the source tree residing in C:\PHPDEV\php-5.1.0.After it's unpacked, open up a build environment window by choosing Start, All Programs, Microsoft Platform SDK for Windows Server 2003 SP1, Open Build Environment Window, Windows 2000 Build Environment, Set Windows 2000 Build Environment (Debug). The specific path to this shortcut might be slightly different depending on the version of the Platform SDK you have installed and the target platform you will be building for (2000, XP, 2003).A simple command prompt window will open up stating the target build platform. This command prompt has most, but not all, necessary environment variables set up. You'll need to run one extra batch file in order to let the PHP build system know where Visual C++ Express is. If you accepted the default installation location this batch file will be located at C:\Program Files\Microsoft Visual Studio 8\VC\bin\vcvars32.bat. If you can't find vcvars32.bat, check the same directoryor its parentfor vcvarsall.bat. Just be sure to run it inside the same command prompt window you just opened. It will set additional environment variables that the build process will need.Now, change the directory to the location where you unpacked PHPC:\PHPDEV\php-5.1.0and run buildconf.bat.C:\Program Files\Microsoft Platform SDK> cd \PHPDEV\php-5.1.0C:\PHPDEV\php-5.1.0> buildconf.batIf all is going well so far you'll see the following two lines of output:Rebuilding configure.jsNow run 'cscript /nologo configure.js help'At this point, you can do as the message says and see what options are available. The enable-maintainer-zts option is not necessary here because the Win32 build automatically assumes that ZTS will be required by any SAPI. If you wanted to turn it off, you could issue disable-zts, but that's not the case here because you're building for a development environment anyway.In this example I've removed a few other extensions that aren't relevant to extension and embedding development for the sake of simplicity. If you'd like to rebuild PHP using additional extensions, you'll need to hunt down the libraries on which they depend.C:\php-5.1.0> cscript /nologo configure.js without-xml without-wddx \without-simplexml without-dom without-libxml disable-zlib \without-sqlite disable-odbc disable-cgi enable-cli \enable-debug without-iconvAgain, a stream of informative output will scroll by, followed by instructions to execute the final command:C:\php-5.1.0> nmakeFinally, a working build of PHP compiled for the Win32 platform.</pre><h1 id="4-5-动手编译PHP"><a href="#4-5-动手编译PHP" class="headerlink" title="4.5 动手编译PHP"></a>4.5 动手编译PHP</h1><p>单就开发一个最基本的php扩展来说，该掌握的前置知识我们已经都掌握了。在接下来的章节里我们将会深入的研究如何制作一个PHP扩展，以及制作一个优秀的PHP扩展所需的其它知识。<br>此外，如果你只想把PHP当作一个嵌入式应用来使用，我们也强烈的建议你不要直接跳到最后几章，因为在接下来的章节里我们将详细的介绍与PHP内核密切相关的一些内容，比如HashTable、数组、对象……等等的实现方式与应用方法。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 内存管理</title>
      <link href="/posts/8f440a19.html"/>
      <url>/posts/8f440a19.html</url>
      
        <content type="html"><![CDATA[<h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3 内存管理"></a>3 内存管理</h1><p>脚本语言与编译型语言最根本的区别可能就在内存管理上。但这并不限于脚本语言，现在越来越多的语言不再允许用户直接操作内存，而由虚拟机来代替用户负责内存的分配及回收，如C#、Java、PHP等。</p><h1 id="3-1-内存管理"><a href="#3-1-内存管理" class="headerlink" title="3.1 内存管理"></a>3.1 内存管理</h1><p>在PHP里，我们可以定义字符串变量，比如&lt;?php $str=”hello”;?&gt;，$str这个字符串变量可以被自由的修改与复制等。这一切在C语言里看起来都是不可能的事情，我们用#char *p = “hello”;#来定义一个字符串，但它是常量，是不能被修改的，如果你用p[1]=’c’;来修改这个字符串会引发段错误(Gcc,c99)，为了修改C语言里的字符串常量，我们往往需要定义字符串数组。为了得到一个能够让我们自由修改的字符串，我们往往需要用strdup函数来复制一个字符串出来。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">// p[0] = 'a'; 如果这么做，就等着运行时段错误吧。</span></span><br><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line">str = strdup(p);</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'a'</span>; <span class="comment">//这时就能自由修改了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。</p><h3 id="Free-the-Mallocs"><a href="#Free-the-Mallocs" class="headerlink" title="Free the Mallocs"></a>Free the Mallocs</h3><p>每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。那么，我们就称其为”内存泄漏”，那么这部分内存就无法再为其它程序所用了。<br>在一个典型的客户端应用程序中，偶尔的小量的内存泄漏是可以被操作系统容忍的，因为在进程结束后该泄漏内存会被返回给OS。这并没有什么高科技含量，因为OS知道它把该内存分配给了哪个程序，并且它能够在一个程序结束后把这些内存给回收回来。<br>但是，世界总是不缺乏特例！对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。现在，我们来在C语言中故意错误的模拟一下PHP的stristr()函数为例，为了使用大小写不敏感的方式来搜索一个字符串，我们需要创建两个辅助的字符串，它们分别是被查找字符串和待查找字符串的小写化副本，然后由这两个副本来帮助我们来完成这次搜索。如果我们在执行这个函数后不释放这些副本占用的资源，那么每一次stristr函数都将是对内存的一次永远的侵占，最终导致这个函数占用了所有的系统内存，而没有实际意义！<br>大多数人提出来的理想的解决方案是：书写优秀，整洁并且风格一致的代码，这当然是毫无疑问的。但是在PHP扩展开发这样的底层环境中，这并不能解决全部的问题。比如，你需要自己保证在层层嵌套调用中对某块内存的使用都是正确的，且会及时释放的。<sup> <a href="#sup1">1</a></sup></p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>为了实现从用户端(PHP语言中)”跳出”，需要使用一种方法来完全”跳出”一个活动请求。这个功能是在内核中实现的：在一个请求的开始设置一个”跳出”地址，然后在任何die()或exit()调用或在遇到任何关键错误(E_ERROR)时执行一个longjmp()以跳转到该”跳出”地址。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname, <span class="keyword">int</span> fname_len TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zend_function *fe;</span><br><span class="line">    <span class="keyword">char</span> *lcase_fname;</span><br><span class="line">    <span class="comment">/* php函数的名字是大小写不敏感的</span></span><br><span class="line"><span class="comment">     * 我们可以在function tables里找到他们</span></span><br><span class="line"><span class="comment">     * 保存的所有函数名都是小写的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lcase_fname = estrndup(fname, fname_len);</span><br><span class="line">    zend_str_tolower(lcase_fname, fname_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(EG(function_table),lcase_fname, fname_len + <span class="number">1</span>, (<span class="keyword">void</span> **)&amp;fe) == SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        zend_execute(fe-&gt;op_array TSRMLS_CC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;    </span><br><span class="line">        php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_ERROR,<span class="string">"Call to undefined function: %s()"</span>, fname);</span><br><span class="line">    &#125;</span><br><span class="line">    efree(lcase_fname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当php_error_docref这个函数被调用的时候，便会触发内核中的错误处理机制，根据错误级别来决定是否调用longjmp来终止当前请求并退出call_function函数，从而efree函数便永远不会被执行了。<br></p><div class="tip-common"><br>其实php_error_docref()函数就相当于php语言里的trigger_error()函数.它的第一个参数是一个将被添加到docref的可选的文档引用第三个参数可以是任何我们熟悉的E_*家族常量，用于指示错误的严重程度。后面的两个参数就像printf()风格的格式化和变量参数列表式样。</div><p></p><h3 id="Zend内存管理器"><a href="#Zend内存管理器" class="headerlink" title="Zend内存管理器"></a>Zend内存管理器</h3><p>在上面的”跳出”请求期间解决内存泄漏的方案之一是：使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是”请求感知”的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。<br></p><p style="text-align:center"><img src="http://www.walu.cc/phpbook/image/03fig01.jpg"><br>除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。<br>把PHP内核代码和OS的实际的内存管理层”钩”在一起的原理并不复杂：所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求”跳出”时，ZendMM可以隐式地释放它。<br>有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为”永久性分配”），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。<br>如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。<br>例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define in Zend/zend_alloc.h:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pemalloc(size, persistent)((persistent)?malloc(size): emalloc(size))</span></span><br></pre></td></tr></table></figure><p></p><p>所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。</p><p><table class="table-common"><br><tr><br><td>C语言原生函数</td><br><td>PHP内核封装后的函数</td><br></tr><br><tr><br><td>void <em>malloc(size_t count);</em></td><br><td>void emalloc(size_t count);<br>void <em>pemalloc(size_t count, char persistent);</em></td><br></tr><br><tr><br><td>void calloc(size_t count);</td><br><td>void <em>ecalloc(size_t count);<br>void </em>pecalloc(size_t count, char persistent);</td><br></tr><br><tr><br><td>void <em>realloc(void </em>ptr, size_t count);</td><br><td>void <em>erealloc(void </em>ptr, size_t count);<br>void <em>perealloc(void </em>ptr, size_t count, char persistent);</td><br></tr><br><tr><br><td>void <em>strdup(void </em>ptr);</td><br><td>void <em>estrdup(void </em>ptr);<br>void <em>pestrdup(void </em>ptr, char persistent);</td><br></tr><br><tr><br><td>void free(void <em>ptr);</em></td><br><td>void efree(void ptr);<br>void pefree(void *ptr, char persistent);</td><br></tr><br></table><br>你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。<br>除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">estrndup</span><span class="params">(<span class="keyword">void</span> *ptr，<span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API <span class="keyword">char</span> *_estrndup(<span class="keyword">const</span> <span class="keyword">char</span> *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">p = (<span class="keyword">char</span> *) _emalloc(length+<span class="number">1</span> ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line"><span class="keyword">if</span> (UNEXPECTED(p == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(p, s, length);</span><br><span class="line">p[length] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">safe_emalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> addtl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">safe_pemalloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> addtl, <span class="keyword">char</span> persistent)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>这些函数分配的内存空间最终大小都是((size*count)+addtl)。<br>你可以会问：”为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？”。<br>原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一”可能性相当小”的结果导致宿主平台的内存溢出。<br>这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。<br>而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。</p><blockquote><p>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p></blockquote><p></p><hr><p></p><dl><br><dt>贡献者名单</dt><br><dd id="sup1">绊大象的蚂蚁{eaglevean#163.com}，注1</dd><br></dl><h1 id="3-2-引用计数"><a href="#3-2-引用计数" class="headerlink" title="3.2 引用计数"></a>3.2 引用计数</h1><p>对于PHP这种需要同时处理多个请求的程序来说，申请和释放内存的时候应该慎之又慎，一不小心便会酿成大错。另一方面，除了要安全的申请和释放内存外，还应该做到内存的最小化使用，因为它可能要处理每秒钟数以千计的请求，为了提高系统整体的性能，每一次操作都应该只使用最少的内存，对于不必要的相同数据的复制则应该能免则免。我们来看下面这段PHP代码：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="string">'Hello World'</span>;</span><br><span class="line">$b = $a;</span><br><span class="line"><span class="keyword">unset</span>($a);</span><br></pre></td></tr></table></figure><p></p><p>第一条语句执行后，PHP创建了$a这个变量，并为它申请了12B的内存来存放”hello world”这个字符串（最后加个NULL字符，你懂的）。紧接着把$a赋给了$b，并释放掉$a;<br>对于PHP来说，如果每一次变量赋值都执行一次内存复制的话，那需要额外申请12B的内存来存放这个重复的数据,当然为了复制内存，还需要cpu执行某些计算，这当然会加重cpu的负载。当第三句执行后，$a被释放了，我们刚才的设想突然变的这么滑稽，这次赋值显得好多余哦。如果早就知道$a不用了，那我们直接让$b用$a的内存不就行了，还赋值干嘛？如果你觉得12B没什么，那设想下如果$a是个10M的文件内容，或者20M，是不是我们的计算机资源消耗的有点冤枉呢？<br>别担心，PHP很聪明！<br>前面章节说过，PHP变量的名称和值在内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zval *helloval;</span><br><span class="line">MAKE_STD_ZVAL(helloval);</span><br><span class="line">ZVAL_STRING(helloval, <span class="string">"Hello World"</span>, <span class="number">1</span>);</span><br><span class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="string">"a"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"b"</span>, <span class="keyword">sizeof</span>(<span class="string">"b"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//通过这个例子我们看出了，我们可以把$a和$b都指向helloval~!</span></span><br></pre></td></tr></table></figure><p></p><p>现在我们检查$a和$b两个变量，他们的值指向了”hello world”这个字符串在内存中的位置。但是在第三行：unset($a);这条语句释放了$a。在这种情况下，unset函数并不知道$a的值同时被$b用着，所以如果它直接释放内存，则会导致$b的值也被清空了，从而导致逻辑错误，甚至可能会导致系统崩溃。<br>呵呵，其实你心里明白，PHP不会让上述问题发生的！回顾一下zval的四个成员value、type、is_ref__gc、refcount__gc，我们对value和type已经很熟了，现在则是后两个成员发挥威力的时候了，这里我们主要讲解refcount__gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount__gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！<br>以上描述转为内核中的代码大体如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zval *helloval;</span><br><span class="line">MAKE_STD_ZVAL(helloval);</span><br><span class="line">ZVAL_STRING(helloval, <span class="string">"Hello World"</span>, <span class="number">1</span>);</span><br><span class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="string">"a"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">ZVAL_ADDREF(helloval); <span class="comment">//这句很特殊，我们显式的增加了helloval结构体的refcount</span></span><br><span class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"b"</span>, <span class="keyword">sizeof</span>(<span class="string">"b"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p></p><p>这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！</p><h3 id="写时复制机制"><a href="#写时复制机制" class="headerlink" title="写时复制机制"></a>写时复制机制</h3><p>引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = $a;</span><br><span class="line">$b += <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p></p><p>从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？<br>答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zval *<span class="title">get_var_and_separate</span><span class="params">(<span class="keyword">char</span> *varname, <span class="keyword">int</span> varname_len TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">zval **varval, *varcopy;</span><br><span class="line"><span class="keyword">if</span> (zend_hash_find(EG(active_symbol_table),varname, varname_len + <span class="number">1</span>, (<span class="keyword">void</span>**)&amp;varval) == FAILURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果在符号表里找不到这个变量则直接return */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((*varval)-&gt;refcount &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return</span></span><br><span class="line"><span class="keyword">return</span> *varval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 否则，复制一份zval*的值 */</span></span><br><span class="line">MAKE_STD_ZVAL(varcopy);</span><br><span class="line">varcopy = *varval;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复制任何在zval*内已分配的结构*/</span></span><br><span class="line">zval_copy_ctor(varcopy);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从符号表中删除原来的变量</span></span><br><span class="line"><span class="comment"> * 这将减少该过程中varval的refcount的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">zend_hash_del(EG(active_symbol_table), varname, varname_len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/</span></span><br><span class="line">varcopy-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">varcopy-&gt;is_ref = <span class="number">0</span>;</span><br><span class="line">zend_hash_add(EG(active_symbol_table), varname, varname_len + <span class="number">1</span>,&amp;varcopy, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回新zval的地址 */</span></span><br><span class="line"><span class="keyword">return</span> varcopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。</p><h3 id="Change-on-Write"><a href="#Change-on-Write" class="headerlink" title="Change on Write"></a>Change on Write</h3><p>如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？</p><p><pre><br>    $a = 1;<br>    $b = &amp;$a;<br>    $b += 5;<br></pre><br>作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！<br>但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &amp;$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！<br>最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/</span></span><br><span class="line"><span class="keyword">if</span> ((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> *varval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。</p><h3 id="Separation-Anxiety"><a href="#Separation-Anxiety" class="headerlink" title="Separation Anxiety"></a>Separation Anxiety</h3><p>我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = $a;</span><br><span class="line">$c = &amp;$a;</span><br></pre></td></tr></table></figure><p></p><p>这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref__gc和refcount__gc该怎样工作，才能正确的处理好这段复杂的关系呢？<br>The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】<br></p><p style="text-align:center"><img src="http://www.walu.cc/phpbook/image/03fig02.jpg"></p><br>同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//上图对应的代码</span></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line">$c = $a;</span><br></pre></td></tr></table></figure><p></p><p>图3.3：<br></p><p style="text-align:center"><img src="http://www.walu.cc/phpbook/image/03fig03.jpg"></p><br>需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。<p></p><h1 id="3-3-内存管理"><a href="#3-3-内存管理" class="headerlink" title="3.3 内存管理"></a>3.3 内存管理</h1><p>PHP是一种解释型的语言，对于用户而言，我们精心的控制内存意味着easier prototyping和更少的崩溃！当我们深入到内核之后，所有的安全防线都已经被越过，最终还是要依赖于真正有责任心的软件工程师来保证系统的稳定运行。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2 PHP变量在内核中的实现</title>
      <link href="/posts/24d1659c.html"/>
      <url>/posts/24d1659c.html</url>
      
        <content type="html"><![CDATA[<h1 id="2-PHP变量在内核中的实现"><a href="#2-PHP变量在内核中的实现" class="headerlink" title="2 PHP变量在内核中的实现"></a>2 PHP变量在内核中的实现</h1><p>所有的编程语言都要提供一种数据的存储与检索机制，PHP也不例外。其它语言大都需要在使用变量之前先定义，并且它的类型也是无法再次改变的，而PHP却允许程序猿自由的使用变量而无须提前定义，甚至可以随时随意的对已存在的变量转换成其它任何PHP支持的数据类型。在程序在运行的时候，PHP还会自动的根据需求转换变量的类型。</p><p>我认为阅读本书的人都已经是标准的PHP程序猿了，所以你们也肯定体验过PHP的弱类型的变量体系。众所周知，PHP引擎是用C写的，而C确实一种强类型的编程语言，PHP内核中是如何用C来实现自己的这种弱类型特性的，你将在本章中找到答案！</p><h1 id="2-1-变量的类型"><a href="#2-1-变量的类型" class="headerlink" title="2.1 变量的类型"></a>2.1 变量的类型</h1><p>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">zvalue_value value;<span class="comment">/* 变量的值 */</span></span><br><span class="line">zend_uint refcount__gc;</span><br><span class="line">zend_uchar type;<span class="comment">/* 变量当前的数据类型 */</span></span><br><span class="line">zend_uchar is_ref__gc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> <span class="title">zval</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在Zend/zend_types.h里定义的：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> zend_uint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> zend_uchar;</span><br></pre></td></tr></table></figure><p>zval里的refcount__gc是zend_uint类型，也就是unsigned int型，is_ref__gc和type则是unsigned char型的。</p><p>保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value &#123;</span><br><span class="line"><span class="keyword">long</span> lval;<span class="comment">/* long value */</span></span><br><span class="line"><span class="keyword">double</span> dval;<span class="comment">/* double value */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *val;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">&#125; str;</span><br><span class="line">HashTable *ht;<span class="comment">/* hash table value */</span></span><br><span class="line">zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p><table><br><tr><br><td><b>常量名称：</b></td><br><td></td><br></tr><br><tr><br><td>IS_NULL</td><br><td>第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</td><br></tr><br><tr><br><td>IS_BOOL</td><br><td>布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</td><br></tr><br><tr><br><td>IS_LONG</td><br><td>PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。<br>在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。<br>有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出，<br>而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。<br>再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a=<span class="number">2147483647</span>;</span><br><span class="line">$a++;</span><br><span class="line">echo $a;<span class="comment">//会正确的输出2147483648；</span></span><br></pre></td></tr></table></figure><br><br></td><br></tr><br><tr><br><td>IS_DOUBLE</td><br><td>PHP中的浮点数据是通过C语言中的signed double型变量来存储的，<br>这最终取决与所在操作系统的浮点型实现。<br>我们做为程序猿，应该知道计算机是无法精准的表示浮点数的，<br>而是采用了科学计数法来保存某个精度的浮点数。<br>用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。<br>用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1，<br>0.8转换后是0.1100110011….。<br>但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。<br>我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数，<br>但是计算机可能只能精确存储到0.333333，当我们再乘以三时，<br>其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.</td><br></tr><br><tr><br><td>IS_STRING</td><br><td>PHP中最常用的数据类型——字符串，在内存中的存储和C差不多，<br>就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。<br>与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度，<br>这个设计使PHP可以在字符串中嵌入‘\0’字符，也使PHP的字符串是二进制安全的，<br>可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存，<br>最后一个字节存储的是‘\0’字符，所以在不需要二进制安全操作的时候，<br>我们可以像通常C语言的方式那样来使用它。</td><br></tr><br><tr><br><td>IS_ARRAY</td><br><td>数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。<br>在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多，<br>它可以承载任意类型的数据，这一切都是HashTable的功劳，<br>每个HashTable中的元素都有两部分组成：索引与值，<br>每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</td><br></tr><br><tr><br><td>IS_OBJECT</td><br><td>和数组一样，对象也是用来存储复合数据的，但是与数组不同的是，<br>对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。<br>相对与zend engine V1，V2中的对象实现已经被彻底修改，<br>所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式，<br>则应该对PHP5和PHP4分别对待！</td><br></tr><br><tr><br><td>IS_RESOURCE</td><br><td>有一些数据的内容可能无法直接呈现给PHP用户的，<br>比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。<br>但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。<br>有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。</td><br></tr><br></table><p>zval结构体里的type成员的值便是以上某个IS_*常量之一。<br>内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。</p><p>如果要我们检测一个变量的类型，最直接的办法便是去读取它的type成员的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe_zval</span><span class="params">(zval *foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (foo-&gt;type == IS_NULL)</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"这个变量的数据类型是： NULL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d"</span>, foo-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>虽然上述实现是正确的，但我们强烈建议你不要这样做。</strong></p><p>PHP内核以后可能会修改变量的实现方式，所以检测type的方法可能在以后就不能用了。<br>为了解决这个兼容问题，zend头文件中定义了大量的宏，供我们检测、操作变量使用，<br>使用这些宏不但让我们的程序更易读，还具有更好的兼容性。<br>这里我们用Z_TYPE_P()宏来改写上面那个程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe_zval</span><span class="params">(zval *foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Z_TYPE_P(foo) == IS_NULL )</span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量的数据类型是： NULL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d"</span>, Z_TYPE_P(foo));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>php_printf()函数是内核对printf()函数的一层封装，我们可以像使用printf()函数那样使用它。</strong></p><p>以一个P结尾的宏的参数大多是*zval型变量。<br>此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。</p><p>这样我们便可以猜测一下php内核是如何实现gettype这个函数了，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始定义php语言中的函数gettype</span></span><br><span class="line">PHP_FUNCTION(gettype)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span></span><br><span class="line"><span class="comment">//所以我们要对他使用__PP后缀的宏。</span></span><br><span class="line">zval **arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个if的操作主要是让arg指向参数～</span></span><br><span class="line"><span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"Z"</span>, &amp;arg) == FAILURE) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></span><br><span class="line"><span class="comment">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></span><br><span class="line"><span class="keyword">switch</span> (Z_TYPE_PP(arg)) &#123;</span><br><span class="line"><span class="keyword">case</span> IS_NULL:</span><br><span class="line">RETVAL_STRING(<span class="string">"NULL"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IS_BOOL:</span><br><span class="line">RETVAL_STRING(<span class="string">"boolean"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IS_LONG:</span><br><span class="line">RETVAL_STRING(<span class="string">"integer"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">RETVAL_STRING(<span class="string">"double"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IS_STRING:</span><br><span class="line">RETVAL_STRING(<span class="string">"string"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">RETVAL_STRING(<span class="string">"array"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">RETVAL_STRING(<span class="string">"object"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> *type_name;</span><br><span class="line">type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</span><br><span class="line"><span class="keyword">if</span> (type_name) &#123;</span><br><span class="line">RETVAL_STRING(<span class="string">"resource"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">RETVAL_STRING(<span class="string">"unknown type"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_TYPE(zval)(zval).type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_TYPE_P(zval_p)Z_TYPE(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_TYPE_PP(zval_pp)Z_TYPE(**zval_pp)</span></span><br></pre></td></tr></table></figure><h1 id="2-2-变量的值"><a href="#2-2-变量的值" class="headerlink" title="2.2 变量的值"></a>2.2 变量的值</h1><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头，并且P结尾和PP结尾的同上一节中的宏一样，<br>分别代表这参数是指针还是指针的指针。</p><p>此外，为了进一步方便我们的工作，内核中针对具体的数据类型分别定义了相应的宏。<br>如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。<br>我们通过下面这个例子来应用一下这几个宏:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_value</span><span class="params">(zval zv,zval *zv_p,zval **zv_pp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( Z_TYPE(zv) == IS_NULL )</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"类型是 IS_NULL!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( Z_TYPE_P(zv_p) == IS_LONG )</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"类型是 IS_LONG，值是：%ld"</span> , Z_LVAL_P(zv_p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Z_TYPE_PP(zv_pp) == IS_DOUBLE )</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"类型是 IS_DOUBLE,值是：%f"</span> , Z_DVAL_PP(zv_pp) );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度，<br>所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。<br>前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string</span><span class="params">(zval *zstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE_P(zstr) != IS_STRING) &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量不是字符串!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));</span><br><span class="line">    <span class="comment">//这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array型变量的值其实是存储在C语言实现的HashTable中的，<br>我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。<br>如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。<br>但不推荐在新代码中再使用了。</p><p>对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。<br>内核中定义了以下组合宏让我们方便的操作对象：<br>OBJ_HANDLE：返回handle标识符，<br>OBJ_HT：handle表，<br>OBJCE：类定义，<br>OBJPROP：HashTable的属性，<br>OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。<br>现在不用担心这些宏对象的意思，后续有专门的章节介绍object。</p><p>资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。有关资源的内容我们将在第9章展开叙述。</p><p>有关值操作的宏都定义在./Zend/zend_operators.h文件里：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作整数的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL(zval)(zval).value.lval</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL_P(zval_p)Z_LVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL_PP(zval_pp)Z_LVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作IS_BOOL布尔型的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL(zval)((zend_bool)(zval).value.lval)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL_P(zval_p)Z_BVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL_PP(zval_pp)Z_BVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作浮点数的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL(zval)(zval).value.dval</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL_P(zval_p)Z_DVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL_PP(zval_pp)Z_DVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作字符串的值和长度的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL(zval)(zval).value.str.val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL_P(zval_p)Z_STRVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL_PP(zval_pp)Z_STRVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN(zval)(zval).value.str.len</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN_P(zval_p)Z_STRLEN(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN_PP(zval_pp)Z_STRLEN(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL(zval)(zval).value.ht</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL_P(zval_p)Z_ARRVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL_PP(zval_pp)Z_ARRVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作对象的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL(zval)(zval).value.obj</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL_P(zval_p)Z_OBJVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL_PP(zval_pp)Z_OBJVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE(zval)Z_OBJVAL(zval).handle</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE_P(zval_p)Z_OBJ_HANDLE(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE_PP(zval_p)Z_OBJ_HANDLE(**zval_p)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT(zval)Z_OBJVAL(zval).handlers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT_P(zval_p)Z_OBJ_HT(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT_PP(zval_p)Z_OBJ_HT(**zval_p)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE(zval)zend_get_class_entry(&amp;(zval) TSRMLS_CC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE_P(zval_p)Z_OBJCE(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE_PP(zval_pp)Z_OBJCE(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP(zval)Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP_P(zval_p)Z_OBJPROP(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP_PP(zval_pp)Z_OBJPROP(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER(zval, hf) Z_OBJ_HT((zval))-&gt;hf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER_P(zval_p, h)Z_OBJ_HANDLER(*zval_p, h)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER_PP(zval_p, h)Z_OBJ_HANDLER(**zval_p, h)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG(zval,is_tmp)(Z_OBJ_HANDLER((zval),get_debug_info)?\</span></span><br><span class="line">Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \</span><br><span class="line">(is_tmp=<span class="number">0</span>,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):<span class="literal">NULL</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG_P(zval_p,is_tmp)Z_OBJDEBUG(*zval_p,is_tmp)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG_PP(zval_pp,is_tmp)Z_OBJDEBUG(**zval_pp,is_tmp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作资源的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL(zval)(zval).value.lval</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL_P(zval_p)Z_RESVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL_PP(zval_pp)Z_RESVAL(**zval_pp)</span></span><br></pre></td></tr></table></figure><p></p><h1 id="2-3-创建PHP变量"><a href="#2-3-创建PHP变量" class="headerlink" title="2.3 创建PHP变量"></a>2.3 创建PHP变量</h1><p>我们已经知道php变量在内核中其实是通过zval结构来实现的，也初步了解如何设置一个zval结构的类型和值。<br>这一节我们将在前两节的基础上，彻底掌握对zval结构的操控，其间将引入很多超棒的新宏。</p><p>在code的时候，很希望在内核中创建的zval可以让用户在PHP语言里以变量的形式使用，为了实现这个功能，<br>我们首先要创建一个zval。最容易想到的办法便是创建一个zval指针，<br>然后申请一块内存并让指针指向它。如果你脑海里浮现出了malloc(sizeof(zval))的影子，<br>那么请你立即刹车，不要用malloc来做这件事情，内核给我们提供了相应的宏来处理这件事，<br>理由和以前一样：为了代码漂亮并保持版本升级时的兼容性。<br>这个宏是：MAKE_STD_ZVAL(pzv)。这个宏会用内核的方式来申请一块内存并将其地址付给pzv，<br>并初始化它的refcount和is_ref两个属性，更棒的是，它不但会自动的处理内存不足问题，<br>还会在内存中选个最优的位置来申请。</p><blockquote><p>除了MAKE_STD_ZVAL()宏函数，ALLOC_INIT_ZVAL()宏函数也是用来干这件事的，<br>唯一的不同便是它会将pzv所指的zval的类型设置为IS_NULL;</p></blockquote><p>申请完空间后，我们便可以给这个zval赋值了。基于已经介绍的宏，<br>也许我们需要Z_TYPE_P(p) = IS_NULL来设置其是null类型，并用Z_SOMEVAL形式的宏来为它赋值，<br>但是现在你有了更好更短的选择！</p><p>内核中提供一些宏来简化我们的操作，可以只用一步便设置好zval的类型和值。</p><table><br><tr><br><td>新宏</td><br><td>其它宏的实现方法</td><br></tr><br><tr><br><td>ZVAL_NULL(pvz); <strong>(注意这个Z和VAL之间没有下划线！)</strong></td><br><td>Z_TYPE_P(pzv) = IS_NULL;(IS_NULL型不用赋值，因为这个类型只有一个值就是null，^_^)</td><br></tr><br><tr><br><td>ZVAL_BOOL(pzv, b); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是b)</strong></td><br><td>Z_TYPE_P(pzv) = IS_BOOL;<br>Z_BVAL_P(pzv) = b ? 1 : 0;</td><br></tr><br><tr><br><td>ZVAL_TRUE(pzv); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是true)</strong></td><br><td>ZVAL_BOOL(pzv, 1);</td><br></tr><br><tr><br><td>ZVAL_FALSE(pzv); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是false)</strong></td><br><td>ZVAL_BOOL(pzv, 0);</td><br></tr><br><tr><br><td>ZVAL_LONG(pzv, l); <strong>(将pzv所指的zval设置为IS_LONG类型，值是l)</strong></td><br><td>Z_TYPE_P(pzv) = IS_LONG;<br>Z_LVAL_P(pzv) = l;</td><br></tr><br><tr><br><td>ZVAL_DOUBLE(pzv, d); <strong>(将pzv所指的zval设置为IS_DOUBLE类型，值是d)</strong></td><br><td>Z_TYPE_P(pzv) = IS_DOUBLE;<br>Z_DVAL_P(pzv) = d;</td><br></tr><br><tr><br><td>ZVAL_STRINGL(pzv,str,len,dup);<strong>(下面单独解释)</strong></td><br><td>Z_TYPE_P(pzv) = IS_STRING;<br>Z_STRLEN_P(pzv) = len;<br>if (dup)<br>{Z_STRVAL_P(pzv) =estrndup(str, len + 1);}<br>else<br>{Z_STRVAL_P(pzv) = str;}</td><br></tr><br><tr><br><td>ZVAL_STRING(pzv, str, dup);</td><br><td>ZVAL_STRINGL(pzv, str,strlen(str), dup);</td><br></tr><br><tr><br><td>ZVAL_RESOURCE(pzv, res);</td><br><td>Z_TYPE_P(pzv) = IS_RESOURCE;<br>Z_RESVAL_P(pzv) = res;</td><br></tr><br></table><h3 id="ZVAL-STRINGL-pzv-str-len-dup-中的dup参数"><a href="#ZVAL-STRINGL-pzv-str-len-dup-中的dup参数" class="headerlink" title="ZVAL_STRINGL(pzv,str,len,dup)中的dup参数"></a>ZVAL_STRINGL(pzv,str,len,dup)中的dup参数</h3><p>先阐述一下ZVAL_STRINGL(pzv,str,len,dup);<br>str和len两个参数很好理解，因为我们知道内核中保存了字符串的地址和它的长度，<br>后面的dup的意思其实很简单，它指明了该字符串是否需要被复制。<br>值为 1 将先申请一块新内存并赋值该字符串，然后把新内存的地址复制给pzv，<br>为 0 时则是直接把str的地址赋值给zval。</p><p>《抚琴居》上的一篇文章说这项特性将会在你仅仅需要创建一个变量并将其指向一个已经由 Zend 内部数据内存时变得很有用。</p><h3 id="ZVAL-STRINGL与ZVAL-STRING的区别"><a href="#ZVAL-STRINGL与ZVAL-STRING的区别" class="headerlink" title="ZVAL_STRINGL与ZVAL_STRING的区别"></a>ZVAL_STRINGL与ZVAL_STRING的区别</h3><p>如果你想在某一位置截取该字符串或已经知道了这个字符串的长度，<br>那么可以使用宏 ZVAL_STRINGL(zval, string, length, duplicate) ，它显式的指定字符串长度，<br>而不是使用strlen()。这个宏该字符串长度作为参数。但它是二进制安全的，而且速度也比ZVAL_STRING快，因为少了个strlen。</p><h3 id="ZVAL-RESOURCE约等于ZVAL-LONG"><a href="#ZVAL-RESOURCE约等于ZVAL-LONG" class="headerlink" title="ZVAL_RESOURCE约等于ZVAL_LONG"></a>ZVAL_RESOURCE约等于ZVAL_LONG</h3><p>上一节中我们说过PHP中的资源类型的值其实就是一个整数，所以ZVAL_RESOURCE和ZVAL_LONG的工作差不多，<br>只不过它会把zval的类型设置为 IS_RESOURCE。</p><h1 id="2-4-变量的存储方式"><a href="#2-4-变量的存储方式" class="headerlink" title="2.4 变量的存储方式"></a>2.4 变量的存储方式</h1><p>我们在前两节已经了解了PHP中变量的类型和值是怎样在内核中用C语言实现的，<br>这一节我们将看一下内核是怎样来组织用户在PHP中定义的变量的。</p><p>有一点对我们扩展开发者来说非常棒，那就是用户在PHP中定义的变量我们都可以在一个HashTable中找到，<br>当PHP中定义了一个变量，内核会自动的把它的信息储存到一个用HashTable实现的符号表里。</p><p>全局作用域的符号表是在调用扩展的RINIT方法(一般都是MINIT方法里)前创建的，并在RSHUTDOWN方法执行后自动销毁。</p><p>当用户在PHP中调用一个函数或者类的方法时，内核会创建一个新的符号表并激活之，<br>这也就是为什么我们无法在函数中使用在函数外定义的变量的原因<br>（因为它们分属两个符号表，一个当前作用域的，一个全局作用域的）。<br>如果不是在一个函数里，则全局作用域的符号表处于激活状态。</p><p>我们现在打开Zend/zend_globals.h文件，看一下_zend_execution_globals结构体，会在其中发现这么两个element：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_executor_globals</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    HashTable symbol_table;</span><br><span class="line">    HashTable *active_symbol_table;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的 symbol_table元素可以通过EG宏来访问，它代表着PHP的全局变量，如$GLOBALS，其实从根本上来讲，<br>$GLOBALS不过是EG(symbol_table)的一层封装而已。</p><p>与之对应，下面的active_symbol_table元素也可以通过EG(active_symbol_table)的方法来访问，它代表的是处于当前作用域的变量符号表。</p><p>我们上边也看到了，其实这两个成员在_zend_executor_globals里虽然都代表HashTable，<br>但一个是真正的HashTable，而另一个是一个指针。<br>当我们在对HashTable进行操作的时候，往往是把它的地址传递给一些函数。<br>所以，如果我们要对EG(symbol_table)的结果进行操作，往往需要对它进行求址操作然后用它的地址作为被调用函数的参数。</p><p>下面我们用一段例子来解释下上面说的理论：<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>上面是一段PHP语言的例子，我们创建了一个变量，并把它的值设置为’bar’，在以后的代码中我们便可以使用$foo变量。相同的功能我们怎样在内核中实现呢？我们可以先构思一下步骤：</p><ul><li>创建一个zval结构，并设置其类型。</li><li>设置值为’bar’。</li><li>将其加入当前作用域的符号表，只有这样用户才能在PHP里使用这个变量。</li><li>具体的代码为：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    zval *fooval;</span><br><span class="line"></span><br><span class="line">    MAKE_STD_ZVAL(fooval);</span><br><span class="line">    ZVAL_STRING(fooval, <span class="string">"bar"</span>, <span class="number">1</span>);</span><br><span class="line">    ZEND_SET_SYMBOL( EG(active_symbol_table) ,  <span class="string">"foo"</span> , fooval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们声明一个zval指针，并申请一块内存。然后通过ZVAL_STRING宏将值设置为‘bar’,最后一行的作用就是将这个zval加入到当前的符号表里去，并将其label定义成foo，这样用户就可以在代码里通过$foo来使用它了。</p><h1 id="2-5-变量的检索"><a href="#2-5-变量的检索" class="headerlink" title="2.5 变量的检索"></a>2.5 变量的检索</h1><p>用户在PHP语言里定义的变量，我们能否在内核中获取到呢？<br>答案当然是肯定的，下面我们就看如何通过zend_hash_find()函数来找到当前某个作用域下用户已经定义好的变量。<br>zend_hash_find()函数是内核提供的操作HashTable的API之一，如果你没有接触过，可以先记住怎么使用就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    zval **fooval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(</span><br><span class="line">    EG(active_symbol_table), <span class="comment">//这个参数是地址，如果我们操作全局作用域，则需要&amp;EG(symbol_table)</span></span><br><span class="line">    <span class="string">"foo"</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="string">"foo"</span>),</span><br><span class="line">    (<span class="keyword">void</span>**)&amp;fooval</span><br><span class="line">    ) == SUCCESS</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"成功发现$foo!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        php_printf(<span class="string">"当前作用域下无法发现$foo."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们定义了一个指向指针的指针，然后通过zend_hash_find去EG(active_symbol_table)作用域下寻找名称为foo($foo)的变量，<br>如果成功找到，此函数将返回SUCCESS。看完代码，你肯定有很多疑问。<br>为什么还要进行<code>sizeof(&quot;foo&quot;)</code>运算，fooval明明是<code>zval**</code>型的，为什么转成<code>void**</code>的？<br>而且为什么还要进行&amp;fooval运算，fooval本身不就已经是指向指针的指针了吗？:-)，<br>该回答的问题确实很多，不要过于担心，让我们带着这些问题继续往下走。</p><p>首先要说明的是，内核定义HashTable这个结构，并不是单单用来储存PHP语言里的变量的，<br>其它很多地方都在应用HashTable<strong>(这就是个神器)</strong>。<br>一个HashTable有很多元素，在内核里叫做bucket。然而每个bucket的大小是固定的，<br>所以如果我们想在bucket里存储任意数据时，最好的办法便是申请一块内存保存数据，<br>然后在bucket里保存它的指针。以<code>zval *foo</code>为例，<br>内核会先申请一块足够保存指针内存来保存foo，比如这块内存的地址是p，也就是p=&amp;foo，<br>并在bucket里保存p，这时我们便明白了，p其实就是<code>zval**</code>类型的。<br>至于bucket为什么保存<code>zval**</code>类型的指针，而不是直接保存<code>zval*</code>类型的指针，我们到下一章在详细叙述。</p><p>所以当我们去HashTable里寻找变量的时候，得到的值其实是一个zval的指针。<br>In order to populate that pointer into a calling function’s local storage,<br>the calling function will naturally dereference the local pointer,<br>resulting in a variable of indeterminate type with two levels of indirection (such as <code>void**</code>).<br>Knowing that your “indeterminate type” in this case is <code>zval*</code>,<br>you can see where the type being passed into zend_hash_find() will look different to the compiler,<br>having three levels of indirection rather than two.<br>This is done on purpose here so a simple typecast is added to the function call to silence compiler warnings.</p><p>如果zend_hash_find()函数找到了我们需要的数据，它将返回SUCCESS常量，<br>并把它的地址赋给我们在调用zend_hash_find()函数传递的fooval参数，<br>也就是说此时fooval就指向了我们要找的数据。如果没有找到，那它不会对我们fooval参数做任何修改，并返回FAILURE常量。</p><p>就去符号表里找变量而言，SUCCESS和FAILURE仅代表这个变量是否存在而已。</p><h1 id="2-6-类型转换"><a href="#2-6-类型转换" class="headerlink" title="2.6 类型转换"></a>2.6 类型转换</h1><p>现在我们已经可以从符号表中获取用户在PHP语言里定义的变量了，是该做点其它事的时候了，举个例子，比如给它来个类型转换:-)。想想C语言中的类型转换细则，你的头是不是已经大了？但是变量的类型转换就是如此重要，如果没有，那我们的代码就会是下面这样了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_zval</span><span class="params">(zval *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_P(value)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">            <span class="comment">/* 如果是NULL，则不输出任何东西 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> IS_BOOL:</span><br><span class="line">            <span class="comment">/* 如果是bool类型，并且true，则输出1，否则什么也不干 */</span></span><br><span class="line">            <span class="keyword">if</span> (Z_BVAL_P(value)) &#123;</span><br><span class="line">                php_printf(<span class="string">"1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">        <span class="comment">/* 如果是long整型，则输出数字形式 */</span></span><br><span class="line">            php_printf(<span class="string">"%ld"</span>, Z_LVAL_P(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">        <span class="comment">/* 如果是double型，则输出浮点数 */</span></span><br><span class="line">            php_printf(<span class="string">"%f"</span>, Z_DVAL_P(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">        <span class="comment">/* 如果是string型，则二进制安全的输出这个字符串 */</span></span><br><span class="line">            PHPWRITE(Z_STRVAL_P(value), Z_STRLEN_P(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">        <span class="comment">/* 如果是资源，则输出Resource #10 格式的东东 */</span></span><br><span class="line">            php_printf(<span class="string">"Resource #%ld"</span>, Z_RESVAL_P(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">        <span class="comment">/* 如果是Array，则输出Array5个字母！ */</span></span><br><span class="line">            php_printf(<span class="string">"Array"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            php_printf(<span class="string">"Object"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* Should never happen in practice,</span></span><br><span class="line"><span class="comment">             * but it's dangerous to make assumptions</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             php_printf(<span class="string">"Unknown"</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完上面的代码，你是不是有点似曾相识的感觉？o(∩∩)o…哈哈，和直接&lt;?php echo $foo;?&gt;这个简单到极点的php语句来比，上面的实现算是天书了。当然，真正的环境并没有这么囧，内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将任意类型的zval转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_zval_to_string</span><span class="params">(zval *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    convert_to_string(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其它基本的类型转换函数</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_long</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_double</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_null</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_boolean</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_array</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_object</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"></span><br><span class="line">ZEND_API <span class="keyword">void</span> _convert_to_string(zval *op ZEND_FILE_LINE_DC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> convert_to_string(op) <span class="meta-keyword">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC); &#125;</span></span><br></pre></td></tr></table></figure><p></p><p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。</p><p>好了，我们用php的echo的时候会先把变量转换成字符串，但是我们看见convert_to_string的参数是zval*的，你是不是开始担心在进行数据转换时破坏了原来数据的值？而我们<code>&lt;?php $a=intval($b);</code>并不会破坏$b的值。把原来的值破坏掉的做法绝对不是一个好主意，内核中在echo一个变量的时候也不是这样做的。在下一章，我们将知道怎样便可以在不损坏原变量值的情况下，进行convert_to_类操作。</p><h1 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h1><p>在这一章我们了解了php变量在内核中是如何实现的，我们已经可以识别出一个变量的类型，把它加到符号表去或者从符号表中找出等等等等。在下一章我们的目光开始转向内存，顺道研究下怎样复制已经存在的zval，以及如何在它们没用的时候及时的清理掉，还有最重要的，怎么不使用copy，而使用引用！</p><p>我们已经了解到zend引擎中针对一个请求的内存管理层，了解了常驻内存与非常驻内存的概念与区别。在读完下一章后，我们便有了比较完整的理论基础来在我们自己的扩展中灵活的操作各个变量。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_ext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1 PHP的生命周期</title>
      <link href="/posts/14e1a885.html"/>
      <url>/posts/14e1a885.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-PHP的生命周期"><a href="#1-PHP的生命周期" class="headerlink" title="1 PHP的生命周期"></a>1 PHP的生命周期</h1><p>在平常的Web环境中，我们并不需要单独启动PHP，它一般都会作为一个模块自动加载到web-server里面去，如apache加载的php5.so。<br>只要我们启动了web-server，被一起加载的php便会和服务器一起解析被请求的php脚本。</p><p>当然，这不是绝对的，当我们以fastcgi模式运行php的时候，往往需要手工通过<br>命令来启动php后端服务。</p><h1 id="1-1-让我们从SAPI开始"><a href="#1-1-让我们从SAPI开始" class="headerlink" title="1.1 让我们从SAPI开始"></a>1.1 让我们从SAPI开始</h1><p>我们平时接触的最多的是web模式下的php，当然你也肯定知道php还有个CLI模式。<br>其实无论哪种模式，PHP的工作原理都是一样的，<br>都是作为一种SAPI在运行（Server Application Programming Interface： the API used by PHP to interface with Web Servers）。当我们在终端敲入php这个命令时候，它使用的是”command line sapi”！它就像一个mini的web服务器一样来支持php完成这个请求，请求完成后再重新把控制权交给终端。</p><p>简单来说, SAPI就是PHP和外部环境的代理器。它把外部环境抽象后, 为内部的PHP提供一套固定的, 统一的接口, 使得PHP自身实现能够不受错综复杂的外部环境影响，保持一定的独立性</p><p>更多内容参看来自Laruence的博客对SAPI的介绍： <a href="http://www.laruence.com/2008/08/12/180.html" target="_blank" rel="noopener">深入理解Zend SAPIs</a></p><h1 id="1-2-PHP的启动与终止"><a href="#1-2-PHP的启动与终止" class="headerlink" title="1.2 PHP的启动与终止"></a>1.2 PHP的启动与终止</h1><p>PHP程序的启动可以看作有两个概念上的启动，终止也有两个概念上的终止。<br>其中一个是PHP作为Apache(拿它举例，板砖勿扔)的一个模块的启动与终止，<br>这次启动php会初始化一些必要数据，比如与宿主Apache有关的，<strong>并且这些数据是常驻内存的！</strong><br>终止与之相对。<br>还有一个概念上的启动就是当Apache分配一个页面请求过来的时候，PHP会有一次启动与终止，这也是我们最常讨论的一种。</p><p>现在我们主要来看一个PHP扩展的生命旅程是怎样走完这四个过程的。</p><p>在最初的初始化时候，就是PHP随着Apache的启动而诞生在内存里的时候，<br>它会把自己所有已加载扩展的MINIT方法(全称Module Initialization，是由每个模块自己定义的函数。)都执行一遍。<br>在这个时间里，扩展可以定义一些自己的常量、类、资源等所有会被用户端的PHP脚本用到的东西。<br>但你要记住，这里定义的东东都会随着Apache常驻内存，可以被所有请求使用，直到Apache卸载掉PHP模块！</p><p>内核中预置了PHP_MINIT_FUNCTION宏函数，来帮助我们实现这个功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抛弃作者那个例子，书才看两页整那样的例子太复杂了!</span></span><br><span class="line"><span class="comment">//walu是我扩展的名称</span></span><br><span class="line"><span class="keyword">int</span> time_of_minit;<span class="comment">//在MINIT()中初始化，在每次页面请求中输出，看看是否变化</span></span><br><span class="line">PHP_MINIT_FUNCTION(walu)</span><br><span class="line">&#123;</span><br><span class="line">time_of_minit=time(<span class="literal">NULL</span>);<span class="comment">//我们在MINIT启动中对他初始化</span></span><br><span class="line"><span class="keyword">return</span> SUCCESS;<span class="comment">//返回SUCCESS代表正常，返回FALIURE就不会加载这个扩展了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个页面请求到来时候，PHP会迅速的开辟一个新的环境，并重新扫描自己的各个扩展，<br>遍历执行它们各自的RINIT方法(俗称Request Initialization)，<br>这时候一个扩展可能会初始化在本次请求中会使用到的变量等，<br>还会初始化等会儿用户端（即PHP脚本）中的变量之类的，内核预置了PHP_RINIT_FUNCTION()这个宏函数来帮我们实现这个功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> time_of_rinit;<span class="comment">//在RINIT里初始化，看看每次页面请求的时候是否变化。</span></span><br><span class="line">PHP_RINIT_FUNCTION(walu)</span><br><span class="line">&#123;</span><br><span class="line">time_of_rinit=time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在这个页面请求执行的差不多了，可能是顺利的走到了自己文件的最后，<br>也可能是出师未捷，半道被用户给die或者exit了，<br>这时候PHP便会启动回收程序，收拾这个请求留下的烂摊子。<br>它这次会执行所有已加载扩展的RSHUTDOWN（俗称Request Shutdown）方法，<br>这时候扩展可以抓紧利用内核中的变量表之类的做一些事情，<br>因为一旦PHP把所有扩展的RSHUTDOWN方法执行完，<br>便会释放掉这次请求使用过的所有东西，<br>包括变量表的所有变量、所有在这次请求中申请的内存等等。</p><p>内核预置了PHP_RSHUTDOWN_FUNCTION宏函数来帮助我们实现这个功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP_RSHUTDOWN_FUNCTION(walu)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp=fopen(<span class="string">"time_rshutdown.txt"</span>,<span class="string">"a+"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">"%ld\n"</span>,time(<span class="literal">NULL</span>));<span class="comment">//让我们看看是不是每次请求结束都会在这个文件里追加数据</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面该启动的也启动了，该结束的也结束了，现在该Apache老人家歇歇的时候，当Apache通知PHP自己要Stop的时候，PHP便进入MSHUTDOWN（俗称Module Shutdown）阶段。这时候PHP便会给所有扩展下最后通牒，如果哪个扩展还有未了的心愿，就放在自己MSHUTDOWN方法里，这可是最后的机会了，一旦PHP把扩展的MSHUTDOWN执行完，便会进入自毁程序，这里一定要把自己擅自申请的内存给释放掉，否则就杯具了。</p><p>内核中预置了PHP_MSHUTDOWN_FUNCTION宏函数来帮助我们实现这个功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PHP_MSHUTDOWN_FUNCTION(walu)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp=fopen(<span class="string">"time_mshutdown.txt"</span>,<span class="string">"a+"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">"%ld\n"</span>,time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这四个宏都是在walu.c里完成最终实现的，而他们的则是在/main/php.h里被定义的(其实也是调用的别的宏，本节最后我把这几个宏给展开了，供有需要的人查看)。</p><p><strong>好了，现在我们本节内容说完了，下面我们把所有的代码合在一起，并预测一下应该出现的结果：</strong><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些代码都在walu.c里面，不在.h里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> time_of_minit;<span class="comment">//在MINIT中初始化，在每次页面请求中输出，看看是否变化</span></span><br><span class="line">PHP_MINIT_FUNCTION(walu)</span><br><span class="line">&#123;</span><br><span class="line">time_of_minit=time(<span class="literal">NULL</span>);<span class="comment">//我们在MINIT启动中对他初始化</span></span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> time_of_rinit;<span class="comment">//在RINIT里初始化，看看每次页面请求的时候是否变化。</span></span><br><span class="line">PHP_RINIT_FUNCTION(walu)</span><br><span class="line">&#123;</span><br><span class="line">time_of_rinit=time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_RSHUTDOWN_FUNCTION(walu)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp=fopen(<span class="string">"/cnan/www/erzha/time_rshutdown.txt"</span>,<span class="string">"a+"</span>);<span class="comment">//请确保文件可写，否则apache会莫名崩溃</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>,time(<span class="literal">NULL</span>));<span class="comment">//让我们看看是不是每次请求结束都会在这个文件里追加数据</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(walu)</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp=fopen(<span class="string">"/cnan/www/erzha/time_mshutdown.txt"</span>,<span class="string">"a+"</span>);<span class="comment">//请确保文件可写，否则apache会莫名崩溃</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">"%d\n"</span>,time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们在页面里输出time_of_minit和time_of_rinit的值</span></span><br><span class="line">PHP_FUNCTION(walu_test)</span><br><span class="line">&#123;</span><br><span class="line">php_printf(<span class="string">"%d&amp;lt;br /&amp;gt;"</span>,time_of_minit);</span><br><span class="line">php_printf(<span class="string">"%d&amp;lt;br /&amp;gt;"</span>,time_of_rinit);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>time_of_minit的值每次请求都不变。</li><li>time_of_rinit的值每次请求都改变。</li><li>每次页面请求结束都会往time_rshutdown.txt中写入数据。</li><li>只有在apache结束后time_mshutdown.txt才写入有数据。</li></ul><blockquote><p>多谢 <a href="http://weibo.com/showz" target="_blank" rel="noopener">闸北陆小洪</a> 指出的有关time_of_rinit的笔误。</p></blockquote><p>上面便是PHP中典型的启动-终止模型，实际情况可能因为模式不同而有所变化，<br>到底PHP的启动-终止会有多少种不同变化方式，请看下一节。</p><h1 id="1-3-PHP的生命周期"><a href="#1-3-PHP的生命周期" class="headerlink" title="1.3 PHP的生命周期"></a>1.3 PHP的生命周期</h1><p>一个PHP实例，无论通过http请求调用的，还是从命令行启动的，都会向我们上一节说的那样，<br>依次进行Module init、Request init、Request Shutdown、Module shutdown四个过程，<br>当然之间还会执行脚本自己的逻辑。<br>那么两种init和两种shutdown各会执行多少次、各自的执行频率有多少呢？<br>这取决于PHP是用什么sapi与宿主通信的。最常见的四种方式如下所列：</p><ul><li>直接以CLI/CGI模式调用</li><li>多进程模式</li><li>多线程模式</li><li>Embedded(嵌入式，在自己的C程序中调用Zend Engine)</li></ul><h2 id="1、CLI-CGI"><a href="#1、CLI-CGI" class="headerlink" title="1、CLI/CGI"></a>1、CLI/CGI</h2><p>CLI和CGI的SAPI是相当特殊的，因为这时PHP的生命周期完全在一个单独的请求中完成。虽然简单，不过我们以前提过的两种init和两种shutdown仍然都会被执行。图1.1展示了PHP在这种模式下是怎么工作的。</p><p style="text-align:center"><img src="http://www.walu.cc/phpbook/image/01fig01.jpg"></p><h2 id="2、多进程模式"><a href="#2、多进程模式" class="headerlink" title="2、多进程模式"></a>2、多进程模式</h2><p><strong>[ps:书是2006年出版的，所以你应该理解作者说多进程是主流]</strong><br>PHP最常见的工作方式便是编译成为Apache2 的Pre-fork MPM或者Apache1 的APXS 模式，其它web服务器也大多用相同的方式工作，在本书后面，把这种方式统一叫做多进程方式。<br>给它起这个名字是有原因的，不是随便拍拍屁股拍拍脑袋定下来的。<br>当Apache启动的时候，会立即把自己fork出好几个子进程，每一个进程都有自己独立的内存空间，<br>也就代表了有自己独立的变量、函数等。在每个进程里的PHP的工作方式如下图所示：</p><p style="text-align:center"><img src="http://www.walu.cc/phpbook/image/01fig02.jpg"></p><p>因为是fork出来的，所以各个进程间的数据是彼此独立，不会受到外界的干扰<strong>(ps：fork后可以用管道等方式实现进程间通信)</strong>。<br>这是一片独立天地，它允许每个子进程做任何事情，玩七十码、躲猫猫都没人管，办公室拿砍刀玩自杀也没事，<br>下图展示了从apache的视角来看多进程工作模式下的PHP：</p><p style="text-align:center"><img src="http://www.walu.cc/phpbook/image/01fig03.jpg"></p><h2 id="3、多线程模式"><a href="#3、多线程模式" class="headerlink" title="3、多线程模式"></a>3、多线程模式</h2><p>随着时代的进步，PHP越来越多的在多线程模式下工作，就像IIS的isapi和Apache MPM worker<strong>(支持混合的多线程多进程的多路处理模块)</strong>。<br>在这种模式下，只有一个服务器进程在运行着，但会同时运行很多线程，这样可以减少一些资源开销，<br>像Module init和Module shutdown就只需要运行一次就行了，一些全局变量也只需要初始化一次，<br>因为线程独具的特质，使得各个请求之间方便的共享一些数据成为可能。</p><blockquote><p>其实多线程与MINIT、MSHUTDOWN只执行一次并没有什么联系，多进程模式下一样可以实现。</p></blockquote><p>下图展示了在这种模式下PHP的工作流程：</p><p style="text-align:center"><img src="http://www.walu.cc/phpbook/image/01fig04.jpg"></p><h2 id="4、Embed"><a href="#4、Embed" class="headerlink" title="4、Embed"></a>4、Embed</h2><p>Embed SAPI是一种比较特殊的sapi，容许你在C/C++语言中调用PHP/ZE提供的函数。<br>并且这种sapi和上面的三种一样，按Module Init、Request Init、Rshutdown、mshutdown的流程执行着。<br>当然，这只是其中一种情况。因为特定的应用有自己特殊的需求，只是在处理PHP脚本这个环节基本一致。</p><p>真正令emebed模式独特的是因为它可能随时嵌入到某个程序里面去(<strong>比如你的test.exe里</strong>)，<br>然后被当作脚本的一部分在一个请求的时候执行。<br>控制权在PHP和原程序间来回传递。关于嵌入式的PHP在第20章会有应用，到时我们再用实例介绍这个不经常使用的sapi。</p><h2 id="关于Embed-SAPI应用的文章"><a href="#关于Embed-SAPI应用的文章" class="headerlink" title="关于Embed SAPI应用的文章"></a>关于Embed SAPI应用的文章</h2><ul><li><a href="http://www.laruence.com/2008/09/23/539.html" target="_blank" rel="noopener">Laruence大哥的使用PHP Embed SAPI实现Opcodes查看器</a></li></ul><h1 id="1-4-线程安全"><a href="#1-4-线程安全" class="headerlink" title="1.4 线程安全"></a>1.4 线程安全</h1><p>在PHP初期，是作为单进程的CGI来运行的，所以并没有考虑线程安全问题。<br>我们可以随意的在全局作用域中设置变量并在程序中对他进行修改、访问，内核申请的资源如果没有正确的释放，<br>也会在CGI进程结束后自动地被清理干净。</p><p>后来，php被作为apache多进程模式下的一个模块运行，但是这仍然把php局限在一个进程里，<br>我们设置的全局变量，只要在每个请求之前将其正确的初始化，并在每个请求之后正确的清理干净，<br>便不会带来什么麻烦。由于对于一个进程来说，同一个时间只能处理一个请求，<br>所以这是内核中加入了针对每个请求的内存管理功能，来防止服务器资源利用出现错误。</p><p>随着使用在多线程模式的软件系统越来越多，php内核中亟需一种新的资源管理方式，<br>并最终在php内核中形成了一个新的抽象层：TSRM(Thread Safe Resource Management)。</p><h2 id="线程安全与非线程安全"><a href="#线程安全与非线程安全" class="headerlink" title="线程安全与非线程安全"></a>线程安全与非线程安全</h2><p>在一个没有线程的程序中，我们往往倾向于把全局变量声明在源文件的顶部，<br>编译器会自动的为它分配资源供我们在声明语句之下的程序逻辑中使用。</p><p><strong>（即使通过fork()出一个子进程，它也会重新申请一段内存，父子进程中的变量从此没有了任何联系）</strong></p><p>但是在一个多线程的程序中，如果我们需要每个线程都拥有自己独立的资源的话，<br>便需要为每个线程独立开辟出一个区域来存放它们各自的资源，<br>在使用资源的时候，每个线程便会只在自己的那一亩三分地里找，而不会拔了别人的庄稼。</p><h2 id="Thread-Safe-Data-Pools-线程安全的资源池？"><a href="#Thread-Safe-Data-Pools-线程安全的资源池？" class="headerlink" title="Thread-Safe Data Pools(线程安全的资源池？)"></a>Thread-Safe Data Pools(线程安全的资源池？)</h2><p>在扩展的Module Init里，扩展可以调用ts_allocate_id()来告诉TRSM自己需要多少资源。<br>TRSM接收后更新系统使用的资源，并得到一个指向刚分配的那份资源的id。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> sampleint;</span><br><span class="line"><span class="keyword">char</span> *samplestring;</span><br><span class="line">&#125; php_sample_globals;</span><br><span class="line"><span class="keyword">int</span> sample_globals_id;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(sample)</span><br><span class="line">&#123;</span><br><span class="line">    ts_allocate_id(&amp;sample_globals_id,</span><br><span class="line">        <span class="keyword">sizeof</span>(php_sample_globals),</span><br><span class="line">        (ts_allocate_ctor) php_sample_globals_ctor,</span><br><span class="line">        (ts_allocate_dtor) php_sample_globals_dtor);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个请求需要访问数据段的时候，扩展从TSRM层请求当前线程的资源池，<br>以ts_allocate_id()返回的资源ID来获取偏移量。<br>换句话说，在代码流中，你可能会在前面所说的MINIT语句中碰到SAMPLE_G(sampleint) = 5;<br>这样的语句。在线程安全的构建下，这个语句通过一些宏扩展如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((php_sample_globals*)(*((<span class="keyword">void</span> ***)tsrm_ls))[sample_globals_id<span class="number">-1</span>])-&gt;sampleint = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>如果你看不懂上面的转换也不用沮丧，它已经很好的封装在PHPAPI中了，以至于许多开发者都不需要知道它怎样工作的。</p><h2 id="当不在线程环境时"><a href="#当不在线程环境时" class="headerlink" title="当不在线程环境时"></a>当不在线程环境时</h2><p>因为在PHP的线程安全构建中访问全局资源涉及到在线程数据池查找对应的偏移量，这是一些额外的负载，结果就是它比对应的非线程方式（直接从编译期已经计算好的真实的全局变量地址中取出数据）慢一些。<br>考虑上面的例子，这一次在非线程构建下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sampleint;</span><br><span class="line">    <span class="keyword">char</span> *samplestring;</span><br><span class="line">&#125; php_sample_globals;</span><br><span class="line">php_sample_globals sample_globals;</span><br><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(sample)</span><br><span class="line">&#123;</span><br><span class="line">    php_sample_globals_ctor(&amp;sample_globals TSRMLS_CC);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先注意到的是这里并没有定义一个int型的标识去引用全局的结构定义，<br>只是简单的在进程的全局空间定义了一个结构体。<br>也就是说SAMPLE_G(sampleint) = 5;展开后就是sample_globals.sampleint = 5; 简单，快速，高效。<br>非线程构建还有进程隔离的优势，这样给定的请求碰到完全出乎意料的情况时，它也不会影响其他进程，<br>即便是产生段错误也不会导致整个webserver瘫痪。<br>实际上，Apache的MaxRequestsPerChild指令就是设计用来提升这个特性的，<br>它经常性的有目的性的kill掉子进程并产生新的子进程，来避免某些可能由于进程长时间运行“累积”而来的问题（比如内存泄露）。</p><h2 id="访问全局变量"><a href="#访问全局变量" class="headerlink" title="访问全局变量"></a>访问全局变量</h2><p>在创建一个扩展时，你并不知道它最终的运行环境是否是线程安全的。幸运的是，你要使用的标准包含文件集合中已经包含了条件定义的ZTS预处理标记。当PHP因为SAPI需要或通过enable-maintainer-zts选项安装等原因以线程安全方式构建时，这个值会被自动的定义，并可以用一组#ifdef ZTS这样的指令集去测试它的值。<br>就像你前面看到的，只有在PHP以线程安全方式编译时，才会存在线程安全池，只有线程安全池存在时，才会真的在线程安全池中分配空间。这就是为什么前面的例子包裹在ZTS检查中的原因，非线程方式供非线程构建使用。<br>在本章前面PHP_MINIT_FUNCTION(myextension)的例子中，你可以看到#ifdef ZTS被用作条件调用正确的全局初始代码。对于ZTS模式它使用ts_allocate_id()弹出myextension_globals_id变量，而非ZTS模式只是直接调用myextension_globals的初始化方法。这两个变量已经在你的扩展源文件中使用Zend宏：DECLARE_MODULE_GLOBALS(myextension)声明，它将自动的处理对ZTS的测试并依赖构建的ZTS模式选择正确的方式声明。<br>在访问这些全局变量的时候，你需要使用前面给出的自定义宏SAMPLE_G()。在第12章，你将学习到怎样设计这个宏以使它可以依赖ZTS模式自动展开。</p><h2 id="即便你不需要线程也要考虑线程"><a href="#即便你不需要线程也要考虑线程" class="headerlink" title="即便你不需要线程也要考虑线程"></a>即便你不需要线程也要考虑线程</h2><p>正常的PHP构建默认是关闭线程安全的，只有在被构建的sapi明确需要线程安全或线程安全在./configure阶段显式的打开时，才会以线程安全方式构建。<br>给出了全局查找的速度问题和进程隔离的缺点后，你可能会疑惑为什么明明不需要还有人故意打开它呢？这是因为，多数情况下，扩展和SAPI的开发者认为你是线程安全开关的操作者，这样做可以很大程度上确保新代码可以在所有环境中正常运行。<br>当线程安全启用时，一个名为tsrm_ls的特殊指针被增加到了很多的内部函数原型中。这个指针允许PHP区分不同线程的数据。回想一下本章前面ZTS模式下的SAMPLE_G()宏函数中就使用了它。没有它，正在执行的函数就不知道查找和设置哪个线程的符号表；不知道应该执行哪个脚本，引擎也完全无法跟踪它的内部寄存器。这个指针保留了线程处理的所有页面请求。<br>这个可选的指针参数通过下面一组定义包含到原型中。当ZTS禁用时，这些定义都被展开为空；当ZTS开启时，它们展开如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSRMLS_D     void ***tsrm_ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSRMLS_DC     , void ***tsrm_ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSRMLS_C     tsrm_ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSRMLS_CC     , tsrm_ls</span></span><br></pre></td></tr></table></figure><p></p><p>非ZTS构建对下面的代码看到的是两个参数：int, char <em>。在ZTS构建下，原型则包含三个参数：int, char </em>, void ***。当你的程序调用这个函数时，只有在ZTS启用时才需要传递第三个参数。下面代码的第二行展示了宏的展开：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_myext_action</span><span class="params">(<span class="keyword">int</span> action_id, <span class="keyword">char</span> *message TSRMLS_DC)</span></span>;</span><br><span class="line">php_myext_action(<span class="number">42</span>, <span class="string">"The meaning of life"</span> TSRMLS_CC);</span><br></pre></td></tr></table></figure><p></p><p>通过在函数调用中包含这个特殊的变量，php_myext_action就可以使用tsrm_ls的值和MYEXT_G()宏函数一起访问它的线程特有全局数据。在非ZTS构建上，tsrm_ls将不可用，但是这是ok的，因为此时MYEXT_G()宏函数以及其他类似的宏都不会使用它。<br>现在考虑，你在一个新的扩展上工作，并且有下面的函数，它可以在你本地使用CLI SAPI的构建上正常工作，并且即便使用apache 1的apxs SAPI编译也可以正常工作：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">php_myext_isset</span><span class="params">(<span class="keyword">char</span> *varname, <span class="keyword">int</span> varname_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zval **dummy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_find(EG(active_symbol_table),</span><br><span class="line">        varname, varname_len + <span class="number">1</span>,</span><br><span class="line">        (<span class="keyword">void</span>**)&amp;dummy) == SUCCESS) &#123;</span><br><span class="line">        <span class="comment">/* Variable exists */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Undefined variable */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所有的一切看起来都工作正常，你打包这个扩展发送给他人构建并运行在生产服务器上。让你气馁的是，对方报告扩展编译失败。<br>事实上它们使用了Apache 2.0的线程模式，因此它们的php构建启用了ZTS。当编译期碰到你使用的EG()宏函数时，它尝试在本地空间查找tsrm_ls没有找到，因为你并没有定义它并且没有在你的函数中传递。<br>修复这个问题非常简单；只需要在php_myext_isset()的定义上增加TSRMLS_DC，并在每行调用它的地方增加TSRMLS_CC。不幸的是，现在对方已经有点不信任你的扩展质量了，这样就会推迟你的演示周期。这种问题越早解决越好。<br>现在有了enable-maintainer-zts指令。通过在./configure时增加该指令来构建php，你的构建将自动的包含ZTS，哪怕你当前的SAPI（比如CLI）不需要它。打开这个开关，你可以避免这些常见的不应该出现的错误。<br>注意：在PHP4中，enable-maintainer-zts标记等价的名字是enable-experimental-zts；请确认使用你的php版本对应的正确标记。</p><h2 id="寻回丢失的tsrm-ls"><a href="#寻回丢失的tsrm-ls" class="headerlink" title="寻回丢失的tsrm_ls"></a>寻回丢失的tsrm_ls</h2><p>有时，我们需要在一个函数中使用tsrm_ls指针，但却不能传递它。通常这是因为你的扩展作为某个使用回调的库的接口，它并没有提供返回抽象指针的地方。考虑下面的代码片段：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_myext_event_callback</span><span class="params">(<span class="keyword">int</span> eventtype, <span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zval *event;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $event = array('event'=&gt;$eventtype,</span></span><br><span class="line"><span class="comment">                    'message'=&gt;$message) */</span></span><br><span class="line">    MAKE_STD_ZVAL(event);</span><br><span class="line">    array_init(event);</span><br><span class="line">    add_assoc_long(event, <span class="string">"type"</span>, eventtype);</span><br><span class="line">    add_assoc_string(event, <span class="string">"message"</span>, message, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $eventlog[] = $event; */</span></span><br><span class="line">    add_next_index_zval(EXT_G(eventlog), event);</span><br><span class="line">&#125;</span><br><span class="line">PHP_FUNCTION(myext_startloop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The eventlib_loopme() function,</span></span><br><span class="line"><span class="comment">     * exported by an external library,</span></span><br><span class="line"><span class="comment">     * waits for an event to happen,</span></span><br><span class="line"><span class="comment">     * then dispatches it to the</span></span><br><span class="line"><span class="comment">     * callback handler specified.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    eventlib_loopme(php_myext_event_callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>虽然你可能不完全理解这段代码，但你应该注意到了回调函数中使用了EXT_G()宏函数，我们知道在线程安全构建下它需要tsrm_ls指针。修改函数原型并不好也不应该这样做，因为外部的库并不知道php的线程安全模型。那这种情况下怎样让tsrm_ls可用呢？<br>解决方案是前面提到的名为TSRMLS_FETCH()的Zend宏函数。将它放到代码片段的顶部，这个宏将执行给予当前线程上下文的查找，并定义本地的tsrm_ls指针拷贝。<br>这个宏可以在任何地方使用并且不用通过函数调用传递tsrm_ls，尽管这看起来很诱人，但是，要注意到这一点：TSRMLS_FETCH调用需要一定的处理时间。这在单次迭代中并不明显，但是随着你的线程数增多，随着你调用TSRMLS_FETCH()的点的增多，你的扩展就会显现出这个瓶颈。因此，请谨慎的使用它。<br>注意：为了和c++编译器兼容，请确保将TSRMLS_FETCH()和所有变量定义放在给定块作用域的顶部（任何其他语句之前）。因为TSRMLS_FETCH()宏自身有多种不同的解析方式，因此最好将它作为变量定义的最后一行。</p><h1 id="1-5-PHP的生命周期"><a href="#1-5-PHP的生命周期" class="headerlink" title="1.5 PHP的生命周期"></a>1.5 PHP的生命周期</h1><p>这一章讲述了一些后续章节需要的基础概念，是你编写优质的PHP扩展的基础。</p>]]></content>
      
      
      <categories>
          
          <category> php_ext </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> php_ext </tag>
            
            <tag> php拓展开发 </tag>
            
            <tag> php生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>90-新垃圾回收机制说明</title>
      <link href="/posts/34204464.html"/>
      <url>/posts/34204464.html</url>
      
        <content type="html"><![CDATA[<h1 id="90-新垃圾回收机制说明"><a href="#90-新垃圾回收机制说明" class="headerlink" title="90-新垃圾回收机制说明"></a>90-新垃圾回收机制说明</h1><p>在5.2及更早版本的PHP中，没有专门的垃圾回收器GC（Garbage Collection），引擎在判断一个变量空间是否能够被释放的时候是依据这个变量的zval的refcount的值，如果refcount为0，那么变量的空间可以被释放，否则就不释放，这是一种非常简单的GC实现。然而在这种简单的GC实现方案中，出现了意想不到的变量内存泄漏情况（Bug:<a href="http://bugs.php.net/bug.php?id=33595），引擎将无法回收这些内存，于是在PHP5.3中出现了新的GC，新的GC有专门的机制负责清理垃圾数据，防止内存泄漏。本文将详细的阐述PHP5.3中新的GC运行机制。" target="_blank" rel="noopener">http://bugs.php.net/bug.php?id=33595），引擎将无法回收这些内存，于是在PHP5.3中出现了新的GC，新的GC有专门的机制负责清理垃圾数据，防止内存泄漏。本文将详细的阐述PHP5.3中新的GC运行机制。</a></p><p>目前很少有详细的资料介绍新的GC，本文将是目前国内最为详细的从源码角度介绍PHP5.3中GC原理的文章。其中关于垃圾产生以及算法简介部分由笔者根据手册翻译而来，当然其中融入了本人的一些看法。手册中相关内容：Garbage Collection</p><h2 id="什么算垃圾"><a href="#什么算垃圾" class="headerlink" title="什么算垃圾"></a>什么算垃圾</h2><p>首先我们需要定义一下“垃圾”的概念，新的GC负责清理的垃圾是指变量的容器zval还存在，但是又没有任何变量名指向此zval。因此GC判断是否为垃圾的一个重要标准是有没有变量名指向变量容器zval。</p><p>假设我们有一段PHP代码，使用了一个临时变量\$tmp存储了一个字符串，在处理完字符串之后，就不需要这个\$tmp变量了，\$tmp变量对于我们来说可以算是一个“垃圾”了，但是对于GC来说，\$tmp其实并不是一个垃圾，\$tmp变量对我们没有意义，但是这个变量实际还存在，\$tmp符号依然指向它所对应的zval，GC会认为PHP代码中可能还会使用到此变量，所以不会将其定义为垃圾。</p><p>那么如果我们在PHP代码中使用完\$tmp后，调用unset删除这个变量，那么\$tmp是不是就成为一个垃圾了呢。很可惜，GC仍然不认为\$tmp是一个垃圾，因为\$tmp在unset之后，refcount减少1变成了0(这里假设没有别的变量和\$tmp指向相同的zval),这个时候GC会直接将\$tmp对应的zval的内存空间释放，\$tmp和其对应的zval就根本不存在了。此时的\$tmp也不是新的GC所要对付的那种“垃圾”。那么新的GC究竟要对付什么样的垃圾呢，下面我们将生产一个这样的垃圾。</p><h2 id="顽固垃圾的产生过程"><a href="#顽固垃圾的产生过程" class="headerlink" title="顽固垃圾的产生过程"></a>顽固垃圾的产生过程</h2><p>如果读者已经阅读了变量内部存储相关的内容，想必对refcount和isref这些变量内部的信息有了一定的了解。这里我们将结合手册中的一个例子来介绍垃圾的产生过程：</p><pre><code>&lt;?php\$a = &quot;new string&quot;;?&gt;</code></pre><p>在这么简单的一个代码中，\$a变量内部存储信息为：a: (refcount=1, is_ref=0)=’new string’</p><p>当把\$a赋值给另外一个变量的时候，\$a对应的zval的refcount会加1。</p><pre><code>&lt;?php\$a = &quot;new string&quot;;\$b = \$a;?&gt;</code></pre><p>此时\$a和\$b变量对应的内部存储信息为 a,b: (refcount=2, is_ref=0)=’new string’</p><p>当我们用unset删除\$b变量的时候，\$b对应的zval的refcount会减少1</p><pre><code>&lt;?php\$a = &quot;new string&quot;;     //a: (refcount=1, is_ref=0)=&apos;new string&apos;\$b = \$a;               //a,b: (refcount=2, is_ref=0)=&apos;new string&apos;unset(\$b);          //a: (refcount=1, is_ref=0)=&apos;new string&apos;?&gt;</code></pre><p>对于普通的变量来说，这一切似乎很正常，但是在复合类型变量（数组和对象）中，会发生比较有意思的事情：</p><pre><code>&lt;?php\$a = array(&apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42);?&gt;</code></pre><p>a的内部存储信息为：</p><pre><code>a: (refcount=1, is_ref=0)=array (   &apos;meaning&apos; =&gt; (refcount=1, is_ref=0)=&apos;life&apos;,   &apos;number&apos; =&gt; (refcount=1, is_ref=0)=42)</code></pre><p>数组变量本身(\$a)在引擎内部实际上是一个哈希表，这张表中有两个zval项 meaning和number，所以实际上那一行代码中一共生成了3个zval,这3个zval都遵循变量的引用和计数原则，用图来表示：</p><center><br><img src="images/2012_03_13_02.gif.png" alt><br></center><p>下面在\$a中添加一个元素，并将现有的一个元素的值赋给新的元素：</p><pre><code>&lt;?php\$a = array(&apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42);\$a[&apos;life&apos;] = \$a[&apos;meaning&apos;];?&gt;</code></pre><p>那么\$a的内部存储为：</p><pre><code>a: (refcount=1, is_ref=0)=array (   &apos;meaning&apos; =&gt; (refcount=2, is_ref=0)=&apos;life&apos;,   &apos;number&apos; =&gt; (refcount=1, is_ref=0)=42,   &apos;life&apos; =&gt; (refcount=2, is_ref=0)=&apos;life&apos;)</code></pre><p>其中的meaning元素和life元素之指向同一个zval的：</p><center><br><img src="images/2012_03_13_03.gif.png" alt><br></center><p>现在，如果我们试一下，将数组的引用赋值给数组中的一个元素，有意思的事情就发生了：</p><pre><code>&lt;?php\$a = array(&apos;one&apos;);\$a[] = &amp;\$a;?&gt;</code></pre><p>这样\$a数组就有两个元素，一个索引为0，值为字符one,另外一个索引为1，为\$a自身的引用，内部存储如下：</p><pre><code>a: (refcount=2, is_ref=1)=array (   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,   1 =&gt; (refcount=2, is_ref=1)=...)</code></pre><p>“…”表示1指向a自身，是一个环形引用：</p><center><br><img src="images/2012_03_13_04.gif.png" alt><br></center><p>这个时候我们对\$a进行unset,那么\$a会从符号表中删除，同时\$a指向的zval的refcount减少1</p><pre><code>&lt;?php\$a = array(&apos;one&apos;);\$a[] = &amp;\$a;unset(\$a);?&gt;</code></pre><p>那么问题也就产生了，\$a已经不在符号表中了，用户无法再访问此变量，但是\$a之前指向的zval的refcount变为1而不是0，因此不能被回收，这样产生了内存泄露：</p><center><br><img src="images/2012_03_13_05.gif.png" alt><br></center><p>这样，这么一个zval就成为了一个真是意义的垃圾了，新的GC要做的工作就是清理这种垃圾。</p><h2 id="新的GC算法"><a href="#新的GC算法" class="headerlink" title="新的GC算法"></a>新的GC算法</h2><p>为解决这种垃圾，产生了新的GC。</p><p>在PHP5.3版本中，使用了专门GC机制清理垃圾，在之前的版本中是没有专门的GC，那么垃圾产生的时候，没有办法清理，内存就白白浪费掉了。在PHP5.3源代码中多了以下文件:{PHPSRC}/Zend/zend_gc.h {PHPSRC}/Zend/zend_gc.c, 这里就是新的GC的实现，我们先简单的介绍一下算法思路，然后再从源码的角度详细介绍引擎中如何实现这个算法的。</p><p>在较新的PHP手册中有简单的介绍新的GC使用的垃圾清理算法，这个算法名为 Concurrent Cycle Collection in Reference Counted Systems ， 这里不详细介绍此算法，根据手册中的内容来先简单的介绍一下思路：</p><p>首先我们有几个基本的准则：</p><ol><li>如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾</li><li>如果一个zval的refcount减少到0， 那么zval可以被释放掉，不属于垃圾</li><li>如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾</li></ol><p>只有在准则3下，GC才会把zval收集起来，然后通过新的算法来判断此zval是否为垃圾。那么如何判断这么一个变量是否为真正的垃圾呢？</p><p>简单的说，就是对此zval中的每个元素进行一次refcount减1操作，操作完成之后，如果zval的refcount=0，那么这个zval就是一个垃圾。这个原理咋看起来很简单，但是又不是那么容易理解，起初笔者也无法理解其含义，直到挖掘了源代码之后才算是了解。如果你现在不理解没有关系，后面会详细介绍，这里先把这算法的几个步骤描叙一下，首先引用手册中的一张图：</p><center><br><img src="images/2012_03_13_06.gif.png" alt><br></center><ul><li>A：为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断，此算法会先把所有前面准则3情况下的zval节点放入一个节点(root)缓冲区(root buffer)，并且将这些zval节点标记成紫色，同时算法必须确保每一个zval节点在缓冲区中之出现一次。当缓冲区被节点塞满的时候，GC才开始开始对缓冲区中的zval节点进行垃圾判断。</li><li>B：当缓冲区满了之后，算法以深度优先对每一个节点所包含的zval进行减1操作，为了确保不会对同一个zval的refcount重复执行减1操作，一旦zval的refcount减1之后会将zval标记成灰色。需要强调的是，这个步骤中，起初节点zval本身不做减1操作，但是如果节点zval中包含的zval又指向了节点zval（环形引用），那么这个时候需要对节点zval进行减1操作。</li><li>C：算法再次以深度优先判断每一个节点包含的zval的值，如果zval的refcount等于0，那么将其标记成白色(代表垃圾)，如果zval的refcount大于0，那么将对此zval以及其包含的zval进行refcount加1操作，这个是对非垃圾的还原操作，同时将这些zval的颜色变成黑色（zval的默认颜色属性）。</li><li>D：遍历zval节点，将C中标记成白色的节点zval释放掉。</li></ul><p>这ABCD四个过程是手册中对这个算法的介绍，这还不是那么容易理解其中的原理，这个算法到底是个什么意思呢？我自己的理解是这样的：</p><p>比如还是前面那个变成垃圾的数组\$a对应的zval,命名为zval_a, 如果没有执行unset， zval_a的refcount为2,分别由\$a和\$a中的索引1指向这个zval。 用算法对这个数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，由于索引1对应的就是zval_a，所以这个时候zval_a的refcount应该变成了1，这样zval_a就不是一个垃圾。如果执行了unset操作，zval_a的refcount就是1，由zval_a中的索引1指向zval_a,用算法对数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，这样zval_a的refcount就会变成0，于是就发现zval_a是一个垃圾了。 算法就这样发现了顽固的垃圾数据。</p><p>举了这个例子，读者大概应该能够知道其中的端倪：</p><p>对于一个包含环形引用的数组，对数组中包含的每个元素的zval进行减1操作，之后如果发现数组自身的zval的refcount变成了0，那么可以判断这个数组是一个垃圾。</p><p>这个道理其实很简单，假设数组a的refcount等于m, a中有n个元素又指向a,如果m等于n,那么算法的结果是m减n，m-n=0，那么a就是垃圾，如果m&gt;n,那么算法的结果m-n&gt;0,所以a就不是垃圾了。</p><p>m=n代表什么？ 代表a的refcount都来自数组a自身包含的zval元素,代表a之外没有任何变量指向它，代表用户代码空间中无法再访问到a所对应的zval，代表a是泄漏的内存，因此GC将a这个垃圾回收了。</p><p>在PHP中，GC默认是开启的，你可以通过ini文件中的 zend.enable_gc 项来开启或则关闭GC。当GC开启的时候，垃圾分析算法将在节点缓冲区(roots buffer)满了之后启动。缓冲区默认可以放10,000个节点，当然你也可以通过修改Zend/zend_gc.c中的GC_ROOT_BUFFER_MAX_ENTRIES 来改变这个数值，需要重新编译链接PHP。当GC关闭的时候，垃圾分析算法就不会运行，但是相关节点还会被放入节点缓冲区，这个时候如果缓冲区节点已经放满，那么新的节点就不会被记录下来，这些没有被记录下来的节点就永远也不会被垃圾分析算法分析。如果这些节点中有循环引用，那么有可能产生内存泄漏。之所以在GC关闭的时候还要记录这些节点，是因为简单的记录这些节点比在每次产生节点的时候判断GC是否开启更快，另外GC是可以在脚本运行中开启的，所以记录下这些节点，在代码运行的某个时候如果又开启了GC，这些节点就能被分析算法分析。当然垃圾分析算法是一个比较耗时的操作。</p><p>在PHP代码中我们可以通过gc_enable()和gc_disable()函数来开启和关闭GC，也可以通过调用gc_collect_cycles()在节点缓冲区未满的情况下强制执行垃圾分析算法。这样用户就可以在程序的某些部分关闭或则开启GC，也可强制进行垃圾分析算法。</p><h2 id="新的GC算法的性能"><a href="#新的GC算法的性能" class="headerlink" title="新的GC算法的性能"></a>新的GC算法的性能</h2><p>1.防止泄漏节省内存</p><p>新的GC算法的目的就是为了防止循环引用的变量引起的内存泄漏问题，在PHP中GC算法，当节点缓冲区满了之后，垃圾分析算法会启动，并且会释放掉发现的垃圾，从而回收内存，在PHP手册上给了一段代码和内存使用状况图：</p><pre><code>&lt;?phpclass Foo{    public \$var = &apos;3.1415962654&apos;;}\$baseMemory = memory_get_usage();for ( \$i = 0; \$i &lt;= 100000; \$i++ ){    \$a = new Foo;    \$a-&gt;self = \$a;    if ( \$i % 500 === 0 )    {        echo sprintf( &apos;%8d: &apos;, \$i ), memory_get_usage() - \$baseMemory, &quot;/n&quot;;    }}?&gt;</code></pre><center><br><img src="images/2012_03_13_07.gif.png" alt><br></center><p>这段代码的循环体中，新建了一个对象变量，并且用对象的一个成员指向了自己，这样就形成了一个循环引用，当进入下一次循环的时候，又一次给对象变量重新赋值，这样会导致之前的对象变量内存泄漏，在这个例子里面有两个变量泄漏了，一个是对象本身，另外一个是对象中的成员self，但是这两个变量只有对象会作为垃圾收集器的节点被放入缓冲区(因为重新赋值相当于对它进行了unset操作，满足前面的准则3)。在这里我们进行了100,000次循环，而GC在缓冲区中有10,000节点的时候会启动垃圾分析算法，所以这里一共会进行10次的垃圾分析算法。从图中可以清晰的看到，在5.3版本PHP中，每次GC的垃圾分析算法被触发后，内存会有一个明显的减少。而在5.2版本的PHP中，内存使用量会一直增加。</p><p>2.运行效率影响</p><p>启用了新的GC后，垃圾分析算法将是一个比较耗时的操作，手册中给了一段测试代码：</p><pre><code>&lt;?phpclass Foo{    public \$var = &apos;3.1415962654&apos;;}for ( \$i = 0; \$i &lt;= 1000000; \$i++ ){    \$a = new Foo;    \$a-&gt;self = \$a;}echo memory_get_peak_usage(), &quot;/n&quot;;?&gt;</code></pre><p>然后分别在GC开启和关闭的情况下执行这段代码：</p><pre><code>time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php# andtime php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php</code></pre><p>最终在该机器上，第一次执行大概使用10.7秒，第二次执行大概使用11.4秒，性能大约降低7%,不过内存的使用量降低了98%,从931M降低到了10M。当然这并不是一个比较科学的测试方法，但是也能说明一定的问题。这种代码测试的是一种极端恶劣条件，实际代码中，特别是在WEB的应用中，很难出现大量循环引用，GC的分析算法的启动不会这么频繁，小规模的代码中甚至很少有机会启动GC分析算法。</p><p>总结：</p><p>当GC的垃圾分析算法执行的时候，PHP脚本的效率会受到一定的影响，但是小规模的代码一般不会有这个机会运行这个算法。如果一旦脚本中GC分析算法开始运行了，那么将花费少量的时间节省出来了大量的内存，是一件非常划算的事情。新的GC对一些长期运行的PHP脚本效果更好，比如PHP的DAEMON守护进程，或则PHP-GTK进程等等。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>89-变量的引用与计数规则</title>
      <link href="/posts/9cc74a95.html"/>
      <url>/posts/9cc74a95.html</url>
      
        <content type="html"><![CDATA[<h1 id="89-变量的引用与计数规则"><a href="#89-变量的引用与计数规则" class="headerlink" title="89-变量的引用与计数规则"></a>89-变量的引用与计数规则</h1><h2 id="变量的内部引用和计数"><a href="#变量的内部引用和计数" class="headerlink" title="变量的内部引用和计数"></a>变量的内部引用和计数</h2><p>在引擎内部，一个PHP的变量是保存在“zval”结构中，此结构包含了变量的类型和值信息，这个在之前的文章 变量的内部存储：值和类型 中已经介绍了，此结构还有另外两个字段信息，一个是”is_ref”(此字段在5.3.2版本中是is_ref__gc)，此字段是一个布尔值，用来标识变量是否是一个引用，通过这个字段，PHP引擎能够区分一般的变量和引用变量。PHP代码中可以通过 &amp; 操作符号来建立一个引用变量，建立的引用变量内部的zval的is_ref字段就为1。zval中还有另外一个字段refcount(此字段在5.3.2版本中是refcount__gc)，这个字段是一个计数器，表示有多少个变量名指向这个zval容器，当此字段为0时，表示没有任何变量指向这个zval，那么zval就可以被释放，这是引擎内部对内存的一种优化。考虑如下代码：</p><p>代码中有两个变变量$a和$b,通过普通赋值方式将$a赋给$b,这样$b的值和$a相等，对$b的修改不会对$a造成任何影响，那么在这段代码中，如果$a和$b对应两个不同的zval，那么显然是对内存的一种浪费，PHP的开发者也不会让这样的事情发生。所以实际上$a和$b是指向同一个zval。这个zval的类型是STRING,值是”Hello world”,有$a和$b两个变量指向它，所以它的refcount=2, 由于是一个普通赋值，所以is_ref字段为0。 这样就节省了内存开销。</p><p>当执行$a = “Hello world”之后，$a对应的zval的信息为：a: (refcount=1, is_ref=0)=”Hello world”</p><p>但执行$b=$a之后，$a对应的zval的信息为：a: (refcount=2, is_ref=0)=”Hello world”</p><p>下面将之前的代码修改一下：</p><pre><code>&lt;?php  $a = &quot;Hello world&quot;;  $b = &amp;$a;  ?&gt;  </code></pre><p>这样就通过引用赋值方式将$a赋给$b。</p><p>当执行$a = “Hello world”之后，$a对应的zval的信息为：a: (refcount=1, is_ref=0)=”Hello world”</p><p>但执行$b=&amp;$a之后，$a对应的zval的信息为：a: (refcount=2, is_ref=1)=”Hello world”</p><p>可以发现is_ref字段被设置成1了，这样$a和$b对应的zval就是一个引用。这样我们基本对引擎中变量的引用和计数有了一个基本的了解，下面将介绍变量的分离。</p><h2 id="变量的分离-copy-on-write"><a href="#变量的分离-copy-on-write" class="headerlink" title="变量的分离 copy on write"></a>变量的分离 copy on write</h2><p>考虑前面第一段代码，用普通方式将$a赋给$b,在内部两个变量还是指向同一个zval的，这个时候如果我们将$b的值修改为”new string”,$a变量的值依然是”Hello world”：</p><pre><code>&lt;?php  $a = &quot;Hello world&quot;;  $b = $a;  $b = &quot;new string&quot;;  echo $a;  echo $b;  ?&gt;  </code></pre><p>$a和$b明明是指向同一个zval，为什么修改了$b,$a还能保持不变呢，这就是copy on write（写时复制）技术，简单的说，当重新给$b赋值的时候，会将$b从之前的zval中分离出来。分离之后，$a和$b分别是指向不同的zval了。</p><p>写时复制技术的一个比较有名的应用是在unix类操作系统内核中，当一个进程调用fork函数生成一个子进程的时候，父子进程拥有相同的地址空间内容，在老版本的系统中，子进程是在fork的时候就将父进程的地址空间中的内容都拷贝一份，对于规模较大的程序这个过程可能会有着很大的开销，更崩溃的是，很多进程在fork之后，直接在子进程中调用exec执行另外一个程序，这样原来花了大量时间从父进程复制的地址空间都还没来得及碰一下就被新的进程地址空间代替，这显然是对资源的极大浪费，所以在后来的系统中，就使用了写时复制技术，fork之后，子进程的地址空间还是简单的指向父进程的地址空间，只有当子进程需要写地址空间中的内容的时候，才会单独分离一份（一般以内存页为单位）给子进程，这样就算子进程马上调用exec函数也没关系，因为根本就不需要从父进程的地址空间中拷贝内容，这样节约了内存同时又提高了速度。</p><p>当$b从$a指向的zval分离出来之后，zval的refcount就要减1，这样由之前的2变成了1，表示这个zval还有一个变量指向它，就是$a。$b变量指向了一个新的zval,新的zval的refcount为1，值为字符串”new string”,大概过程如下：</p><pre><code>$a = &quot;Hello world&quot;     //a: (refcount=1, is_ref=0)=&quot;Hello world&quot;$b = $a               //a,b: (refcount=2, is_ref=0)=&quot;Hello world&quot;$b = &quot;new string&quot;     //a: (refcount=1, is_ref=0)=&quot;Hello world&quot;   b: (refcount=1, is_ref=0)=&quot;new string&quot;(发生分离操作)</code></pre><p>这个分离逻辑可以表叙为：对一个一般变量a(isref=0)进行一般赋值操作，如果a所指向的zval的计数refcount大于1,那么需要为a重新分配一个新的zval，并且把之前的zval的计数refcount减少1。</p><p>以上为普通赋值的情况，如果是引用赋值，我们看看这个变化过程：</p><pre><code>$a = &quot;Hello world&quot;     //a: (refcount=1, is_ref=0)=&quot;Hello world&quot;$b = &amp;$a           //a,b: (refcount=2, is_ref=1)=&quot;Hello world&quot;$b = &quot;new string&quot;     //a,b: (refcount=2, is_ref=1)=&quot;new string&quot;</code></pre><p>可以看出来，对一个引用类型的zval进行赋值是不会进行分离操作的，实际上我们再产生一个引用变量的时候是可能出现一个分离操作的，只是时机有些不同：</p><ol><li>在普通赋值的情况下，分离操作发生在$b=”new string”这一步，也就是在对变量赋新的值的时候，才会进行zval分离操作</li><li>在引用赋值的情况下，分离操作有可能发生在$b = &amp;$a这一步,也就是在生成引用变量的时候</li></ol><p>情况1就不多解释了，情况2中强调是有可能发生分离，以前面的这代码为例子，是否进行分离与$a当前指向的zval的refcount有关系，代码中$b = &amp;$a 的时候, $a指向的zval的refcount=1,这个时候不需要进行分离操作，但是如果refcount=2,那么就需要分离一个zval出来。比如如下代码：</p><pre><code>&lt;?php  $a = &quot;Hello world&quot;;  $c = $a;  $b = &amp;$a;  $b = &quot;new string&quot;;  ?&gt;  </code></pre><p>在执行引用赋值的时候，$a指向的zval的refcount=2,因为$a和$c同时指向了这个zval,所以在$b=&amp;$a的时候，就需要进行一个分离操作，这个分离操作生成了一个ref=1的zval,并且计数为2，因为$a,$b两个变量指向分离出来的zval,原来的zval的refcount减少1，所以最终只有$c指向一个值为”Hello world”，ref=0的zval1, $a和$b指向一个值为”Hello world”,ref=1的zval2。 这样我们对$c的修改时在操作zval1,对$a和$b的修改都是在操作zval2,这样就符合引用的特性了。</p><p>此过程大致如下：</p><pre><code>$a = &quot;Hello world&quot;;    //a: (refcount=1, is_ref=0)=&quot;Hello world&quot;$c  = $a;           // a,c: (refcount=2, is_ref=0)=&quot;Hello world&quot;$b = &amp;$a;           // c: (refcount=1, is_ref=0)=&quot;Hello world&quot; a,b: (refcount=2, is_ref=1)=&quot;Hello world&quot; (发生分离操作)$b = &quot;new string&quot;;     // c: (refcount=1, is_ref=0)=&quot;Hello world&quot; a,b: (refcount=2, is_ref=1)=&quot;new string&quot;</code></pre><p>试想一下如果不进行这个分离会有什么后果？如果不进行分离，$a,$b,$c都指向了同一个zval,对$b的修改也会影响到$c,这显然是不符合PHP语言特性的。</p><p>这个分离逻辑可以表述为：将一个一般变量a(isref=0)的引用赋给另外一个变量b的时候，如果a的refcount大于1，那么需要对a进行一次分离操作，分离之后的zval的isref等于1,refcount等于2</p><p>通过以上的一些知识和分离逻辑读者应该可以很容易分析其它的一些情况。比如将一个引用变量a(isref=1)的引用赋给一般变量b的时候，需要将b之前指向的zval的refcount减少1，然后将b指向a的zval,a的zval的refcount加1，没有任何分离操作</p><p>这些理论结合实际代码会让你更容易理解这个过程。</p><h2 id="unset的作用"><a href="#unset的作用" class="headerlink" title="unset的作用"></a>unset的作用</h2><p>unset()并非一个函数，而是一种语言结构，这个可以通过查看编译生成的opcode看到区别，unset对应的不是一个函数调用的opcode。那么unset到底做了什么？ 在unset对应的opcode的handler中可以看到相关内容，主要的操作时从当前符号表中删除参数中的符号，比如在全局代码中执行unset($a),那么将会在全局符号表中删除a这个符号。全局符号表是一张哈希表，建立这张表的时候会提供一个表中的项的析构函数，当我们从符号表中删除a的时候，会对符号a指向的项（这里是zval的指针）调用这个析构函数，这个析构函数的主要功能是将a对应的zval的refcount减1，如果refcount变成了0，那么释放这个zval。所以当我们调用unset的时候，不一定能释放变量所占的内存空间，只有当这个变量对应的zval没有别的变量指向它的时候，才会释放掉zval,否则只是对refcount进行减1操作。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88-zend_execute的具体执行过程</title>
      <link href="/posts/fb962590.html"/>
      <url>/posts/fb962590.html</url>
      
        <content type="html"><![CDATA[<h1 id="88-zend-execute的具体执行过程"><a href="#88-zend-execute的具体执行过程" class="headerlink" title="88-zend_execute的具体执行过程"></a>88-zend_execute的具体执行过程</h1><p>解释器引擎最终执行op的函数是zend_execute，实际上zend_execute是一个函数指针，在引擎初始化的时候zend_execute默认指向了execute,这个execute定义在{PHPSRC}/Zend/zend_vm_execute.h：</p><pre><code>ZEND_API void execute(zend_op_array *op_array TSRMLS_DC)  {      zend_execute_data *execute_data;      zend_bool nested = 0;      zend_bool original_in_execution = EG(in_execution);      if (EG(exception)) {          return;      }      EG(in_execution) = 1;  zend_vm_enter:      /* Initialize execute_data */      execute_data = (zend_execute_data *)zend_vm_stack_alloc(          ZEND_MM_ALIGNED_SIZE(sizeof(zend_execute_data)) +          ZEND_MM_ALIGNED_SIZE(sizeof(zval**) * op_array-&gt;last_var * (EG(active_symbol_table) ? 1 : 2)) +          ZEND_MM_ALIGNED_SIZE(sizeof(temp_variable)) * op_array-&gt;T TSRMLS_CC);      EX(CVs) = (zval***)((char*)execute_data + ZEND_MM_ALIGNED_SIZE(sizeof(zend_execute_data)));      memset(EX(CVs), 0, sizeof(zval**) * op_array-&gt;last_var);      EX(Ts) = (temp_variable *)(((char*)EX(CVs)) + ZEND_MM_ALIGNED_SIZE(sizeof(zval**) * op_array-&gt;last_var * (EG(active_symbol_table) ? 1 : 2)));      EX(fbc) = NULL;      EX(called_scope) = NULL;      EX(object) = NULL;      EX(old_error_reporting) = NULL;      EX(op_array) = op_array;      EX(symbol_table) = EG(active_symbol_table);      EX(prev_execute_data) = EG(current_execute_data);      EG(current_execute_data) = execute_data;      EX(nested) = nested;      nested = 1;      if (op_array-&gt;start_op) {          ZEND_VM_SET_OPCODE(op_array-&gt;start_op);      } else {          ZEND_VM_SET_OPCODE(op_array-&gt;opcodes);      }      if (op_array-&gt;this_var != -1 &amp;&amp; EG(This)) {          Z_ADDREF_P(EG(This)); /* For $this pointer */          if (!EG(active_symbol_table)) {              EX(CVs)[op_array-&gt;this_var] = (zval**)EX(CVs) + (op_array-&gt;last_var + op_array-&gt;this_var);              *EX(CVs)[op_array-&gt;this_var] = EG(This);          } else {              if (zend_hash_add(EG(active_symbol_table), &quot;this&quot;, sizeof(&quot;this&quot;), &amp;EG(This), sizeof(zval *), (void**)&amp;EX(CVs)[op_array-&gt;this_var])==FAILURE) {                  Z_DELREF_P(EG(This));              }          }      }      EG(opline_ptr) = &amp;EX(opline);      EX(function_state).function = (zend_function *) op_array;      EX(function_state).arguments = NULL;      while (1) {          int ret;  #ifdef ZEND_WIN32          if (EG(timed_out)) {              zend_timeout(0);          }  #endif          if ((ret = EX(opline)-&gt;handler(execute_data TSRMLS_CC)) &gt; 0) {              switch (ret) {                  case 1:                      EG(in_execution) = original_in_execution;                      return;                  case 2:                      op_array = EG(active_op_array);                      goto zend_vm_enter;                  case 3:                      execute_data = EG(current_execute_data);                  default:                      break;              }          }      }      zend_error_noreturn(E_ERROR, &quot;Arrived at end of main loop which shouldn&apos;t happen&quot;);  }</code></pre><p>此函数的参数为op_array，这是一个指向zend_op_array的指针，op_array是在编译过程中生成，这里有必要介绍一下zend_op_array这个类型。</p><h2 id="zend-op-array简介"><a href="#zend-op-array简介" class="headerlink" title="zend_op_array简介"></a>zend_op_array简介</h2><p>此类型的定义在{PHPSRC}/Zend/zend_compile.h:</p><pre><code>struct _zend_op_array {      /* Common elements */      zend_uchar type;      char *function_name;              zend_class_entry *scope;      zend_uint fn_flags;      union _zend_function *prototype;      zend_uint num_args;      zend_uint required_num_args;      zend_arg_info *arg_info;      zend_bool pass_rest_by_reference;      unsigned char return_reference;      /* END of common elements */      zend_bool done_pass_two;      zend_uint *refcount;      zend_op *opcodes;      zend_uint last, size;      zend_compiled_variable *vars;      int last_var, size_var;      zend_uint T;      zend_brk_cont_element *brk_cont_array;      int last_brk_cont;      int current_brk_cont;      zend_try_catch_element *try_catch_array;      int last_try_catch;      /* static variables support */      HashTable *static_variables;      zend_op *start_op;      int backpatch_count;      zend_uint this_var;      char *filename;      zend_uint line_start;      zend_uint line_end;      char *doc_comment;      zend_uint doc_comment_len;      zend_uint early_binding; /* the linked list of delayed declarations */      void *reserved[ZEND_MAX_RESERVED_RESOURCES];  };  typedef struct _zend_op_array zend_op_array;  </code></pre><p>此结构比较复杂，我们目前只介绍最基本的几个字段。</p><h3 id="1-type："><a href="#1-type：" class="headerlink" title="1.type："></a>1.type：</h3><p>op_array的类型，首先需要说明的是，一段PHP代码被编译之后，虽然返回的是一个zend_op_array指针，但是实际上生成的zend_op_array结构可能不止一个，通过这个结构中的一些字段,例如function_name ,num_args等你也许会发现这个zend_op_array结构似乎能和函数产生一定的联系，确实如此，用户自定义的函数，以及用户定义的类的方法，都是一个zend_op_array结构，这些zend_op_array结构在编译过程中被保存在某些地方，例如用户自定义的函数被保存进了GLOBAL_FUNCTION_TABLE,这个是全局函数符号表，通过函数名可以在此表中检索到函数体。那么编译后返回的那个zend_op_array指针是什么呢，其实编译后返回的zend_op_array是执行的一个入口,也可以认为它是最外层，即不在任何函数体内的全局代码组成的op_array。然而全局代码，用户自定义函数，用户自定义的方法都拥有相同的type值：2 ，type可取值的宏定义为:</p><pre><code>#define ZEND_INTERNAL_FUNCTION              1  #define ZEND_USER_FUNCTION                  2  #define ZEND_OVERLOADED_FUNCTION            3  #define ZEND_EVAL_CODE                      4  #define ZEND_OVERLOADED_FUNCTION_TEMPORARY  5  </code></pre><p>可以看到全局代码，用户函数，用户方法都对应的是ZEND_USER_FUNCTION,这个也是最常见的type了，其中ZEND_EVAL_CODE对应的是eval函数中的PHP代码，所以我们可以想到，eval函数参数中的PHP代码也会被编译成单独的zend_op_array。</p><h3 id="2-function-name"><a href="#2-function-name" class="headerlink" title="2.function_name"></a>2.function_name</h3><p>如果op_array是由用户定义的函数或则方法编译而生成，那么此字段对应函数的名字，如果是全局代码或则是eval部分的代码，那么此字段为控制。</p><h3 id="3-opcodes"><a href="#3-opcodes" class="headerlink" title="3.opcodes"></a>3.opcodes</h3><p>这个字段类型为zend_op *,因此这是一个zend_op的数组，这个数组保存的就是此编译过程中生成的op,如果不了解zend_op，可以看看之前的文章 OPcode简介 , 这个字段是最重要的部分了，zend_execute最终就是执行这里保存的op。</p><p>现在基本对参数op_array有了一定的了解，那么我们就开始进入到execute中。</p><h2 id="执行过程详解"><a href="#执行过程详解" class="headerlink" title="执行过程详解"></a>执行过程详解</h2><p>execute函数开始的时候是一些基础变量的申明，其中zend_execute_data *execute_data;是执行期的数据结构，此变量在进行一定的初始化之后将会被传递给每个op的handler函数作为参数，op在执行过程中随时有可能改变execute_data中的内容。</p><ul><li>第14行zend_vm_enter 这个跳转标签是作为虚拟机执行的入口，当op中涉及到函数调用的时候，就有可能会跳转到这里来执行函数体。</li><li>第16行到第19行为execute_data分配空间</li><li>第21行到第32行主要是对execute_data进行一些初始化，以及保存现场工作，要保存现场是因为在进入函数调用的时候，需要保存当前一些运行期间的数据，在函数调用结束之后再进行还原，可以想象为操作系统中进程调度，当进程在调出的时候需要保存寄存器等上下文环境，而当进程被调入的时候再取出来继续执行。</li><li>第41行到第51行主要是在当前动态符号表中加入$this变量，这个是在调用对象的方法时才有必要进行。</li><li><p>第58行开始的while无限循环就是开始执行op_array中的opcodes了，在第66行中调用当前执行的op的handler:</p><p>EX(opline)-&gt;handler(execute_data TSRMLS_CC))</p></li></ul><p>然后如果handler的返回值小于0则循环继续，如果大于0则进入一个switch结构：</p><ul><li>当返回值为1时：execute函数将返回，执行也就结束了。</li><li>当返回值为2时：op_array被重新设置，并跳转到zend_vm_enter ，这个一般是函数调用或则执行eval函数中的代码，将在新的上下文执行相关函数的op_array</li><li>当返回值为3时：循环体继续继续执行，当然再继续执行之前，EX(opline)已经往后移了一位（可能多位），也就是已经指向了后面一个新的opline,于是继续执行新的opline</li><li>当返回其他值时：结束循环，报错，结束应该用return,也就是返回1</li></ul><p>在op的handler中返回特定的值都被定义成了宏,例如{PHPSRC}/Zend/zend_execute.c中定义的：</p><pre><code>#define ZEND_VM_NEXT_OPCODE() /      CHECK_SYMBOL_TABLES() /      EX(opline)++; /      ZEND_VM_CONTINUE()  #define ZEND_VM_SET_OPCODE(new_op) /      CHECK_SYMBOL_TABLES() /      EX(opline) = new_op  #define ZEND_VM_JMP(new_op) /      CHECK_SYMBOL_TABLES() /      if (EXPECTED(!EG(exception))) { /          EX(opline) = new_op; /      } /      ZEND_VM_CONTINUE()  #define ZEND_VM_INC_OPCODE() /      EX(opline)++</code></pre><p>以及在{PHPSRC}/Zend/zend_vm_execute.c中定义的：</p><pre><code>#define ZEND_VM_CONTINUE()   return 0  #define ZEND_VM_RETURN()     return 1  #define ZEND_VM_ENTER()      return 2  #define ZEND_VM_LEAVE()      return 3  #define ZEND_VM_DISPATCH(opcode, opline) return zend_vm_get_opcode_handler(opcode, opline)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);  </code></pre><p>简单介绍功能</p><ul><li>ZEND_VM_NEXT_OPCODE()：移动到下一条op，返回0，不进入switch，循环继续（这个是最常用到的）</li><li>ZEND_VM_SET_OPCODE(new_op)：当前opline设置成new_op</li><li>ZEND_VM_JMP(new_op) ：当前opline设置成new_op，返回0，不进入switch，循环继续</li><li>ZEND_VM_INC_OPCODE()：仅仅移动到下一条op</li></ul><h2 id="执行环境的切换"><a href="#执行环境的切换" class="headerlink" title="执行环境的切换"></a>执行环境的切换</h2><p>在前面的内容已经提到，用户自定义函数，类方法，eval的代码都会编译成单独的op_array,那么当进行函数调用等操作时，必然涉及到调用前的op_array执行环境和新的函数的op_array执行环境的切换，这一段我们将以调用用户自定义函数来介绍整个切换过程如何进行。</p><p>介绍此过程前必须了解执行环境的相关数据结构，涉及到执行环境的数据结构主要有两个：</p><h3 id="1-执行期全局变量结构"><a href="#1-执行期全局变量结构" class="headerlink" title="1. 执行期全局变量结构"></a>1. 执行期全局变量结构</h3><p>相关的定义在{PHPSRC}/Zend/zend_globals_macros.h:</p><pre><code>/* Executor */  #ifdef ZTS  # define EG(v) TSRMG(executor_globals_id, zend_executor_globals *, v)  #else  # define EG(v) (executor_globals.v)  extern ZEND_API zend_executor_globals executor_globals;  #endif  </code></pre><p>这里是一个条件编译，ZTS表示线程安全启用，为了简化，我们这里以非线程安全模式的情况下来介绍，那么执行期的全局变量就是executor_globals,其类型为zend_executor_globals, zend_executor_globals的定义在{PHPSRC}/Zend/zend_globals.h，结构比较庞大，这里包含了整个执行期需要用到的各种变量，无论是哪个op_array在执行，都共用这一个全局变量，在执行过程中，此结构中的一些成员可能会改变，比如当前执行的op_array字段active_op_array，动态符号表字段active_symbol_table可能会根据不同的op_array而改变，This指针会根据在不同的对象环境而改变。</p><p>另外还定义了一个EG宏来取此变量中的字段值，此宏是针对线程安全和非线程安全模式的一个封装。</p><h3 id="2-每个op-array自身的执行数据"><a href="#2-每个op-array自身的执行数据" class="headerlink" title="2.每个op_array自身的执行数据"></a>2.每个op_array自身的执行数据</h3><p>针对每一个op_array,都会有自己执行期的一些数据，在函数execute开始的时候我们能看到zend_vm_enter跳转标签下面就会初始一个局部变量execute_data，所以我们每次切换到新的op_array的时候，都会为新的op_array建立一个execute_data变量，此变量的类型为zend_execute_data的指针，相关定义在{PHPSRC}/Zend/zend_compile.h：</p><pre><code>struct _zend_execute_data {      struct _zend_op *opline;      zend_function_state function_state;      zend_function *fbc; /* Function Being Called */      zend_class_entry *called_scope;      zend_op_array *op_array;      zval *object;      union _temp_variable *Ts;      zval ***CVs;      HashTable *symbol_table;      struct _zend_execute_data *prev_execute_data;      zval *old_error_reporting;      zend_bool nested;      zval **original_return_value;      zend_class_entry *current_scope;      zend_class_entry *current_called_scope;      zval *current_this;      zval *current_object;      struct _zend_op *call_opline;  };  </code></pre><p>可以用EX宏来取其中的值:#define EX(element) execute_data-&gt;element</p><p>这里只简单介绍其中两个字段：</p><ul><li>opline: 当前正在执行的op。</li><li>prev_execute_data: op_array环境切换的时候，这个字段用来保存切换前的op_array,此字段非常重要，他能将每个op_array的execute_data按照调用的先后顺序连接成一个单链表，每当一个op_array执行结束要还原到调用前op_array的时候，就通过当前的execute_data中的prev_execute_data字段来得到调用前的执行器数据。</li></ul><p>在executor_globals中的字段current_execute_data就是指向当前正在执行的op_array的execute_data。</p><p>再正式介绍之前还需要简单的介绍一下用户自定义函数的调用过程，详细的过程以后再函数章节中专门介绍，这里简单的说明一下：</p><p>在调用函数的时候，比如test()函数，会先在全局函数符号表中根据test来搜索相关的函数体，如果搜索不到则会报错函数没有定义，找到test的函数体之后，取得test函数的op_array，然后跳转到execute中的goto标签:zend_vm_enter,于是就进入到了test函数的执行环境。</p><p>下面我们将以一段简单的代码来介绍执行环境切换过程，例子代码：</p><pre><code>&lt;?php  $a = 123;  test();  function test()  {      return 1;  }  ?&gt;  </code></pre><p>这段代码非常简单，这样方便我们介绍原理，复杂的代码读者可以举一反三。此代码编译之后会生成两个op_array,一个是全局代码的op_array,另外一个是test函数的op_array,其中全局代码中会通过函数调用进入到test函数的执行环境，执行结束之后，会返回到全局代码，然后代码结束。</p><p>下面我们分几个阶段来介绍这段代码的过程，然后从中可以知道执行环境切换的方法。</p><p>1.进入execute函数，开始执行op_array ,这个op_array就是全局代码的op_array，我们暂时称其为op_array1</p><p>首先在execute中为op_array1建立了一个execute_data数据,我们暂时命名为execute_data1,然后进行相关的初始化操作，其中比较重要的是：</p><pre><code>EX(op_array) = op_array; // 设置op_array字段为当前执行的op_array,也就是全局代码的op_array1EX(prev_execute_data) = EG(current_execute_data);//将全局执行数据中保存的当前op_array执行数据保存到op_array1的execute_data1的prev_execute_data字段，由于这是执行的第一个op_array,所以prev_execute_data实际上是空值,然后将执行期全局变量的current_execute_data设置成execute_data1,然后设置execute_data1的当前执行op，这样就可以开始执行当前的op了</code></pre><p>2.在op_array1执行到test函数调用的的时候，首先从全局函数符号表中找到test的函数体，将函数体保存在execute_data1的function_state字段，然后从函数体中取到test的op_array,我们这里用op_array2来表示，并将op_array2赋值给EG(active_op_array)：</p><pre><code>EG(active_op_array) = &amp;EX(function_state).function-&gt;op_array;</code></pre><p>于是执行期全局变量的动态op_array字段指向了函数test的op_array，然后用调用ZEND_VM_ENTER();这个时候会先回到execute函数中的switch结构，并且满足以下case</p><pre><code>case 2:     op_array = EG(active_op_array);     goto zend_vm_enter;</code></pre><p>EG(active_op_array)之前已经被我们设置为test函数的op_array2，于是在函数execute中，op_array变量就指向了test的op_array2,然后跳转到zend_vm_enter。</p><p>3.跳转到zend_vm_enter之后其实又回到了类似1中的步骤，此时为test的op_array2建立了它的执行数据execute_data,我们这里用execute_data2来表示。跟1中有些不同的是EX(prev_execute_data) = EG(current_execute_data);这个时候current_execute_data = execute_data1,也就是全局代码的执行执行期数据，然后EG(current_execute_data) = execute_data;这样current_execute_data就等于test的执行期数据execute_data2了，同时全局代码的execute_data1被保存在execute_data2的prev_execute_data字段。这个时候进行环境的切换已经完成，于是开始执行test函数。</p><ol start="4"><li>test函数执行完之后就要返回到调用前的执行环境了，也就是全局代码执行环境，此阶段最重要的一个操作就是EG(current_execute_data) = EX(prev_execute_data); 在3中EX(prev_execute_data)已经设置成了全局代码的execute_data1,所以这样当前执行数据就变成了全局代码的执行数据，这样就成功的从函数test执行环境返回到了全局代码执行环境</li></ol><p>这样，执行环境的切换过程就完成了，对于深层次的函数调用，原理一样，执行数据execute_data组成的单链表会更长。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>87-代码的加密与解密</title>
      <link href="/posts/b9676981.html"/>
      <url>/posts/b9676981.html</url>
      
        <content type="html"><![CDATA[<h1 id="87-代码的加密与解密"><a href="#87-代码的加密与解密" class="headerlink" title="87-代码的加密与解密"></a>87-代码的加密与解密</h1><p>PHP语言作为脚本语言的一种，由于不需要进行编译，所以通常PHP程序的分发都是直接发布源代码。 对于一些开源软件来说，这并没有什么问题，因为它本来就希望有更多的人阅读代码，希望有更多的人参与进来， 而对于商业代码来说，这却是一个不太好的消息，不管是从商业秘密，还是从对公司产权的保护来说却是一个问题， 基于此，从而引出了对PHP代码的加密和解密的议题。 例如国内的Discuz论坛程序在开源之前要运行是必须安装Zend Optimizer的， Zend官方的代码加密软件是Zend Guard， 可以用来加密和混淆PHP代码，这样分发出去的代码就可以避免直接分发源代码， 不过加密后的代码是无法直接运行的，在运行时还需要一个解密的模块来运行加密后的程序， 要运行Zend Guard加密后的代码需要安装Zend Optimizer(PHP5.2之前的版本)， 或者安装Zend Guard Loader(PHP5.3版本)扩展才能运行。</p><h2 id="加密的本质"><a href="#加密的本质" class="headerlink" title="加密的本质"></a>加密的本质</h2><p>本质上程序在运行时都是在执行机器码，而基于虚拟机的语言的加密通常也是加密到这个级别， 也就是说PHP加密后的程序在执行之前都会解密成opcode来执行。</p><p>PHP在执行之前有一个编译的环节，编译的结果是opcode，然后由Zend虚拟机执行， 从这里看如果只要将源代码加密，然后在执行之前将代码解密即可。</p><p>从这里看，只要代码能被解密为opcode，那么总有可能反编译出来源代码， 其他的语言中也是类似，比如objdump程序能将二进制程序反汇编出来， .NET、Java的程序也是一样，都有一些反编译的程序，不过通常这些厂商同时还会 附带代码混淆的工具，经过混淆的代码可读性极差，很多人都留意过Gmail等网站 经过混淆的JS代码吧，他们阅读起来非常困难，经过混淆的代码即使反编译出来， 读者也很难通过代码分析出代码中的逻辑，这样也就极大的增加了应用的安全性。</p><h2 id="简单的代码加密解密实战"><a href="#简单的代码加密解密实战" class="headerlink" title="简单的代码加密解密实战"></a>简单的代码加密解密实战</h2><p>根据前文的介绍，作为实例，本文将编写一个简单的代码加密扩展用于对PHP代码的加密， 我们只需要能把源码加密，简单通过浏览源代码的方法无法获取到源代码那我们的目标就达到了， 为了能正确执行加密后的代码，我们还需要另一个模块：解密模块。</p><p>简单的思路是把所有的PHP文件代码进行加密，同时另存为同名的PHP文件， 这是一种很简单的做法，只是为了防止源代码赤裸裸的暴露在代码中。</p><p>加密也有很多种做法，第一种简单的方法可以简单的把源码本身进行一些可逆加密， 这样我们可以在运行之前把真实的源码反解出来执行，不过这种方式存在一种问题， 只要知道了加密算法我们就可以把代码给解出来，采用这种方式唯一能做的就是尽量 增加加密的复杂度，既然正式的代码在运行之前会被转化成PHP源代码，通过hack的方式是可以 完完整整的获得PHP源码的，保密的效果就很有限了。</p><p>因为Zend引擎最终执行的是opcode，那么我们只要保证能解密出opcode则能满足需求， 我们只要简单的将opcode进行简单的序列化或者像Zend Guard那样进行混淆， 在运行之前将opcode还原，那么源代码的信息就不存在了，这样我们就能保证源代码的安全， 而不至于泄露。</p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>前面提到加密的目的就是为了防止轻易获取程序源码的一种手段，对于PHP来说， 将源码编译为opcode已经能达到目的了，因为PHP引擎最终都是需要执行opcode的。 虽然可以将加密进一步，但是如果需要修改Zend引擎，那么成本就有点大了，因为需要修改 Zend引擎了，而这是无法通过简单的扩展机制来实现了，所以解密的成本也会变的太大， 也就没有实际意义了。</p><p>在本例中为了方便，代码的加密和解密实现均实现在同一个模块中。</p><p>熟悉PHP的同学可能会发现，这种加密方式和opcode缓存本质上没有太大差别，opcode缓存的工作是将 源码编译为opcode然后缓存起来，在执行的时候绕过编译直接执行opcode，的确是没错的。这里唯一的区别是： opcode缓存是动态透明的，而加密后我们要做的是分发加密后的代码。这么说我们是不是可以直接将 APC之类的缓存扩展进行改造就可以了，其实理论上是可以的。不过这两者的定位还是有差别的： 加密的目的是为了减少源码被分析破解的可能，而缓存只是为了提高程序运行的速度。</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>本例中的代码其实并没有进行加密，相对源代码来说，opcode编译本身也可以算做一种加密了， 因为毕竟通过阅读opcode来理解程序的逻辑还是比较困难的。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>86-中间代码opcode的执行</title>
      <link href="/posts/47c057c0.html"/>
      <url>/posts/47c057c0.html</url>
      
        <content type="html"><![CDATA[<h1 id="86-中间代码opcode的执行"><a href="#86-中间代码opcode的执行" class="headerlink" title="86-中间代码opcode的执行"></a>86-中间代码opcode的执行</h1><p>假如我们现在使用的是CLI模式，直接在SAPI/cli/php_cli.c文件中找到main函数， 默认情况下PHP的CLI模式的行为模式为PHP_MODE_STANDARD。 此行为模式中PHP内核会调用php_execute_script(&amp;file_handle TSRMLS_CC);来执行PHP文件。 顺着这条执行的线路，可以看到一个PHP文件在经过词法分析，语法分析，编译后生成中间代码的过程：</p><pre><code>EG(active_op_array) = zend_compile_file(file_handle, type TSRMLS_CC);</code></pre><p>在销毁了文件所在的handler后，如果存在中间代码，则PHP虚拟机将通过以下代码执行中间代码：</p><pre><code>zend_execute(EG(active_op_array) TSRMLS_CC);</code></pre><p>如果你是使用VS查看源码的话，将光标移到zend_execute并直接按F12， 你会发现zend_execute的定义跳转到了一个指针函数的声明(Zend/zend_execute_API.c)。</p><pre><code>ZEND_API void (*zend_execute)(zend_op_array *op_array TSRMLS_DC);</code></pre><p>这是一个全局的函数指针，它的作用就是执行PHP代码文件解析完的转成的zend_op_array。 和zend_execute相同的还有一个zedn_execute_internal函数，它用来执行内部函数。 在PHP内核启动时(zend_startup)时，这个全局函数指针将会指向execute函数。 注意函数指针前面的修饰符ZEND_API，这是ZendAPI的一部分。 在zend_execute函数指针赋值时，还有PHP的中间代码编译函数zend_compile_file（文件形式）和zend_compile_string(字符串形式)。</p><pre><code>zend_compile_file = compile_file;zend_compile_string = compile_string;zend_execute = execute;zend_execute_internal = NULL;zend_throw_exception_hook = NULL;</code></pre><p>这几个全局的函数指针均只调用了系统默认实现的几个函数，比如compile_file和compile_string函数， 他们都是以全局函数指针存在，这种实现方式在PHP内核中比比皆是，其优势在于更低的耦合度，甚至可以定制这些函数。 比如在APC等opcode优化扩展中就是通过替换系统默认的zend_compile_file函数指针为自己的函数指针my_compile_file， 并且在my_compile_file中增加缓存等功能。</p><p>到这里我们找到了中间代码执行的最终函数：execute(Zend/zend_vm_execure.h)。 在这个函数中所有的中间代码的执行最终都会调用handler。这个handler是什么呢？</p><pre><code>if ((ret = EX(opline)-&gt;handler(execute_data TSRMLS_CC)) &gt; 0) {}</code></pre><p>这里的handler是一个函数指针，它指向执行该opcode时调用的处理函数。 此时我们需要看看handler函数指针是如何被设置的。 在前面我们有提到和execute一起设置的全局指针函数：zend_compile_string。 它的作用是编译字符串为中间代码。在Zend/zend_language_scanner.c文件中有compile_string函数的实现。 在此函数中，当解析完中间代码后，一般情况下，它会执行pass_two(Zend/zend_opcode.c)函数。 pass_two这个函数，从其命名上真有点看不出其意义是什么。 但是我们关注的是在函数内部，它遍历整个中间代码集合， 调用ZEND_VM_SET_OPCODE_HANDLER(opline);为每个中间代码设置处理函数。 ZEND_VM_SET_OPCODE_HANDLER是zend_vm_set_opcode_handler函数的接口宏， zend_vm_set_opcode_handler函数定义在Zend/zend_vm_execute.h文件。 其代码如下：</p><pre><code>static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op){        static const int zend_vm_decode[] = {            _UNUSED_CODE, /* 0              */            _CONST_CODE,  /* 1 = IS_CONST   */            _TMP_CODE,    /* 2 = IS_TMP_VAR */            _UNUSED_CODE, /* 3              */            _VAR_CODE,    /* 4 = IS_VAR     */            _UNUSED_CODE, /* 5              */            _UNUSED_CODE, /* 6              */            _UNUSED_CODE, /* 7              */            _UNUSED_CODE, /* 8 = IS_UNUSED  */            _UNUSED_CODE, /* 9              */            _UNUSED_CODE, /* 10             */            _UNUSED_CODE, /* 11             */            _UNUSED_CODE, /* 12             */            _UNUSED_CODE, /* 13             */            _UNUSED_CODE, /* 14             */            _UNUSED_CODE, /* 15             */            _CV_CODE      /* 16 = IS_CV     */        };        return zend_opcode_handlers[opcode * 25                + zend_vm_decode[op-&gt;op1.op_type] * 5                + zend_vm_decode[op-&gt;op2.op_type]];}ZEND_API void zend_vm_set_opcode_handler(zend_op* op){    op-&gt;handler = zend_vm_get_opcode_handler(zend_user_opcodes[op-&gt;opcode], op);}</code></pre><p>前面介绍了四种查找opcode处理函数的方法， 而根据其本质实现查找也在其中，只是这种方法对于计算机来说比较容易识别，而对于自然人来说却不太友好。 比如一个简单的A + B的加法运算，如果你想用这种方法查找其中间代码的实现位置的话， 首先你需要知道中间代码的代表的值，然后知道第一个表达式和第二个表达式结果的类型所代表的值， 然后计算得到一个数值的结果，然后从数组zend_opcode_handlers找这个位置，位置所在的函数就是中间代码的函数。 这对阅读代码的速度没有好处，但是在开始阅读代码的时候根据代码的逻辑走这样一个流程却是大有好处。</p><p>回到正题。 handler所指向的方法基本都存在于Zend/zend_vm_execute.h文件文件。 知道了handler的由来，我们就知道每个opcode调用handler指针函数时最终调用的位置。</p><p>在opcode的处理函数执行完它的本职工作后，常规的opcode都会在函数的最后面添加一句：ZEND_VM_NEXT_OPCODE();。 这是一个宏，它的作用是将当前的opcode指针指向下一条opcode，并且返回0。如下代码：</p><pre><code>#define ZEND_VM_NEXT_OPCODE() \CHECK_SYMBOL_TABLES() \EX(opline)++; \ZEND_VM_CONTINUE()#define ZEND_VM_CONTINUE()   return 0</code></pre><p>在execute函数中，处理函数的执行是在一个while(1)循环作用范围中。如下：</p><pre><code>while (1) {        int ret;#ifdef ZEND_WIN32        if (EG(timed_out)) {            zend_timeout(0);        }#endif        if ((ret = EX(opline)-&gt;handler(execute_data TSRMLS_CC)) &gt; 0) {            switch (ret) {                case 1:                    EG(in_execution) = original_in_execution;                    return;                case 2:                    op_array = EG(active_op_array);                    goto zend_vm_enter;                case 3:                    execute_data = EG(current_execute_data);                default:                    break;            }        }    }</code></pre><p>前面说到每个中间代码在执行完后都会将中间代码的指针指向下一条指令，并且返回0。 当返回0时，while 循环中的if语句都不满足条件，从而使得中间代码可以继续执行下去。 正是这个while(1)的循环使得PHP内核中的opcode可以从第一条执行到最后一条， 当然这中间也有一些函数的跳转或类方法的执行等。</p><p>以上是一条中间代码的执行，那么对于函数的递归调用，PHP内核是如何处理的呢？ 看如下一段PHP代码：</p><pre><code>function t($c) {    echo $c, &quot;\n&quot;;    if ($c &gt; 2) {            return ;    }    t($c + 1);}t(1);</code></pre><p>这是一个简单的递归调用函数实现，它递归调用了两次，这个递归调用是如何进行的呢？ 我们知道函数的调用所在的中间代码最终是调用zend_do_fcall_common_helper_SPEC(Zend/zend_vm_execute.h)。 在此函数中有如下一段：</p><pre><code>if (zend_execute == execute &amp;&amp; !EG(exception)) {    EX(call_opline) = opline;    ZEND_VM_ENTER();} else {    zend_execute(EG(active_op_array) TSRMLS_CC);}</code></pre><p>前面提到zend_execute API可能会被覆盖，这里就进行了简单的判断，如果扩展覆盖了opcode执行函数， 则进行特殊的逻辑处理。</p><p>上一段代码中的ZEND_VM_ENTER()定义在Zend/zend_vm_execute.h的开头，如下：</p><pre><code>#define ZEND_VM_CONTINUE()   return 0#define ZEND_VM_RETURN()     return 1#define ZEND_VM_ENTER()      return 2#define ZEND_VM_LEAVE()      return 3</code></pre><p>这些在中间代码的执行函数中都有用到，这里的ZEND_VM_ENTER()表示return 2。 在前面的内容中我们有说到在调用了EX(opline)-&gt;handler(execute_data TSRMLS_CC))后会将返回值赋值给ret。 然后根据ret判断下一步操作，这里的递归函数是返回2，于是下一步操作是：</p><pre><code>op_array = EG(active_op_array);goto zend_vm_enter;</code></pre><p>这里将EG(active_op_array)的值赋给op_array后，直接跳转到execute函数的定义的zend_vm_enter标签， 此时的EG(active_op_array)的值已经在zend_do_fcall_common_helper_SPEC中被换成了当前函数的中间代码集合， 其实现代码为：</p><pre><code>if (EX(function_state).function-&gt;type == ZEND_USER_FUNCTION) {  //  用户自定义的函数    EX(original_return_value) = EG(return_value_ptr_ptr);    EG(active_symbol_table) = NULL;    EG(active_op_array) = &amp;EX(function_state).function-&gt;op_array;   //  将当前活动的中间代码指针指向用户自定义函数的中间代码数组    EG(return_value_ptr_ptr) = NULL;}</code></pre><p>当内核执行完用户自定义的函数后，怎么返回之前的中间代码代码主干路径呢？ 这是由于在execute函数中初始化数据时已经将当前的路径记录在EX(op_array)中了（EX(op_array)　= op_array;） 当用户函数返回时程序会将之前保存的路径重新恢复到EG(active_op_array)中（EG(active_op_array) = EX(op_array);）。 可能此时你会问如果函数没有返回呢？这种情况在用户自定义的函数中不会发生的， 就算是你没有写return语句，PHP内核也会自动给加上一个return语句。</p><p>整个调用路径如下图所示：</p><center><br><img src="images/2012_03_09_02.png" alt><br></center><br><center><br>Zend中间代码调用路径图<br></center><p>以上是opcode的执行过程，与过程相比，过程中的数据会更加重要，那么在执行过程中的核心数据结构有哪些呢？ 在Zend/zend_vm_execute.h文件中的execute函数实现中，zend_execute_data类型的execute_data变量贯穿整个中间代码的执行过程， 其在调用时并没有直接使用execute_data，而是使用EX宏代替，其定义在Zend/zend_compile.h文件中，如下：</p><pre><code>#define EX(element) execute_data.element</code></pre><p>因此我们在execute函数或在opcode的实现函数中会看到EX(fbc)，EX(object)等宏调用， 它们是调用函数局部变量execute_data的元素：execute_data.fbc和execute_data.object。 execute_data不仅仅只有fbc、object等元素，它包含了执行过程中的中间代码，上一次执行的函数，函数执行的当前作用域，类等信息。 其结构如下：</p><pre><code>typedef struct _zend_execute_data zend_execute_data;struct _zend_execute_data {    struct _zend_op *opline;    zend_function_state function_state;    zend_function *fbc; /* Function Being Called */    zend_class_entry *called_scope;    zend_op_array *op_array;  /* 当前执行的中间代码 */    zval *object;    union _temp_variable *Ts;    zval ***CVs;    HashTable *symbol_table; /* 符号表 */    struct _zend_execute_data *prev_execute_data;   /* 前一条中间代码执行的环境*/    zval *old_error_reporting;    zend_bool nested;    zval **original_return_value; /* */    zend_class_entry *current_scope;    zend_class_entry *current_called_scope;    zval *current_this;    zval *current_object;    struct _zend_op *call_opline;};</code></pre><p>在前面的中间代码执行过程中有介绍：中间代码的执行最终是通过EX(opline)-&gt;handler(execute_data TSRMLS_CC)来调用最终的中间代码程序。 在这里会将主管中间代码执行的execute函数中初始化好的execture_data传递给执行程序。</p><p>zend_execute_data结构体部分字段说明如下：</p><ul><li>opline字段：struct _zend_op类型，当前执行的中间代码</li><li>op_array字段： zend_op_array类型，当前执行的中间代码队列</li><li>fbc字段：zend_function类型，已调用的函数</li><li>called_scope字段：zend_class_entry类型，当前调用对象作用域，常用操作是EX(called_scope) = Z_OBJCE_P(EX(object))， 即将刚刚调用的对象赋值给它。</li><li>symbol_table字段： 符号表，存放局部变量。 在execute_data初始时，EX(symbol_table) = EG(active_symbol_table);</li><li>prev_execute_data字段：前一条中间代码执行的中间数据，用于函数调用等操作的运行环境恢复。</li></ul><p>在execute函数中初始化时，会调用zend_vm_stack_alloc函数分配内存。 这是一个栈的分配操作，对于一段PHP代码的上下文环境，它存在于这样一个分配的空间作放置中间数据用，并作为栈顶元素。 当有其它上下文环境的切换（如函数调用），此时会有一个新的元素生成，上一个上下文环境会被新的元素压下去， 新的上下文环境所在的元素作为栈顶元素存在。</p><p>在zend_vm_stack_alloc函数中我们可以看到一些PHP内核中的优化。 比如在分配时，这里会存在一个最小分配单元，在zend_vm_stack_extend函数中， 分配的最小单位是ZEND_VM_STACK_PAGE_SIZE((64 * 1024) - 64)，这样可以在一定范围内控制内存碎片的大小。 又比如判断栈元素是否为空，在PHP5.3.1之前版本(如5.3.0)是通过第四个元素elelments与top的位置比较来实现， 而从PHP5.3.1版本开始，struct _zend_vm_stack结构就没有第四个元素，直接通过在当前地址上增加整个结构体的长度与top的地址比较实现。 两个版本结构代码及比较代码如下：</p><pre><code>// PHP5.3.0struct _zend_vm_stack {    void **top;    void **end;    zend_vm_stack prev;    void *elements[1];};if (UNEXPECTED(EG(argument_stack)-&gt;top == EG(argument_stack)-&gt;elements)) {}//  PHP5.3.1struct _zend_vm_stack {    void **top;    void **end;    zend_vm_stack prev;};if (UNEXPECTED(EG(argument_stack)-&gt;top == ZEND_VM_STACK_ELEMETS(EG(argument_stack)))) {}#define ZEND_VM_STACK_ELEMETS(stack) \((void**)(((char*)(stack)) + ZEND_MM_ALIGNED_SIZE(sizeof(struct _zend_vm_stack))))</code></pre><p>当一个上下文环境结束其生命周期后，如果回收这段内存呢？ 还是以函数为例，每个函数都会有一个函数返回， 即使没有在函数的实现中定义，也会默认返回一个NULL。以ZEND_RETURN_SPEC_CONST_HANDLER实现为例， 在函数的返回最后都会调用一个函数zend_leave_helper_SPEC。</p><p>在zend_leave_helper_SPEC函数中，对于执行过程中的函数处理有几个关键点：</p><ul><li>上下文环境的切换：这里的关键代码是：EG(current_execute_data) = EX(prev_execute_data);。 EX(prev_execute_data)用于保留当前函数调用前的上下文环境，从而达到恢复和切换的目的。</li><li>当前上下文环境所占用内存空间的释放：这里的关键代码是：zend_vm_stack_free(execute_data TSRMLS_CC);。 zend_vm_stack_free函数的实现存在于Zend/zend_execute.h文件，它的作用就是释放栈元素所占用的内存。</li><li>返回到之前的中间代码执行路径中：这里的关键代码是：ZEND_VM_LEAVE();。 我们从zend_vm_execute.h文件的开始部分就知道ZEND_VM_LEAVE宏的效果是返回3。 在执行中间代码的while循环当中，当ret=3时，这个执行过程就会恢复之前上下文环境，继续执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>85-虚拟机的语法分析</title>
      <link href="/posts/44943e2.html"/>
      <url>/posts/44943e2.html</url>
      
        <content type="html"><![CDATA[<h1 id="85-虚拟机的语法分析"><a href="#85-虚拟机的语法分析" class="headerlink" title="85-虚拟机的语法分析"></a>85-虚拟机的语法分析</h1><p>Bison是一种通用目的的分析器生成器。它将LALR(1)上下文无关文法的描述转化成分析该文法的C程序。 使用它可以生成解释器，编译器，协议实现等多种程序。 Bison向上兼容Yacc，所有书写正确的Yacc语法都应该可以不加修改地在Bison下工作。 它不但与Yacc兼容还具有许多Yacc不具备的特性。</p><p>Bison分析器文件是定义了名为yyparse并且实现了某个语法的函数的C代码。 这个函数并不是一个可以完成所有的语法分析任务的C程序。 除此这外我们还必须提供额外的一些函数： 如词法分析器、分析器报告错误时调用的错误报告函数等等。 我们知道一个完整的C程序必须以名为main的函数开头，如果我们要生成一个可执行文件，并且要运行语法解析器， 那么我们就需要有main函数，并且在某个地方直接或间接调用yyparse，否则语法分析器永远都不会运行。</p><p>先看下bison的示例：逆波兰记号计算器</p><pre><code>%{#define YYSTYPE double#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;ctype.h&gt;int yylex (void);void yyerror (char const *);%}%token NUM%%input:    /* empty */     | input line    ;line:     &apos;\n&apos;    | exp &apos;\n&apos;      { printf (&quot;\t%.10g\n&quot;, $1); };exp:      NUM           { $$ = $1;           }   | exp exp &apos;+&apos;   { $$ = $1 + $2;      }    | exp exp &apos;-&apos;   { $$ = $1 - $2;      }    | exp exp &apos;*&apos;   { $$ = $1 * $2;      }    | exp exp &apos;/&apos;   { $$ = $1 / $2;      }     /* Exponentiation */    | exp exp &apos;^&apos;   { $$ = pow($1, $2); }    /* Unary minus    */    | exp &apos;n&apos;       { $$ = -$1;          };%%#include &lt;ctype.h&gt;int yylex (void) {       int c;/* Skip white space.  */       while ((c = getchar ()) == &apos; &apos; || c == &apos;\t&apos;) ;/* Process numbers.  */       if (c == &apos;.&apos; || isdigit (c)) {       ungetc (c, stdin);       scanf (&quot;%lf&quot;, &amp;yylval);       return NUM;     }       /* Return end-of-input.  */       if (c == EOF) return 0;       /* Return a single char.  */       return c;}void yyerror (char const *s) {    fprintf (stderr, &quot;%s\n&quot;, s);}int main (void) {    return yyparse ();}</code></pre><p>我们先看下运行的效果：</p><pre><code>bison demo.ygcc -o test -lm test.tab.cchmod +x test./test</code></pre><p>gcc命令需要添加-lm参数。因为头文件仅对接口进行描述，但头文件不是负责进行符号解析的实体。此时需要告诉编译器应该使用哪个函数库来完成对符号的解析。 　GCC的命令参数中，-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名，这里我们在-l后面接的是m，即数学库，他的库名是m，他的库文件名是libm.so。</p><p>这是一个逆波兰记号计算器的示例，在命令行中输入 3 7 + 回车，输出10</p><p>一般来说，使用Bison设计语言的流程，从语法描述到编写一个编译器或者解释器,有三个步骤:</p><ul><li>以Bison可识别的格式正式地描述语法。对每一个语法规则，描述当这个规则被识别时相应的执行动作，动作由C语句序列。即我们在示例中看到的%%和%%这间的内容。</li><li>描述编写一个词法分析器处理输入并将记号传递给语法分析器（即yylex函数一定要存在）。词法分析器既可是手工编写的C代码, 也可以由lex产生，后面我们会讨论如何将re2c与bison结合使用。上面的示例中是直接手工编写C代码实现一个命令行读取内容的词法分析器。</li><li>编写一个调用Bison产生的分析器的控制函数，在示例中是main函数直接调用。编写错误报告函数（即yyerror函数）。</li></ul><p>将这些源代码转换成可执行程序，需要按以下步骤进行：</p><ul><li>按语法运行Bison产生分析器。对应示例中的命令，bison demo.y</li><li>同其它源代码一样编译Bison输出的代码，链接目标文件以产生最终的产品。即对应示例中的命令　gcc -o test -lm test.tab.c</li></ul><p>我们可以将整个Bison语法文件划分为四个部分。 这三个部分的划分通过%%’,%{‘ 和`%}’符号实现。 一般来说，Bison语法文件结构如下：</p><pre><code>%{这里可以用来定义在动作中使用类型和变量，或者使用预处理器命令在那里来定义宏, 或者使用#include包含需要的文件。如在示例中我们声明了YYSTYPE，包含了头文件math.h等，还声明了词法分析器yylex和错误打印程序yyerror。%}Bison 的一些声明在这里声明终结符和非终结符以及操作符的优先级和各种符号语义值的各种类型如示例中的%token　NUM。我们在PHP的源码中可以看到更多的类型和符号声明，如%left，%right的使用%%在这里定义如何从每一个非终结符的部分构建其整体的语法规则。%%</code></pre><p>这里存放附加的内容<br>这里就比较自由了，你可以放任何你想放的代码。<br>在开始声明的函数，如yylex等，经常是在这里实现的，我们的示例就是这么搞的。</p><p>我们在前面介绍了PHP是使用re2c作为词法分析器，那么PHP是如何将re2c与bison集成在一起的呢？ 我们以一个从PHP源码中剥离出来的示例来说明整个过程。这个示例的功能与上一小节的示例类似，作用都是识别输入参数中的字符串类型。 本示例是在其基础上添加了语法解析过程。 首先我们看这个示例的语法文件：demo.y</p><pre><code>%{#include &lt;stdio.h&gt;#include &quot;demo_scanner.h&quot;extern int yylex(znode *zendlval);void yyerror(char const *);#define YYSTYPE znode   //关键点一，znode定义在demo_scanner.h   %}%pure_parser    //  关键点二%token T_BEGIN%token T_NUMBER%token T_LOWER_CHAR%token T_UPPER_CHAR%token T_EXIT%token T_UNKNOWN%token T_INPUT_ERROR%token T_END%token T_WHITESPACE%%begin: T_BEGIN {printf(&quot;begin:\ntoken=%d\n&quot;, $1.op_type);}     | begin variable {        printf(&quot;token=%d &quot;, $2.op_type);        if ($2.constant.value.str.len &gt; 0) {            printf(&quot;text=%s&quot;, $2.constant.value.str.val);        }        printf(&quot;\n&quot;);}variable: T_NUMBER {$$ = $1;}|T_LOWER_CHAR {$$ = $1;}|T_UPPER_CHAR {$$ = $1;}|T_EXIT {$$ = $1;}|T_UNKNOWN {$$ = $1;}|T_INPUT_ERROR {$$ = $1;}|T_END {$$ = $1;}|T_WHITESPACE {$$ = $1;}%%void yyerror(char const *s) {    printf(&quot;%s\n&quot;, s);  }</code></pre><p>这个语法文件有两个关键点：</p><p>1.znode是复制PHP源码中的znode，只是这里我们只保留了两个字段，其结构如下：</p><pre><code>typedef union _zvalue_value {    long lval;                  /* long value */    double dval;                /* double value */    struct {        char *val;        int len;    } str;} zvalue_value;typedef struct _zval_struct {    /* Variable information */    zvalue_value value;     /* value */    int type;    /* active type */}zval;typedef struct _znode {    int op_type;    zval constant;}znode;</code></pre><p>这里我们同样也复制了PHP的zval结构，但是我们也只取了关于整型，浮点型和字符串型的结构。 op_type用于记录操作的类型，constant记录分析过程获取的数据。 一般来说，在一个简单的程序中，对所有的语言结构的语义值使用同一个数据类型就足够用了。比如在前一小节的逆波兰记号计算器示例就只有double类型。 而且Bison默认是对于所有语义值使用int类型。如果要指明其它的类型，可以像我们示例一样将YYSTYPE定义成一个宏：</p><pre><code>#define YYSTYPE znode</code></pre><p>2.%pure_parser 在Bison中声明%pure_parse表明你要产生一个可重入(reentrant)的分析器。默认情况下Bison调用的词法分析函数名为yylex，并且其参数为void，如果定义了YYLEX_PARAM，则使用YYLEX_PARAM为参数， 这种情况我们可以在Bison生成的.c文件中发现其是使用#ifdef实现。</p><p>如果声明了%pure_parser，通信变量yylval和yylloc则变为yyparse函数中的局部变量，变量yynerrs也变为在yyparse中的局部变量，而yyparse自己的调用方式并没有改变。比如在我们的示例中我们声明了可重入，并且使用zval类型的变更作为yylex函数的第一个参数，则在生成的.c文件中，我们可以看到yylval的类型变成</p><p>一个可重入(reentrant)程序是在执行过程中不变更的程序；换句话说,它全部由纯(pure)(只读)代码构成。 当可异步执行的时候，可重入特性非常重要。例如，从一个句柄调用不可重入程序可能是不安全的。 在带有多线程控制的系统中，一个非可重入程序必须只能被互锁(interlocks)调用。</p><p>通过声明可重入函数和使用znode参数，我们可以记录分析过程中获取的值和词法分析过程产生的token。 在yyparse调用过程中会调用yylex函数，在本示例中的yylex函数是借助re2c生成的。 在demo_scanner.l文件中定义了词法的规则。大部分规则是借用了上一小节的示例， 在此基础上我们增加了新的yylex函数，并且将zendlval作为通信变量，把词法分析过程中的字符串和token传递回来。 而与此相关的增加的操作为：</p><pre><code>SCNG(yy_text) = YYCURSOR;   //  记录当前字符串所在位置/*!re2c  &lt;!*&gt; {yyleng = YYCURSOR - SCNG(yy_text);} //  记录字符串长度　</code></pre><p>main函数发生了一些改变：</p><pre><code>int main(int argc, char* argv[]){    BEGIN(INITIAL); //  全局初始化，需要放在scan调用之前    scanner_globals.yy_cursor = argv[1];    //将输入的第一个参数作为要解析的字符串    yyparse();    return 0;}</code></pre><p>在新的main函数中，我们新增加了yyparse函数的调用，此函数在执行过程中会自动调用yylex函数。如果需要运行这个程序，则需要执行下面的命令：</p><pre><code>re2c -o demo_scanner.c -c -t demo_scanner_def.h demo_scanner.lbison -d demo.ygcc -o t demo.tab.c demo_scanner.cchmod +x t./t &quot;&lt;?php tipi2011&quot;</code></pre><p>在前面我们以一个小的示例和从PHP源码中剥离出来的示例简单说明了bison的入门和bison与re2c的结合。 当我们用gdb工具Debug PHP的执行流程中编译PHP代码过程如下：</p><pre><code>#0  lex_scan (zendlval=0xbfffccbc) at Zend/zend_language_scanner.c:841#1  0x082bab51 in zendlex (zendlval=0xbfffccb8)    at /home/martin/project/c/phpsrc/Zend/zend_compile.c:4930#2  0x082a43be in zendparse ()    at /home/martin/project/c/phpsrc/Zend/zend_language_parser.c:3280#3  0x082b040f in compile_file (file_handle=0xbffff2b0, type=8)    at Zend/zend_language_scanner.l:343#4  0x08186d15 in phar_compile_file (file_handle=0xbffff2b0, type=8)    at /home/martin/project/c/phpsrc/ext/phar/phar.c:3390#5  0x082d234f in zend_execute_scripts (type=8, retval=0x0, file_count=3)    at /home/martin/project/c/phpsrc/Zend/zend.c:1186#6  0x08281b70 in php_execute_script (primary_file=0xbffff2b0)    at /home/martin/project/c/phpsrc/main/main.c:2225#7  0x08351b97 in main (argc=4, argv=0xbffff424)    at /home/martin/project/c/phpsrc/sapi/cli/php_cli.c:1190</code></pre><p>在PHP源码中，词法分析器的最终是调用re2c规则定义的lex_scan函数，而提供给Bison的函数则为zendlex。 而yyparse被zendparse代替。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84-虚拟机的词法解析</title>
      <link href="/posts/c4ea12a2.html"/>
      <url>/posts/c4ea12a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="84-虚拟机的词法解析"><a href="#84-虚拟机的词法解析" class="headerlink" title="84-虚拟机的词法解析"></a>84-虚拟机的词法解析</h1><p>语言从广义上来讲是人们进行沟通交流的各种表达符号。每种语言都有专属于自己的符号，表达方式和规则。 就编程语言来说，它也是由特定的符号，特定的表达方式和规则组成。 语言的作用是沟通，不管是自然语言，还是编程语言，它们的区别在于自然语言是人与人之间沟通的工具， 而编程语言是人与机器之间的沟通渠道。相对于自然语言，编程语言的历史还非常短， 虽然编程语言是站在历史巨人的基础上创建的，但是它还很小，还是一个小孩。 它只能按编程人员所给的指令翻译成对应的机器可以识别的语言。它就相当于一个转化工具， 将人们的知识或者业务逻辑转化成机器码（机器的语言），让其执行对应的的操作。 而这些指令是一些规则，一些约定，这些规则约定都是由编程语言来处理。</p><p>就PHP语言来说，它也是一组符合一定规则的约定的指令。 在编程人员将自己的想法以PHP语言实现后，通过PHP的虚拟机将这些PHP指令转变成C语言 （可以理解为更底层的一种指令集）指令，而C语言又会转变成汇编语言， 最后汇编语言将根据处理器的规则转变成机器码执行。这是一个更高层次抽象的不断具体化，不断细化的过程。</p><p>这里，我们讨论PHP虚拟机是如何将PHP语言转化成C语言。 从一种语言到另一种语言的转化称之为编译，这两种语言分别可以称之为源语言和目标语言。 这种编译过程通过发生在目标语言比源语言更低级（或者说更底层）。 语言转化的编译过程是由编译器来完成， 编码器通常被分为一系列的过程：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成等。 前面几个阶段（词法分析、语法分析和语义分析）的作用是分析源程序，我们可以称之为编译器的前端。 后面的几个阶段（中间代码生成、代码优化和目标代码生成）的作用是构造目标程序，我们可以称之为编译器的后端。 一种语言被称为编译类语言，一般是由于在程序执行之前有一个翻译的过程， 其中关键点是有一个形式上完全不同的等价程序生成。 而PHP之所以被称为解释类语言，就是因为并没有这样的一个程序生成， 它生成的是中间代码，这只是PHP的一种内部数据结构。</p><p>这里我们会介绍PHP编译器的前端的两个阶段，语法分析、语法分析；后端的一个阶段，中间代码生成。</p><p>在前面我们提到语言转化的编译过程一般分为词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成等六个阶段。 不管是编译型语言还是解释型语言，扫描（词法分析）总是将程序转化成目标语言的第一步。 词法分析的作用就是将整个源程序分解成一个一个的单词， 这样做可以在一定程度上减少后面分析工作需要处理的个体数量，为语法分析等做准备。 除了拆分工作，更多的时候它还承担着清洗源程序的过程，比如清除空格，清除注释等。 词法分析作为编译过程的第一步，在业界已经有多种成熟工具，如PHP在开始使用的是Flex，之后改为re2c， MySQL的词法分析使用的Flex，除此之外还有作为UNIX系统标准词法分析器的Lex等。 这些工具都会读进一个代表词法分析器规则的输入字符串流，然后输出以C语言实做的词法分析器源代码。 这里我们只介绍PHP的现版词法分析器，re2c。</p><p>re2c是一个扫描器制作工具，可以创建非常快速灵活的扫描器。 它可以产生高效代码，基于C语言，可以支持C/C++代码。与其它类似的扫描器不同， 它偏重于为正则表达式产生高效代码（和他的名字一样）。因此，这比传统的词法分析器有更广泛的应用范围。 你可以在sourceforge.net获取源码。</p><p>PHP在最开始的词法解析器是使用的是Flex，后来改为使用re2c。 在源码目录下的Zend/zend_language_scanner.l 文件是re2c的规则文件， 如果需要修改该规则文件需要安装re2c才能重新编译，生成新的规则文件。</p><p>re2c调用方式：</p><pre><code>re2c [-bdefFghisuvVw1] [-o output] [-c [-t header]] file</code></pre><p>我们通过一个简单的例子来看下re2c。如下是一个简单的扫描器，它的作用是判断所给的字符串是数字/小写字母/大小字母。 当然，这里没有做一些输入错误判断等异常操作处理。示例如下：</p><pre><code>#include &lt;stdio.h&gt;char *scan(char *p){#define YYCTYPE char#define YYCURSOR p#define YYLIMIT p#define YYMARKER q#define YYFILL(n)    /*!re2c      [0-9]+ {return &quot;number&quot;;}      [a-z]+ {return &quot;lower&quot;;}      [A-Z]+ {return &quot;upper&quot;;}      [^] {return &quot;unkown&quot;;}     */}int main(int argc, char* argv[]){    printf(&quot;%s\n&quot;, scan(argv[1]));    return 0;}</code></pre><p>如果你是在ubuntu环境下，可以执行下面的命令生成可执行文件。</p><pre><code>re2c -o a.c a.lgcc a.c -o achmod +x a./a 1000</code></pre><p>此时程序会输出number。</p><p>我们解释一下我们用到的几个re2c约定的宏。</p><ul><li>YYCTYPE 用于保存输入符号的类型，通常为char型和unsigned char型</li><li>YYCURSOR 指向当前输入标记， -当开始时，它指向当前标记的第一个字符，当结束时，它指向下一个标记的第一个字符</li><li>YYFILL(n) 当生成的代码需要重新加载缓存的标记时，则会调用YYFILL(n)。</li><li>YYLIMIT 缓存的最后一个字符，生成的代码会反复比较YYCURSOR和YYLIMIT，以确定是否需要重新填充缓冲区。</li></ul><p>参照如上几个标识的说明，可以较清楚的理解生成的a.c文件，当然，re2c不会仅仅只有上面代码所显示的标记， 这只是一个简单示例，更多的标识说明和帮助信息请移步 re2c帮助文档：<a href="http://re2c.org/manual.html。" target="_blank" rel="noopener">http://re2c.org/manual.html。</a></p><p>我们回过头来看PHP的词法规则文件zend_language_scanner.l。 你会发现前面的简单示例与它最大的区别在于每个规则前面都会有一个条件表达式。</p><p>NOTE re2c中条件表达式相关的宏为YYSETCONDITION和YYGETCONDITION，分别表示设置条件范围和获取条件范围。 在PHP的词法规则中共有10种，其全部在zend_language_scanner_def.h文件中。此文件并非手写， 而是re2c自动生成的。如果需要生成和使用条件表达式，在编译成c时需要添加-c 和-t参数。</p><p>在PHP的词法解析中，它有一个全局变量:language_scanner_globals，此变量为一结构体，记录当前re2c解析的状态，文件信息，解析过程信息等。 它在zend_language_scanner.l文件中直接定义如下：</p><pre><code>#ifdef ZTSZEND_API ts_rsrc_id language_scanner_globals_id;#elseZEND_API zend_php_scanner_globals language_scanner_globals;#endif</code></pre><p>在zend_language_scanner.l文件中写的C代码在使用re2c生成C代码时会直接复制到新生成的C代码文件中。 这个变量贯穿了PHP词法解析的全过程，并且一些re2c的实现也依赖于此， 比如前面说到的条件表达式的存储及获取，就需要此变量的协助，我们看这两个宏在PHP词法中的定义：</p><pre><code>//  存在于zend_language_scanner.l文件中#define YYGETCONDITION()  SCNG(yy_state)#define YYSETCONDITION(s) SCNG(yy_state) = s#define SCNG    LANG_SCNG//  存在于zend_globals_macros.h文件中# define LANG_SCNG(v) (language_scanner_globals.v)</code></pre><p>结合前面的全局变量和条件表达式宏的定义，我们可以知道PHP的词法解析是通过全局变量在一次解析过程中存在。 那么这个条件表达式具体是怎么使用的呢？我们看下面一个例子。这是一个可以识别为结束， 识别字符，数字等的简单字符串识别器。它使用了re2c的条件表达式，代码如下：</p><pre><code>#include &lt;stdio.h&gt;#include &quot;demo_def.h&quot;#include &quot;demo.h&quot;Scanner scanner_globals;#define YYCTYPE char#define YYFILL(n)#define STATE(name)  yyc##name#define BEGIN(state) YYSETCONDITION(STATE(state))#define LANG_SCNG(v) (scanner_globals.v)#define SCNG    LANG_SCNG#define YYGETCONDITION()  SCNG(yy_state)#define YYSETCONDITION(s) SCNG(yy_state) = s#define YYCURSOR  SCNG(yy_cursor)#define YYLIMIT   SCNG(yy_limit)#define YYMARKER  SCNG(yy_marker)int scan(){    /*!re2c      &lt;INITIAL&gt;&quot;&lt;?php&quot; {BEGIN(ST_IN_SCRIPTING); return T_BEGIN;}      &lt;ST_IN_SCRIPTING&gt;[0-9]+ {return T_NUMBER;}      &lt;ST_IN_SCRIPTING&gt;[ \n\t\r]+ {return T_WHITESPACE;}      &lt;ST_IN_SCRIPTING&gt;&quot;exit&quot; { return T_EXIT; }      &lt;ST_IN_SCRIPTING&gt;[a-z]+ {return T_LOWER_CHAR;}      &lt;ST_IN_SCRIPTING&gt;[A-Z]+ {return T_UPPER_CHAR;}      &lt;ST_IN_SCRIPTING&gt;&quot;?&gt;&quot; {return T_END;}      &lt;ST_IN_SCRIPTING&gt;[^] {return T_UNKNOWN;}      &lt;*&gt;[^] {return T_INPUT_ERROR;}     */}void print_token(int token) {    switch (token) {        case T_BEGIN: printf(&quot;%s\n&quot;, &quot;begin&quot;);break;        case T_NUMBER: printf(&quot;%s\n&quot;, &quot;number&quot;);break;        case T_LOWER_CHAR: printf(&quot;%s\n&quot;, &quot;lower char&quot;);break;        case T_UPPER_CHAR: printf(&quot;%s\n&quot;, &quot;upper char&quot;);break;        case T_EXIT: printf(&quot;%s\n&quot;, &quot;exit&quot;);break;        case T_UNKNOWN: printf(&quot;%s\n&quot;, &quot;unknown&quot;);break;        case T_INPUT_ERROR: printf(&quot;%s\n&quot;, &quot;input error&quot;);break;        case T_END: printf(&quot;%s\n&quot;, &quot;end&quot;);break;    }}int main(int argc, char* argv[]){    int token;    BEGIN(INITIAL); //  全局初始化，需要放在scan调用之前    scanner_globals.yy_cursor = argv[1];    //将输入的第一个参数作为要解析的字符串    while(token = scan()) {        if (token == T_INPUT_ERROR) {            printf(&quot;%s\n&quot;, &quot;input error&quot;);            break;        }        if (token == T_END) {            printf(&quot;%s\n&quot;, &quot;end&quot;);            break;        }        print_token(token);    }    return 0;}</code></pre><p>和前面的简单示例一样，如果你是在linux环境下，可以使用如下命令生成可执行文件</p><pre><code>re2c -o demo.c -c -t demo_def.h demo.lgcc demo.c -o demo -gchmod +x demo</code></pre><p>在使用re2c生成C代码时我们使用了-c -t demo_def.h参数，这表示我们使用了条件表达式模式，生成条件的定义头文件。 main函数中，在调用scan函数之前我们需要初始化条件状态，将其设置为INITIAL状态。 然后在扫描过程中会直接识别出INITIAL状态，然后匹配&lt;?php字符串识别为开始，如果开始不为&lt;?php，则输出input error。 在扫描的正常流程中，当扫描出&lt;?php后，while循环继续向下走，此时会再次调用scan函数，当前条件状态为ST_IN_SCRIPTING， 此时会跳过INITIAL状态，直接匹配&lt;ST_IN_SCRIPTING&gt;状态后的规则。如果所有的&lt;ST_IN_SCRIPTING&gt;后的规则都无法匹配，输出unkwon。 这只是一个简单的识别示例，但是它是从PHP的词法扫描器中抽离出来的，其实现过程和原理类似。</p><p>那么这种条件状态是如何实现的呢？我们查看demo.c文件，发现在scan函数开始后有一个跳转语句：</p><pre><code>int scan(){#line 25 &quot;demo.c&quot;{    YYCTYPE yych;    switch (YYGETCONDITION()) {    case yycINITIAL: goto yyc_INITIAL;    case yycST_IN_SCRIPTING: goto yyc_ST_IN_SCRIPTING;    }...}</code></pre><p>在zend_language_scanner.c文件的lex_scan函数中也有类型的跳转过程，只是过程相对这里来说if语句多一些，复杂一些。 这就是re2c条件表达式的实现原理。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83-Zend虚拟机</title>
      <link href="/posts/d2c01f8a.html"/>
      <url>/posts/d2c01f8a.html</url>
      
        <content type="html"><![CDATA[<h1 id="83-Zend虚拟机"><a href="#83-Zend虚拟机" class="headerlink" title="83-Zend虚拟机"></a>83-Zend虚拟机</h1><p>通过前面的学习，我们了解到一个PHP文件在服务器端的执行过程包括以下两个大的过程：</p><ol><li>递给php程序需要执行的文件， php程序完成基本的准备工作后启动PHP及Zend引擎， 加载注册的扩展模块。</li><li>初始化完成后读取脚本文件，Zend引擎对脚本文件进行词法分析，语法分析。然后编译成opcode执行。 如过安装了apc之类的opcode缓存， 编译环节可能会被跳过而直接从缓存中读取opcode执行。</li></ol><p>在第二步中，词法分析、语法分析，编译中间代码，执行中间代码等各个部分统称为Zend虚拟机。 与Java、C#等编译型语言相比，PHP少了一个手动编译的过程，它们无需编译即可运行，我们称其为解释性语言。 Java有自己的Java虚拟机，它在多个平台上实现统一语言； C#有自己的.NET虚拟机，它在单一平台实现多种语言； PHP跟他们一样，也有属于自己的Zend虚拟机。它们在本质是相同的，它们都是抽象的计算机。 这些虚拟机都是在某种较底层的语言上抽象出另外一种语言，有自己的指令集，有自己的内存管理体系。 它们最终都会将抽象级别较高的语言实现转化为抽象级别较低的语言实现， 并且实现其它辅助功能，如内存管理，垃圾回收等机制， 以减少程序员在具体实现上的工作，从而可以将更多的时间和精力投入到业务逻辑中。 从抽象层次看，Zend虚拟机比Java等语言更高级一些，这里的高级不是说功能更强大或效率更高， 简单点说，Zend虚拟机离真正的机器实现更远一些。 最近这些年，语言的发展只是不断的抽象，不断的远离机器，没有根本性的变化。</p><p>这里我们从虚拟机的前世今生讲起，叙述Zend虚拟机的实现原理，关键的数据结构， 并其中穿插一个关于语法实现的示例和源码加密解密的过程说明。</p><p>在wiki中虚拟机的定义是： 虚拟机（Virtual Machine），在计算机科学中的体系结构里，是指一种特殊的软件， 他可以在计算机平台和终端用户之间创建一种环境，而终端用户则是基于这个软件所创建的环境来操作软件。 在计算机科学中，虚拟机是指可以像真实机器一样运行程序的计算机的软件实现。</p><p>虚拟机是一种抽象的计算机，它有自己的指令集，有自己的内存管理体系。 在此类虚拟机上实现的语言比较低抽象层次的语言更加明了，更加简单易学。</p><p>PHP文件是如何被解析的，生成的中间代码表示什么，生成的中间代码与实际的PHP代码是如何对应的，生成的中间代码如何被执行的？ 在执行过程中会将会哪些中间的数据？整个虚拟机是否可以优化？如何优化？</p><h2 id="Zend虚拟机体系结构"><a href="#Zend虚拟机体系结构" class="headerlink" title="Zend虚拟机体系结构"></a>Zend虚拟机体系结构</h2><p>从概念层将Zend虚拟机的实现进行抽象，我们可以将Zend虚拟机的体系结构分为：解释层、执行引擎、中间数据层。</p><center><br><img src="images/2012_03_09_01.png" alt><br></center><br><center><br>Zend虚拟机体系结构图<br></center><p>当一段PHP代码进入Zend虚拟机，它会被执行两步操作:编译和执行。 对于一个解释性语言来说，这是一个创造性的举动，但是，现在的实现并不彻底。 现在当PHP代码进入Zend虚拟机后，它虽然会被执行这两步操作，但是这两步操作对于一个常规的执行过程来说却是连续的， 也就是说它并没有转变成和Java这种编译型语言一样：生成一个中间文件存放编译后的结果。 如果每次执行这样的操作，对于PHP脚本的性能来说是一个极大的损失。 虽然有类似于APC，eAccelerator等缓存解决方案。但是其本质上是没有变化的，并且不能将两个步骤分离，各自发展壮大。</p><h2 id="解释层"><a href="#解释层" class="headerlink" title="解释层"></a>解释层</h2><p>解释层是Zend虚拟机执行编译过程的位置。它包括词法解析、语法解析和编译生成中间代码三个部分。 词法分析就是将我们要执行的PHP源文件，去掉空格，去掉注释，切分为一个个的标记(token)， 并且处理程序的层级结构(hierarchical structure)。</p><p>语法分析就是将接受的标记(token)序列，根据定义的语法规则，来执行一些动作，Zend虚拟机现在使用的Bison使用巴科斯范式(BNF)来描述语法。 编译生成中间代码是根据语法解析的结果对照Zend虚拟机制定的opcode生成中间代码， 在PHP5.3.1中，Zend虚拟机支持135条指令（见Zend/zend_vm_opcodes.h文件）， 无论是简单的输出语句还是程序复杂的递归调用，Zend虚拟机最终都会将所有我们编写的PHP代码转化成这135条指令的序列， 之后在执行引擎中按顺序执行。</p><h2 id="中间数据层"><a href="#中间数据层" class="headerlink" title="中间数据层"></a>中间数据层</h2><p>当Zend虚拟机执行一个PHP代码时，它需要内存来存储许多东西， 比如，中间代码，PHP自带的函数列表，用户定义的函数列表，PHP自带的类，用户自定义的类， 常量，程序创建的对象，传递给函数或方法的参数，返回值，局部变量以及一些运算的中间结果等。 我们把这些所有的存放数据的地方称为中间数据层。</p><p>如果PHP以mod扩展的方式依附于Apache2服务器运行，中间数据层的部分数据可能会被多个线程共享，如果PHP自带的函数列表等。 如果只考虑单个进程的方式，当一个进程被创建时它就会被加载PHP自带的各种函数列表，类列表，常量列表等。 当解释层将PHP代码编译完成后，各种用户自定义的函数，类或常量会添加到之前的列表中， 只是这些函数在其自身的结构中某些字段的赋值是不一样的。</p><p>当执行引擎执行生成的中间代码时，会在Zend虚拟机的栈中添加一个新的执行中间数据结构（zend_execute_data）， 它包括当前执行过程的活动符号列表的快照、一些局部变量等。</p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>Zend虚拟机的执行引擎是一个非常简单的实现，它只是依据中间代码序列（EX(opline)）,一步一步调用对应的方法执行。 在执行引擎中没并有类似于PC寄存器一样的变量存放下一条指令，当Zend虚拟机执行到某条指令时，当它所有的任务都执行完了， 这条指令会自己调用下一条指令，即将序列的指针向前移动一个位置，从而执行下一条指令，并且在最后执行return语句，如此反复。 这在本质上是一个函数嵌套调用。</p><p>回到开头的问题，PHP通过词法分析、语法分析和中间代码生成三个步骤后，PHP文件就会被解析成PHP的中间代码opcode。 生成的中间代码与实际的PHP代码之间并没有完全的一一对应关系。只是针对用户所给的PHP代码和PHP的语法规则和一些内部约定生成中间代码， 并且这些中间代码还需要依靠一些全局变量中转数据和关联。至于生成的中间代码的执行过程是依据中间代码的顺利， 依赖于执行过程中的全局变量，一步步执行。当然，在遇到一些函数跳转也会发生偏移，但是最终还是会回到偏移点。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>82-资源resource类型</title>
      <link href="/posts/861f2c56.html"/>
      <url>/posts/861f2c56.html</url>
      
        <content type="html"><![CDATA[<h1 id="82-资源resource类型"><a href="#82-资源resource类型" class="headerlink" title="82-资源resource类型"></a>82-资源resource类型</h1><p>讲述之前，先描述下{资源}类型在内核中的结构：</p><pre><code>//每一个资源都是通过它来实现的。typedef struct _zend_rsrc_list_entry{    void *ptr;    int type;    int refcount;}zend_rsrc_list_entry;</code></pre><p>在真实世界中，我们经常需要操作一些不好用标量值表现的数据，比如某个文件的句柄，而对于C来说，它也仅仅是个指针而已。</p><pre><code>#include &lt;stdio.h&gt;int main(void){    FILE *fd;    fd = fopen(&quot;/home/jdoe/.plan&quot;, &quot;r&quot;);    fclose(fd);    return 0;}</code></pre><p>C语言中stdio的文件描述符(file descriptor)是与每个打开的文件相匹配的一个变量，它实际上十一个FILE类型的指针，它将在程序与硬件交互通讯时使用。我们可以使用fopen函数来打开一个文件获取句柄，之后只需把这个句柄传递给feof()、fread()、fwrite()、fclose()之类的函数，便可以对这个文件进行后续操作了。既然这个数据在C语言中就无法直接用标量数据来表示，那我们如何对其进行封装才能保证用户在PHP语言中也能使用到它呢？这便是PHP中资源类型变量的作用了！所以它也是通过一个zval结构来进行封装的。</p><p>资源类型的实现并不复杂，它的值其实仅仅是一个整数，内核将根据这个整数值去一个类似资源池的地方寻找最终需要的数据。</p><h2 id="资源类型变量的使用"><a href="#资源类型变量的使用" class="headerlink" title="资源类型变量的使用"></a>资源类型变量的使用</h2><p>资源类型的变量在实现中也是有类型区分的！为了区分不同类型的资源，比如一个是文件句柄，一个是mysql链接，我们需要为其赋予不同的分类名称。首先，我们需要先把这个分类添加到程序中去。这一步的操作可以在MINIT中来做：</p><pre><code>#define PHP_SAMPLE_DESCRIPTOR_RES_NAME &quot;山寨文件描述符&quot;static int le_sample_descriptor;ZEND_MINIT_FUNCTION(sample){    le_sample_descriptor = zend_register_list_destructors_ex(NULL, NULL, PHP_SAMPLE_DESCRIPTOR_RES_NAME,module_number);    return SUCCESS;}//附加资料#define register_list_destructors(ld, pld) zend_register_list_destructors((void (*)(void *))ld, (void (*)(void *))pld, module_number);ZEND_API int zend_register_list_destructors(void (*ld)(void *), void (*pld)(void *), int module_number);ZEND_API int zend_register_list_destructors_ex(rsrc_dtor_func_t ld, rsrc_dtor_func_t pld, char *type_name, int module_number);</code></pre><p>接下来，我们把定义好的MINIT阶段的函数添加到扩展的module_entry里去，只需要把原来的”NULL, /<em> MINIT </em>/“一行替换掉即可：</p><pre><code>ZEND_MINIT(sample), /* MINIT */</code></pre><p>ZEND_MINIT_FUNCTION()宏用来帮助我们定义MINIT阶段的函数。看到zend_register_list_destructors_ex()函数，你肯定回想是不是也存在一个zend_register_list_destructors()函数呢？是的，确实有这么一个函数，它的参数中比前者少了资源类别的名称。那这两这的区别在哪呢？</p><pre><code>eaco $re_1;//resource(4) of type (山寨版File句柄)echo $re_2;//resource(4) of type (Unknown)</code></pre><h2 id="创建资源"><a href="#创建资源" class="headerlink" title="创建资源"></a>创建资源</h2><p>我们在上面向内核中注册了一种新的资源类型，下一步便可以创建这种类型的资源变量了。接下来让我们简单的重新实现一个fopen函数，现在叫sample_open：</p><pre><code>PHP_FUNCTION(sample_fopen){    FILE *fp;    char *filename, *mode;    int filename_len, mode_len;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;ss&quot;,&amp;filename, &amp;filename_len,&amp;mode, &amp;mode_len) == FAILURE)    {        RETURN_NULL();    }    if (!filename_len || !mode_len)    {        php_error_docref(NULL TSRMLS_CC, E_WARNING,&quot;Invalid filename or mode length&quot;);            RETURN_FALSE;    }    fp = fopen(filename, mode);    if (!fp)    {        php_error_docref(NULL TSRMLS_CC, E_WARNING,&quot;Unable to open %s using mode %s&quot;,filename, mode);            RETURN_FALSE;    }    //将fp添加到资源池中去，并标记它为le_sample_descriptor类型的。    ZEND_REGISTER_RESOURCE(return_value,fp,le_sample_descriptor);}</code></pre><p>如果前面章节的知识你都看过的话，应该可以猜出最后一行代码是干啥的了。它创建了一个新的le_sample_descriptor类型的资源，此资源的值是fp，另外它把这个资源加入到一个存储资源的HashTable中，并把此资源在其中对应的数字Key赋给return_value。</p><p>资源并不局限与文件句柄，我们可以申请一块内存，并它指向它的指针来作为一种资源。所以资源可以对应任意类型的数据。</p><h2 id="销毁资源"><a href="#销毁资源" class="headerlink" title="销毁资源"></a>销毁资源</h2><p>世间万物皆有喜有悲，有生有灭，到了我们探讨如何销毁资源的时候了。最简单的一种莫非于仿照fclose写一个sample_close()函数，在它里面实现对某种{资源：专指PHP的资源类型变量代表的值}的释放。</p><p>但是，如果用户端的脚本通过unset()函数来释放某个资源类型的变量会如何呢？它们可不知道它的值最终对应一个FILE<em>指针啊，所以也无法使用fclose()函数来释放它，这个FILE</em>句柄很有可能会一直存在于内存中，直到PHP程序挂掉，由OS来回收。但在一个平常的Web环境中，我们的服务器都会长时间运行的。</p><p>难道就没有解决方案了吗？当然不是，谜底就在那个NULL参数里，就是我们在上面为了生成新的资源类型，调用的zend_register_list_destructors_ex()函数的第一个参数和第二个参数。这两个参数都各自代表一个回调参数。第一个回调函数会在脚本中的相应类型的资源变量被释放掉的时候触发，比如作用域结束了，或者被unset()掉了。</p><p>第二个回调函数则是用在一个类似与长链接类型的资源上的，也就是这个资源创建后会一直存在于内存中，而不会在request结束后被释放掉。它将会在Web服务器进程终止时调用，相当与在MSHUTDOWN阶段被内核调用。</p><p>我们先来定义第一种回调函数。</p><pre><code>static void php_sample_descriptor_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC){    FILE *fp = (FILE*)rsrc-&gt;ptr;    fclose(fp);}</code></pre><p>然后用它替换掉zend_register_list_destructors_ex()函数的第一个参数NULL：</p><pre><code>le_sample_descriptor = zend_register_list_destructors_ex(php_sample_descriptor_dtor,NULL,PHP_SAMPLE_DESCRIPTOR_RES_NAME,module_number);</code></pre><p>现在，如果脚本中得到了一个上述类型的资源变量，当它被unset的时候，或者因为作用域执行完被内核释放掉的时候都会被内核调用底层的php_sample_descriptor_dtor来预处理它。这样一来，貌似我们根本就不需要sample_close()函数了！</p><pre><code>&lt;?php  $fp = sample_fopen(&quot;/home/jdoe/notes.txt&quot;, &quot;r&quot;);  unset($fp);?&gt;</code></pre><p>unset($fp)执行后，内核会自动的调用php_sample_descriptor_dtor函数来清理这个变量对应的一些数据。当然，事情绝对没有这么简单，让我们先记住这个疑问，继续往下看。</p><h3 id="Decoding-Resources"><a href="#Decoding-Resources" class="headerlink" title="Decoding Resources"></a>Decoding Resources</h3><p>我们把资源变量比作书签，可如果仅有书签的话绝对没有任何作用啊！我们需要通过书签找到相应的页才行。对于资源变量，我们必须能够通过它找到相应的最终数据才行！</p><pre><code>ZEND_FUNCTION(sample_fwrite){    FILE *fp;    zval *file_resource;    char *data;    int data_len;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;rs&quot;,&amp;file_resource, &amp;data, &amp;data_len) == FAILURE )    {        RETURN_NULL();    }    /* Use the zval* to verify the resource type and     * retrieve its pointer from the lookup table */    ZEND_FETCH_RESOURCE(fp,FILE*,&amp;file_resource,-1,PHP_SAMPLE_DESCRIPTOR_RES_NAME,le_sample_descriptor);    /* Write the data, and     * return the number of bytes which were     * successfully written to the file */    RETURN_LONG(fwrite(data, 1, data_len, fp));}</code></pre><p>zend_parse_parameters()函数中的r占位符代表着接收资源类型的变量，它的载体是一个zval*。然后让我们看一下ZEND_FETCH_RESOURCE()宏函数。</p><pre><code>#define ZEND_FETCH_RESOURCE(rsrc, rsrc_type, passed_id,default_id, resource_type_name, resource_type)    rsrc = (rsrc_type) zend_fetch_resource(passed_id TSRMLS_CC,default_id, resource_type_name, NULL,1, resource_type);    ZEND_VERIFY_RESOURCE(rsrc);//在我们的例子中，它是这样的：fp = (FILE*) zend_fetch_resource(&amp;file_descriptor TSRMLS_CC, -1,PHP_SAMPLE_DESCRIPTOR_RES_NAME, NULL,1, le_sample_descriptor);if (!fp){    RETURN_FALSE;}</code></pre><p>zend_fetch_resource()是对zend_hash_find()的一层封装，它使用一个数字key去一个保存各种{资源}的HashTable中寻找最终需要的数据，找到之后，我们用ZEND_VERIFY_RESOURCE()宏函数校验一下这个数据。从上面的代码中我们可以看出，NULL、0是绝对不能作为一种资源的。</p><p>上面的例子中，zend_fetch_resource()函数首先获取le_sample_descriptor代表的资源类型，如果资源不存在或者接收的zval不是一个资源类型的变量，它便会返回NULL，并抛出相应的错误信息。</p><p>最后的ZEND_VERIFY_RESOURCE()宏函数如果检测到错误，便会自动返回，是我们可以从错误检测中脱离出来，更加专注与程序的主逻辑。现在我们已经获取到了相应的FILE*了，下面就用fwrite()像其中写入点数据吧！</p><p>我们也可以通过另一种方法来获取我们最终想要的数据。</p><pre><code>ZEND_FUNCTION(sample_fwrite){    FILE *fp;    zval *file_resource;    char *data;    int data_len, rsrc_type;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;rs&quot;,&amp;file_resource, &amp;data, &amp;data_len) == FAILURE ) {        RETURN_NULL();    }    fp = (FILE*)zend_list_find(Z_RESVAL_P(file_resource),&amp;rsrc_type);    if (!fp || rsrc_type != le_sample_descriptor) {        php_error_docref(NULL TSRMLS_CC, E_WARNING,&quot;Invalid resource provided&quot;);        RETURN_FALSE;    }    RETURN_LONG(fwrite(data, 1, data_len, fp));}</code></pre><p>可以根据自己习惯来选择到底使用哪一种形式，不过推荐使用ZEND_FETCH_RESOURCE()宏函数。</p><h3 id="Forcing-Destruction"><a href="#Forcing-Destruction" class="headerlink" title="Forcing Destruction"></a>Forcing Destruction</h3><p>在上面我们还有个疑问没有解决，就类似与我们上面实现的unset($fp)真的是万能的么？当然不是，看一下下面的代码：</p><pre><code>&lt;?php  $fp = sample_fopen(&quot;/home/jdoe/world_domination.log&quot;, &quot;a&quot;);  $evil_log = $fp;  unset($fp);?&gt;</code></pre><p>这次，$fp和$evil_log共用一个zval，虽然$fp被释放了，但是它的zval并不会被释放，因为$evil_log还在用着。也就是说，现在$evil_log代表的文件句柄仍然是可以写入的！所以为了避免这种错误，真的需要我们手动来close it！sample_close()函数是必须存在的！</p><pre><code>PHP_FUNCTION(sample_fclose){    FILE *fp;    zval *file_resource;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;r&quot;,&amp;file_resource) == FAILURE ) {        RETURN_NULL();    }    /* While it&apos;s not necessary to actually fetch the     * FILE* resource, performing the fetch provides     * an opportunity to verify that we are closing     * the correct resource type. */    ZEND_FETCH_RESOURCE(fp, FILE*, &amp;file_resource, -1,PHP_SAMPLE_DESCRIPTOR_RES_NAME, le_sample_descriptor);    /* Force the resource into self-destruct mode */    zend_hash_index_del(&amp;EG(regular_list),Z_RESVAL_P(file_resource));    RETURN_TRUE;}</code></pre><p>这个删除操作也再次说明了资源数据是保存在HashTable中的。虽然我们可以通过zend_hash_index_find()或者zend_hash_next_index_insert()之类的函数操作这个储存资源的HashTable，但这绝不是一个好主意，因为在后续的版本中，PHP可能会修改有关这一部分的实现方式，到那时上述方法便不起作用了，所以为了更好的兼容性，请使用标准的宏函数或者api函数。</p><p>当我们在EG(regular_list)这个HashTable中删除数据的时候，回调用一个dtor函数，它根据资源变量的类别来调用相应的dtor函数实现，就是我们调用zend_register_list_destructors_ex()函数时的第一个参数。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>81-继承与实现接口</title>
      <link href="/posts/7bac6e8d.html"/>
      <url>/posts/7bac6e8d.html</url>
      
        <content type="html"><![CDATA[<h1 id="81-继承与实现接口"><a href="#81-继承与实现接口" class="headerlink" title="81-继承与实现接口"></a>81-继承与实现接口</h1><p>在定义一个类时往往会使其继承某个父类或者实现某个接口，在扩展中实现这个功能非常方便。下面我先给出PHP语言中的代码。</p><pre><code>&lt;?phpinterface i_myinterface{    public function hello();}class parent_class implements i_myinterface{    public function hello()    {        echo &quot;Good Morning!\n&quot;;    }}final class myclass extends parent_class{    public function call_hello()    {        $this-&gt;hello();    }}?&gt;</code></pre><p>上面的代码我们已经非常熟悉了，它们在PHP扩展中的实现应该是这样的：</p><pre><code>//三个zend_class_entryzend_class_entry *i_myinterface_ce,*parent_class_ce,*myclass_ce;//parent_class的hello方法ZEND_METHOD(parent_class,hello){    php_printf(&quot;hello world!\n&quot;);}//myclass的call_hello方法ZEND_METHOD(myclass,call_hello){    //这里涉及到如何调用对象的方法，详细内容下一章叙述    zval *this_zval;    this_zval = getThis();    zend_call_method_with_0_params(&amp;this_zval,myclass_ce,NULL,&quot;hello&quot;,NULL);}//各自的zend_function_entrystatic zend_function_entry i_myinterface_method[]={    ZEND_ABSTRACT_ME(i_myinterface,    hello,    NULL)    {NULL,NULL,NULL}};static zend_function_entry parent_class_method[]={    ZEND_ME(parent_class,hello,NULL,ZEND_ACC_PUBLIC)    {NULL,NULL,NULL}};static zend_function_entry myclass_method[]={    ZEND_ME(myclass,call_hello,NULL,ZEND_ACC_PUBLIC)    {NULL,NULL,NULL}};ZEND_MINIT_FUNCTION(test){    zend_class_entry ce,p_ce,i_ce;    INIT_CLASS_ENTRY(i_ce,&quot;i_myinterface&quot;,i_myinterface_method);    i_myinterface_ce = zend_register_internal_interface(&amp;i_ce TSRMLS_CC);    //定义父类，最后使用zend_class_implements函数声明它实现的接口    INIT_CLASS_ENTRY(p_ce,&quot;parent_class&quot;,parent_class_method);    parent_class_ce = zend_register_internal_class(&amp;p_ce TSRMLS_CC);    zend_class_implements(parent_class_ce TSRMLS_CC,1,i_myinterface_ce);    //定义子类，使用zend_register_internal_class_ex函数    INIT_CLASS_ENTRY(ce,&quot;myclass&quot;,myclass_method);    myclass_ce = zend_register_internal_class_ex(&amp;ce,parent_class_ce,&quot;parent_class&quot; TSRMLS_CC);    //注意：ZEND_ACC_FINAL是用来修饰方法的，而ZEND_ACC_FINAL_CLASS是用来修饰类的    myclass_ce-&gt;ce_flags |= ZEND_ACC_FINAL_CLASS;    return SUCCESS;}</code></pre><p>这样，当我们在PHP语言中进行如下操作时，便会得到预期的输出：</p><pre><code>&lt;?php$obj = new myclass();$obj-&gt;hello();/*输出内容：walu@walu-ThinkPad-Edge:/cnan/program/php-5.3.6/ext/test$ php test.phphello world!*/?&gt;</code></pre><p>这里的ZEND_ABSTRACT_ME()宏函数比较特殊，它会声明一个abstract public类型的函数，这个函数不需要我们实现，因此也就不需要相应的ZEND_METHOD(i_myinterface,hello){…}的实现。一般来说，一个接口是不能设计出某个非public类型的方法的，因为接口暴露给使用者的都应该是一些公开的信息。不过如果你非要这么设计，那也不是办不到，只要别用ZEND_ABSTRACT_ME()宏函数就行了，而用它的底层实现ZEND_FN()宏函数。</p><pre><code>//它可以对应&lt;?php ...public static function apply_request();...的接口方法声明。static zend_function_entry i_myinterface[]={    ZEND_FENTRY(apply_request, NULL, NULL, ZEND_ACC_STATIC|ZEND_ACC_ABSTRACT|ZEND_ACC_PUBLIC)    {NULL,NULL,NULL}};</code></pre><p>这样，只要掩码中有ZEND_ACC_ABSTRACT，便代表是一个不需要具体实现的方法。ZEND_FENTRY其实是ZEND_ME和ZEND_FE的最终实现，现在我们把这一组宏罗列在这一次展开，供你参考使用。</p><pre><code>#define ZEND_FENTRY(zend_name, name, arg_info, flags)    { #zend_name, name, arg_info, (zend_uint) (sizeof(arg_info)/sizeof(struct _zend_arg_info)-1), flags },#define ZEND_FN(name) zif_##name#define ZEND_MN(name) zim_##name#define ZEND_FE(name, arg_info)                        ZEND_FENTRY(name, ZEND_FN(name), arg_info, 0)#define ZEND_ME(classname, name, arg_info, flags)    ZEND_FENTRY(name, ZEND_MN(classname##_##name), arg_info, flags)</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>80-定义接口</title>
      <link href="/posts/75b33594.html"/>
      <url>/posts/75b33594.html</url>
      
        <content type="html"><![CDATA[<h1 id="80-定义接口"><a href="#80-定义接口" class="headerlink" title="80-定义接口"></a>80-定义接口</h1><p>定义一个接口还是很方便的，我先给出一个PHP语言中的形式。</p><pre><code>&lt;?phpinterface i_myinterface{    public function hello();}?&gt;</code></pre><p>那它在扩展中的实现是这样的。</p><pre><code>zend_class_entry *i_myinterface_ce;static zend_function_entry i_myinterface_method[]={    ZEND_ABSTRACT_ME(i_myinterface, hello, NULL) //注意这里的null指的是arginfo    {NULL,NULL,NULL}};ZEND_MINIT_FUNCTION(test){    zend_class_entry ce;    INIT_CLASS_ENTRY(ce, &quot;i_myinterface&quot;, i_myinterface_method);    i_myinterface_ce = zend_register_internal_interface(&amp;ce TSRMLS_CC);    return SUCCESS;}</code></pre><p>我们使用ZEND_ABSTRACT_ME()宏函数来为这个接口添加函数，它的作用是声明一个类似虚函数的东西，不用实现。也就是说我们不用为其添加ZEND_METHOD(i_myinterface,hello){…}的实现。但是这个宏函数只能为我们实现public类型的函数声明，如果有其它特殊需要，需要使用ZEND_FENTRY()宏函数来实现，因为ZEND_ABSTRACT_ME也不过是后者的一种封装。</p><p>下面我们在PHP语言中使用这个接口。</p><pre><code>&lt;?phpclass sample implements i_myinterface{    public $name = &quot;hello world!&quot;;    public function hello()    {        echo $this-&gt;name.&quot;\n&quot;;    }}$obj = new sample();$obj-&gt;hello();?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79-命名空间</title>
      <link href="/posts/24666495.html"/>
      <url>/posts/24666495.html</url>
      
        <content type="html"><![CDATA[<h1 id="79-命名空间"><a href="#79-命名空间" class="headerlink" title="79-命名空间"></a>79-命名空间</h1><p>在维基百科中，对命名空间的定义是： 命名空间（英语：Namespace）表示标识符（identifier）的上下文（context）。一个标识符可在多个命名空间中定义， 它在不同命名空间中的含义是互不相干的。在编程语言中，命名空间是一种特殊的作用域，它包含了处于该作用域内的标识符， 且本身也用一个标识符来表示，这样便将一系列在逻辑上相关的标识符用一个标识符组织了起来。 函数和类的作用域可被视作隐式命名空间，它们和可见性、可访问性和对象生命周期不可分割的联系在一起。</p><p>命名空间可以看作是一种封装事物的方法，同时也可以看作是组织代码结构的一种形式，在很多语言中都可以见到这种抽象概念和组织形式。 在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题：</p><ol><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ol><p>PHP从5.3.0版本开始支持命名空间特性。看一个定义和使用命名空间的示例：</p><pre><code>&lt;?phpnamespace tipi;class Exception {    public static $var = &apos;think in php internal&apos;;}const E_ALL = &quot;E_ALL IN Tipi&quot;;function strlen(){    echo &apos;strlen in tipi&apos;;}echo Exception::$var;echo strlen(Exception::$var);?&gt;</code></pre><p>如上所示，定义了命名空间tipi，在这个命名空间内定义了一个Exception类，一个E_ALL常量和一个函数strlen。 这些类、常量和函数PHP默认已经实现。假如没有这个命名空间，声明这些类、常量或函数时会报函数重复声明或类重复声明的错误， 并且常量的定义也不会成功。</p><p>从PHP语言来看，命名空间通过 namespace 关键字定义，在命名空间内，可以包括任何合法的PHP代码，但是它的影响范围仅限于类、常量和函数。 从语法上来讲，PHP支持在一个文件中定义多个命名空间，但是不推荐这种代码组织方式。 当需要将全局的非命名空间中的代码与命名空间中的代码组合在一起，全局代码必须用一个不带名称的 namespace 语句加上大括号括起来。</p><p>此时，思考一下，在PHP内核中，命名空间的定义是如何实现的呢？ 当在多个命名空间中存在多个相同的函数或类时，如何区分？ 命名空间内的函数如何调用？</p><h2 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h2><p>命名空间在PHP中的实现方案比较简单，不管是函数，类或者常量， 在声明的过程中都将命名空间与定义的函数名以\合并起来，作为函数名或类名存储在其对应的容器中。 如上面示例中的Exception类，最后存储的类名是tipi\Exception。 对于整个PHP实现的架构来说，这种实现方案的代价和对整个代码结构的调整都是最小的。</p><p>下面我们以Exception类为例说明整个命名空间的实现。 命名空间实现的关键字是namespace，从此关键字开始我们可以找到在编译时处理此关键字的函数为 zend_do_begin_namespace。 在此函数中，关键是在对CG(current_namespace)的赋值操作，这个值在后面类声明或函数等声明时都会有用到。</p><p>在前面我们讲过，类声明的实现在编译时会调用Zend/zend_complie.c文件中的zend_do_begin_class_declaration函数， 在此函数中对于命名空间的处理代码如下：</p><pre><code>if (CG(current_namespace)) {    /* Prefix class name with name of current namespace */    znode tmp;    tmp.u.constant = *CG(current_namespace);    zval_copy_ctor(&amp;tmp.u.constant);    zend_do_build_namespace_name(&amp;tmp, &amp;tmp, class_name TSRMLS_CC);    class_name = &amp;tmp;    efree(lcname);    lcname = zend_str_tolower_dup(Z_STRVAL(class_name-&gt;u.constant), Z_STRLEN(class_name-&gt;u.constant));}</code></pre><p>这段代码的作用是如果当前存在命名空间，则给类名加上命名空间的前缀， 如前面提到示例中的tipi\Exception类，添加tipi\的操作就是在这里执行的。 在zend_do_build_namespace_name函数中最终会调用zend_do_build_full_name函数实现类名的合并。 在函数和常量的声明中存在同样的名称合并操作。这也是命名空间仅对类、常量和函数有效的原因。</p><h2 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h2><p>以函数调用为例，当需要调用函数时，会调用zend_do_begin_function_call函数。 在此函数中，当使用到命名空间时会检查函数名，其调用的函数为zend_resolve_non_class_name。 在zend_resolve_non_class_name函数中会根据类型作出判断并返回相关结果：</p><ol><li>完全限定名称的函数： 程序首先会做此判断，其判断的依据是第一个字符是否为”\”，这种情况下，在解析时会直接返回。 如类似于\strlen这样以\开头的全局调用或类似于前面定义的\tipi\Exception调用。</li><li>所有的非限定名称和限定名称（非完全限定名称）：根据当前的导入规则 程序判断是否为别名，并从编译期间存储别名的HashTable中取出对应的命名空间名称，将其与现有的函数名合并。 关于别名的存储及生成在后面的内容中会说明，</li><li>在命名空间内部： 所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。最后判断是否在当前命名空间， 最终程序都会返回一个合并了命名空间的函数名。</li></ol><h2 id="别名-导入"><a href="#别名-导入" class="headerlink" title="别名/导入"></a>别名/导入</h2><p>允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。 这有点类似于在类 unix 文件系统中可以创建对其它的文件或目录的符号连接。 PHP 命名空间支持 有两种使用别名或导入方式：为类名称使用别名，或为命名空间名称使用别名。</p><p>PHP不支持导入函数或常量。</p><p>在PHP中，别名是通过操作符 use 来实现的。从而我们可以从源码中找到编译时调用的函数是zend_do_use。 别名在编译为中间代码过程中存放在CG(current_import)中，这是一个HashTable。 zend_do_use整个函数的实现基本上是一个查找，判断是否错误，最后写入到HashTable的过程。 其中针对命名空间和类名都有导入的处理过程，而对于常量和函数来说却没有， 这就是PHP不支持导入函数或常量的根本原因所在。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78-对象属性读写</title>
      <link href="/posts/358abb1f.html"/>
      <url>/posts/358abb1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="78-对象属性读写"><a href="#78-对象属性读写" class="headerlink" title="78-对象属性读写"></a>78-对象属性读写</h1><p>这一节主要描述与对象属性有关的东西。有关如何对它进行定义的操作我们已经在上一章中描述过了，这里不再叙述，只讲对其的操作。</p><h2 id="读取对象的属性"><a href="#读取对象的属性" class="headerlink" title="读取对象的属性"></a>读取对象的属性</h2><pre><code>ZEND_API zval *zend_read_property(zend_class_entry *scope, zval *object, char *name, int name_length, zend_bool silent TSRMLS_DC);ZEND_API zval *zend_read_static_property(zend_class_entry *scope, char *name, int name_length, zend_bool silent TSRMLS_DC);</code></pre><p>zend_read_property函数用于读取对象的属性，而zend_read_static_property则用于读取静态属性。可以看出，静态属性是直接保存在类上的，用具体的对象无关。</p><p>silent参数：</p><ul><li>0: 如果属性不存在，则抛出一个notice错误。</li><li>1: 如果属性不存在，不报错。</li></ul><p>如果所查的属性不存在，那么此函数将返回IS_NULL类型的zval。</p><p>更新对象的属性：</p><pre><code>ZEND_API void zend_update_property(zend_class_entry *scope, zval *object, char *name, int name_length, zval *value TSRMLS_DC);ZEND_API int zend_update_static_property(zend_class_entry *scope, char *name, int name_length, zval *value TSRMLS_DC);</code></pre><p>zend_update_property用来更新对象的属性，zend_update_static_property用来更新类的静态属性。如果对象或者类中没有相关的属性，函数将自动的添加上。</p><h2 id="读写对象与类属性的实例"><a href="#读写对象与类属性的实例" class="headerlink" title="读写对象与类属性的实例"></a>读写对象与类属性的实例</h2><p>假设我们已经在扩展中定义好下面的类：</p><pre><code>class baby{    public $age;    public static $area;    public function __construct($age, $area)    {        $this-&gt;age = $age;        self::$area = $area;        var_dump($this-&gt;age, self::$area);    }}ZEND_METHOD(baby, __construct){    zval *age, *area;    zend_class_entry *ce;    ce = Z_OBJCE_P(getThis());    if( zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;zz&quot;, &amp;age, &amp;area) == FAILURE )    {        printf(&quot;Error\n&quot;);        RETURN_NULL();    }    zend_update_property(ce, getThis(), &quot;age&quot;, sizeof(&quot;age&quot;)-1, age TSRMLS_CC);    zend_update_static_property(ce, &quot;area&quot;, sizeof(&quot;area&quot;)-1, area TSRMLS_CC);    age = NULL;    area = NULL;    age = zend_read_property(ce, getThis(), &quot;age&quot;, sizeof(&quot;age&quot;)-1, 0 TSRMLS_DC);    php_var_dump(&amp;age, 1 TSRMLS_CC);    area = zend_read_static_property(ce, &quot;area&quot;, sizeof(&quot;area&quot;)-1, 0 TSRMLS_DC);    php_var_dump(&amp;area, 1 TSRMLS_CC);}</code></pre><h2 id="一些其它的快捷函数"><a href="#一些其它的快捷函数" class="headerlink" title="一些其它的快捷函数"></a>一些其它的快捷函数</h2><pre><code>ZEND_API void zend_update_property_null(zend_class_entry *scope, zval *object, char *name, int name_length TSRMLS_DC);ZEND_API void zend_update_property_bool(zend_class_entry *scope, zval *object, char *name, int name_length, long value TSRMLS_DC);ZEND_API void zend_update_property_long(zend_class_entry *scope, zval *object, char *name, int name_length, long value TSRMLS_DC);ZEND_API void zend_update_property_double(zend_class_entry *scope, zval *object, char *name, int name_length, double value TSRMLS_DC);ZEND_API void zend_update_property_string(zend_class_entry *scope, zval *object, char *name, int name_length, const char *value TSRMLS_DC);ZEND_API void zend_update_property_stringl(zend_class_entry *scope, zval *object, char *name, int name_length, const char *value, int value_length TSRMLS_DC);ZEND_API int zend_update_static_property_null(zend_class_entry *scope, char *name, int name_length TSRMLS_DC);ZEND_API int zend_update_static_property_bool(zend_class_entry *scope, char *name, int name_length, long value TSRMLS_DC);ZEND_API int zend_update_static_property_long(zend_class_entry *scope, char *name, int name_length, long value TSRMLS_DC);ZEND_API int zend_update_static_property_double(zend_class_entry *scope, char *name, int name_length, double value TSRMLS_DC);ZEND_API int zend_update_static_property_string(zend_class_entry *scope, char *name, int name_length, const char *value TSRMLS_DC);ZEND_API int zend_update_static_property_stringl(zend_class_entry *scope, char *name, int name_length, const char *value, int value_length TSRMLS_DC);</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77-创建对象实例</title>
      <link href="/posts/eacee2b6.html"/>
      <url>/posts/eacee2b6.html</url>
      
        <content type="html"><![CDATA[<h1 id="77-创建对象实例"><a href="#77-创建对象实例" class="headerlink" title="77-创建对象实例"></a>77-创建对象实例</h1><p>为了操作一个对象，我们需要先获取这个对象的实例，而这有肯定会涉及调用对象的构造方法。首先我们先了解下一个object在PHP内核中到底是如何实现的。</p><pre><code>typedef struct _zend_object_value {    zend_object_handle handle;    zend_object_handlers *handlers;} zend_object_value;//此外再回顾一下zval的值value的结构。typedef union _zvalue_value {    long lval;                    /* long value */    double dval;                /* double value */    struct {        char *val;        int len;    } str;    HashTable *ht;                /* hash table value */    zend_object_value obj;} zvalue_value;</code></pre><p>如果我们有一个zval *tmp，那么tmp-&gt;value.obj来访问到最终保存对象实例的zend_object_value结构体，它包含两个成员：</p><ul><li>zend_object_handle handle：最终实现是一个unsigned int值，Zend会把每个对象放进数组里，这个handle就是此实例的索引。所以我们在把对象当作参数传递时，只不过是传递的handle罢了，这样对性能有利，同时也是对象的引用机制的原理。</li><li>zend_object_handlers *handlers：这个里面是一组函数指针，我们可以通过它来对象进行一些操作，比如：添加引用、获取属性等。此结构体在Zend/zend_object_handlers.h里定义。</li></ul><p>下面我给出这个类的PHP语言实现，让我们在扩展中实现它，并生成它。</p><pre><code>&lt;?phpclass baby{    public function __construct()    {        echo &quot;a new baby!\n&quot;;    }    public function hello()    {        echo &quot;hello world!\n&quot;;    }}function test_call(){    $obj = new baby();    $obj-&gt;hello();}?&gt;</code></pre><p>下面我们在扩展中实现以上test_call函数。</p><pre><code>zend_class_entry *baby_ce;ZEND_FUNCTION(test_call){    zval *obj;    MAKE_STD_ZVAL(obj);    object_init_ex(obj, baby_ce);    //如果确认此类没有构造函数就不用调用了。    walu_call_user_function(NULL, obj, &quot;__construct&quot;, &quot;&quot;);    walu_call_user_function(NULL, obj, &quot;hello&quot;, &quot;&quot;);    zval_ptr_dtor(&amp;obj);    return;}ZEND_METHOD(baby, __construct){    printf(&quot;a new baby!\n&quot;);}ZEND_METHOD(baby, hello){    printf(&quot;hello world!!!!!\n&quot;);}static zend_function_entry baby_method[]={    ZEND_ME(baby, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)    ZEND_ME(baby, hello, NULL, ZEND_ACC_PUBLIC)    {NULL, NULL, NULL}};ZEND_MINIT_FUNCTION(test){    zend_class_entry ce;    INIT_CLASS_ENTRY(ce, &quot;baby&quot;, baby_method);    baby_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);    return SUCCESS;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76-对象</title>
      <link href="/posts/6eebb5ea.html"/>
      <url>/posts/6eebb5ea.html</url>
      
        <content type="html"><![CDATA[<h1 id="76-对象"><a href="#76-对象" class="headerlink" title="76-对象"></a>76-对象</h1><p>对象是我们可以进行研究的任何事物，世间万物都可以看作对象。它不仅可以表示我们可以看到的具体事物， 也可以表示那些我们看不见的事件等。对象是一个实体，它具有状态，一般我们用变量来表示， 同时它也可以具有操作行为，一般用方法来表示，对象就是对象状态和对象行为的集合体。</p><p>在之前我们很多次的说到类，对于对象来说，具有相同或相似性质的对象的抽象就是类。 因此，对象的抽象是类，类的具体化就是对象，我们常常也说对象是类的实例。 从对象的表现形式来看，它和一般的数据类型在形式上十分相似，但是它们在本质是不同的。 对象拥有方法，对象间的通信是通过方法调用，以一种消息传递的方式进行。 而我们常说的面向对象编程(OOP)使得对象具有交互能力的主要模型就是消息传递模型。 对象是消息传递的主体，它可以接收，也可以拒绝外界发来的消息。</p><p>这一小节，我们从源码结构来看看PHP实现对象的方法以及其消息传递的方式。</p><h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><p>对象在PHP中是使用一种zend_object_value的结构体来存储。</p><pre><code>typedef struct _zend_object_value {    zend_object_handle handle;        //  unsigned int类型，EG(objects_store).object_buckets的索引    zend_object_handlers *handlers;} zend_object_value;</code></pre><p>PHP内核会将所有的对象存放在一个对象列表容器中，这个列表容器是保存在EG(objects_store)里的一个全局变量。 上面的handle字段就是这个列表中object_buckets的索引。当我们需要在PHP中存储对象的时候， PHP内核会根据handle索引从对象列表中获取相对应的对象。而获取的对象有其独立的结构，如下代码所示：</p><pre><code>typedef struct _zend_object {    zend_class_entry *ce;    HashTable *properties;    HashTable *guards; /* protects from __get/__set ... recursion */} zend_object;</code></pre><p>ce是存储该对象的类结构，properties是一个HashTable，用来存放对象的属性。</p><p>在zend_object_value结构体中除了索引字段外还有一个包含对象处理方法的字段：handlers。 它的类型是zend_object_handlers，我们可以在Zend/zend_object_handlers.h文件中找到它的定义。 这是一个包含了多个指针函数的结构体，这些指针函数包括对对象属性的操作，对对象方法的操作，克隆等。 此字段会在对象创建的时候初始化。</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>在PHP代码中，对象的创建是通过关键字 new 进行的。从此关键字出发，我们遍历词法分析，语法分析和编译成中间代码等过程， 得到其最后执行的函数为 ZEND_NEW_SPEC_HANDLER 。</p><p>ZEND_NEW_SPEC_HANDLER函数首先会判断对象所对应的类是否为可实例化的类， 即判断类的ce_flags是否与ZEND_ACC_INTERFACE、ZEND_ACC_IMPLICIT_ABSTRACT_CLASS或ZEND_ACC_EXPLICIT_ABSTRACT_CLASS有交集， 即判断类是否为接口或抽象类。</p><p>此处的抽象类包括直接声明的抽象类或因为包含了抽象方法而被声明的抽象类。</p><p>在类的类型判断完成后，如果一切正常，程序会给需要创建的对象存放的ZVAL容器分配内存。 然后调用object_init_ex方法初始化类，其调用顺序为： [object_init_ex()] –&gt; [_object_init_ex()] –&gt; [_object_and_properties_init()]</p><p>在_object_and_properties_init函数中，程序会执行前面提到的类的类型的判断，然后更新类的静态变量等信息（在这前面的章节有说明）， 更新完成后，程序会设置zval的类型为IS_OBJECT。</p><p>Z_TYPE_P(arg) = IS_OBJECT;</p><p>在设置了类型之后，程序会执行zend_object类型的对象的初始化工作，此时调用的函数是zend_objects_new。</p><pre><code>ZEND_API zend_object_value zend_objects_new(zend_object **object, zend_class_entry *class_type TSRMLS_DC){    zend_object_value retval;    *object = emalloc(sizeof(zend_object));    (*object)-&gt;ce = class_type;    retval.handle = zend_objects_store_put(*object, (zend_objects_store_dtor_t) zend_objects_destroy_object, (zend_objects_free_object_storage_t) zend_objects_free_object_storage, NULL TSRMLS_CC);    retval.handlers = &amp;std_object_handlers;    (*object)-&gt;guards = NULL;    return retval;}</code></pre><p>zend_objects_new函数会初始化对象自身的相关信息，包括对象归属于的类，对象实体的存储索引，对象的相关处理函数。 在这里将对象放入对象池中的函数为zend_objects_store_put。</p><p>在将对象放入对象池，返回对象的存放索引后，程序设置对象的处理函数为标准对象处理函数：std_object_handlers。 其位于Zend/zend_object_handles.c文件中。</p><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>这里针对对象，我们引入一个新的概念–对象池。 我们将PHP内核在运行中存储所有对象的列表称之为对象池，即EG(objects_store)。 这个对象池的作用是存储PHP中间代码运行阶段所有生成的对象，这个思想有点类似于我们做数据库表设计时， 当一个实例与另一个实体存在一对多的关系时，将多的那一端对应的实体提取出来存储在一个独立的表一样。 这样做的好处有两个，一个是可以对象复用，另一个是节省内存，特别是在对象很大，并且我们不需要用到对象的所有信息时。 对象池的存储结构为zend_objects_store结构体，如下：</p><pre><code>typedef struct _zend_objects_store {    zend_object_store_bucket *object_buckets;    zend_uint top;    zend_uint size;    int free_list_head;} zend_objects_store;typedef struct _zend_object_store_bucket {    zend_bool destructor_called;    zend_bool valid;    union _store_bucket {        struct _store_object {            void *object;            zend_objects_store_dtor_t dtor;            zend_objects_free_object_storage_t free_storage;            zend_objects_store_clone_t clone;            const zend_object_handlers *handlers;            zend_uint refcount;            gc_root_buffer *buffered;        } obj;        struct {            int next;        } free_list;    } bucket;} zend_object_store_bucket;</code></pre><p>针对对象池，PHP内核有一套对象操作API，位于Zend/zend_objects_API.c文件，其列表如下：</p><ul><li>zend_objects_store_init 对象池初始化操作，它的执行阶段是请求初始化阶段， 执行顺序是：[php_request_startup] –&gt; [php_start_sapi] –&gt; [zend_activate] –&gt; [init_executor] 初始化时，它会分配1024个zend_object_store_bucket给对象池。</li><li>zend_objects_store_destroy　销毁对象池，调用efree释放内存</li><li>zend_objects_store_mark_destructed 标记所有对象已经调用了析构函数</li><li>zend_objects_store_free_object_storage 释放存储的对象</li><li>zend_objects_store_put 对象的添加API，在此函数中，程序会执行单个bucket的初始化操作</li><li>zend_objects_store_get_refcount　获取对象池中对象的引用计数</li><li>zend_objects_store_add_ref　对象的引用计数加1，传入值为对象</li><li>zend_objects_store_add_ref_by_handle 通过handle查找对象，并将其引用计数加1</li><li>zend_objects_store_del_ref 对象的引用计数减1，传入值为对象</li><li>zend_objects_store_del_ref_by_handle_ex 通过handle查找对象，并将其引用计数减1，对于引用计数为1的对象有清除处理</li><li>zend_objects_store_clone_obj 对象克隆API，构造一个新的bucket，并将新的对象添加到对象池</li><li>zend_object_store_get_object 获取对象池中bucket中的对象，传入值为对象</li><li>zend_object_store_get_object_by_handle 获取对象池中bucket中的对象，传入值为索引值</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>从前面的对象结构来看，对象的成员变量存储在properties参数中。并且每个对象都会有一套标准的操作函数， 如果需要获取成员变量，对象最后调用的是read_property，其对应的标准函数为zend_std_read_property; 如果需要设置成员变量，对象最后调用的是write_property，其对应的标准函数zend_std_write_property。 这些函数都是可以定制的，如果有不同的需求，可以通过设置对应的函数指针替换。如在dom扩展中，它的变量的获取函数和设置函数都是定制的。</p><pre><code>/* {{{ PHP_MINIT_FUNCTION(dom) */PHP_MINIT_FUNCTION(dom){    zend_class_entry ce;    memcpy(&amp;dom_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));    dom_object_handlers.read_property = dom_read_property;    dom_object_handlers.write_property = dom_write_property;    //  ...省略}</code></pre><p>以上是dom扩展的模块初始化函数的部分内容，在这里，它替换了对象的read_property方法等。</p><p>这里我们以标准的操作函数为例说明成员变量的读取和获取。成员变量的获取最终调用的是zend_std_read_property函数。 这个函数的流程是这样的：</p><ul><li>第一步，获取对象的属性，如果存在，转第二步；如果没有相关属性，转第三步</li><li>第二步，从对象的properties查找是否存在与名称对应的属性存在，如果存在返回结果，如果不存在，转第三步</li><li>第三步，如果存在__get魔术方法，则调用此方法获取变量，如果不存在，转第四步</li><li>第四步，如果type=BP_VAR_IS，返回 &amp;EG(uninitialized_zval_ptr)，否则报错</li></ul><p>成员变量的设置最终调用的是zend_std_write_property函数。整个执行流程如下：</p><ul><li>第一步，获取对象的属性，如果存在，转第二步；如果没有相关属性，转第四步</li><li>第二步，从对象的properties查找是否存在与名称对应的属性存在，如果存在，转第三步，如果不存在，转第四步</li><li>第三步，如果已有的值和需要设置的值相同，则不执行任何操作，否则执行变量赋值操作， 此处的变量赋值操作和常规的变量赋值类似，有一些区别，这里只处理了是否引用的问题</li><li>第四步，如果存在__set魔术方法，则调用此方法设置变量，如果不存在，转第五步</li><li>第五步，如果成员变量一直没有被设置过，则直接将此变量添加到对象的properties字段所在HashTable中。</li></ul><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>成员方法又包括常规的成员方法和魔术方法。魔术方法在前面的第五小节已经介绍过了，这里就不再赘述。 在对象的标准函数中并没有成员方法的调用函数，默认情况下设置为NULL。在SPL扩展中，有此函数的调用设置，如下代码：</p><pre><code>PHP_MINIT_FUNCTION(spl_iterators){    // ...省略    memcpy(&amp;spl_handlers_dual_it, zend_get_std_object_handlers(), sizeof(zend_object_handlers));    spl_handlers_dual_it.get_method = spl_dual_it_get_method;    /*spl_handlers_dual_it.call_method = spl_dual_it_call_method;*/    spl_handlers_dual_it.clone_obj = NULL;    // ...省略}</code></pre><p>以下面的PHP代码为例，我们看看成员方法的调用过程：</p><pre><code>class Tipi {    public function t() {        echo &apos;tipi&apos;;    }}$obj = new Tipi();$obj-&gt;t();</code></pre><p>这是一个简单的类实现，它仅有一个成员方法叫t。创建一个此类的实例，将其赋值给变量$obj，通过这个对象变量执行其成员方法。 使用VLD扩展查看其生成的中间代码，可以知道其过程分为初始化成员方法的调用，执行方法两个过程。 初始化成员方法的调用对应的中间代码为ZEND_INIT_METHOD_CALL， 从我们的调用方式（一个为CV，一个为CONST）可知其对应的执行函数为 ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER 此函数的调用流程如下：</p><ul><li>第一步，处理调用的方法名，获取其值，并做检验处理：如果不是字符串，则报错</li><li>第二步，如果第一个操作数是对象，则转第三步，否则报错 Call to a member function t on a non-object</li><li>第三步，调用对象的get_method函数获取成员方法</li><li>第四步，其它处理，包括静态方法，this变量等。</li></ul><p>而get_method函数一般是指标准实现中的get_method函数，其对应的具体函数为Zend/zend_object_handlers.c文件中zend_std_get_method函数。 zend_std_get_method函数的流程如下：</p><ul><li>第一步，从zobj-&gt;ce-&gt;function_table中查找是否存在需要调用的函数，如果不存在，转第二步，如果存在，转第三步</li><li>第二步，如果__call函数存在，则调用zend_get_user_call_function函数获取并返回，如果不存在，则返回NULL</li><li>第三步，检查方法的访问控制，如果为私有函数，转第四步，否则转第五步</li><li>第四步，如果为同一个类或父类和这个方法在同一个作用域范围，则返回此方法，否则判断__call函数是否存在，存在则调用此函数，否则报错</li><li>第五步，处理函数重载及访问控制为protected的情况。 转第六步</li><li>第六步，返回fbc</li></ul><p>在获得了函数的信息后，下面的操作就是执行了，关于函数的执行在前面章节已经介绍过了。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75-保留类与特殊类</title>
      <link href="/posts/64a52dba.html"/>
      <url>/posts/64a52dba.html</url>
      
        <content type="html"><![CDATA[<h1 id="75-保留类与特殊类"><a href="#75-保留类与特殊类" class="headerlink" title="75-保留类与特殊类"></a>75-保留类与特殊类</h1><p>在面向对象语言中，都会内置一些语言内置提供的基本功能类，比如JavaScript中的Array，Number等类， PHP中也有很多这种类，比如Directory，stdClass，Exception等类，同时一些标准扩展比如PDO等扩展中也会定义一些类， PHP中类是不允许重复定义的，所以在编写代码时不允许定义已经存在的类。</p><p>同时PHP中有一些特殊的类：self，static和parent，相信读者对这self和parent都比较熟悉了，而static特殊类是PHP5.3才引入的。</p><p>PHP中的static关键字非常多义:</p><ul><li>在函数体内的修饰变量的static关键字用于定义静态局部变量。</li><li>用于修饰类成员函数和成员变量时用于声明静态成员。</li><li>(PHP5.3)在作用域解析符(::)前又表示静态延迟绑定的特殊类。</li></ul><p>这个关键字修饰的意义都表示”静态”，在PHP手册中提到self， parent和static这几个关键字，但实际上除了static是关键字以外，其他两个均不是关键字， 在手册的关键字列表中也没有这两个关键字， 要验证这一点很简单：</p><pre><code>&lt;?phpvar_dump(self); // -&gt;  string(4) &quot;self&quot;?&gt;</code></pre><p>上面的代码并没有报错，如果你把error_reporting(E_ALL)打开，就能看到实际是什么情况了: 运行这段代码会出现“ Notice: Use of undefined constant self - assumed ‘self’“， 也就是说PHP把self当成一个普通常量了，尝试未定义的常量会把产量本身当成一个字符串， 例如上例的”self”，不过同时会出一个NOTICE，这就是说self这个标示符并没有什么特殊的。</p><pre><code>&lt;?phpdefine(&apos;self&apos;, &quot;stdClass&quot;);echo self; // stdClass?&gt;</code></pre><p>不同语言中的关键字的意义会有些区别，Wikipedia上的解释是： 具有特殊含义的标示符或者单词，从这个意义上说$this也算是一个关键字，但在PHP的关键字列表中并没有。 PHP的关键字和C/C++一样属于保留字(关键字)，关键字用于表示特定的语法形式，例如函数定义，流程控制等结构。 这些关键字有他们的特定的使用场景，而上面提到的self和parent并没有这样的限制。</p><h2 id="self，parent，static类"><a href="#self，parent，static类" class="headerlink" title="self，parent，static类"></a>self，parent，static类</h2><p>前面已经说过self的特殊性。self是一个特殊类，它指向当前类，但只有在类定义内部才有效， 但也并不一定指向类本身这个特殊类，比如前面的代码，如果放在类方法体内运行，echo self; 还是会输出常量self的值，而不是当前类，它不止要求在类的定义内部，还要求在类的上下文环境， 比如 new self()的时候，这时self就指向当前类，或者self::$static_varible， self::CONSTANT类似的作用域解析符号(::)，这时的self才会作为指向本身的类而存在。</p><p>同理parent也和self类似。下面先看看在在类的环境下的编译吧$PHP_SRC/Zend/zend_language_parser.y:</p><pre><code>class_name_reference:        class_name                      { zend_do_fetch_class(&amp;$$, &amp;$1 TSRMLS_CC); }    |   dynamic_class_name_reference    { zend_do_end_variable_parse(&amp;$1, BP_VAR_R, 0 TSRMLS_CC); zend_do_fetch_class(&amp;$$, &amp;$1 TSRMLS_CC); };</code></pre><p>在需要获取类名时会执行zend_do_fetch_class()函数：</p><pre><code>void zend_do_fetch_class(znode *result, znode *class_name TSRMLS_DC) /* {{{ */{    // ...    opline-&gt;opcode = ZEND_FETCH_CLASS;    if (class_name-&gt;op_type == IS_CONST) {        int fetch_type;        fetch_type = zend_get_class_fetch_type(class_name-&gt;u.constant.value.str.val, class_name-&gt;u.constant.value.str.len);        switch (fetch_type) {            case ZEND_FETCH_CLASS_SELF:            case ZEND_FETCH_CLASS_PARENT:            case ZEND_FETCH_CLASS_STATIC:                SET_UNUSED(opline-&gt;op2);                opline-&gt;extended_value = fetch_type;                zval_dtor(&amp;class_name-&gt;u.constant);                break;            default:                zend_resolve_class_name(class_name, &amp;opline-&gt;extended_value, 0 TSRMLS_CC);                opline-&gt;op2 = *class_name;                break;        }    } else {        opline-&gt;op2 = *class_name;    }    // ...}</code></pre><p>上面省略了一些无关的代码，重点关注fetch_type变量。这是通过zend_get_class_fetch_type()函数获取到的。</p><pre><code>int zend_get_class_fetch_type(const char *class_name, uint class_name_len) /* {{{ */{    if ((class_name_len == sizeof(&quot;self&quot;)-1) &amp;&amp;        !memcmp(class_name, &quot;self&quot;, sizeof(&quot;self&quot;)-1)) {        return ZEND_FETCH_CLASS_SELF;    } else if ((class_name_len == sizeof(&quot;parent&quot;)-1) &amp;&amp;        !memcmp(class_name, &quot;parent&quot;, sizeof(&quot;parent&quot;)-1)) {        return ZEND_FETCH_CLASS_PARENT;    } else if ((class_name_len == sizeof(&quot;static&quot;)-1) &amp;&amp;        !memcmp(class_name, &quot;static&quot;, sizeof(&quot;static&quot;)-1)) {        return ZEND_FETCH_CLASS_STATIC;    } else {        return ZEND_FETCH_CLASS_DEFAULT;    }}</code></pre><p>前面的代码是Zend引擎编译类相关操作的代码，下面就到执行阶段了，self，parent等类的指向会在执行时进行获取， 找到执行opcode为ZEND_FETCH_CLASS的执行函数:</p><pre><code>zend_class_entry *zend_fetch_class(const char *class_name, uint class_name_len, int fetch_type TSRMLS_DC) /* {{{ */{    zend_class_entry **pce;    int use_autoload = (fetch_type &amp; ZEND_FETCH_CLASS_NO_AUTOLOAD) == 0;    int silent       = (fetch_type &amp; ZEND_FETCH_CLASS_SILENT) != 0;    fetch_type &amp;= ZEND_FETCH_CLASS_MASK;check_fetch_type:    switch (fetch_type) {        case ZEND_FETCH_CLASS_SELF:            if (!EG(scope)) {                zend_error(E_ERROR, &quot;Cannot access self:: when no class scope is active&quot;);            }            return EG(scope);        case ZEND_FETCH_CLASS_PARENT:            if (!EG(scope)) {                zend_error(E_ERROR, &quot;Cannot access parent:: when no class scope is active&quot;);            }            if (!EG(scope)-&gt;parent) {                zend_error(E_ERROR, &quot;Cannot access parent:: when current class scope has no parent&quot;);            }            return EG(scope)-&gt;parent;        case ZEND_FETCH_CLASS_STATIC:            if (!EG(called_scope)) {                zend_error(E_ERROR, &quot;Cannot access static:: when no class scope is active&quot;);            }            return EG(called_scope);        case ZEND_FETCH_CLASS_AUTO: {                fetch_type = zend_get_class_fetch_type(class_name, class_name_len);                if (fetch_type!=ZEND_FETCH_CLASS_DEFAULT) {                    goto check_fetch_type;                }            }            break;    }    if (zend_lookup_class_ex(class_name, class_name_len, use_autoload, &amp;pce TSRMLS_CC) == FAILURE) {        if (use_autoload) {            if (!silent &amp;&amp; !EG(exception)) {                if (fetch_type == ZEND_FETCH_CLASS_INTERFACE) {                    zend_error(E_ERROR, &quot;Interface &apos;%s&apos; not found&quot;, class_name);                } else {                    zend_error(E_ERROR, &quot;Class &apos;%s&apos; not found&quot;, class_name);                }                }            }        }        return NULL;    }    return *pce;}</code></pre><p>从这个函数就能看出端倪了，当需要获取self类的时候，则将EG(scope)类返回，而EG(scope)指向的正是当前类。 如果时parent类的话则从去EG(scope)-&gt;parent也就是当前类的父类，而static获取的时EG(called_scope)， 分别说说EG宏的这几个字段，前面已经介绍过EG宏，它可以展开为如下这个结构体：</p><pre><code>struct _zend_executor_globals {    // ...    zend_class_entry *scope;    zend_class_entry *called_scope; /* Scope of the calling class */    // ...}struct _zend_class_entry {    char type;    char *name;    zend_uint name_length;    struct _zend_class_entry *parent;}#define struct _zend_class_entry zend_class_entry</code></pre><p>其中的zend_class_entry就是PHP中类的内部结构表示，zend_class_entry有一个parent字段，也就是该类的父类。 在EG结构体中的中called_scope会在执行过程中将当前执行的类赋值给called_scope，例如如下代码：</p><pre><code>&lt;?phpclass A {    public static funcA() {        static::funcB();    }}class B {    public static funcB() {        echo  &quot;B::funcB()&quot;;    }}B::funcA();?&gt;</code></pre><p>代码B::funcA()执行的时候，实际执行的是B的父类A中定义的funcA函数，A::funcA()执行时当前的类(scope)指向的是类A， 而这个方法是从B类开始调用的，called_scope指向的是类B，static特殊类指向的正是called_scope，也就是当前类(触发方法调用的类)， 这也是延迟绑定的原理。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74-魔术函数与延迟绑定</title>
      <link href="/posts/a81fa64c.html"/>
      <url>/posts/a81fa64c.html</url>
      
        <content type="html"><![CDATA[<h1 id="74-魔术函数与延迟绑定"><a href="#74-魔术函数与延迟绑定" class="headerlink" title="74-魔术函数与延迟绑定"></a>74-魔术函数与延迟绑定</h1><p>PHP中有一些特殊的函数和方法，这些函数和方法相比普通方法的特殊之处在于：用户代码通常不会主动调用， 而是在特定的时机会被PHP自动调用。在PHP中通常以”<strong>“打头的方法都作为魔术方法， 所以通常不要定义以”</strong>“开头的函数或方法。 例如:<strong>autoload()函数， 通常我们不会手动调用这个函数， 而如果在代码中访问某个未定义的方法， 如过已经定义了</strong>autoload()函数，此时PHP将会尝试调用<strong>autoload()函数， 例如在类的定义中如果定义了</strong>construct()方法， 在初始化类的实例时将会调用这个方法， 同理还有__destuct()方法， 详细内容请参考PHP手册。</p><h2 id="魔术函数和魔术方法"><a href="#魔术函数和魔术方法" class="headerlink" title="魔术函数和魔术方法"></a>魔术函数和魔术方法</h2><p>前面提到魔术函数和魔术方法的特殊之处在于这些方法(在这里把函数和方法统称方法)的调用时机是在某些特定的场景才会被触发， 这些方法可以理解为一些事件监听方法， 在事件触发时才会执行。</p><p>根据前面的介绍， 魔术方法就是在类的某些场景下触发的一些监听方法。这些方法需要在类定义中进行定义， 在存储上魔术方法自然存储于类中， 而类在PHP内部是一个_zend_class_entry结构体，与普通方法一样， 只不过这些类不是存储在类的函数表， 而是直接存储在类结构体中:</p><ul><li>在_zend_class_entry结构体中的存储位置不同;</li><li>由ZendVM自动分情境进行调用;</li><li>不是必须的，按需定义，自动调用</li></ul><p>从以上三个方面可以发现，关于魔术变量的关键理解，主要集中在两个方面：一，定义在哪里; 二，如何判断其存在并进行调用。</p><p>首先，魔术变量的存储在_zend_class_entry中的代码如下：</p><pre><code>struct _zend_class_entry {    ...    //构造方法 __construct    union _zend_function *constructor;    //析构方法 __destruct    union _zend_function *destructor;    //克隆方法 __clone    union _zend_function *clone;    union _zend_function *__get;    union _zend_function *__set;    union _zend_function *__unset;    union _zend_function *__isset;    union _zend_function *__call;    union _zend_function *__callstatic;    union _zend_function *__tostring;    //序列化    union _zend_function *serialize_func;    //反序列化    union _zend_function *unserialize_func;    ...}</code></pre><p>这段代码明确的在对象内部定义了不同的指针来保存各种魔术变量。 关于Zend VM对魔术方法的调用机制，由于每种方法的调用情境不同，笔者在这里也分开进行分析。</p><h3 id="construct"><a href="#construct" class="headerlink" title="__construct"></a>__construct</h3><p><strong>construct构造方法，在对象创建时被自动调用。 与其它很多语言（如JAVA）不同的是，在PHP中，构造方法并没有使用”与类定义同名“的约定方式，而是单独用魔术方法来实现。 **</strong>construct**方法的调用入口是new关键字对应的ZEND_NEW_SPEC_HANDLER函数。 Zend VM在初始化对象的时候，使用了new关键字，对其OPCODE进行分析后，使用GDB可以得到下面的堆栈信息：</p><pre><code>#0  ZEND_NEW_SPEC_HANDLER (execute_data=0x100d00080) at zend_vm_execute.h:461#1  0x000000010041c1f0 in execute (op_array=0x100a1fd60) at zend_vm_execute.h:107#2  0x00000001003e9394 in zend_execute_scripts (type=8, retval=0x0, file_count=3) at /Volumes/DEV/C/php-5.3.4/Zend/zend.c:1194#3  0x0000000100368031 in php_execute_script (primary_file=0x7fff5fbff890) at /Volumes/DEV/C/php-5.3.4/main/main.c:2265#4  0x00000001004d4b5c in main (argc=2, argv=0x7fff5fbffa30) at /Volumes/DEV/C/php-5.3.4/sapi/cli/php_cli.c:1193</code></pre><p>上面的椎栈信息清晰显示了new关键的调用过程，可以发现new关键字对应了ZEND_NEW_SPEC_HANDLER的处理函数， 在ZEND_NEW_SPEC_HANDLER中，Zend VM使用下面的代码来获取对象是否定义了__construct方法：</p><pre><code>...constructor = Z_OBJ_HT_P(object_zval)-&gt;get_constructor(object_zval TSRMLS_CC);if (constructor == NULL){    ...} else {    ...}//get_constructor的实现ZEND_API union _zend_function *zend_std_get_constructor(zval *object TSRMLS_DC){    zend_object *zobj = Z_OBJ_P(object);    zend_function *constructor = zobj-&gt;ce-&gt;constructor;    if(constructor){ ... } else { ...}    ...}</code></pre><p>从上面的代码可以看出ZendVM通过读取zend_object-&gt;ce-&gt;constructor的值来判断对象是不是定义的构造函数。</p><p>Z_OBJ_P(zval); Z_OBJ_P宏将一个zval类型变量构造为zend_object类型。</p><p>在判断了<strong>construct魔术变量存在之后，ZEND_NEW_SPEC_HANDLER中对当前EX(called_scope)进行了重新赋值， 使ZEND_VM_NEXT_OPCODE();将opline指针指向</strong>construct方法的op_array，开始执行__construct魔术方法</p><pre><code>[c]EX(object) = object_zval;EX(fbc) = constructor;EX(called_scope) = EX_T(opline-&gt;op1.u.var).class_entry;ZEND_VM_NEXT_OPCODE();</code></pre><h2 id="destruct"><a href="#destruct" class="headerlink" title="__destruct"></a>__destruct</h2><p><strong>destruct是析构方法，运行于对象被显示销毁或者脚本关闭时，一般被用于释放占用的资源。 </strong>destruct的调用涉及到垃圾回收机制，在第七章中会有更详尽的介绍。 本文笔者只针对__destruct调用机制进行分析，其调用堆栈信息如下：</p><pre><code>//省略部分内存地址信息后的堆栈：#0  zend_call_function () at /..//php-5.3.4/Zend/zend_execute_API.c:767#1  zend_call_method () at /..//php-5.3.4/Zend/zend_interfaces.c:97#2  zend_objects_destroy_object () at /..//php-5.3.4/Zend/zend_objects.c:112#3  zend_objects_store_del_ref_by_handle_ex () at /..//php-5.3.4/Zend/zend_objects_API.c:206#4  zend_objects_store_del_ref () at /..//php-5.3.4/Zend/zend_objects_API.c:172#5  _zval_dtor_func () at /..//php-5.3.4/Zend/zend_variables.c:52#6  _zval_dtor () at zend_variables.h:35#7  _zval_ptr_dtor () at /..//php-5.3.4/Zend/zend_execute_API.c:443#8  _zval_ptr_dtor_wrapper () at /..//php-5.3.4/Zend/zend_variables.c:189#9  zend_hash_apply_deleter () at /..//php-5.3.4/Zend/zend_hash.c:614#10 zend_hash_reverse_apply () at /..//php-5.3.4/Zend/zend_hash.c:763#11 shutdown_destructors () at /..//php-5.3.4/Zend/zend_execute_API.c:226#12 zend_call_destructors () at /..//php-5.3.4/Zend/zend.c:874#13 php_request_shutdown () at /..//php-5.3.4/main/main.c:1587#14 main () at /..//php-5.3.4/sapi/cli/php_cli.c:1374</code></pre><p><strong>destruct方法存在与否是在zend_objects_destroy_object函数中进行判断的。 在脚本执行结果时，ZendVM在php_request_shutdown阶段会将对象池中的对象一一销毁， 这时如果某对象定义了</strong>destruct魔术方法，此方法便会被执行。</p><p>在zend_objects_destroy_object中，与<strong>construct一样， ZendVM判断zend_object-&gt;ce-&gt;destructor是否为空，如果不为空，则调用zend_call_method执行</strong>destruct析构方法。 进入<strong>destruct的方式与</strong>construct不同的是，<strong>destruct的执行方式是由ZendVM直接调用zend_call_function来执行。 </strong>call与__callStatic</p><ul><li>__call：在对对象不存在的方法进行调用时自动执行;</li><li>__callStatic：在对对象不存在的静态方法进行调用时自动执行;</li></ul><p><strong>call与</strong>callStatic的调用机制几乎完全相同，关于函数的执行已经在上一章中提到， 用户对函数的调用是由zend_do_fcall_common_helper_SPEC()方法进行处理的。</p><p>经过[ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER]-&gt; [zend_do_fcall_common_helper_SPEC]-&gt; [zend_std_call_user_call]-&gt; [zend_call_method]-&gt;[zend_call_function] 调用，经过zend_do_fcall_common_helper_SPEC的分发，最终使用zend_call_function来执行__call。</p><p>经过[ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER]-&gt; [zend_do_fcall_common_helper_SPEC]-&gt; [zend_std_callstatic_user_call]-&gt; [zend_call_method]-&gt;[zend_call_function] 调用，经过zend_do_fcall_common_helper_SPEC的分发，最终使用zend_call_function来执行__callStatic。</p><h3 id="其他魔术方法"><a href="#其他魔术方法" class="headerlink" title="其他魔术方法"></a>其他魔术方法</h3><p>PHP中还有很多种魔术方法，它们的处理方式基本与上面类似，运行时执行与否取决的判断根据， 最终都是_zend_class_entry结构体中对应的指针是否为空。 这里列出它们的底层实现函数：<br>| 魔术方法 | 对应处理函数 |所在源文件 |<br>| :————- | :————- | :———- |<br>|<strong>set| zend_std_call_setter()| Zend/zend_object_handlers.c|<br>|</strong>get| zend_std_call_getter()| Zend/zend_object_handlers.c|<br>|<strong>isset| zend_std_call_issetter()| Zend/zend_object_handlers.c|<br>|</strong>unset| zend_std_call_unsetter()| Zend/zend_object_handlers.c|<br>|<strong>sleep| php_var_serialize_intern()| ext/standard/var.c|<br>|</strong>wakeup| php_var_unserialize()| ext/standard/var_unserializer.c|<br>|<strong>toString| zend_std_cast_object_tostring()| Zend/zend_object_handlers.c|<br>|</strong>invoke| ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER()| Zend/zend_vm_execute.h|<br>|<strong>set_state| php_var_export_ex()| ext/standard/var.c|<br>|</strong>clone| ZEND_CLONE_SPEC_CV_HANDLER()| Zend/zend_vm_execute.h|</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>从PHP 5.3.0开始，PHP增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。 该功能从语言内部角度考虑被命名为“后期静态绑定”。 “后期绑定”的意思是说，static::不再被解析为定义当前方法所在的类，而是在实际运行时计算的。 也可以称之为”静态绑定“，因为它可以用于（但不限于）静态方法的调用。</p><p>延迟绑定的实现关键在于static关键字，如果以static调用静态方法，则在语法解析时：</p><pre><code>function_call:...//省略若干其它情况的函数调用|   class_name T_PAAMAYIM_NEKUDOTAYIM T_STRING &apos;(&apos; { $4.u.opline_num = zend_do_begin_class_member_function_call(&amp;$1, &amp;$3 TSRMLS_CC); }        function_call_parameter_list        &apos;)&apos; { zend_do_end_function_call($4.u.opline_num?NULL:&amp;$3, &amp;$$, &amp;$6, $4.u.opline_num, $4.u.opline_num TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}...//省略若干其它情况的函数调用class_name:    T_STATIC { $$.op_type = IS_CONST; ZVAL_STRINGL(&amp;$$.u.constant, &quot;static&quot;, sizeof(&quot;static&quot;)-1, 1);}</code></pre><p>如上所示，static将以第一个参数(class_name)传递给zend_do_begin_class_member_function_call函数。 此时class_name的op_type字段为IS_CONST，但是通过zend_get_class_fetch_type获取此类的类型为ZEND_FETCH_CLASS_STATIC。 这个类型作为操作的extended_value字段存在，此字段在后面执行获取类的中间代码ZEND_FETCH_CLASS（ZEND_FETCH_CLASS_SPEC_CONST_HANDLER）时， 将作为第三个参数(fetch_type)传递给获取类名的最终执行函数zend_fetch_class。</p><pre><code>EX_T(opline-&gt;result.u.var).class_entry = zend_fetch_class(Z_STRVAL_P(class_name),Z_STRLEN_P(class_name), opline-&gt;extended_value TSRMLS_CC);</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73-继承，多态与抽象类</title>
      <link href="/posts/f9f9c3f3.html"/>
      <url>/posts/f9f9c3f3.html</url>
      
        <content type="html"><![CDATA[<h1 id="73-继承，多态与抽象类"><a href="#73-继承，多态与抽象类" class="headerlink" title="73-继承，多态与抽象类"></a>73-继承，多态与抽象类</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是一种关联类的层次模型，它可以建立类之间的关系，并实现代码重用，方便系统扩展。 继承提供了一种明确表述共性的方法，是一个新类从现有的类中派生的过程。 继承产生的新类继承了原始类的特性，新类称为原始类的派生类（或子类）， 而原始类称为新类的基类（或父类）。派生类可以从基类那里继承方法和变量， 并且新类可以重载或增加新的方法，使之满足自己的定制化的需要。</p><p>PHP中使用extends关键字来进行类的继承，一个类只能继承一个父类。 被继承的成员方法和成员变量可以使用同名的方法或变量重写，如果需要访问父类的成员方法或变量可以 使用特殊类parent来进行。</p><p>PHP内核将类的继承实现放在了”编译阶段”，因此使用VLD生成中间代码时会发现并没有关于继承的相关信息。 通过对extends关键字的词法分析和语法分析，在Zend/zend_complie.c文件中 找到继承实现的编译函数zend_do_inheritance()。其调用顺序如下: [zend_do_early_binding] –&gt; [do_bind_inherited_class()] –&gt; [zend_do_inheritance()]</p><pre><code>ZEND_API void zend_do_inheritance(zend_class_entry *ce, zend_class_entry *parent_ce TSRMLS_DC){    //  ...省略  报错处理 接口不能从类继承，final类不能继承    //  ...省略 序列化函数和反序列化函数 如果当前类没有，则取父类的    /* Inherit interfaces */    zend_do_inherit_interfaces(ce, parent_ce TSRMLS_CC);    /* Inherit properties */    zend_hash_merge(&amp;ce-&gt;default_properties, &amp;parent_ce-&gt;default_properties, (void (*)(void *)) zval_add_ref, NULL, sizeof(zval *), 0);    if (parent_ce-&gt;type != ce-&gt;type) {        /* User class extends internal class */        zend_update_class_constants(parent_ce  TSRMLS_CC);        zend_hash_apply_with_arguments(CE_STATIC_MEMBERS(parent_ce) TSRMLS_CC, (apply_func_args_t)inherit_static_prop, 1, &amp;ce-&gt;default_static_members);    } else {        zend_hash_apply_with_arguments(&amp;parent_ce-&gt;default_static_members TSRMLS_CC, (apply_func_args_t)inherit_static_prop, 1, &amp;ce-&gt;default_static_members);    }    zend_hash_merge_ex(&amp;ce-&gt;properties_info, &amp;parent_ce-&gt;properties_info, (copy_ctor_func_t) (ce-&gt;type &amp; ZEND_INTERNAL_CLASS ? zend_duplicate_property_info_internal : zend_duplicate_property_info), sizeof(zend_property_info), (merge_checker_func_t) do_inherit_property_access_check, ce);    zend_hash_merge(&amp;ce-&gt;constants_table, &amp;parent_ce-&gt;constants_table, (void (*)(void *)) zval_add_ref, NULL, sizeof(zval *), 0);    zend_hash_merge_ex(&amp;ce-&gt;function_table, &amp;parent_ce-&gt;function_table, (copy_ctor_func_t) do_inherit_method, sizeof(zend_function), (merge_checker_func_t) do_inherit_method_check, ce);    do_inherit_parent_constructor(ce);    if (ce-&gt;ce_flags &amp; ZEND_ACC_IMPLICIT_ABSTRACT_CLASS &amp;&amp; ce-&gt;type == ZEND_INTERNAL_CLASS) {        ce-&gt;ce_flags |= ZEND_ACC_EXPLICIT_ABSTRACT_CLASS;    } else if (!(ce-&gt;ce_flags &amp; ZEND_ACC_IMPLEMENT_INTERFACES)) {        /* The verification will be done in runtime by ZEND_VERIFY_ABSTRACT_CLASS */        zend_verify_abstract_class(ce TSRMLS_CC);    }}</code></pre><p>整个继承的过程是以类结构为中心，当继承发生时，程序会先处理所有的接口。接口继承调用了zend_do_inherit_interfaces函数 此函数会遍历所有的接口列表，将接口写入到类结构的interfaces字段，并增加num_interfaces的计数统计。 在接口继承后，程序会合并类的成员变量、属性、常量、函数等，这些都是HashTable的merge操作。</p><p>在继承过程中，除了常规的函数合并后，还有魔法方法的合并，其调用的函数为do_inherit_parent_constructor(ce)。 此函数实现魔术方法继承，如果子类中没有相关的魔术方法，则继承父类的对应方法。如下所示的PHP代码为子类没构造函数的情况：</p><pre><code>class Base {    public function __construct() {        echo &apos;Base __construct&lt;br /&gt;&apos;;    }}class Foo extends Base {}$foo = new Foo();</code></pre><p>在PHP函数中运行，会输出：Base __construct</p><p>这显然继承了父类的构造方法，如果子类有自己的构造方法，并且需要调用父类的构造方法时 需要在子类的构造方法中调用父类的构造方法，PHP不会自动调用。</p><p>当说到继承，就不得不提到访问控制。继承在不同的访问控制权限下有不同的表现。 以成员方法为例，我们可以使用private和protected访问修饰符来控制需要继承的内容。</p><ul><li>private 如果一个成员被指定为private，它将不能被继承。实际上在PHP中这个方法会被继承下来，只是无法访问。</li><li>protected 如果一个成员被指定为protected，它将在类外不可见，可以被继承。</li></ul><p>在继承中访问控制的实现是在合并函数时实现，其实现函数为do_inherit_method_check。 在此函数中，如果子类没有父类中定义的方法，则所有的此类方法都会被继承，包括私有访问控制权限的方法。</p><p>看一个PHP的示例：</p><pre><code>class Base {    private function privateMethod() {    }}class Child extends Base{    public function publicMethod() {    }}$c = new Child();if (method_exists($c, &apos;privateMethod&apos;)) {    echo 1;}else{    echo 0;}</code></pre><p>这段代码会输出1，至此，我们可以证明：在PHP中，对于私有方法，在继承时是可以被继承下来的。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是继数据抽象和继承后的第三个特性。顾名思义，多态即多种形态，相同方法调用实现不同的实现方式。 多态关注一个接口或基类，在编程时不必担心一个对象所属于的具体类。在面向对象的原则中 里氏代换原则（Liskov Substitution Principle，LSP），依赖倒转原则（dependence inversion principle，DIP）等 都依赖于多态特性。而我们在平常工作中也会经常用到。</p><pre><code>interface Animal {    public function run();}class Dog implements Animal {    public function run() {        echo &apos;dog run&apos;;    }}class  Cat implements Animal{    public function run() {        echo &apos;cat run&apos;;    }}class Context {    private $_animal;    public function __construct(Animal $animal) {        $this-&gt;_animal = $animal;    }    public function run() {        $this-&gt;_animal-&gt;run();    }}$dog = new Dog();$context = new Context($dog);$context-&gt;run();$cat = new Cat();$context = new Context();$context-&gt;run();</code></pre><p>上面是策略模式示例性的简单实现。对于不同的动物，其跑的方式不一样， 当在环境中跑的时候，根据所传递进来的动物执行相对应的跑操作。 多态是一种编程的思想，但对于不同的语言，其实现也不同。 对于PHP的程序实现来说，关键点在于类型提示的实现。而类型提示是PHP5之后才有的特性。在此之前， PHP本身就具有多态特性。</p><p>前面说明了类型提示的实现，只是对于 对象的判断没有做深入的探讨。它已经指出对于类的类型提示实现函数为zend_verify_arg_type。 在此函数中，关于对象的关键代码如下：</p><pre><code>if (Z_TYPE_P(arg) == IS_OBJECT) {    need_msg = zend_verify_arg_class_kind(cur_arg_info, fetch_type, &amp;class_name, &amp;ce TSRMLS_CC);    if (!ce || !instanceof_function(Z_OBJCE_P(arg), ce TSRMLS_CC)) {        return zend_verify_arg_error(zf, arg_num, cur_arg_info, need_msg, class_name, &quot;instance of &quot;, Z_OBJCE_P(arg)-&gt;name TSRMLS_CC);    }}</code></pre><p>第一步，判断参数是否为对象，使用宏Z_TYPE_P，如果是转二步，否则跳到其它情况处理</p><p>第二步，获取类的类型验证信息，调用了zend_verify_arg_class_kind函数，此函数位于Zend/zend_execute.c文件中， 它会通过zend_fetch_class函数获取类信息，根据类的类型判断是否为接口，返回字符串”implement interface”或”be an instance of”</p><p>第三步，判断是否为指定类的实例，调用的函数是instanceof_function。此函数首先会遍历实例所在类的所有接口， 递归调用其本身，判断实例的接口是否为指定类的实例，如果是，则直接返回1，如果不是，在非仅接口的情况下， 循环遍历所有的父类，判断父类与指定的类是否相等，如果相等返回1，当函数执行完时仍没有找到，则返回0，表示不是类的实例。 instanceof_function函数的代码如下：</p><pre><code>ZEND_API zend_bool instanceof_function_ex(const zend_class_entry *instance_ce, const zend_class_entry *ce, zend_bool interfaces_only TSRMLS_DC) /* {{{ */{    zend_uint i;    for (i=0; i &lt; instance_ce-&gt;num_interfaces; i++) { //  递归遍历所有的接口        if (instanceof_function(instance_ce-&gt;interfaces[i], ce TSRMLS_CC)) {            return 1;        }    }    if (!interfaces_only) {        while (instance_ce) {   //  遍历所有的父类            if (instance_ce == ce) {                return 1;            }            instance_ce = instance_ce-&gt;parent;        }    }    return 0;}</code></pre><p>第四步，如果不是指定类的实例，程序会调用zend_verify_arg_error报错，此函数最终会调用zend_error函数显示错误。</p><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>前面的PHP示例中有用到接口，而且在多态中，接口是一个不得不提的概念。接口是一些方法特征的集合， 是一种逻辑上的抽象，它没有方法的实现，因此这些方法可以在不同的地方被实现，可以有相同的名字而具有完全不同的行为。</p><p>而PHP内核对类和接口一视同仁，它们的内部结构一样。这点在前面的类型提示实现中也有看到，不管是接口还是类， 调用instanceof_function函数时传入的参数和计算过程中使用的变量都是zend_class_entry类型。</p><p>前面已经对于类的类型做了说明，在语法解析时， PHP内核已经设置了其type=ZEND_ACC_INTERFACE，</p><pre><code>interface_entry:    T_INTERFACE     { $$.u.opline_num = CG(zend_lineno);             $$.u.EA.type = ZEND_ACC_INTERFACE; };</code></pre><p>而在声明类的函数zend_do_begin_class_declaration中，通过下列语句，将语法解析的类的类型赋值给类的ce_flags字段。</p><pre><code>new_class_entry-&gt;ce_flags |= class_token-&gt;u.EA.type;</code></pre><p>类结构的ce_flags字段的作用是标记类的类型。</p><p>接口与类除了在ce_flags字段不同外，在其它一些字段的表现上也不一样，如继承时，类只能继承一个父类，却可以实现多个接口。 二者在类的结构中存储在不同的字段，类的继承由于是一对一的关系，则每个类都有一个parent字段。 而接口实现是一个一对多的关系，每个类都会有一个二维指针存放接口的列表，还有一个存储接口数的字段num_interfaces。</p><p>接口也可以和类一样实现继承，并且只能是一个接口继承另一个接口。一个类可以实现多个接口， 接口在编译时调用zend_do_implement_interface函数， zend_do_implement_interface函数会合并接口中的常量列表和方法列表操作，这就是接口中不能有变量却可以有常量的实现原因。 在接口继承的过程中有对当前类的接口中是否存在同样接口的判断操作，如果已经存在了同样的接口，则此接口继承将不会执行。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类是相对于具体类来说的，抽象类仅提供一个类的部分实现。抽象类可以有实例变量，构造方法等。 抽象类可以同时拥有抽象方法和具体方法。一般来说，抽象类代表一个抽象的概念，它提供了一个继承的 出发点，理想情况下，所有的类都需要从抽象类继承而来。而具体类则不同，具体类可以实例化。 由于抽象类不可以实例化，因此所有抽象类应该都是作为继承的父类的。</p><p>在PHP中，抽象类是被abstract关键字修饰的类，或者类没有被声明为abstract，但是在类中存在抽象成员的类。 对于这两种情况，PHP内核作了区分，类的结构体zend_class_entry.ce_flags中保存了这些信息， 二者对应的值为ZEND_ACC_EXPLICIT_ABSTRACT_CLASS和ZEND_ACC_IMPLICIT_ABSTRACT_CLASS， 这两个值在前面的第一节已经做了介绍。</p><p>标记类为抽象类或标记成员方法为抽象方法的确认阶段是语法解析阶段。标记为抽象类与标记为接口等的过程一样。 而通过标记成员方法为抽象方法来确认一个类为抽象类则是在声明函数时实现的。从第四章中我们知道编译时声明函数会调用 zend_do_begin_function_declaration函数。在此函数中有如下代码：</p><pre><code>if (fn_flags &amp; ZEND_ACC_ABSTRACT) {        CG(active_class_entry)-&gt;ce_flags |= ZEND_ACC_IMPLICIT_ABSTRACT_CLASS;    }}</code></pre><p>若函数为抽象函数，则设置类的ce_flags为ZEND_ACC_IMPLICIT_ABSTRACT_CLASS，从而将这个类设置为抽象类。</p><p>抽象类，接口，普通类都是保存在zend_class_entry结构体中，他们只通过一个标志字段来区分， 抽象类和接口还有一个共性：无法实例化。那我们看看Zend在那里限制的。要实例化一个对象我们只能使用new关键字来进行。 下面是执行new是进行的操作：</p><pre><code>static int ZEND_FASTCALL  ZEND_NEW_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS){    zend_op *opline = EX(opline);    zval *object_zval;    zend_function *constructor;    if (EX_T(opline-&gt;op1.u.var).class_entry-&gt;ce_flags &amp; (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {        char *class_type;        if (EX_T(opline-&gt;op1.u.var).class_entry-&gt;ce_flags &amp; ZEND_ACC_INTERFACE) {            class_type = &quot;interface&quot;;        } else {            class_type = &quot;abstract class&quot;;        }        zend_error_noreturn(E_ERROR, &quot;Cannot instantiate %s %s&quot;, class_type,  EX_T(opline-&gt;op1.u.var).class_entry-&gt;name);    }    // ...}</code></pre><p>代码很好理解，进行了简单的判断，如果为抽象类、隐式抽象类或者接口都无法进行实例化操作。</p><p>类的继承、多态、封装，以及访问控制，接口，抽象类等都是基于类的结构实现的，因为这几个类型只有个别的特性的差异，其他基本一致。 如果要真正理解这些特性，需要更多的关注类的结构，基础往往很重要，而在程序，数据结构就是程序的基础。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>72-访问控制</title>
      <link href="/posts/68b2d158.html"/>
      <url>/posts/68b2d158.html</url>
      
        <content type="html"><![CDATA[<h1 id="72-访问控制"><a href="#72-访问控制" class="headerlink" title="72-访问控制"></a>72-访问控制</h1><p>面向对象的三大特性(封装、继承、多态)，其中封装是一个非常重要的特性。封装隐藏了对象内部的细节和实现， 使对象能够集中而完整的描述并对应一个具体的事物， 只提供对外的访问接口，这样可以在不改变接口的前提下改变实现细节，而且能使对象自我完备。 除此之外，封装还可以增强安全性和简化编程。 在面向对象的语言中一般是通过访问控制来实现封装的特性。 PHP提供了public、protected及private三个层次访问控制。这和其他面向对象的语言中对应的关键字语义一样。 这几个关键字都用于修饰类的成员：</p><ul><li>private 用于禁止除类本身以外(包括继承也属于非类本身)对成员的访问，用于隐藏类的内部数据和实现。</li><li>protectd 用于禁止除本类以及继承该类的类以外的任何访问。同样用于封装类的实现，同时给予类一定的扩展能力， 因为子类还是可以访问到这些成员。</li><li>public 最好理解，被public修饰的成员可以被任意的访问。</li></ul><p>如果没有设置访问控制关键字，则类的成员方法和成员变量会被设置成默认的 public。</p><p>这三个关键字在语法解析时分别对应三种访问控制的标记：</p><pre><code>member_modifier:    T_PUBLIC                { Z_LVAL($$.u.constant) = ZEND_ACC_PUBLIC; }|   T_PROTECTED             { Z_LVAL($$.u.constant) = ZEND_ACC_PROTECTED; }|   T_PRIVATE               { Z_LVAL($$.u.constant) = ZEND_ACC_PRIVATE; }</code></pre><p>这三种访问控制的标记是PHP内核中定义的三个常量，在Zend/zend_complic.h中，其定义如下：</p><pre><code>#define ZEND_ACC_PUBLIC     0x100#define ZEND_ACC_PROTECTED  0x200#define ZEND_ACC_PRIVATE    0x400#define ZEND_ACC_PPP_MASK  (ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)</code></pre><p>我们经常使用16进制的数字表标示状态，例如上面的访问控制常量， 0x100使用二进制表示就为 0001 0000 0000 0x200为0010 0000 0000 0x400为0100 0000 0000 我们通过二进制的某个位来表示特定的意义，至于为什么ZEND_ACC_PUBLIC这几个常量后面多两个0， 这是因为0x01和0x10已经被占用了，使用和其他不同意义的常量值不一样的值可以避免误用。 通过简单的二进制&amp;即可的除某个数值是否表示特定的意义，例如:某个常量为0011 0000 0000，这个数值和 0001 0000 0000 做&amp;， 如果结果为0则说明这个位上的值不为1，在上面的例子中就是这个访问控制不具有public的级别。 当然PHP中不允许使用多个访问控制修饰符修饰同一个成员。这种处理方式在很多语言中都很常见。</p><p>在前面有提到当我们没有给成员方法或成员变量设置访问控制时，其默认值为public。 与常规的访问控制实现一样，也是在语法解析阶段进行的。</p><pre><code>method_modifiers:        /* empty */        { Z_LVAL($$.u.constant) = ZEND_ACC_PUBLIC; }    |   non_empty_member_modifiers          { $$ = $1;          if (!(Z_LVAL($$.u.constant) &amp; ZEND_ACC_PPP_MASK))        { Z_LVAL($$.u.constant) |= ZEND_ACC_PUBLIC; } };</code></pre><p>虽然是在语法解析时就已经设置了访问控制，但其最终还是要存储在相关结构中。 在上面的语法解析过程中，访问控制已经存储在编译节点中，在编译具体的类成员时会传递给相关的结构。 此变量会作为一个参数传递给生成中间代码的函数。如在解析成员方法时，PHP内核是通过调用zend_do_begin_function_declaration 函数实现，此函数的第五个参数表示访问控制，在具体的代码中，</p><pre><code>// ...省略fn_flags = Z_LVAL(fn_flags_znode-&gt;u.constant);// ... 省略op_array.fn_flags |= fn_flags;//  ...省略如此，就将访问控制的相关参数传递给了将要执行的中间代码。 假如我们先现在有下面一段代码：class Tipi{    private static function t() {        echo 1;    }}Tipi::t();</code></pre><p>这个还是上一小节中我们说明静态成员方法的示例，只是，这里我们将其访问控制从public变成了private。 执行这段代码会报错：Fatal error: Call to private method Tipi::t() from context ‘’ in…</p><p>根据前一节的内容我们知道，如果要执行一个静态成员变量需要先获得类，再获得类的方法，最后执行访方法。 而是否有访问权限的检测的实现过程在获取类的方法过程中，即在zend_std_get_static_method函数中。 此函数在获取了类的方法后，会执行访问控制的检查过程。</p><pre><code>if (fbc-&gt;op_array.fn_flags &amp; ZEND_ACC_PUBLIC) {    //公有方法，可以访问} else if (fbc-&gt;op_array.fn_flags &amp; ZEND_ACC_PRIVATE) {    //  私有方法，报错} else if ((fbc-&gt;common.fn_flags &amp; ZEND_ACC_PROTECTED)) {    //  保护方法，报错}</code></pre><p>见前面有关访问控制常量的讨论，这是使用的是 fbc-&gt;op_array.fn_flags &amp; ZEND_ACC_PUBLIC 而不是使用==来判断访问控制类型， 通过这种方式，op_array.fn_flags中可以保存不止访问控制的信息，所以flag使用的是复数。</p><p>对于成员函数来说，其对于访问控制存储在函数结构体中的fn_flags字段中， 不管是函数本身的common结构体中的fn_flags，还是函数包含所有中间代码的代码集合op_array中的fn_flags。</p><h2 id="访问控制的小漏洞"><a href="#访问控制的小漏洞" class="headerlink" title="访问控制的小漏洞"></a>访问控制的小漏洞</h2><p>先看一个小例子吧：</p><pre><code>&lt;?phpclass A {    private $money = 10000;    public function doSth($anotherA) {        $anotherA-&gt;money = 10000000000;    }    public function getMoney() {        return $this-&gt;money;        }}$b = new A();echo $b-&gt;getMoney(); // 10000$a = new A();$a-&gt;doSth($b);echo $b-&gt;getMoney(); // 10000000000;?&gt;</code></pre><p>在$a变量的doSth()方法中我们直接修改了$b变量的私有成员money，当然我们不太可能这样写代码，从封装的角度来看， 这也是不应该的行为，从PHP实现的角度来看，这并不是一个功能，在其他语言中并不是这样表现的。这也是PHP面向对象不纯粹的表现之一。</p><p>下面我们从实现上面来看看是什么造就了这样的行为。以下函数为验证某个属性能否被访问的验证方法：</p><pre><code>static int zend_verify_property_access(zend_property_info *property_info, zend_class_entry *ce TSRMLS_DC) /* {{{ */{    switch (property_info-&gt;flags &amp; ZEND_ACC_PPP_MASK) {        case ZEND_ACC_PUBLIC:            return 1;        case ZEND_ACC_PROTECTED:            return zend_check_protected(property_info-&gt;ce, EG(scope));        case ZEND_ACC_PRIVATE:            if ((ce==EG(scope) || property_info-&gt;ce == EG(scope)) &amp;&amp; EG(scope)) {                return 1;            } else {                return 0;            }            break;    }    return 0;}</code></pre><p>在doSth()方法中，我们要访问$b对象的属性money，这是Zend引擎检查我们能否访问$b对象的这个属性， 这是Zend赢取获取$b对象的类，以及要访问的属性信息，首先要看看这个属性是否为public，公开的话直接访问就好了。 如果是protected的则继续调用zend_check_protected()函数检查，因为涉及到该类的父类，这里不继续跟这个函数了， 看看是private的情况下是什么情况，在函数doSth()执行的时候，这时的EG(scope)指向的正是类A，ce变量值得就是变量$b的类， 而$b的类就是类A，这样检查就判断成功返回1，也就表示可以访问。</p><p>至于成员函数的检查规则类似，就留给读者自己去探索了。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>71-类的定义</title>
      <link href="/posts/5e456e7a.html"/>
      <url>/posts/5e456e7a.html</url>
      
        <content type="html"><![CDATA[<h1 id="71-类的定义"><a href="#71-类的定义" class="headerlink" title="71-类的定义"></a>71-类的定义</h1><p>在这一节中，我们正式的定义一个类。首先我给出PHP语言的实现：</p><pre><code>&lt;?phpclass myclass{    public $public_var;    private $private_var;    protected $protected_var;    public static $static_var;    public function __construct()    {        echo &quot;我是__construct方法\n&quot;;    }    public function public_method()    {        echo &quot;我是public类型的方法\n&quot;;    }    public function private_method()    {        echo &quot;我是private类型的方法\n&quot;;    }    public function protected_method()    {        echo &quot;我是protected类型的方法\n&quot;;    }    public static function static_var()    {        echo &quot;我是static类型的方法\n&quot;;    }}?&gt;</code></pre><h2 id="定义类对应的zend-class-entry"><a href="#定义类对应的zend-class-entry" class="headerlink" title="定义类对应的zend_class_entry"></a>定义类对应的zend_class_entry</h2><p>定义类的第一步，便是先定义好这个类的zend_class_entry，这一步操作是在MINIT阶段完成的。</p><pre><code>static zend_function_entry myclass_method[]={NULL,NULL,NULL};PHP_MINIT_FUNCTION(test){    zend_class_entry ce;    INIT_CLASS_ENTRY(ce,&quot;myclass&quot;,myclass_method);    zend_register_internal_class(&amp;ce TSRMLS_CC);    return SUCCESS;}//这就是最简单的一个类，没有属性没有方法，但是可以使用了&lt;?php$obj = new myclass();var_dump($obj);//得到：object(myclass)#1 (0) {}?&gt;</code></pre><p>某个类的zend_class_entry会经常用到，所以我们一般会把它保存在一个变量里，供扩展中其它地方的程序使用，所以上述的代码组合一般是这样的：</p><pre><code>zend_class_entry *myclass_ce;static zend_function_entry myclass_method[]={    {NULL,NULL,NULL}};ZEND_MINIT_FUNCTION(test){    zend_class_entry ce;    INIT_CLASS_ENTRY(ce,&quot;myclass&quot;,myclass_method);    myclass_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);    return SUCCESS;}</code></pre><h2 id="为类定义属性"><a href="#为类定义属性" class="headerlink" title="为类定义属性"></a>为类定义属性</h2><p>我们可以用zend_declare_property*系列函数还完成这项操作，为某个类定义属性一般会需要三个信息：</p><ul><li>属性的名称</li><li>属性的默认值</li><li>属性的访问权限等</li></ul><p>我们为上面的myclass类定义一个名为“public_var”的属性，默认值为null，访问权限为public。</p><pre><code>ZEND_MINIT_FUNCTION(test){    zend_class_entry ce;    INIT_CLASS_ENTRY(ce,&quot;myclass&quot;,myclass_method);    myclass_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);    //定义属性    zend_declare_property_null(myclass_ce, &quot;public_var&quot;, strlen(&quot;public_var&quot;), ZEND_ACC_PUBLIC TSRMLS_CC);    return SUCCESS;}</code></pre><p>ZEND_ACC_PUBLIC是ZEND_ACC系列掩码中的一个，代表着public，其余的还有ZEND_ACC_PRIVATE,ZEND_ACC_PROTECTED等等，详细描述请见后面的章节。这三个掩码比较简单，就不在叙述了。</p><h2 id="为类定义方法"><a href="#为类定义方法" class="headerlink" title="为类定义方法"></a>为类定义方法</h2><p>为类定义方法比较繁琐一些，首先我们先回顾一下zend_function_entry结构，在以前我们用它来保存我们扩展的函数，通过它把PHP语言中的函数和我们用C语言编写的函数联系起来，在这它也发挥了这么一个桥梁的作用。下面我们实现myclass类的public_method()和构造方法。</p><pre><code>//首先，定义这个函数的C语言部分，不过这一次我们使用的是ZEND_METHODZEND_METHOD( myclass , public_method ){    php_printf(&quot;我是public类型的方法\n&quot;);}ZEND_METHOD( myclass , __construct ){    php_printf(&quot;我是__construct方法\n&quot;);}//然后，定义一个zend_function_entryzend_function_entry myclass_method[]={    ZEND_ME(myclass,    public_method,    NULL,    ZEND_ACC_PUBLIC)    ZEND_ME(myclass,    __construct,    NULL,    ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)    {NULL,    NULL,    NULL}}//最后，在MINIT阶段register internal class的时候将它作为一个参数传递进去ZEND_MINIT_FUNCTION(test){    zend_class_entry ce;    //这里使用了myclass_method这个zend_function_entry    INIT_CLASS_ENTRY(ce,&quot;myclass&quot;,myclass_method);    myclass_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);    return SUCCESS;}</code></pre><p>现在我们在PHP脚本中调用一下这个方法，看看输出结果：</p><pre><code>&lt;?php$obj = new myclass();$obj-&gt;public_method();/*walu@walu-ThinkPad-Edge:/cnan/program/php-5.3.6/ext/test$ php test.php我是__construct方法我是public_method方法*/?&gt;</code></pre><p>这里在定义__construct方法的时候，使用到了ZEND_ACC_CTOR，它的作用便是声明这个方法是此类的构造函数，而ZEND_ACC_PUBLIC|ZEND_ACC_CTOR是我们常见的掩码或运算，代表它是一个public类型构造函数，:-)。如果我们去掉ZEND_ACC_CTOR标志，那么此构造函数还会其作用吗？在这里例子中它仍然起作用，但是在别的环境下我就不敢保证了。</p><p>说到现在，protected和private类型的属性与方法的定义和public的一样。而定义static的属性与方法只是在掩码标志中加入ZEND_ACC_STATIC即可。</p><p>下面详细的罗列出了所有掩码，fn_flags代表可以在定义方法时使用，zend_property_info.flags代表可以在定义属性时使用，ce_flags代表在定义zend_class_entry时候可用。</p><pre><code>#define ZEND_ACC_STATIC                     0x01     /* fn_flags, zend_property_info.flags */#define ZEND_ACC_ABSTRACT                   0x02     /* fn_flags */#define ZEND_ACC_FINAL                      0x04     /* fn_flags */#define ZEND_ACC_IMPLEMENTED_ABSTRACT       0x08     /* fn_flags */#define ZEND_ACC_IMPLICIT_ABSTRACT_CLASS    0x10     /* ce_flags */#define ZEND_ACC_EXPLICIT_ABSTRACT_CLASS    0x20     /* ce_flags */#define ZEND_ACC_FINAL_CLASS                0x40     /* ce_flags */#define ZEND_ACC_INTERFACE                  0x80     /* ce_flags */#define ZEND_ACC_INTERACTIVE                0x10     /* fn_flags */#define ZEND_ACC_PUBLIC                     0x100    /* fn_flags, zend_property_info.flags */#define ZEND_ACC_PROTECTED                  0x200    /* fn_flags, zend_property_info.flags */#define ZEND_ACC_PRIVATE                    0x400    /* fn_flags, zend_property_info.flags */#define ZEND_ACC_PPP_MASK    (ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)#define ZEND_ACC_CHANGED                    0x800    /* fn_flags, zend_property_info.flags */#define ZEND_ACC_IMPLICIT_PUBLIC            0x1000   /* zend_property_info.flags; unused (1) */#define ZEND_ACC_CTOR                       0x2000   /* fn_flags */#define ZEND_ACC_DTOR                       0x4000   /* fn_flags */#define ZEND_ACC_CLONE                      0x8000   /* fn_flags */#define ZEND_ACC_ALLOW_STATIC               0x10000  /* fn_flags */#define ZEND_ACC_SHADOW                     0x20000  /* fn_flags */#define ZEND_ACC_DEPRECATED                 0x40000  /* fn_flags */#define ZEND_ACC_CLOSURE                    0x100000 /* fn_flags */#define ZEND_ACC_CALL_VIA_HANDLER           0x200000 /* fn_flags */</code></pre><p>ZEND_ACC_CTOR与ZEND_ACC_DTOR是比较特殊的掩码标志，分别代表着构造函数与析构函数，不要将这两个标志位用在其它的方法上面。其它的一些魔术方法，如<strong>get,</strong>call等大都需要arginfo，有关它们的内容将在下一章中描述。</p><h2 id="为类定义常量"><a href="#为类定义常量" class="headerlink" title="为类定义常量"></a>为类定义常量</h2><p>这个内容比较简单，只涉及到一组函数，可以查看Zend/zend_API.h</p><pre><code>ZEND_API int zend_declare_class_constant(zend_class_entry *ce, const char *name, size_t name_length, zval *value TSRMLS_DC);ZEND_API int zend_declare_class_constant_null(zend_class_entry *ce, const char *name, size_t name_length TSRMLS_DC);ZEND_API int zend_declare_class_constant_long(zend_class_entry *ce, const char *name, size_t name_length, long value TSRMLS_DC);ZEND_API int zend_declare_class_constant_bool(zend_class_entry *ce, const char *name, size_t name_length, zend_bool value TSRMLS_DC);ZEND_API int zend_declare_class_constant_double(zend_class_entry *ce, const char *name, size_t name_length, double value TSRMLS_DC);ZEND_API int zend_declare_class_constant_stringl(zend_class_entry *ce, const char *name, size_t name_length, const char *value, size_t value_length TSRMLS_DC);ZEND_API int zend_declare_class_constant_string(zend_class_entry *ce, const char *name, size_t name_le</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70-类的原型zend_class_entry</title>
      <link href="/posts/5a3f5944.html"/>
      <url>/posts/5a3f5944.html</url>
      
        <content type="html"><![CDATA[<h1 id="70-类的原型zend-class-entry"><a href="#70-类的原型zend-class-entry" class="headerlink" title="70-类的原型zend_class_entry"></a>70-类的原型zend_class_entry</h1><p>zend_class_entry是内核中定义的一个结构体，是内核实现PHP语言中类与对象的一个非常基础、关键的结构类型。他就相当于我们定义的类的原型。</p><p>如果我们想获得一个名字为myclass的类该怎么做呢？首先我们定义一个zend_class_entry变量，并为它设置名字，最后注册到runtime中去。</p><pre><code>zend_class_entry *myclass_ce;static zend_function_entry myclass_method[] = {    { NULL, NULL, NULL }};ZEND_MINIT_FUNCTION(sample3){    zend_class_entry ce;    //&quot;myclass&quot;是这个类的名称。    INIT_CLASS_ENTRY(ce, &quot;myclass&quot;,myclass_method);    myclass_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);    return SUCCESS;}</code></pre><p>这样我们便定义了一个类myclass，而且我们可以正常的在PHP语言中使用它，比如：</p><pre><code>&lt;?php$obj = new myclass();?&gt;</code></pre><p>我们上面还定义了一个myclass_ce指针，他是干什么用的呢？当我们在扩展中对这个类进行操作，比如生成实例的时候，会使用到它，它的作用就类似与打开文件的操作句柄。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69-类的成员方法</title>
      <link href="/posts/1b87585b.html"/>
      <url>/posts/1b87585b.html</url>
      
        <content type="html"><![CDATA[<h1 id="69-类的成员方法"><a href="#69-类的成员方法" class="headerlink" title="69-类的成员方法"></a>69-类的成员方法</h1><p>成员方法从本质上来讲也是一种函数，所以其存储结构也和常规函数一样，存储在zend_function结构体中。 对于一个类的多个成员方法，它是以HashTable的数据结构存储了多个zend_function结构体。 和前面的成员变量一样，在类声明时成员方法也通过调用zend_initialize_class_data方法，初始化了整个方法列表所在的HashTable。 在类中我们如果要定义一个成员方法，格式如下：</p><pre><code>class Tipi{    public function t() {        echo 1;    }}</code></pre><p>除去访问控制关键字，一个成员方法和常规函数是一样的，从语法解析中调用的函数一样（都是zend_do_begin_function_declaration函数）， 但是其调用的参数有一些不同，第三个参数is_method，成员方法的赋值为1，表示它作为成员方法的属性。 在这个函数中会有一系统的编译判断，比如在接口中不能声明私有的成员方法。 看这样一段代码：</p><pre><code>interface Ifce {   private function method();}</code></pre><p>如果直接运行，程序会报错：Fatal error: Access type for interface method Ifce::method() must be omitted in 这段代码对应到zend_do_begin_function_declaration函数中的代码，如下：</p><pre><code>if (is_method) {    if (CG(active_class_entry)-&gt;ce_flags &amp; ZEND_ACC_INTERFACE) {        if ((Z_LVAL(fn_flags_znode-&gt;u.constant) &amp; ~(ZEND_ACC_STATIC|ZEND_ACC_PUBLIC))) {            zend_error(E_COMPILE_ERROR, &quot;Access type for interface method %s::%s() must be omitted&quot;,                CG(active_class_entry)-&gt;name, function_name-&gt;u.constant.value.str.val);        }        Z_LVAL(fn_flags_znode-&gt;u.constant) |= ZEND_ACC_ABSTRACT; /* propagates to the rest of the parser */    }    fn_flags = Z_LVAL(fn_flags_znode-&gt;u.constant); /* must be done *after* the above check */} else {    fn_flags = 0;}</code></pre><p>在此程序判断后，程序将方法直接添加到类结构的function_talbe字段，在此之后，又是若干的编译检测。 比如接口的一些魔术方法不能被设置为非公有，不能被设置为static，如<strong>call()、</strong>callStatic()、__get()等。 如果在接口中设置了静态方法，如下定义的一个接口：</p><pre><code>interface ifce {    public static function __get();}</code></pre><p>若运行这段代码，则会显示Warning：Warning: The magic method __get() must have public visibility and cannot be static in</p><p>这段编译检测在zend_do_begin_function_declaration函数中对应的源码如下：</p><pre><code>if (CG(active_class_entry)-&gt;ce_flags &amp; ZEND_ACC_INTERFACE) {        if ((name_len == sizeof(ZEND_CALL_FUNC_NAME)-1) &amp;&amp; (!memcmp(lcname, ZEND_CALL_FUNC_NAME, sizeof(ZEND_CALL_FUNC_NAME)-1))) {            if (fn_flags &amp; ((ZEND_ACC_PPP_MASK | ZEND_ACC_STATIC) ^ ZEND_ACC_PUBLIC)) {                zend_error(E_WARNING, &quot;The magic method __call() must have public visibility and cannot be static&quot;);            }        } else if() {   //  其它魔术方法的编译检测        }}</code></pre><p>同样，对于类中的这些魔术方法，也有同样的限制，如果在类中定义了静态的魔术方法，则显示警告。如下代码：</p><pre><code>class Tipi {    public static function __get($var) {    }}</code></pre><p>运行这段代码，则会显示： Warning: The magic method __get() must have public visibility and cannot be static in</p><p>与成员变量一样，成员方法也有一个返回所有成员方法的函数–get_class_methods()。 此函数返回由指定的类中定义的方法名所组成的数组。 从 PHP 4.0.6 开始，可以指定对象本身来代替指定的类名。 它属于PHP内建函数，整个程序流程就是一个遍历类成员方法列表，判断是否为符合条件的方法， 如果是，则将这个方法作为一个元素添加到返回数组中。</p><h2 id="静态成员方法"><a href="#静态成员方法" class="headerlink" title="静态成员方法"></a>静态成员方法</h2><p>类的静态成员方法通常也叫做类方法。 与静态成员变量不同，静态成员方法与成员方法都存储在类结构的function_table 字段。</p><p>类的静态成员方法可以通过类名直接访问。</p><pre><code>class Tipi{    public static function t() {        echo 1;    }}Tipi::t();</code></pre><p>以上的代码在VLD扩展下生成的部分中间代码如如下：</p><pre><code>number of ops:  8compiled vars:  noneline     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------   2     0  &gt;   EXT_STMT         1      NOP   8     2      EXT_STMT         3      ZEND_INIT_STATIC_METHOD_CALL                             &apos;Tipi&apos;,&apos;t&apos;         4      EXT_FCALL_BEGIN         5      DO_FCALL_BY_NAME                              0         6      EXT_FCALL_END   9     7    &gt; RETURN                                                   1branch: #  0; line:     2-    9; sop:     0; eop:     7path #1: 0,Class Tipi:Function t:Finding entry pointsBranch analysis from position: 0</code></pre><p>从以上的内容可以看出整个静态成员方法的调用是一个先查找方法，再调用的过程。 而对于调用操作，对应的中间代码为 ZEND_INIT_STATIC_METHOD_CALL。由于类名和方法名都是常量， 于是我们可以知道中间代码对应的函数是ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER。 在这个函数中，它会首先调用zend_fetch_class函数，通过类名在EG(class_table)中查找类，然后再执行静态方法的获取方法。</p><pre><code>if (ce-&gt;get_static_method) {    EX(fbc) = ce-&gt;get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);} else {    EX(fbc) = zend_std_get_static_method(ce, function_name_strval, function_name_strlen TSRMLS_CC);}</code></pre><p>如果类结构中的get_static_method方法存在，则调用此方法，如果不存在，则调用zend_std_get_static_method。 在PHP的源码中get_static_method方法一般都是NULL，这里我们重点查看zend_std_get_static_method函数。 此函数会查找ce-&gt;function_table列表，在查找到方法后检查方法的访问控制权限，如果不允许访问，则报错，否则返回函数结构体。 关于访问控制，我们在后面的小节中说明。</p><h2 id="静态方法和实例方法的小漏洞"><a href="#静态方法和实例方法的小漏洞" class="headerlink" title="静态方法和实例方法的小漏洞"></a>静态方法和实例方法的小漏洞</h2><p>细心的读者应该注意到前面提到静态方法和实例方法都是保存在类结构体zend_class_entry.function_table中，那这样的话， Zend引擎在调用的时候是怎么区分这两类方法的，比如我们静态调用实例方法或者实例调用静态方法会怎么样呢？</p><p>可能一般人不会这么做，不过笔者有一次错误的这样调用了，而代码没有出现任何问题， 在review代码的时候意外发现笔者像实例方法那样调用的静态方法，而什么问题都没有发生(没有报错)。 在理论上这种情况是不应发生的，类似这这样的情况在PHP中是非常的多的，例如前面提到的create_function方法返回的伪匿名方法， 后面介绍访问控制时还会介绍访问控制的一些瑕疵，PHP在现实中通常采用Quick and Dirty的方式来实现功能和解决问题， 这一点和Ruby完整的面向对象形成鲜明的对比。我们先看一个例子：</p><pre><code>&lt;?phperror_reporting(E_ALL);class A {    public static function staticFunc() {        echo &quot;static&quot;;    }    public function instanceFunc() {        echo &quot;instance&quot;;        }}A::instanceFunc(); // instance$a = new A();$a-&gt;staticFunc();  // static?&gt;</code></pre><p>上面的代码静态的调用了实例方法，程序输出了instance，实例调用静态方法也会正确输出static，这说明这两种方法本质上并没有却别。 唯一不同的是他们被调用的上下文环境，例如通过实例方法调用方法则上下文中将会有$this这个特殊变量，而在静态调用中将无法使用$this变量。</p><p>不过实际上Zend引擎是考虑过这个问题的，将error_reporting的级别增加E_STRICT，将会出出现E_STRICT错误：</p><pre><code>Strict Standards: Non-static method A::instanceFunc() should not be called statically</code></pre><p>这只是不建议将实例方法静态调用，而对于实例调用静态方法没有出现E_STRICT错误，有人说：某些事情可以做并不代表我们要这样做。</p><p>PHP在实现新功能时通常采用渐进的方式，保证兼容性，在具体实现上通常采用打补丁的方式，这样就造成有些”边界“情况没有照顾到。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>68-类的成员变量</title>
      <link href="/posts/c01e61ab.html"/>
      <url>/posts/c01e61ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="68-类的成员变量"><a href="#68-类的成员变量" class="headerlink" title="68-类的成员变量"></a>68-类的成员变量</h1><p>在上一小节，我们介绍了类的结构和声明过程，从而，我们知道了类的存储结构，接口抽象类等类型的实现方式。 在本小节，我们将介绍类的成员变量和成员方法。首先，我们看一下，什么是成员变量，什么是成员方法。</p><p>类的成员变量在PHP中本质上是一个变量，只是这些变量都归属于某个类，并且给这些变量是有访问控制的。 类的成员变量也称为成员属性，它是现实世界实体属性的抽象，是可以用来描述对象状态的数据。</p><p>类的成员方法在PHP中本质上是一个函数，只是这个函数以类的方法存在，它可能是一个类方法也可能是一个实例方法， 并且在这些方法上都加上了类的访问控制。类的成员方法是现实世界实体行为的抽象，可以用来实现类的行为。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>前面介绍过变量，不过那些变量要么是定义在全局范围中，叫做全局变量，要么是定义在某个函数中， 叫做局部变量。 成员变量是定义在类里面，并和成员方法处于同一层次。如下一个简单的PHP代码示例，定义了一个类， 并且这个类有一个成员变量。</p><pre><code>class Tipi {    public $var;}</code></pre><p>类的结构在PHP内核中的存储方式我们已经在上一小节介绍过了。现在，我们要讨论类的成员变量的存储方式。 假如我们需要直接访问这个变量，整个访问过程是什么？ 当然，以这个示例来说，访问这个成员变量是通过对象来访问，关于对象的相关知识我们将在后面的小节作详细的介绍。</p><p>当我们用VLD扩展查看以上代码生成的中间代码时，我们发现，并没有相关的中间代码输出。 这是因为成员变量在编译时已经注册到了类的结构中，那注册的过程是什么? 成员变量注册的位置在哪？</p><p>我们从上一小节知道，在编译时类的声明编译会调用zend_do_begin_class_declaration函数。 此函数用来初始化类的基本信息，其中包括类的成员变量。其调用顺序为： [zend_do_begin_class_declaration] –&gt; [zend_initialize_class_data] –&gt; [zend_hash_init_ex]</p><p>zend_hash_init_ex(&amp;ce-&gt;default_properties, 0, NULL, zval_ptr_dtor_func, persistent_hashes, 0);</p><p>在声明类的时候初始化了类的成员变量所在的HashTable，之后如果有新的成员变量声明时，在编译时zend_do_declare_property。函数首先检查成员变量不允许的一些情况：</p><ul><li>接口中不允许使用成员变量</li><li>成员变量不能拥有抽象属性</li><li>不能声明成员变量为final</li><li>不能重复声明属性</li></ul><p>如果在上面的PHP代码中的类定义中，给成员变量前面添加final关键字：</p><pre><code>class Tipi {    public final $var;}</code></pre><p>运行程序将报错：Fatal error: Cannot declare property Tipi::$var final, the final modifier is allowed only for methods and classes in .. 这个错误由zend_do_declare_property函数抛出：</p><pre><code>if (access_type &amp; ZEND_ACC_FINAL) {    zend_error(E_COMPILE_ERROR, &quot;Cannot declare property %s::$%s final, the final modifier is allowed only for methods and classes&quot;,               CG(active_class_entry)-&gt;name, var_name-&gt;u.constant.value.str.val);}</code></pre><p>在定义检查没有问题之后，函数会进行成员变量的初始化操作。</p><pre><code>ALLOC_ZVAL(property);   //  分配内存if (value) {    //  成员变量有初始化数据    *property = value-&gt;u.constant;} else {    INIT_PZVAL(property);    Z_TYPE_P(property) = IS_NULL;}</code></pre><p>在初始化过程中，程序会先分配内存，如果这个成员变量有初始化的数据，则将数据直接赋值给该属性， 否则初始化ZVAL，并将其类型设置为IS_NULL。在初始化过程完成后，程序通过调用 zend_declare_property_ex 函数将此成员变量添加到指定的类结构中。</p><p>以上为成员变量的初始化和注册成员变量的过程，常规的成员变量最后都会注册到类的 default_properties 字段。 在我们平时的工作中，可能会用不到上面所说的这些过程，但是我们可能会使用get_class_vars()函数来查看类的成员变量。 此函数返回由类的默认属性组成的关联数组，这个数组的元素以 varname =&gt; value 的形式存在。其实现核心代码如下：</p><pre><code>if (zend_lookup_class(class_name, class_name_len, &amp;pce TSRMLS_CC) == FAILURE) {    RETURN_FALSE;} else {    array_init(return_value);    zend_update_class_constants(*pce TSRMLS_CC);    add_class_vars(*pce, &amp;(*pce)-&gt;default_properties, return_value TSRMLS_CC);    add_class_vars(*pce, CE_STATIC_MEMBERS(*pce), return_value TSRMLS_CC);}</code></pre><p>首先调用zend_lookup_class函数查找名为class_name的类，并将赋值给pce变量。 这个查找的过程最核心是一个HashTable的查找函数zend_hash_quick_find，它会查找EG(class_table)。 判断类是否存在，如果存在则直接返回。如果不存在，则需要判断是否可以自动加载，如果可以自动加载，则会加载类后再返回。 如果不能找到类，则返回FALSE。如果找到了类，则初始化返回的数组，更新类的静态成员变量，添加类的成员变量到返回的数组。 这里针对类的静态成员变量有一个更新的过程，关于这个过程我们在下面有关于静态成员变量中做相关介绍。</p><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>类的静态成员变量是所有实例共用的，它归属于这个类，因此它也叫做类变量。 在PHP的类结构中，类本身的静态变量存放在类结构的 default_static_members 字段中。</p><p>与普通成员变量不同，类变量可以直接通过类名调用，这也体现其称作类变量的特别。一个PHP示例：</p><pre><code>class Tipi {    public static $var = 10;}Tipi::$var;</code></pre><p>这是一个简单的类，它仅包括一个公有的静态变量$var。 通过VLD扩展查看其生成的中间代码：</p><pre><code>function name:  (null)number of ops:  6compiled vars:  !0 = $varline     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------   2     0  &gt;   EXT_STMT         1      NOP   6     2      EXT_STMT         3      ZEND_FETCH_CLASS                                 :1      &apos;Tipi&apos;         4      FETCH_R                      static member               &apos;var&apos;         5    &gt; RETURN                                                   1branch: #  0; line:     2-    6; sop:     0; eop:     5path #1: 0,Class Tipi: [no user functions]</code></pre><p>这段生成的中间代码仅与Tipi::$var;这段调用对应，它与前面的类定义没有多大关系。 根据前面的内容和VLD生成的内容，我们可以知道PHP代码：Tipi::$var;　生成的中间代码包括ZEND_FETCH_CLASS和FETCH_R。 这里只是一个静态变量的调用，但是它却生成了两个中间代码，什么原因呢？ 很直白的解释：我们要调用一个类的静态变量，当然要先找到这个类，然后再获取这个类的变量。 从PHP源码来看，这是由于在编译时其调用了zend_do_fetch_static_member函数， 而在此函数中又调用了zend_do_fetch_class函数， 从而会生成ZEND_FETCH_CLASS中间代码。它所对应的执行函数为 ZEND_FETCH_CLASS_SPEC_CONST_HANDLER。 此函数会调用zend_fetch_class函数（Zend/zend_execute_API.c）。 而zend_fetch_class函数最终也会调用 zend_lookup_class_ex 函数查找类，这与前面的查找方式一样。</p><p>找到了类，接着应该就是查找类的静态成员变量，其最终调用的函数为：zend_std_get_static_property。 这里由于第二个参数的类型为 ZEND_FETCH_STATIC_MEMBER。这个函数最后是从 static_members 字段中查找对应的值返回。 而在查找前会和前面一样，执行zend_update_class_constants函数，从而更新此类的所有静态成员变量，其程序流程如图所示：</p><center><br><img src="images/2012_03_05_05.jpg" alt><br></center><center><br>静态变量更新流程图<br></center>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>67-类的结构和实现</title>
      <link href="/posts/35a2a7f8.html"/>
      <url>/posts/35a2a7f8.html</url>
      
        <content type="html"><![CDATA[<h1 id="67-类的结构和实现"><a href="#67-类的结构和实现" class="headerlink" title="67-类的结构和实现"></a>67-类的结构和实现</h1><p>面向对象编程中我们的编程都是围绕类和对象进行的。那在PHP内部类是怎么实现的呢？ 它的内存布局以及存储是怎么样的呢？继承、封装和多态又是怎么实现的呢？</p><h2 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h2><p>首先我们看看类是什么。类是用户定义的一种抽象数据类型，它是现实世界中某些具有共性事物的抽象。 有时我们也可以理解其为对象的类别。类也可以看作是一种复合型的结构，其需要存储多元化的数据， 如属性、方法、以及自身的一些性质等。</p><p>类和函数类似，PHP内置及PHP扩展均可以实现自己的内部类，也可以由用户使用PHP代码进行定义。 当然我们在编写代码时通常是自己定义。</p><p>使用上，我们使用class关键字进行定义，后面接类名，类名可以是任何非PHP保留字的名字。 在类名后面紧跟着一对花括号，里面是类的实体，包括类所具有的属性，这些属性是对象的状态的抽象， 其表现为PHP中支持的数据类型，也可以包括对象本身，通常我们称其为成员变量。 除了类的属性， 类的实体中也包括类所具有的操作，这些操作是对象的行为的抽象，其表现为用操作名和实现该操作的方法， 通常我们称其为成员方法或成员函数。看类示例的代码：</p><pre><code>class ParentClass {}interface Ifce {        public function iMethod();}final class Tipi extends ParentClass implements Ifce {        public static $sa = &apos;aaa&apos;;        const CA = &apos;bbb&apos;;        public function __constrct() {        }        public function iMethod() {        }        private function _access() {        }        public static function access() {        }}</code></pre><p>这里定义了一个父类ParentClass，一个接口Ifce，一个子类Tipi。子类继承父类ParentClass， 实现接口Ifce，并且有一个静态变量$sa，一个类常量 CA，一个公用方法，一个私有方法和一个公用静态方法。 这些结构在Zend引擎内部是如何实现的？类的方法、成员变量是如何存储的？访问控制，静态成员是如何标记的？</p><p>首先，我们看看类的内部存储结构：</p><pre><code>struct _zend_class_entry {    char type;     // 类型：ZEND_INTERNAL_CLASS / ZEND_USER_CLASS    char *name;// 类名称    zend_uint name_length;                  // 即sizeof(name) - 1    struct　_zend_class_entry *parent; // 继承的父类    int　refcount;  // 引用数    zend_bool constants_updated;    zend_uint ce_flags; // ZEND_ACC_IMPLICIT_ABSTRACT_CLASS: 类存在abstract方法    // ZEND_ACC_EXPLICIT_ABSTRACT_CLASS: 在类名称前加了abstract关键字    // ZEND_ACC_FINAL_CLASS    // ZEND_ACC_INTERFACE    HashTable function_table;      // 方法    HashTable default_properties;          // 默认属性    HashTable properties_info;     // 属性信息    HashTable default_static_members;// 类本身所具有的静态变量    HashTable *static_members; // type == ZEND_USER_CLASS时，取&amp;default_static_members;    // type == ZEND_INTERAL_CLASS时，设为NULL    HashTable constants_table;     // 常量    struct _zend_function_entry *builtin_functions;// 方法定义入口    union _zend_function *constructor;    union _zend_function *destructor;    union _zend_function *clone;    /* 魔术方法 */    union _zend_function *__get;    union _zend_function *__set;    union _zend_function *__unset;    union _zend_function *__isset;    union _zend_function *__call;    union _zend_function *__tostring;    union _zend_function *serialize_func;    union _zend_function *unserialize_func;    zend_class_iterator_funcs iterator_funcs;// 迭代    /* 类句柄 */    zend_object_value (*create_object)(zend_class_entry *class_type TSRMLS_DC);    zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object,        intby_ref TSRMLS_DC);    /* 类声明的接口 */    int(*interface_gets_implemented)(zend_class_entry *iface,            zend_class_entry *class_type TSRMLS_DC);    /* 序列化回调函数指针 */    int(*serialize)(zval *object， unsignedchar**buffer, zend_uint *buf_len,             zend_serialize_data *data TSRMLS_DC);    int(*unserialize)(zval **object, zend_class_entry *ce, constunsignedchar*buf,            zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC);    zend_class_entry **interfaces;  //  类实现的接口    zend_uint num_interfaces;   //  类实现的接口数    char *filename; //  类的存放文件地址 绝对地址    zend_uint line_start;   //  类定义的开始行    zend_uint line_end; //  类定义的结束行    char *doc_comment;    zend_uint doc_comment_len;    struct _zend_module_entry *module; // 类所在的模块入口：EG(current_module)};</code></pre><p>取上面这个结构的部分字段，我们分析文章最开始的那段PHP代码在内核中的表现。 如下表所示：</p><table><br><tr><td>字段名</td><td>字段说明</td><td>ParentClass类</td><td>Ifce接口</td><td>Tipi类</td></tr><br><tr><td>name</td><td>类名</td><td>ParentClass Ifce</td><td>Tipi</td></tr><br><tr><td>type</td><td>类别</td><td>2</td><td>2</td><td>2</td></tr><br><tr><td>parent</td><td>父类</td><td>空</td><td>空</td><td>ParentClass类</td></tr><br><tr><td>refcount</td><td>引用计数</td><td>1</td><td>1</td><td>2</td></tr><br><tr><td>ce_flags</td><td>类的类型</td><td>0</td><td>144</td><td>524352</td></tr><br><tr><td>function_table</td><td>函数列表</td><td>空</td><td>function_name=iMethod | type=2 | fn_flags=258</td><td>function_name=__construct | type=2 | fn_flags=8448<br><br>function_name=iMethod | type=2 | fn_flags=65800<br><br>function_name=_access | type=2 | fn_flags=66560<br><br>function_name=access | type=2 | fn_flags=257</td></tr><br><tr><td>interfaces</td><td>接口列表</td><td>空</td><td>空</td><td>Ifce接口</td><td>接口数为1</td></tr><br><tr><td>filename</td><td>存放文件地址</td><td>/tipi.php</td><td>/tipi.php</td><td>/ipi.php</td></tr><br><tr><td>line_start</td><td>类开始行数</td><td>15</td><td>18</td><td>22</td></tr><br><tr><td>line_end</td><td>类结束行数</td><td>16</td><td>20</td><td>38</td></tr><br></table><p>类的结构中，type有两种类型，数字标记为1和2。分别为一下宏的定义，也就是说用户定义的类和模块或者内置的类也是保存在这个结构里的：</p><pre><code>#define ZEND_INTERNAL_CLASS         1#define ZEND_USER_CLASS             2</code></pre><p>对于父类和接口，都是保存在struct　_zend_class_entry结构体中。这表示接口也是以类的形式存储， 而实现是一样的，并且在继承等操作时有与类操作的不同的处理。常规的成员方法存放在函数结构体的哈希表中， 而魔术方法则单独保存。 如在类定义中的 union _zend_function *constructor; 定义就是类的构造魔术方法， 它是以函数的形式存在于类结构中，并且与常规的方法分隔开来了。在初始化时，这些魔术方法都会被设置为NULL。</p><h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><p>类的定义是以class关键字开始，在Zend/zend_language_scanner.l文件中，找到class对应的token为T_CLASS。 根据此token，在Zend/zend_language_parser.y文件中，找到编译时调用的函数：</p><pre><code>unticked_class_declaration_statement:        class_entry_type T_STRING extends_from            { zend_do_begin_class_declaration(&amp;$1, &amp;$2, &amp;$3 TSRMLS_CC); }            implements_list            &apos;{&apos;                class_statement_list            &apos;}&apos; { zend_do_end_class_declaration(&amp;$1, &amp;$2 TSRMLS_CC); }    |   interface_entry T_STRING            { zend_do_begin_class_declaration(&amp;$1, &amp;$2, NULL TSRMLS_CC); } interface_extends_list            &apos;{&apos;                class_statement_list            &apos;}&apos; { zend_do_end_class_declaration(&amp;$1, &amp;$2 TSRMLS_CC); };class_entry_type:        T_CLASS         { $$.u.opline_num = CG(zend_lineno); $$.u.EA.type = 0; }    |   T_ABSTRACT T_CLASS { $$.u.opline_num = CG(zend_lineno); $$.u.EA.type = ZEND_ACC_EXPLICIT_ABSTRACT_CLASS; }    |   T_FINAL T_CLASS { $$.u.opline_num = CG(zend_lineno); $$.u.EA.type = ZEND_ACC_FINAL_CLASS; };</code></pre><p>上面的class_entry_type语法说明在语法分析阶段将类分为三种类型：常规类(T_CLASS)， 抽象类(T_ABSTRACT T_CLASS)和final类(T_FINAL T_CLASS )。 他们分别对应的类型在内核中为:</p><ul><li>常规类(T_CLASS) 对应的type=0</li><li>抽象类(T_ABSTRACT T_CLASS) 对应type=ZEND_ACC_EXPLICIT_ABSTRACT_CLASS</li><li>final类(T_FINAL T_CLASS) 对应type=ZEND_ACC_FINAL_CLASS</li></ul><p>除了上面的三种类型外，类还包含有另外两种类型没有加abstract关键字的抽象类和接口：</p><ul><li>没有加abstract关键字的抽象类，它对应的type=ZEND_ACC_IMPLICIT_ABSTRACT_CLASS。 由于在class前面没有abstract关键字，在语法分析时并没有分析出来这是一个抽象类，但是由于类中拥有抽象方法， 在函数注册时判断成员函数是抽象方法或继承类中的成员方法是抽象方法时，会将这个类设置为此种抽象类类型。</li><li>接口，其type=ZEND_ACC_INTERFACE。接口类型的区分是在interface关键字解析时设置，见interface_entry:对应的语法说明。</li></ul><p>这五种类型在Zend/zend_complie.h文件中定义如下：</p><pre><code>#define ZEND_ACC_IMPLICIT_ABSTRACT_CLASS    0x10#define ZEND_ACC_EXPLICIT_ABSTRACT_CLASS    0x20#define ZEND_ACC_FINAL_CLASS                0x40#define ZEND_ACC_INTERFACE                  0x80</code></pre><p>常规类为0，在这里没有定义，并且在程序也是直接赋值为0。</p><p>语法解析完后就可以知道一个类是抽象类还是final类，普通的类，又或者接口。 定义类时调用了zend_do_begin_class_declaration和zend_do_end_class_declaration函数， 从这两个函数传入的参数，zend_do_begin_class_declaration函数用来处理类名，类的类别和父类， zend_do_end_class_declaration函数用来处理接口和类的中间代码 这两个函数在Zend/zend_complie.c文件中可以找到其实现。</p><p>在zend_do_begin_class_declaration中，首先会对传入的类名作一个转化，统一成小写，这也是为什么类名不区分大小的原因，如下代码：</p><pre><code>&lt;?phpclass TIPI {}class tipi {}?&gt;</code></pre><p>运行时程序报错: Fatal error: Cannot redeclare class tipi。 这个错误会在运行生成中间的代码时触发。 此错误的判断过程在后面中间代码生成时说明。而关于类的名称的判断则是通过 T_STRING token， 在语法解析时做的判断， 但是这只能识别出类名是一个字符串。假如类名为一些关键字， 如下代码：</p><pre><code>class self {}</code></pre><p>运行， 程序会显示： Fatal error: Cannot use ‘self’ as class name as it is reserved in…</p><p>以上的错误程序判断定义在 zend_do_begin_class_declaration 函数。 与self关键字一样， 还有parent， static两个关键字的判断在同一个地方。 当这个函数执行完后，我们会得到类声明生成的中间代码为：ZEND_DECLARE_CLASS 。 当然，如果我们是声明内部类的话，则生成的中间代码为： ZEND_DECLARE_INHERITED_CLASS。</p><p>根据生成的中间代码，我们在Zend/zend_vm_execute.h文件中找到其对应的执行函数 ZEND_DECLARE_CLASS_SPEC_HANDLER。 这个函数通过调用 do_bind_class 函数将此类加入到 EG(class_table) 。 在添加到列表的同时，也判断该类是否存在，如果存在，则添加失败，报我们之前提到的类重复声明错误，只是这个判断在编译开启时是不会生效的。</p><p>类相关的各个结构均保存在struct _zend_class_entry 结构体中。这些具体的类别在语法分析过程中进行区分。 识别出类的类别，类的类名等，并将识别出来的结果存放到类的结构中。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66-面向对象开篇</title>
      <link href="/posts/e7329fe7.html"/>
      <url>/posts/e7329fe7.html</url>
      
        <content type="html"><![CDATA[<h1 id="66-面向对象开篇"><a href="#66-面向对象开篇" class="headerlink" title="66-面向对象开篇"></a>66-面向对象开篇</h1><p>面向对象是一种编程范式，它将对象作为程序的基本单元，将程序和数据封装起来， 以此来提高程序的重用性、灵活性和可扩展性。</p><p>目前很多语言都支持面向对象编程，既然对象对象是一种范式，其实这就和具体的编程语言没有直接关系， 只不过很多语言将这个范式作为语言的基本元素，使用C语言也能够进行面向对象编程。</p><p>面向对象的程序设计中包含：</p><ol><li>类。类是具体事物的抽象。通常类定义了事物的属性和所能完成的工作。有一点需要注意， 并不是所有的面向对象编程语言的类都具有class这个明确的实体。例如Javascript就不是基于类的。 Javascript中的类(Function)也具有类定义的特性。这也印证了面向对象只是一种编程范式。</li><li>对象。对象是类的实例。对象是具体的。</li><li>方法。方法是类定义对象可以做的事情。</li><li>继承性。继承是类的具体化，子类是比具备更多特性和行为的类。面向对象是对现实世界的一个抽象。 在很多时候的关系并不一定是继承关系。能在一定程序上实现代码的重用。</li><li>封装性、抽象性。封装性能实现的复杂性隐藏，减少出错的可能。</li></ol><p>从我们接触PHP开始，我们最先遇到的是函数：数组操作函数，字符串操作函数，文件操作函数等等。 这些函数是我们使用PHP的基础，也是PHP自出生就支持的面向过程编程。面向过程将一个个功能封装， 以一种模块化的思想解决问题。</p><p>面向对象听起来很美，但是现实中的编程语言中很少有纯粹的面向对象的语言， 处于性能或者程序员的开发习惯，通常的编程语言都同时支持两种变编程方式。</p><p>PHP就是如此，从PHP4起开始支持面向对象编程。但PHP4的面向对象支持不太完善。 从PHP5起，PHP引入了新的对象模型（Object Model），增加了许多新特性，包括访问控制、 抽象类和final类、类方法、魔术方法、接口、对象克隆和类型提示等。 并且在近期发布的PHP5.3版本中，针对面向对象编程增加了命名空间、延迟静态绑定（Late Static Binding） 以及增加了两个魔术方法<strong>callStatic()和</strong>invoke()。</p><p>PHP中对象是按引用传递的，即对象进行赋值和操作的时候是按引用（reference）传递的，而不是整个对象的拷贝。</p><p>这一章我们从面向对象讲起，会说到PHP中的类，包括类的定义和实现、接口、抽象类以及与类相关的访问控制、 对象和命名空间等。除此之外也会从其存储的内部结构，类的单继承的实现，接口的多继承， 以及魔法方法的实现等细微处着手分析类相关的方方面面。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>65-匿名函数及闭包</title>
      <link href="/posts/8b76978e.html"/>
      <url>/posts/8b76978e.html</url>
      
        <content type="html"><![CDATA[<h1 id="65-匿名函数及闭包"><a href="#65-匿名函数及闭包" class="headerlink" title="65-匿名函数及闭包"></a>65-匿名函数及闭包</h1><p>匿名函数在编程语言中出现的比较早，最早出现在Lisp语言中，随后很多的编程语言都开始有这个功能了， 目前使用比较广泛的Javascript以及C#，PHP直到5.3才开始真正支持匿名函数， C++的新标准C++0x也开始支持了。</p><p>匿名函数是一类不需要指定标示符，而又可以被调用的函数或子例程，匿名函数可以方便的作为参数传递给其他函数， 最常见应用是作为回调函数。</p><h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h2><p>说到匿名函数，就不得不提到闭包了，闭包是词法闭包(Lexical Closure)的简称，是引用了自由变量的函数， 这个被应用的自由变量将和这个函数一同存在，即使离开了创建它的环境也一样，所以闭包也可认为是有函数和与其相关引用组合而成的实体。 在一些语言中，在函数内定义另一个函数的时候，如果内部函数引用到外部函数的变量，则可能产生闭包。在运行外部函数时， 一个闭包就形成了。</p><p>这个词和匿名函数很容易被混用，其实这是两个不同的概念，这可能是因为很多语言实现匿名函数的时候允许形成闭包。</p><h3 id="使用create-function-创建”匿名”函数"><a href="#使用create-function-创建”匿名”函数" class="headerlink" title="使用create_function()创建”匿名”函数"></a>使用create_function()创建”匿名”函数</h3><p>前面提到PHP5.3中才才开始正式支持匿名函数，说到这里可能会有细心读者有意见了，因为有个函数是可以生成匿名函数的: create_function函数， 在手册里可以查到这个函数在PHP4.1和PHP5中就有了，这个函数通常也能作为匿名回调函数使用， 例如如下：</p><pre><code>&lt;?php$array = array(1, 2, 3, 4);array_walk($array, create_function(&apos;$value&apos;, &apos;echo $value&apos;));?&gt;</code></pre><p>这段代码只是将数组中的值依次输出，当然也能做更多的事情。 那为什么这不算真正的匿名函数呢， 我们先看看这个函数的返回值，这个函数返回一个字符串， 通常我们可以像下面这样调用一个函数：</p><pre><code>&lt;?phpfunction a() {    echo &apos;function a&apos;;}$a = &apos;a&apos;;$a();?&gt;</code></pre><p>我们在实现回调函数的时候也可以采用这样的方式，例如：</p><pre><code>&lt;?phpfunction do_something($callback) {    // doing    # ...    // done    $callback();}?&gt;</code></pre><p>这样就能实现在函数do_something()执行完成之后调用$callback指定的函数。回到create_function函数的返回值: 函数返回一个唯一的字符串函数名， 出现错误的话则返回FALSE。这么说这个函数也只是动态的创建了一个函数，而这个函数是有函数名的，也就是说，其实这并不是匿名的。 只是创建了一个全局唯一的函数而已。</p><pre><code>&lt;?php$func = create_function(&apos;&apos;, &apos;echo &quot;Function created dynamic&quot;;&apos;);echo $func; // lambda_1$func();    // Function created dynamic$my_func = &apos;lambda_1&apos;;$my_func(); // 不存在这个函数lambda_1(); // 不存在这个函数?&gt;</code></pre><p>上面这段代码的前面很好理解，create_function就是这么用的，后面指定函数名调用却失败了，这就有些不好理解了， php是怎么保证这个函数是全局唯一的? lambda_1看起来也是一个很普通的函数明，如果我们先定义一个叫做lambda_1的函数呢? 这里函数的返回字符串会是lambda_2，它在创建函数的时候会检查是否这个函数是否存在知道找到合适的函数名， 但如果我们在create_function之后定义一个叫做lambda_1的函数会怎么样呢? 这样就出现函数重复定义的问题了， 这样的实现恐怕不是最好的方法，实际上如果你真的定义了名为lambda_1的函数也是不会出现我所说的问题的。这究竟是怎么回事呢? 上面代码的倒数2两行也说明了这个问题，实际上并没有定义名为lambda_1的函数。</p><p>也就是说我们的lambda_1和create_function返回的lambda_1并不是一样的!? 怎么会这样呢? 那只能说明我们没有看到实质， 只看到了表面，表面是我们在echo的时候输出了lambda_1，而我们的lambda_1是我们自己敲入的. 我们还是使用debug_zval_dump函数来看看吧。</p><pre><code>&lt;?php$func = create_function(&apos;&apos;, &apos;echo &quot;Hello&quot;;&apos;);$my_func_name = &apos;lambda_1&apos;;debug_zval_dump($func);         // string(9) &quot;lambda_1&quot; refcount(2)debug_zval_dump($my_func_name); // string(8) &quot;lambda_1&quot; refcount(2)?&gt;</code></pre><p>看出来了吧，他们的长度居然不一样，长度不一样，所以我们调用的函数当然是不存在的， 我们还是直接看看create_function函数到底都做了些什么吧。 该实现见: $PHP_SRC/Zend/zend_builtin_functions.c</p><pre><code>#define LAMBDA_TEMP_FUNCNAME    &quot;__lambda_func&quot;ZEND_FUNCTION(create_function){    // ... 省去无关代码    function_name = (char *) emalloc(sizeof(&quot;0lambda_&quot;)+MAX_LENGTH_OF_LONG);    function_name[0] = &apos;\0&apos;;  // &lt;--- 这里    do {        function_name_length = 1 + sprintf(function_name + 1, &quot;lambda_%d&quot;, ++EG(lambda_count));    } while (zend_hash_add(EG(function_table), function_name, function_name_length+1, &amp;new_function, sizeof(zend_function), NULL)==FAILURE);    zend_hash_del(EG(function_table), LAMBDA_TEMP_FUNCNAME, sizeof(LAMBDA_TEMP_FUNCNAME));    RETURN_STRINGL(function_name, function_name_length, 0);}</code></pre><p>该函数在定义了一个函数之后，给函数起了个名字，它将函数名的第一个字符变为了’\0’也就是空字符，然后在函数表中查找是否已经定义了这个函数， 如果已经有了则生成新的函数名， 第一个字符为空字符的定义方式比较特殊， 这样在用户代码中就无法定义出这样的函数了， 这样也就不存在命名冲突的问题了， 这也算是种取巧的做法了， 在了解到这个特殊的函数之后，我们其实还是可以调用到这个函数的， 只要我们在函数名前加一个空字符就可以了， chr()函数可以帮我们生成这样的字符串， 例如前面创建的函数可以通过如下的方式访问到：</p><pre><code>&lt;?php$my_func = chr(0) . &quot;lambda_1&quot;;$my_func(); // Hello?&gt;</code></pre><p>这种创建”匿名函数”的方式有一些缺点：</p><pre><code>函数的定义是通过字符串动态eval的， 这就无法进行基本的语法检查；这类函数和普通函数没有本质区别， 无法实现闭包的效果。</code></pre><h2 id="真正的匿名函数"><a href="#真正的匿名函数" class="headerlink" title="真正的匿名函数"></a>真正的匿名函数</h2><p>在PHP5.3引入的众多功能中， 除了匿名函数还有一个特性值得讲讲: 新引入的__invoke 魔幻方法。</p><p>这个魔幻方法被调用的时机是: 当一个对象当做函数调用的时候， 如果对象定义了__invoke魔幻方法则这个函数会被调用， 这和C++中的操作符重载有些类似， 例如可以像下面这样使用：</p><pre><code>&lt;?phpclass Callme {    public function __invoke($phone_num) {        echo &quot;Hello: $num&quot;;    }}$call = new Callme();$call(13810688888); // &quot;Hello: 13810688888?&gt;</code></pre><h3 id="匿名函数的实现"><a href="#匿名函数的实现" class="headerlink" title="匿名函数的实现"></a>匿名函数的实现</h3><p>前面介绍了将对象作为函数调用的方法， 聪明的你可能想到在PHP实现匿名函数的方法了，PHP中的匿名函数就的确是通过这种方式实现的。 我们先来验证一下：</p><pre><code>&lt;?php$func = function() {    echo &quot;Hello, anonymous function&quot;;}echo gettype($func);    // objectecho get_class($func);  // Closure?&gt;</code></pre><p>原来匿名函数也只是一个普通的类而已。熟悉Javascript的同学对匿名函数的使用方法很熟悉了， PHP也使用和Javascript类似的语法来定义， 匿名函数可以赋值给一个变量， 因为匿名函数其实是一个类实例， 所以能复制也是很容易理解的， 在Javascript中可以将一个匿名函数赋值给一个对象的属性， 例如：</p><pre><code>var a = {};a.call = function() {alert(&quot;called&quot;);}a.call(); // alert called</code></pre><p>这在Javascript中很常见， 但在PHP中这样并不可以， 给对象的属性复制是不能被调用的， 这样使用将会导致类寻找类中定义的方法， 在PHP中属性名和定义的方法名是可以重复的， 这是由PHP的类模型所决定的， 当然PHP在这方面是可以改进的， 后续的版本中可能会允许这样的调用， 这样的话就更容易灵活的实现一些功能了。目前想要实现这样的效果也是有方法的: 使用另外一个魔幻方法__call()， 至于怎么实现就留给各位读者当做习题吧。</p><h3 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h3><p>PHP使用闭包(Closure)来实现匿名函数， 匿名函数最强大的功能也就在匿名函数所提供的一些动态特性以及闭包效果， 匿名函数在定义的时候如果需要使用作用域外的变量需要使用如下的语法来实现：</p><pre><code>&lt;?php$name = &apos;TIPI Tea&apos;;$func = function() use($name) {    echo &quot;Hello, $name&quot;;}$func(); // Hello TIPI Team?&gt;</code></pre><p>这个use语句看起来挺别扭的， 尤其是和Javascript比起来， 不过这也应该是PHP-Core综合考虑才使用的语法， 因为和Javascript的作用域不同， PHP在函数内定义的变量默认就是局部变量， 而在Javascript中则相反， 除了显式定义的才是局部变量， PHP在变异的时候则无法确定变量是局部变量还是上层作用域内的变量， 当然也可能有办法在编译时确定， 不过这样对于语言的效率和复杂性就有很大的影响。</p><p>这个语法比较直接， 如果需要访问上层作用域内的变量则需要使用use语句来申明， 这样也简单易读， 说到这里， 其实可以使用use来实现类似global语句的效果。</p><p>匿名函数在每次执行的时候都能访问到上层作用域内的变量， 这些变量在匿名函数被销毁之前始终保存着自己的状态， 例如如下的例子：</p><pre><code>&lt;?phpfunction getCounter() {    $i = 0;    return function() use($i) { // 这里如果使用引用传入变量: use(&amp;$i)        echo ++$i;    };}$counter = getCounter();$counter(); // 1$counter(); // 1?&gt;</code></pre><p>和Javascript中不同， 这里两次函数调用并没有使$i变量自增， 默认PHP是通过拷贝的方式传入上层变量进入匿名函数， 如果需要改变上层变量的值则需要通过引用的方式传递。 所以上面得代码没有输出1， 2而是1， 1。</p><h3 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h3><p>前面提到匿名函数是通过闭包来实现的， 现在我们开始看看闭包(类)是怎么实现的。 匿名函数和普通函数除了是否有变量名以外并没有区别， 闭包的实现代码在$PHP_SRC/Zend/zend_closure.c。匿名函数”对象化”的问题已经通过Closure实现， 而对于匿名是怎么样访问到创建该匿名函数时的变量的呢?</p><p>例如如下这段代码：</p><pre><code>&lt;?php$i=100;$counter = function() use($i) {    debug_zval_dump($i);};  $counter();?&gt;</code></pre><p>通过VLD来查看这段编码编译什么样的opcode了。</p><pre><code>$ php -dvld.active=1 closure.phpvars:  !0 = $i, !1 = $counter# *  op                           fetch          ext  return  operands------------------------------------------------------------------------0  &gt;   ASSIGN                                                   !0, 1001      ZEND_DECLARE_LAMBDA_FUNCTION                             &apos;%7Bclosure2      ASSIGN                                                   !1, ~13      INIT_FCALL_BY_NAME                                       !14      DO_FCALL_BY_NAME                              0          5    &gt; RETURN                                                   1function name:  {closure}number of ops:  5compiled vars:  !0 = $iline     # *  op                           fetch          ext  return  operands--------------------------------------------------------------------------------  3     0  &gt;   FETCH_R                      static              $0      &apos;i&apos;        1      ASSIGN                                                   !0, $0  4     2      SEND_VAR                                                 !0        3      DO_FCALL                                      1          &apos;debug_zval_dump&apos;  5     4    &gt; RETURN                                                   null</code></pre><p>上面根据情况去掉了一些无关的输出， 从上到下， 第1开始将100赋值给!0也就是变量$i， 随后执行ZEND_DECLARE_LAMBDA_FUNCTION， 那我们去相关的opcode执行函数中看看这里是怎么执行的， 这个opcode的处理函数位于$PHP_SRC/Zend/zend_vm_execute.h中：</p><pre><code>static int ZEND_FASTCALL  ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS){    zend_op *opline = EX(opline);    zend_function *op_array;    if (zend_hash_quick_find(EG(function_table), Z_STRVAL(opline-&gt;op1.u.constant), Z_STRLEN(opline-&gt;op1.u.constant), Z_LVAL(opline-&gt;op2.u.constant), (void *) &amp;op_array) == FAILURE ||        op_array-&gt;type != ZEND_USER_FUNCTION) {        zend_error_noreturn(E_ERROR, &quot;Base lambda function for closure not found&quot;);    }    zend_create_closure(&amp;EX_T(opline-&gt;result.u.var).tmp_var, op_array TSRMLS_CC);    ZEND_VM_NEXT_OPCODE();}</code></pre><p>该函数调用了zend_create_closure()函数来创建一个闭包对象, 那我们继续看看位于$PHP_SRC/Zend/zend_closures.c的zend_create_closure()函数都做了些什么。</p><pre><code>ZEND_API void zend_create_closure(zval *res, zend_function *func TSRMLS_DC){    zend_closure *closure;    object_init_ex(res, zend_ce_closure);    closure = (zend_closure *)zend_object_store_get_object(res TSRMLS_CC);    closure-&gt;func = *func;    if (closure-&gt;func.type == ZEND_USER_FUNCTION) { // 如果是用户定义的匿名函数        if (closure-&gt;func.op_array.static_variables) {            HashTable *static_variables = closure-&gt;func.op_array.static_variables;            // 为函数申请存储静态变量的哈希表空间            ALLOC_HASHTABLE(closure-&gt;func.op_array.static_variables);            zend_hash_init(closure-&gt;func.op_array.static_variables, zend_hash_num_elements(static_variables), NULL, ZVAL_PTR_DTOR, 0);            // 循环当前静态变量列表， 使用zval_copy_static_var方法处理            zend_hash_apply_with_arguments(static_variables TSRMLS_CC, (apply_func_args_t)zval_copy_static_var, 1, closure-&gt;func.op_array.static_variables);        }        (*closure-&gt;func.op_array.refcount)++;    }    closure-&gt;func.common.scope = NULL;}</code></pre><p>如上段代码注释中所说, 继续看看zval_copy_static_var()函数的实现：</p><pre><code>static int zval_copy_static_var(zval **p TSRMLS_DC, int num_args, va_list args, zend_hash_key *key) /* {{{ */{    HashTable *target = va_arg(args, HashTable*);    zend_bool is_ref;    // 只对通过use语句类型的静态变量进行取值操作， 否则匿名函数体内的静态变量也会影响到作用域之外的变量    if (Z_TYPE_PP(p) &amp; (IS_LEXICAL_VAR|IS_LEXICAL_REF)) {        is_ref = Z_TYPE_PP(p) &amp; IS_LEXICAL_REF;        if (!EG(active_symbol_table)) {            zend_rebuild_symbol_table(TSRMLS_C);        }        // 如果当前作用域内没有这个变量        if (zend_hash_quick_find(EG(active_symbol_table), key-&gt;arKey, key-&gt;nKeyLength, key-&gt;h, (void **) &amp;p) == FAILURE) {            if (is_ref) {                zval *tmp;                // 如果是引用变量， 则创建一个零时变量一边在匿名函数定义之后对该变量进行操作                ALLOC_INIT_ZVAL(tmp);                Z_SET_ISREF_P(tmp);                zend_hash_quick_add(EG(active_symbol_table), key-&gt;arKey, key-&gt;nKeyLength, key-&gt;h, &amp;tmp, sizeof(zval*), (void**)&amp;p);            } else {                // 如果不是引用则表示这个变量不存在                p = &amp;EG(uninitialized_zval_ptr);                zend_error(E_NOTICE,&quot;Undefined variable: %s&quot;, key-&gt;arKey);            }        } else {            // 如果存在这个变量， 则根据是否是引用， 对变量进行引用或者复制            if (is_ref) {                SEPARATE_ZVAL_TO_MAKE_IS_REF(p);            } else if (Z_ISREF_PP(p)) {                SEPARATE_ZVAL(p);            }        }    }    if (zend_hash_quick_add(target, key-&gt;arKey, key-&gt;nKeyLength, key-&gt;h, p, sizeof(zval*), NULL) == SUCCESS) {        Z_ADDREF_PP(p);    }    return ZEND_HASH_APPLY_KEEP;}</code></pre><p>这个函数作为一个回调函数传递给zend_hash_apply_with_arguments()函数， 每次读取到hash表中的值之后由这个函数进行处理， 而这个函数对所有use语句定义的变量值赋值给这个匿名函数的静态变量， 这样匿名函数就能访问到use的变量了。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64-引用与函数执行</title>
      <link href="/posts/e8146e42.html"/>
      <url>/posts/e8146e42.html</url>
      
        <content type="html"><![CDATA[<h1 id="64-引用与函数执行"><a href="#64-引用与函数执行" class="headerlink" title="64-引用与函数执行"></a>64-引用与函数执行</h1><p>一个函数的执行结果要返回给调用者，除了使用return功能，还有一种办法，那就是以引用的形式传递参数，然后在内部修改这个参数的值。前一种方法往往只能返回一个值，如果我们的函数执行结果具有多种数据，便需要把这些数据打包到一个数组、类等复合类型的变量中才能得以实现；但后一种方法相比而言就简单一些了。</p><h2 id="运行时传递引用：Call-time-Pass-by-ref"><a href="#运行时传递引用：Call-time-Pass-by-ref" class="headerlink" title="运行时传递引用：Call-time Pass-by-ref"></a>运行时传递引用：Call-time Pass-by-ref</h2><p>标题有点绕口，其实很简单，功能如以下php代码所示：</p><pre><code>&lt;?phpfunction byref_calltime($a) {    $a = &apos;(modified by ref!)&apos;;}$foo = &apos;I am a string&apos;;//使用&amp;传递引用byref_calltime(&amp;$foo);echo $foo;//输出&apos;(modified by ref!)&apos;?&gt;</code></pre><p>我们在传递参数的时候使用&amp;操作符，便可以传递$foo变量的引用过去，而不是copy一份。当我们在函数内核修改这个参数时，函数外部的$foo也跟着被一起修改了。同样的功能我们如何在扩展里实现呢，其实很简单，请看下面的源码：</p><pre><code>ZEND_FUNCTION(byref_calltime){    zval *a;    //我们我接收的参数传给zval *a;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z&quot;, &amp;a) == FAILURE)    {        RETURN_NULL();    }    //如果a不是以应用的方式传递的。    if (!a-&gt;is_ref__gc)    {        return;    }    //将a转成字符串    convert_to_string(a);    //更改数据    ZVAL_STRING(a,&quot; (modified by ref!)&quot;,1);    return;}</code></pre><h2 id="编译时的传递引用Compile-time-Pass-by-ref"><a href="#编译时的传递引用Compile-time-Pass-by-ref" class="headerlink" title="编译时的传递引用Compile-time Pass-by-ref"></a>编译时的传递引用Compile-time Pass-by-ref</h2><p>如果每一次都在调用函数时候都对参数加一个&amp;符号真是太罗嗦了，有没有一个简单的办法呢，比如在定义函数的时候便声明这个参数是引用形式的，而不用用户自己加&amp;符号表示引用，而由内核来完成这步操作？这个功能是有的，我们在PHP语言中可以这样实现。</p><pre><code>&lt;?php// 在定义函数参数的时候加了引用符function byref_compiletime(&amp;$a) {    $a = &apos; (modified by ref!)&apos;;}$foo = &apos;I am a string&apos;;//这个地方我们没有加&amp;引用符byref_compiletime($foo);echo $foo;//输出 (modified by ref!)?&gt;</code></pre><p>上面的代码中，我们只是把引用符号从函数调用里转移到函数定义里。此功能在扩展里面实现的话就颇费周折了，我们需要提前为它定义一个arginfo结构体来向内核通知此函数的这个特定行为。添加此函数到module_entry里需要这样：</p><pre><code>ZEND_FE(byref_compiletime, byref_compiletime_arginfo)</code></pre><p>byref_compiletime_arginfo十一个arginfo结构体，我们在前面的章节中已经用过一次了。</p><p>在Zend Engine 2 (PHP5+)中，arginfo的数据是由多个zend_arg_info结构体构成的数组，数组的每一个成员即每一个zend_arg_info结构体处理函数的一个参数。zend_arg_info结构体的定义如下：</p><pre><code>typedef struct _zend_arg_info {    const char *name;                /* 参数的名称*/    zend_uint name_len;                /* 参数名称的长度*/    const char *class_name;            /* 类名 */    zend_uint class_name_len;        /* 类名长度*/    zend_bool array_type_hint;        /* 数组类型提示 */    zend_bool allow_null;            /* 是否允许为NULL　*/    zend_bool pass_by_reference;    /* 是否引用传递 */    zend_bool return_reference;        /* 返回值是否为引用形式 */    int required_num_args;          /* 必要参数的数量 */} zend_arg_info;</code></pre><p>生成zend_arg_info结构的数组比较繁琐，为了方便PHP扩展开发者，内核已经准备好了相应的宏来专门处理此问题，首先先用一个宏函数来生成头部，然后用第二个宏生成具体的数据，最后用一个宏生成尾部代码。</p><pre><code>#define ZEND_BEGIN_ARG_INFO(name, pass_rest_by_reference)    ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, ZEND_RETURN_VALUE, -1)#define ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, return_reference, required_num_args)    \    static const zend_arg_info name[] = {                                                                        \        { NULL, 0, NULL, 0, 0, 0, pass_rest_by_reference, return_reference, required_num_args },#define ZEND_ARG_INFO(pass_by_ref, name)        { #name, sizeof(#name)-1, NULL, 0, 0, 0, pass_by_ref, 0, 0 },#define ZEND_ARG_PASS_INFO(pass_by_ref)            { NULL, 0, NULL, 0, 0, 0, pass_by_ref, 0, 0 },#define ZEND_ARG_OBJ_INFO(pass_by_ref, name, classname, allow_null) { #name, sizeof(#name)-1, #classname, sizeof(#classname)-1, 0, allow_null, pass_by_ref, 0, 0 },#define ZEND_ARG_ARRAY_INFO(pass_by_ref, name, allow_null) { #name, sizeof(#name)-1, NULL, 0, 1, allow_null, pass_by_ref, 0, 0 },#define ZEND_END_ARG_INFO()        };//这里我们先看ZEND_BEGIN_ARG_INFO(name, pass_rest_by_reference)ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, return_reference,required_num_args)</code></pre><p>这两个宏函数的前两个参数的含义是一样的，name便是这个zend_arg_info数组变量的名字，这里我们定义它为：byref_compiletime_arginfo。pass_rest_by_reference如果被赋值为1，则代表着所有的参数默认都是需要以引用的方式传递的(在arginfo中单独声明的除外)。而对于ZEND_BEGIN_ARG_INFO_EX的后两个参数：</p><ul><li>name和pass_rest_by_reference的含义同上。</li><li>return_reference：声明这个函数的返回值需要以引用的形式返回，这个参数已经在前面章节用过了。</li><li>required_num_args：函数被调用时，传递参数至少为前N个函数(也就是后面参数都有默认值)，当设置为-1时，必须传递所有参数</li></ul><p>接下来让我们看生成具体数据的宏：</p><pre><code>ZEND_ARG_PASS_INFO(by_ref)//强制所有参数使用引用的方式传递ZEND_ARG_INFO(by_ref, name)//如果by_ref为1，则名称为name的参数必须以引用的方式传递，ZEND_ARG_ARRAY_INFO(by_ref, name, allow_null)ZEND_ARG_OBJ_INFO(by_ref, name, classname, allow_null)这两个宏实现了类型绑定，也就是说我们在传递某个参数时，必须是数组类型或者某个类的实例。如果最后的参数为真，则除了绑定的数据类型，还可以传递一个NULL数据。//我们组合起来使用：ZEND_BEGIN_ARG_INFO(byref_compiletime_arginfo, 0)    ZEND_ARG_PASS_INFO(1)ZEND_END_ARG_INFO()</code></pre><p>为了使我们的扩展能够兼容PHP4，还需要使用#ifdef进行特殊处理。</p><pre><code>#ifdef ZEND_ENGINE_2    ZEND_BEGIN_ARG_INFO(byref_compiletime_arginfo, 0)        ZEND_ARG_PASS_INFO(1)    ZEND_END_ARG_INFO()#else /* ZE 1 */static unsigned char byref_compiletime_arginfo[] =   { 1, BYREF_FORCE };#endif</code></pre><p>我们copy一份ZEND_FUNCTION(byref_calltime)的实现，并重名成ZEND_FUNCTION(byref_compiletime)就行了。或者直接弄个ZEND_FALIAS就行了：</p><pre><code>ZEND_FE(byref_compiletime,byref_calltime,byref_compiletime_arginfo)</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>63-函数调用与执行</title>
      <link href="/posts/1bf10103.html"/>
      <url>/posts/1bf10103.html</url>
      
        <content type="html"><![CDATA[<h1 id="63-函数调用与执行"><a href="#63-函数调用与执行" class="headerlink" title="63-函数调用与执行"></a>63-函数调用与执行</h1><p>前面对函数的内部表示以及参数的传递，返回值都有了介绍，那函数是怎么被调用的呢？内置函数和用户定义函数在调用时会有什么不一样呢？ 下面将介绍函数调用和执行的过程。<br>函数的调用</p><p>函数被调用需要一些基本的信息，比如函数的名称，参数以及函数的定义(也就是最终函数是怎么执行的)， 从我们开发者的角度来看， 定义了一个函数我们在执行的时候自然知道这个函数叫什么名字，以及调用的时候给传递了什么参数，以及函数是怎么执行的。 但是对于Zend引擎来说，它并不能像我们这样能“看懂”php源代码，他们需要对代码进行处理以后才能执行。我们还是从以下两个小例子开始：</p><pre><code>&lt;?php    function foo(){        echo &quot;I&apos;m foo!&quot;;    }       foo();?&gt;</code></pre><p>下面我们先看一下其对应的opcodes：</p><pre><code>function name:  (null)line     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------              DO_FCALL                                      0          &apos;foo&apos;              NOP                                                                  &gt; RETURN                                                   1function name:  fooline     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------   4     0  &gt;   ECHO                                                     &apos;I%27m+foo%21&apos;   5     1    &gt; RETURN                                                   null</code></pre><p>上面是去除了一些枝节信息的的opcodes，可以看到执行时函数部分的opcodes是单独独立出来的，这点对于函数的执行特别重要，下面的部分会详细介绍。 现在，我们把焦点放到对foo函数的调用上面。调用foo的OPCODE是“DO_FCALL“， DO_FCALL进行函数调用操作时，ZE会在function_table中根据函数名 （如前所述，这里的函数名经过str_tolower的处理，所以PHP的函数名大小写不敏感)查找函数的定义， 如果不存在， 则报出“Call to undefined function xxx()”的错误信息; 如果存在，就返回该函数zend_function结构指针， 然后通过function.type的值来判断函数是内部函数还是用户定义的函数， 调用zend_execute_internal（zend_internal_function.handler）或者直接 调用zend_execute来执行这个函数包含的zend_op_array。</p><h2 id="函数的执行"><a href="#函数的执行" class="headerlink" title="函数的执行"></a>函数的执行</h2><p>细心的读者可能会注意到上面opcodes里函数被调用的时候以及函数定义那都有个”function name:”，其实用户定义函数的执行与其他语句的执行并无区别， 在本质上看，其实函数中的php语句与函数外的php语句并无不同。函数体本身最大的区别，在于其执行环境的不同。 这个“执行环境”最重要的特征就是变量的作用域。大家都知道，函数内定义的变量在函数体外是无法直接使用的，反之也是一样。那么，在函数执行的时候， 进入函数前的环境信息是必须要保存的。在函数执行完毕后，这些环境信息也会被还原，使整个程序继续的执行下去。</p><p>内部函数的执行与用户函数不同。用户函数是php语句一条条“翻译”成op_line组成的一个op_array，而内部函数则是用C来实现的，因为执行环境也是C环境， 所以可以直接调用。如下面的例子：</p><pre><code>&lt;?php    $foo = &apos;test&apos;;    print_r($foo);?&gt;</code></pre><p>对应的opcodes也很简单：</p><pre><code>line     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------   2     0  &gt;   ASSIGN                                                   !0, &apos;test&apos;   3     1      SEND_VAR                                                 !0         2      DO_FCALL                                      1          &apos;print_r&apos;   4     3    &gt; RETURN                                                   1</code></pre><p>可以看出，生成的opcodes中，内部函数和用户函数的处理都是由DO_FCALL来进行的。而在其具体实现的zend_do_fcall_common_helper_SPEC()中， 则对是否为内部函数进行了判断，如果是内部函数，则使用一个比较长的调用：</p><pre><code>((zend_internal_function *) EX(function_state).function)-&gt;handler(opline-&gt;extended_value, EX_T(opline-&gt;result.u.var).var.ptr, EX(function_state).function-&gt;common      .return_reference?&amp;EX_T(opline-&gt;result.u.var).var.ptr:NULL, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);</code></pre><p>上面这种方式的内部函数是在zend_execute_internal函数没有定义的情况下。而在而在Zend/zend.c文件的zend_startup函数中，</p><pre><code>zend_execute_internal = NULL;</code></pre><p>此函数确实被赋值为NULL。于是我们在if (!zend_execute_internal)判断时会成立，所以我们是执行那段很长的调用。 那么，这段很长的调用到底是什么呢？以我们常用的 count函数为例。我们知道内部函数所在的结构体中 有一个handler指针指向此函数需要调用的内部定义的C函数。 这些内部函数在模块初始化时就以扩展的函数的形式加载到EG(function_table)。其调用顺序：</p><pre><code>php_module_startup --&gt; php_register_extensions --&gt; zend_register_internal_module--&gt; zend_register_module_ex --&gt; zend_register_functionszend_register_functions(NULL, module-&gt;functions, NULL, module-&gt;type TSRMLS_CC)</code></pre><p>在standard扩展中。module的定义为：</p><pre><code>zend_module_entry basic_functions_module = { /* {{{ */    STANDARD_MODULE_HEADER_EX,    NULL,    standard_deps,    &quot;standard&quot;,                 /* extension name */    basic_functions,            /* function list */    ... //省略}</code></pre><p>从上面的代码可以看出，module-&gt;functions是指向basic_functions。在basic_functions.c文件中查找basic_functions的定义。</p><pre><code>const zend_function_entry basic_functions[] = { /* {{{ */    ...//   省略    PHP_FE(count,                                                           arginfo_count)    ...//省略}#define PHP_FE          ZEND_FE#define ZEND_FE(name, arg_info)                     ZEND_FENTRY(name, ZEND_FN(name), arg_info, 0)#define ZEND_FN(name) zif_##name#define ZEND_FENTRY(zend_name, name, arg_info, flags)   { #zend_name, name, arg_info, (zend_uint) (sizeof(arg_info)/sizeof(struct _zend_arg_info)-1), flags },</code></pre><p>综合上面的代码，count函数最后调用的函数名为zif_count，但是此函数对外的函数名还是为count。 调用的函数名name以第二个元素存放在zend_function_entry结构体数组中。 对于zend_function_entry的结构：</p><pre><code>typedef struct _zend_function_entry {    const char *fname;    void (*handler)(INTERNAL_FUNCTION_PARAMETERS);    const struct _zend_arg_info *arg_info;    zend_uint num_args;    zend_uint flags;} zend_function_entry;</code></pre><p>第二个元素为handler。这也就是我们在执行内部函数时的调用方法。因此在执行时就会调用到对应的函数。</p><p>对于用户定义的函数，在zend_do_fcall_common_helper_SPEC()函数中，</p><pre><code>if (EX(function_state).function-&gt;type == ZEND_USER_FUNCTION ||    EX(function_state).function-&gt;common.scope) {    should_change_scope = 1;    EX(current_this) = EG(This);    EX(current_scope) = EG(scope);    EX(current_called_scope) = EG(called_scope);    EG(This) = EX(object);    EG(scope) = (EX(function_state).function-&gt;type == ZEND_USER_FUNCTION || !EX(object)) ? EX(function_state).function-&gt;common.scope : NULL;    EG(called_scope) = EX(called_scope);}</code></pre><p>先将EG下的This，scope等暂时缓存起来（这些在后面会都恢复到此时缓存的数据）。在此之后，对于用户自定义的函数， 程序会依据zend_execute是否等于execute并且是否为异常来判断是返回，还是直接执行函数定义的op_array：</p><pre><code>if (zend_execute == execute &amp;&amp; !EG(exception)) {        EX(call_opline) = opline;        ZEND_VM_ENTER();    } else {        zend_execute(EG(active_op_array) TSRMLS_CC);    }</code></pre><p>而在Zend/zend.c文件的zend_startup函数中，已将zend_execute赋值为：</p><pre><code>zend_execute = execute;</code></pre><p>从而对于异常，程序会抛出异常；其它情况，程序会调用execute执行此函数中生成的opcodes。 execute函数会遍历所传递给它的zend_op_array数组，以方式</p><pre><code>ret = EX(opline)-&gt;handler(execute_data TSRMLS_CC)</code></pre><p>调用每个opcode的处理函数。而execute_data在execute函数开始时就已经给其分配了空间，这就是这个函数的执行环境。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62-形参return value</title>
      <link href="/posts/d538eee9.html"/>
      <url>/posts/d538eee9.html</url>
      
        <content type="html"><![CDATA[<h1 id="62-形参return-value"><a href="#62-形参return-value" class="headerlink" title="62-形参return value"></a>62-形参return value</h1><p>PHP语言中函数的返回值是通过return来完成了，就像下面的程序：</p><pre><code>&lt;?phpfunction sample_long() {  return 42;}$bar = sample_long();?&gt;</code></pre><p>C语言也一样使用return关键字：</p><pre><code>int sample_long(void) {    return 42;}int main(void) {    int bar = sample_long();    return 1;}</code></pre><p>那我们在扩展中编写的PHP函数如何把返回值回馈给用户端的函数调用者呢？看好，这里指的是回馈给，而不是单单的return～</p><p>你也许会认为扩展中定义的函数应该直接通过return关键字来返回一个值，比如由你自己来生成一个zval并返回，就像下面这样：</p><pre><code>ZEND_FUNCTION(sample_long_wrong){    zval *retval;    MAKE_STD_ZVAL(retval);    ZVAL_LONG(retval, 42);    return retval;}</code></pre><p>但是，上面的写法是无效的！与其让扩展开发员每次都初始化一个zval并return之，zend引擎早就准备好了一个更好的方法。它在每个zif函数声明里加了一个zval*类型的形参，名为return_value，专门来解决返回值这个问题。在前面我们已经知道了ZEND_FUNCTION宏展开后是void name(INTERNAL_FUNCTION_PARAMETERS)的形式，现在是我们展开代表参数声明的INTERNAL_FUNCTION_PARAMETERS宏的时候了。</p><pre><code>#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used TSRMLS_DC</code></pre><ul><li>int ht</li><li>zval *return_value，我们在函数内部修改这个指针，函数执行完成后，内核将把这个指针指向的zval返回给用户端的函数调用者。</li><li>zval **return_value_ptr，</li><li>zval *this_ptr，如果此函数是一个类的方法，那么这个指针的含义和PHP语言中$this变量差不多。</li><li>int return_value_used，代表用户端在调用此函数时有没有使用到它的返回值。</li></ul><p>下面让我们先试验一个非常简单的例子，我先给出PHP语言中的实现，然后给出我们在扩展中用C语言完成相同功能的代码。</p><pre><code>&lt;?phpfunction sample_long(){    return 42;}/*    这个函数非常简单.    $a = sample_long();    那此时$a的值便是42了，这个我们大家肯定都明白。*/?&gt;</code></pre><p>下面是我们在编写扩展时的实现。</p><pre><code>ZEND_FUNCTION(sample_long){    ZVAL_LONG(return_value, 42);    return;}</code></pre><p>需要注意的是，ZEND_FUNCTION本身并没有通过return关键字返回任何有价值的东西，它只不过是在运行时修改了return_value指针所指向的变量的值而已，而内核则会把return_value指向的变量作为用户端调用此函数后的得到的返回值。回想一下,ZVAL_LONG()宏是对一类操作的封装，展开后应该就是下面这样：</p><pre><code>Z_TYPE_P(return_value) = IS_LONG;Z_LVAL_P(return_value) = 42;//更彻底的讲，应该是这样的：return_value-&gt;type = IS_LONG;return_value-&gt;value.lval = 42;</code></pre><p>我们千万不要自己去修改return_value的is_ref__gc和refcount__gc属性，这两个属性的值会由PHP内核自动管理。</p><p>现在我们把它加到我们在第五章得到的那个扩展框架里，并把这个函数名称注册到函数入口数组里，就像下面这样：</p><pre><code>static zend_function_entry walu_functions[] = {    ZEND_FE(walu_hello,        NULL)    PHP_FE(sample_long, NULL)    { NULL, NULL, NULL }};</code></pre><p>现在我们编译我们的扩展，便可以在用户端通过调用sample_long函数来得到一个整型的返回值了:</p><pre><code>&lt;?php var_dump(sample_long());?&gt;</code></pre><h2 id="与return-value有关的宏"><a href="#与return-value有关的宏" class="headerlink" title="与return_value有关的宏"></a>与return_value有关的宏</h2><p>return_value如此重要，内核肯定早已经为它准备了大量的宏，来简化我们的操作，提高程序的质量。 在前几章我们接触的宏大多都是以ZVAL_开头的，而接下来我们要介绍的宏的名字是：RETVAL。 再回到上面的那个例子，我们用RETVAL来重写一下：</p><pre><code>PHP_FUNCTION(sample_long){    RETVAL_LONG(42);    //展开后相当与ZVAL_LONG(return_value, 42);    return;}</code></pre><p>大多数情况下，我们在处理玩return_value后所做的便是用return语句结束我们的函数执行，帮人帮到底，送佛送到西，为了减少我们的工作量，内核中还提供了RETURN_*系列宏来为我们自动补上return;如：</p><pre><code>PHP_FUNCTION(sample_long) { RETURN_LONG(42); //#define RETURN_LONG(l) { RETVAL_LONG(l); return; } php_printf(&quot;I will never be reached.\n&quot;); //这一行代码永远不会被执行。 }</code></pre><p>下面，我们给出目前所有的RETVAL_<strong><em>宏和RETURN_</em></strong>宏，供大家查阅使用。</p><pre><code>//这些宏都定义在Zend/zend_API.h文件里#define RETVAL_RESOURCE(l)                ZVAL_RESOURCE(return_value, l)#define RETVAL_BOOL(b)                    ZVAL_BOOL(return_value, b)#define RETVAL_NULL()                     ZVAL_NULL(return_value)#define RETVAL_LONG(l)                     ZVAL_LONG(return_value, l)#define RETVAL_DOUBLE(d)                 ZVAL_DOUBLE(return_value, d)#define RETVAL_STRING(s, duplicate)         ZVAL_STRING(return_value, s, duplicate)#define RETVAL_STRINGL(s, l, duplicate)     ZVAL_STRINGL(return_value, s, l, duplicate)#define RETVAL_EMPTY_STRING()             ZVAL_EMPTY_STRING(return_value)#define RETVAL_ZVAL(zv, copy, dtor)        ZVAL_ZVAL(return_value, zv, copy, dtor)#define RETVAL_FALSE                      ZVAL_BOOL(return_value, 0)#define RETVAL_TRUE                       ZVAL_BOOL(return_value, 1)#define RETURN_RESOURCE(l)                 { RETVAL_RESOURCE(l); return; }#define RETURN_BOOL(b)                     { RETVAL_BOOL(b); return; }#define RETURN_NULL()                     { RETVAL_NULL(); return;}#define RETURN_LONG(l)                     { RETVAL_LONG(l); return; }#define RETURN_DOUBLE(d)                 { RETVAL_DOUBLE(d); return; }#define RETURN_STRING(s, duplicate)     { RETVAL_STRING(s, duplicate); return; }#define RETURN_STRINGL(s, l, duplicate) { RETVAL_STRINGL(s, l, duplicate); return; }#define RETURN_EMPTY_STRING()             { RETVAL_EMPTY_STRING(); return; }#define RETURN_ZVAL(zv, copy, dtor)        { RETVAL_ZVAL(zv, copy, dtor); return; }#define RETURN_FALSE                      { RETVAL_FALSE; return; }#define RETURN_TRUE                       { RETVAL_TRUE; return; }</code></pre><p>其实，除了这些标量类型，还有很多php语言中的复合类型我们需要在函数中返回，如数组和对象，我们可以通过RETVAL_ZVAL与RETURN_ZVAL来操作它们，有关它们的详细介绍我们将在后续章节中叙述。</p><h2 id="不返回值可以么？"><a href="#不返回值可以么？" class="headerlink" title="不返回值可以么？"></a>不返回值可以么？</h2><p>其实，zend internal function的形参中还有一个比较常用的名为return_value_used的参数，它是干嘛使的呢？它用来标志这个函数的返回值在用户端有没有用到。看下面的代码：</p><pre><code>&lt;?phpfunction sample_array_range() {    $ret = array();    for($i = 0; $i &lt; 1000; $i++) {        $ret[] = $i;    }    return $ret;}sample_array_range();?&gt;</code></pre><p>sample_array_range()仅仅是执行了一下而已，并没有使用到函数的返回值。函数的返回值$ret初始化并返回给调用者后根本就没有发挥作用，却白白浪费了很多内存来存储它的1000个元素。虽然这个例子有点极端，但是却提醒了我们，如果返回值没有被用到，我有没有办法在函数中提前知晓并进行一些有利于性能的操作呢？</p><p>这个想法在PHP脚本语言里简直就是异想天开，肯定是无法实现的。但是如果我们所处的环境是内核，即zif，便可以轻松实现这个愿望了，而我们所需要做的便是充分利用return_value_used这个参数：</p><pre><code>ZEND_FUNCTION(sample_array_range){    if (return_value_used) {        int i;        //把返回值初始化成一个PHP语言中的数组        array_init(return_value);        for(i = 0; i &lt; 1000; i++)        {            //向retrun_value里不断的添加新元素，值为i            add_next_index_long(return_value, i);        }        return;    }    else    {        //抛出一个E_NOTICE级错误        php_error_docref(NULL TSRMLS_CC, E_NOTICE,&quot;猫了个咪的，我就知道你没用我的劳动成果！&quot;);        RETURN_NULL();    }}</code></pre><h2 id="以引用的形式返回值"><a href="#以引用的形式返回值" class="headerlink" title="以引用的形式返回值"></a>以引用的形式返回值</h2><p>你肯定已经在手册中看到过有关将函数的返回值以引用的形式的返回的技术了。但是因为某些历史原因，在为扩展编写函数时候如果想然返回值以引用的形式返回时一定要慎之又慎，因为在php5.1之前，根本就没法真正的实现这个功能，look一下下面的代码：</p><pre><code>&lt;?php//关于PHP语言中引用形式返回值的详述，请参考PHP手册。$a = &apos;china&apos;;function &amp;return_by_ref(){    global $a;    return $a;}$b = &amp;return_by_ref();$b = &quot;php&quot;;echo $a;//此时程序输出php?&gt;</code></pre><p>在上面的代码中，$b其实是$a的一个引用，当最后一行代码执行后，$a和$b都开始寻找‘bar’这个字符串对应的zval，让我们以内核的角度重新观察这一切：</p><pre><code>#if (PHP_MAJOR_VERSION &gt; 5) || (PHP_MAJOR_VERSION == 5 &amp;&amp; PHP_MINOR_VERSION &gt; 0)ZEND_FUNCTION(return_by_ref){    zval **a_ptr;    zval *a;    //检查全局作用域中是否有$a这个变量，如果没有则添加一个    //在内核中真的是可以胡作非为啊，:-)    if(zend_hash_find(&amp;EG(symbol_table) , &quot;a&quot;,sizeof(&quot;a&quot;),(void **)&amp;a_ptr ) == SUCCESS )    {        a = *a_ptr;    }    else    {        ALLOC_INIT_ZVAL(a);        zend_hash_add(&amp;EG(symbol_table), &quot;a&quot;, sizeof(&quot;a&quot;), &amp;a,sizeof(zval*), NULL);    }    //废弃return_value,使用return_value_ptr来接替它的工作    zval_ptr_dtor(return_value_ptr);    if( !a-&gt;is_ref__gc &amp;&amp; a-&gt;refcount__gc &gt; 1 )    {        zval *tmp;        MAKE_STD_ZVAL(tmp);        *tmp = *a;        zval_copy_ctor(tmp);        tmp-&gt;is_ref__gc = 0;        tmp-&gt;refcount__gc = 1;        zend_hash_update(&amp;EG(symbol_table), &quot;a&quot;, sizeof(&quot;a&quot;), &amp;tmp,sizeof(zval*), NULL);        a = tmp;    }    a-&gt;is_ref__gc = 1;    a-&gt;refcount__gc++;    *return_value_ptr = a;}#endif /* PHP &gt;= 5.1.0 */</code></pre><p>return_value_ptr是定义zend internal function时的另外一个重要参数，他是一个zval**类型的指针，并且指向函数的返回值。我们调用zval_ptr_dtor()函数后，默认的return_value便被废弃了。这里的$a变量如果是与某个非引用形式的变量共用一个zval的话，便要进行分离。</p><p>不幸的是，如果你编译上面的代码，使用的时候便会得到一个段错误。为了使它能够正常的工作，需要在源文件中加一些东西：</p><pre><code>#if (PHP_MAJOR_VERSION &gt; 5) || (PHP_MAJOR_VERSION == 5 &amp;&amp; PHP_MINOR_VERSION &gt; 0)    ZEND_BEGIN_ARG_INFO_EX(return_by_ref_arginfo, 0, 1, 0)    ZEND_END_ARG_INFO ()#endif /* PHP &gt;= 5.1.0 */然后使用下面的代码来申明我们的定义的函数：#if (PHP_MAJOR_VERSION &gt; 5) || (PHP_MAJOR_VERSION == 5 &amp;&amp; PHP_MINOR_VERSION &gt; 0)    ZEND_FE(return_by_ref, return_by_ref_arginfo)#endif /* PHP &gt;= 5.1.0 */</code></pre><p>arginfo是一种特殊的结构体，用来提前向内核告知此函数具有的一些特定的性质，如本例，其将告诉内核本函数需要引用形式的返回值，所以内核不再通过return_value来获取执行结果，而是通过return_value_ptr。如果没有arginfo，那内核会预先把return_value_ptr置为NULL，当我们对其调用zval_ptr_dtor()函数时便会使程序崩溃。</p><p>这一些代码都包含在了一个宏里面，只有在php版本大于等于5.1的时候才会被启用。如果没有这些if、endif，哪我们的程序将无法在php4下通过编译，在php5.0上也会激活一些无法预测的错误。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61-函数返回值</title>
      <link href="/posts/7c009247.html"/>
      <url>/posts/7c009247.html</url>
      
        <content type="html"><![CDATA[<h1 id="61-函数返回值"><a href="#61-函数返回值" class="headerlink" title="61-函数返回值"></a>61-函数返回值</h1><p>在编程语言中，一个函数或一个方法一般都有返回值，但也存在不返回值的情况，此时，这些函数仅仅仅是处理一些事务， 没有返回，或者说没有明确的返回值，在pascal语言中它有一个专有的关键字 procedure 。 在PHP中，函数都有返回值，分两种情况，使用return语句明确的返回和没有return语句返回NULL。</p><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>当使用return语句时，PHP给用户自定义的函数返回指定类型的变量。 依旧我们查看源码的方式，对return 关键字进行词法分析和语法分析后，生成中间代码。 从 Zend/zend_language_parser.y文件中可以确认其生成中间代码调用的是 zend_do_return 函数。</p><pre><code>void zend_do_return(znode *expr, int do_end_vparse TSRMLS_DC) /* {{{ */    {        zend_op *opline;        int start_op_number, end_op_number;        if (do_end_vparse) {            if (CG(active_op_array)->return_reference                    && !zend_is_function_or_method_call(expr)) {                zend_do_end_variable_parse(expr, BP_VAR_W, 0 TSRMLS_CC);/* 处理返回引用 */            } else {                zend_do_end_variable_parse(expr, BP_VAR_R, 0 TSRMLS_CC);/* 处理常规变量返回 */            }        }       ...// 省略  取其它中间代码操作        opline->opcode = ZEND_RETURN;        if (expr) {            opline->op1 = *expr;            if (do_end_vparse && zend_is_function_or_method_call(expr)) {                opline->extended_value = ZEND_RETURNS_FUNCTION;            }        } else {            opline->op1.op_type = IS_CONST;            INIT_ZVAL(opline->op1.u.constant);        }        SET_UNUSED(opline->op2);    }    /* }}} */</code></pre><p>生成中间代码为 ZEND_RETURN。 第一个操作数的类型在返回值为可用的表达式时， 其类型为表达式的操作类型，否则类型为 IS_CONST。这在后续计算执行中间代码函数时有用到。 根据操作数的不同，ZEND_RETURN中间代码会执行 ZEND_RETURN_SPEC_CONST_HANDLER， ZEND_RETURN_SPEC_TMP_HANDLER或ZEND_RETURN_SPEC_TMP_HANDLER。 这三个函数的执行流程基本类似，包括对一些错误的处理。 这里我们以ZEND_RETURN_SPEC_CONST_HANDLER为例说明函数返回值的执行过程：</p><pre><code>static int ZEND_FASTCALL  ZEND_RETURN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS){    zend_op *opline = EX(opline);    zval *retval_ptr;    zval **retval_ptr_ptr;    if (EG(active_op_array)-&gt;return_reference == ZEND_RETURN_REF) {        //  返回引用时不允许常量和临时变量        if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {               /* Not supposed to happen, but we&apos;ll allow it */            zend_error(E_NOTICE, &quot;Only variable references \                should be returned by reference&quot;);            goto return_by_value;        }        retval_ptr_ptr = NULL;  //  返回值        if (IS_CONST == IS_VAR &amp;&amp; !retval_ptr_ptr) {            zend_error_noreturn(E_ERROR, &quot;Cannot return string offsets by reference&quot;);        }        if (IS_CONST == IS_VAR &amp;&amp; !Z_ISREF_PP(retval_ptr_ptr)) {            if (opline-&gt;extended_value == ZEND_RETURNS_FUNCTION &amp;&amp;                EX_T(opline-&gt;op1.u.var).var.fcall_returned_reference) {            } else if (EX_T(opline-&gt;op1.u.var).var.ptr_ptr ==                    &amp;EX_T(opline-&gt;op1.u.var).var.ptr) {                if (IS_CONST == IS_VAR &amp;&amp; !0) {                      /* undo the effect of get_zval_ptr_ptr() */                    PZVAL_LOCK(*retval_ptr_ptr);                }                zend_error(E_NOTICE, &quot;Only variable references \                 should be returned by reference&quot;);                goto return_by_value;            }        }        if (EG(return_value_ptr_ptr)) { //  返回引用            SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr);   //  is_ref__gc设置为1            Z_ADDREF_PP(retval_ptr_ptr);    //  refcount__gc计数加1            (*EG(return_value_ptr_ptr)) = (*retval_ptr_ptr);        }    } else {return_by_value:        retval_ptr = &amp;opline-&gt;op1.u.constant;        if (!EG(return_value_ptr_ptr)) {            if (IS_CONST == IS_TMP_VAR) {            }        } else if (!0) { /* Not a temp var */            if (IS_CONST == IS_CONST ||                EG(active_op_array)-&gt;return_reference == ZEND_RETURN_REF ||                (PZVAL_IS_REF(retval_ptr) &amp;&amp; Z_REFCOUNT_P(retval_ptr) &gt; 0)) {                zval *ret;                ALLOC_ZVAL(ret);                INIT_PZVAL_COPY(ret, retval_ptr);   //  复制一份给返回值                zval_copy_ctor(ret);                *EG(return_value_ptr_ptr) = ret;            } else {                *EG(return_value_ptr_ptr) = retval_ptr; //  直接赋值                Z_ADDREF_P(retval_ptr);            }        } else {            zval *ret;            ALLOC_ZVAL(ret);            INIT_PZVAL_COPY(ret, retval_ptr);    //  复制一份给返回值            *EG(return_value_ptr_ptr) = ret;            }    }    return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);   //  返回前执行收尾工作}</code></pre><p>函数的返回值在程序执行时存储在 *EG(return_value_ptr_ptr)。ZE内核对值返回和引用返回作了区分， 并且在此基础上对常量，临时变量和其它类型的变量在返回时进行了不同的处理。在return执行完之前， ZE内核通过调用zend_leave_helper_SPEC函数，清除函数内部使用的变量等。 这也是ZE内核自动给函数加上NULL返回的原因之一。</p><h2 id="没有return语句的函数"><a href="#没有return语句的函数" class="headerlink" title="没有return语句的函数"></a>没有return语句的函数</h2><p>在PHP中，没有过程这个概念，只有没有返回值的函数。但是对于没有返回值的函数，PHP内核会“帮你“加上一个NULL来做为返回值。 这个“帮你”的操作也是在生成中间代码时进行的。在每个函数解析时都需要执行函数 zend_do_end_function_declaration， 在此函数中有一条语句：</p><p>zend_do_return(NULL, 0 TSRMLS_CC);</p><p>结合前面的内容，我们知道这条语句的作用就是返回NULL。这就是没有return语句的函数返回NULL的原因所在。</p><h2 id="内部函数的返回值"><a href="#内部函数的返回值" class="headerlink" title="内部函数的返回值"></a>内部函数的返回值</h2><p>内部函数的返回值都是通过一个名为 return_value 的变量传递的。 这个变量同时也是函数中的一个参数，在PHP_FUNCTION函数扩展开来后可以看到。 这个参数总是包含有一个事先申请好空间的 zval 容器，因此你可以直接访问其成员并对其进行修改而无需先对 return_value 执行一下 MAKE_STD_ZVAL 宏指令。 为了能够更方便从函数中返回结果，也为了省却直接访问 zval 容器内部结构的麻烦，ZEND 提供了一大套宏命令来完成相关的这些操作。 这些宏命令会自动设置好类型和数值。</p><h3 id="从函数直接返回值的宏："><a href="#从函数直接返回值的宏：" class="headerlink" title="从函数直接返回值的宏："></a>从函数直接返回值的宏：</h3><ul><li>RETURN_RESOURCE(resource) 返回一个资源。</li><li>RETURN_BOOL(bool) 返回一个布尔值。</li><li>RETURN_NULL() 返回一个空值。</li><li>RETURN_LONG(long) 返回一个长整数。</li><li>RETURN_DOUBLE(double) 返回一个双精度浮点数。</li><li>RETURN_STRING(string, duplicate) 返回一个字符串。duplicate 表示这个字符是否使用 estrdup() 进行复制。</li><li>RETURN_STRINGL(string, length, duplicate) 返回一个定长的字符串。其余跟 RETURN_STRING 相同。这个宏速度更快而且是二进制安全的。</li><li>RETURN_EMPTY_STRING() 返回一个空字符串。</li><li>RETURN_FALSE 返回一个布尔值假。</li><li>RETURN_TRUE 返回一个布尔值真。</li></ul><h3 id="设置函数返回值的宏："><a href="#设置函数返回值的宏：" class="headerlink" title="设置函数返回值的宏："></a>设置函数返回值的宏：</h3><ul><li>RETVAL_RESOURCE(resource) 设定返回值为指定的一个资源。</li><li>RETVAL_BOOL(bool) 设定返回值为指定的一个布尔值。</li><li>RETVAL_NULL 设定返回值为空值</li><li>RETVAL_LONG(long) 设定返回值为指定的一个长整数。</li><li>RETVAL_DOUBLE(double) 设定返回值为指定的一个双精度浮点数。</li><li>RETVAL_STRING(string, duplicate) 设定返回值为指定的一个字符串，duplicate 含义同 RETURN_STRING。</li><li>RETVAL_STRINGL(string, length, duplicate) 设定返回值为指定的一个定长的字符串。其余跟 RETVAL_STRING 相同。这个宏速度更快而且是二进制安全的。</li><li>RETVAL_EMPTY_STRING 设定返回值为空字符串。</li><li>RETVAL_FALSE 设定返回值为布尔值假。</li><li>RETVAL_TRUE 设定返回值为布尔值真。</li></ul><p>如果需要返回的是像数组和对象这样的复杂类型的数据，那就需要先调用 array_init() 和 object_init()， 也可以使用相应的 hash 函数直接操作 return_value。 由于这些类型主要是由一些杂七杂八的东西构成，所以对它们就没有了相应的宏。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>60-zend_parse_parameters函数</title>
      <link href="/posts/15fd986d.html"/>
      <url>/posts/15fd986d.html</url>
      
        <content type="html"><![CDATA[<h1 id="60-zend-parse-parameters函数"><a href="#60-zend-parse-parameters函数" class="headerlink" title="60-zend_parse_parameters函数"></a>60-zend_parse_parameters函数</h1><p>最简单的获取函数调用者传递过来的参数便是使用zend_parse_parameters()函数。</p><p>zend_parse_parameters()函数的前几个参数我们直接用内核里宏来生成便可以了，形式为：ZEND_NUM_ARGS() TSRMLS_CC，注意两者之间有个空格，但是没有逗号。从名字可以看出，ZEND_NUM_ARGS()代表这参数的个数。</p><p>紧接着需要传递个zend_parse_parameters()函数的参数是一个用于格式化的字符串，就像printf的第一个参数一样。下面表示了最常用的几个符号。</p><p>type_spec是格式化字符串，其常见的含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">代表着的类型</th></tr></thead><tbody><tr><td style="text-align:left">b</td><td style="text-align:left">Boolean</td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">Integer 整型</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">Floating point 浮点型</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">String 字符串</td></tr><tr><td style="text-align:left">r</td><td style="text-align:left">Resource 资源</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">Array 数组</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">Object instance 对象</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">Object instance of a specified type 特定类型的对象</td></tr><tr><td style="text-align:left">z</td><td style="text-align:left">Non-specific zval 任意类型～</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">zval**类型</td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">表示函数、方法名称，PHP5.1里貌似木有… …</td></tr></tbody></table><p>这个函数就像printf()函数一样，后面的参数是与格式化字符串里的格式一一对应的。一些基础类型的数据会直接映射成C语言里的类型。</p><pre><code>ZEND_FUNCTION(sample_getlong){    long foo;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;l&quot;, &amp;foo) == FAILURE)    {        RETURN_NULL();    }    php_printf(&quot;The integer value of the parameter is: %ld\n&quot;, foo);    RETURN_TRUE;}</code></pre><p>一般来说，int和long这两种数据类型的数据往往是相同的，但也有例外情况。所以我们不应改把long的数组放在一个int里，尤其是在64位平台里，那将引发一些不容易排查的Bug。所以通过zend_parse_parameter()函数接收参数时，我们应该使用内核约定好的那些类型的变量作为载体。</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">对应C里的数据类型</th></tr></thead><tbody><tr><td style="text-align:left">b</td><td style="text-align:left">zend_bool</td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">long</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">double</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">char*, int 前者接收指针，后者接收长度</td></tr><tr><td style="text-align:left">r</td><td style="text-align:left">zval*</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">zval*</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">zval*</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">zval<em>, zend_class_entry</em></td></tr><tr><td style="text-align:left">z</td><td style="text-align:left">zval*</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">zval**</td></tr></tbody></table><p>注意，所有的PHP语言中的复合类型参数都需要zval*类型来作为载体，因为它们都是内核自定义的一些数据结构。我们一定要确认参数和载体的类型一直，如果需要，它可以进行类型转换，比如把array转换成stdClass对象。</p><p>s和O(字母大写欧)类型需要单独说一些，因为它们都需要两个载体。我们将在接下来的章节里了解php中对象的具体实现。这样我们改写一下我们在第五章定义的一个函数：</p><pre><code>&lt;?phpfunction sample_hello_world($name){    echo &quot;Hello $name!\n&quot;;}?&gt;</code></pre><p>在编写扩展时，我们需要用zend_parse_parameters()来接收这个字符串:</p><pre><code>ZEND_FUNCTION(sample_hello_world){    char *name;    int name_len;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;,&amp;name, &amp;name_len) == FAILURE)    {        RETURN_NULL();    }    php_printf(&quot;Hello &quot;);    PHPWRITE(name, name_len);    php_printf(&quot;!\n&quot;);}</code></pre><p>如果传递给函数的参数数量小于zend_parse_parameters()要接收的参数数量，它便会执行失败，并返回FAILURE。</p><p>如果我们需要接收多个参数，可以直接在zend_parse_paramenters()的参数里罗列接收载体便可以了，如：</p><pre><code>&lt;?phpfunction sample_hello_world($name, $greeting){    echo &quot;Hello $greeting $name!\n&quot;;}sample_hello_world(&apos;John Smith&apos;, &apos;Mr.&apos;);?&gt;</code></pre><p>在PHP扩展里应该这样来实现：</p><pre><code>ZEND_FUNCTION(sample_hello_world){    char *name;    int name_len;    char *greeting;    int greeting_len;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;ss&quot;,&amp;name, &amp;name_len, &amp;greeting, &amp;greeting_len) == FAILURE)    {        RETURN_NULL();    }    php_printf(&quot;Hello &quot;);    PHPWRITE(greeting, greeting_len);    php_printf(&quot; &quot;);    PHPWRITE(name, name_len);    php_printf(&quot;!\n&quot;);}</code></pre><p>除了上面定义的参数，还有其它的三个参数来增强我们接受参数的能力，如下：</p><pre><code>Type Modifier    Meaning|        它之前的参数都是必须的，之后的都是非必须的，也就是有默认值的。!        如果接收了一个PHP语言里的null变量，则直接把其转成C语言里的NULL，而不是封装成IS_NULL类型的zval。/        如果传递过来的变量与别的变量共用一个zval，而且不是引用，则进行强制分离，新的zval的is_ref__gc==0, and refcount__gc==1.</code></pre><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>现在让我们继续改写sample_hello_world(), 接下来我们使用一些参数的默认值，在php语言里就像下面这样：</p><pre><code>&lt;?phpfunction sample_hello_world($name, $greeting=&apos;Mr./Ms.&apos;){    echo &quot;Hello $greeting $name!\n&quot;;}sample_hello_world(&apos;Ginger Rogers&apos;,&apos;Ms.&apos;);sample_hello_world(&apos;Fred Astaire&apos;);?&gt;</code></pre><p>此时即可以只向sample_hello_world中传递一个参数，也可以传递完整的两个参数。</p><p>那同样的功能我们怎样在扩展函数里实现呢？我们需要借助zend_parse_parameters中的(|)参数，这个参数之前的参数被认为是必须的，之后的便认为是非必须的了,如果没有传递，则不会去修改载体。</p><pre><code>ZEND_FUNCTION(sample_hello_world){    char *name;    int name_len;    char *greeting = &quot;Mr./Mrs.&quot;;    int greeting_len = sizeof(&quot;Mr./Mrs.&quot;) - 1;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s|s&quot;,      &amp;name, &amp;name_len, &amp;greeting, &amp;greeting_len) == FAILURE) {        RETURN_NULL();    }    php_printf(&quot;Hello &quot;);    PHPWRITE(greeting, greeting_len);    php_printf(&quot; &quot;);    PHPWRITE(name, name_len);    php_printf(&quot;!\n&quot;);}</code></pre><p>如果你不传递第二个参数，则扩展函数会被认为默认而不去修改载体。所以，我们需要自己来预先设置有载体的值，它往往是是NULL，或者一个与函数逻辑有关的值。</p><p>每个zval，包括IS_NULL型的zval，都需要占用一定的内存空间，并且需要cpu的计算资源来为它申请内存、初始化，并在它们完成工作后释放掉。但是很多代码都都没有意识到这一点。有很多代码都会把一个null型的值包裹成zval的IS_NULL类型，在扩展开发里这种操作是可以优化的，我们可以把参数接收城C语言里的NULL。我们就这一个问题看以下代码：</p><pre><code>ZEND_FUNCTION(sample_arg_fullnull){    zval *val;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z&quot;,&amp;val) == FAILURE) {        RETURN_NULL();    }    if (Z_TYPE_P(val) == IS_NULL) {        val = php_sample_make_defaultval(TSRMLS_C);    }    ...}ZEND_FUNCTION(sample_arg_nullok){    zval *val;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z!&quot;,                                    &amp;val) == FAILURE) {        RETURN_NULL();    }    if (!val) {        val = php_sample_make_defaultval(TSRMLS_C);    }}</code></pre><p>这两段代码乍看起来并没有什么很大的不同，但是第一段代码确实需要更多的cpu和内存资源。可能这个技巧在平时并没多大用，不过技多不压身，知道总比不知道好。</p><h3 id="Forced-Separation"><a href="#Forced-Separation" class="headerlink" title="Forced Separation"></a>Forced Separation</h3><p>当一个变量被传递给函数时候，无论它是否被引用，它的refcoung__gc属性都会加一，至少成为2。一份是它自己，另一份是传递给函数的的copy。在改变这个zval之前，有时会需要提前把它分成实际意义上的两份copy。这就是”/“格式符的作用。它将把写时复制的zval提前分成两个完整独立的copy，从而使我们可以在下面的代码中随意的对其进行操作。否则我们可能需要不停的提醒自己对接收的参数进行分离等操作。Like the NULL flag, this modifier goes after the type it means to impact. Also like the NULL flag, you won’t know you need this feature until you actually have a use for it.</p><h3 id="zend-get-arguments"><a href="#zend-get-arguments" class="headerlink" title="zend_get_arguments()"></a>zend_get_arguments()</h3><p>如果你想让你的扩展能够兼容老版本的PHP，或者你只想以zval*为载体来接收参数，便可以考虑使用zend_get_parameters()函数来接收参数。</p><p>zend_get_parameters()与zend_parse_parameters()不同，从名字上我们便可以看出，它直接获取，而不做解析。首先，它不会自动进行类型转换，所有的参数在扩展实现中的载体都需要是zval*类型的，下面让我们来看一个最简单的例子：</p><pre><code>ZEND_FUNCTION(sample_onearg){    zval *firstarg;    if (zend_get_parameters(ZEND_NUM_ARGS(), 1, &amp;firstarg)== FAILURE)    {        php_error_docref(NULL TSRMLS_CC, E_WARNING,&quot;Expected at least 1 parameter.&quot;);        RETURN_NULL();    }    /* Do something with firstarg... */}</code></pre><p>其次，zend_get_parameters()在接收失败的时候，并不会自己抛出错误，它也不能方便的处理具有默认值的参数。</p><p>最后一点与zend_parse_parameters不同的是，它会自动的把所有复合copy-on-write的zval进行强制分离，生成一个崭新的copy送到函数内部。如果你希望用它其它的特性，而唯独不需要这个功能，可以去尝试一下用zend_get_parameters_ex()函数来接收参数。</p><p>为了不对copy-on-write的变量进行分离操作，zend_get_parameters_ex()的参数是zval*<em>类型的，而不是zval</em>。 这个函数不太经常用，可能只会在你碰到一些极端问题时候才会想到它，而它用起来却很简单：</p><pre><code>ZEND_FUNCTION(sample_onearg){    zval **firstarg;    if (zend_get_parameters_ex(1, &amp;firstarg) == FAILURE)    {        WRONG_PARAM_COUNT;    }    /* Do something with firstarg... */}</code></pre><p>注意zend_get_parameters_ex不需要ZEND_NUM_ARGS()作为参数，因为它是在是在后期加入的，那个参数已经不再需要了。</p><p>上面例子中还使用了WRONG_PARAM_COUNT宏,它的功能是抛出一个E_WARNING级别的错误信息，并自动return。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>有两种其它的zend_get_parameter_**函数，专门用来解决参数很多或者无法提前知道参数数目的问题。想一下php语言中var_dump()函数的用法，我们可以向其传递任意数量的参数，它在内核中的实现其实是这样的：</p><pre><code>ZEND_FUNCTION(var_dump){    int i, argc = ZEND_NUM_ARGS();    zval ***args;    args = (zval ***)safe_emalloc(argc, sizeof(zval **), 0);    if (ZEND_NUM_ARGS() == 0 || zend_get_parameters_array_ex(argc, args) == FAILURE)    {        efree(args);        WRONG_PARAM_COUNT;    }    for (i=0; i &lt; argc; i++)    {        php_var_dump(args[i], 1 TSRMLS_CC);    }    efree(args);}</code></pre><p>程序首先获取参数数量，然后通过safe_emalloc函数申请了相应大小的内存来存放这些zval*<em>类型的参数。这里使用了zend_get_parameters_array_ex()函数来把传递给函数的参数填充到args中。你可能已经立即想到，还存在一个名为zend_get_parameters_array()的函数，唯一不同的是它将zval</em>类型的参数填充到args中，并且需要ZEND_NUM_ARGS()作为参数。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>59-函数的参数</title>
      <link href="/posts/ca8df295.html"/>
      <url>/posts/ca8df295.html</url>
      
        <content type="html"><![CDATA[<h1 id="59-函数的参数"><a href="#59-函数的参数" class="headerlink" title="59-函数的参数"></a>59-函数的参数</h1><p>前面介绍了函数的定义，函数的定义只是一个将函数名注册到函数列表的过程，在了解了函数的定义后，我们来看看函数的参数。 这一小节将包括用户自定义函数的参数和内部函数的参数两部分，详细内容如下：</p><h2 id="用户自定义函数的参数"><a href="#用户自定义函数的参数" class="headerlink" title="用户自定义函数的参数"></a>用户自定义函数的参数</h2><p>我们对于参数的类型提示做了分析，这里我们在这一小节的基础上，进行一些更详细的说明。 在经过词语分析，语法分析后，我们知道对于函数的参数检查是通过 zend_do_receive_arg 函数来实现的。在此函数中对于参数的关键代码如下：</p><pre><code>CG(active_op_array)-&gt;arg_info = erealloc(CG(active_op_array)-&gt;arg_info,        sizeof(zend_arg_info)*(CG(active_op_array)-&gt;num_args));cur_arg_info = &amp;CG(active_op_array)-&gt;arg_info[CG(active_op_array)-&gt;num_args-1];cur_arg_info-&gt;name = estrndup(varname-&gt;u.constant.value.str.val,        varname-&gt;u.constant.value.str.len);cur_arg_info-&gt;name_len = varname-&gt;u.constant.value.str.len;cur_arg_info-&gt;array_type_hint = 0;cur_arg_info-&gt;allow_null = 1;cur_arg_info-&gt;pass_by_reference = pass_by_reference;cur_arg_info-&gt;class_name = NULL;cur_arg_info-&gt;class_name_len = 0;</code></pre><p>整个参数的传递是通过给中间代码的arg_info字段执行赋值操作完成。关键点是在arg_info字段。arg_info字段的结构如下：</p><pre><code>typedef struct _zend_arg_info {    const char *name;   /* 参数的名称*/    zend_uint name_len;     /* 参数名称的长度*/    const char *class_name; /* 类名 */    zend_uint class_name_len;   /* 类名长度*/    zend_bool array_type_hint;  /* 数组类型提示 */    zend_bool allow_null;   /* 是否允许为NULL　*/    zend_bool pass_by_reference;    /*　是否引用传递 */    zend_bool return_reference;    int required_num_args;  } zend_arg_info;</code></pre><p>参数的值传递和参数传递的区分是通过 pass_by_reference参数在生成中间代码时实现的。</p><p>对于参数的个数，中间代码中包含的arg_nums字段在每次执行 **zend_do_receive_arg×× 时都会加1.如下代码：</p><pre><code>CG(active_op_array)-&gt;num_args++;</code></pre><p>并且当前参数的索引为CG(active_op_array)-&gt;num_args-1 .如下代码：</p><pre><code>cur_arg_info = &amp;CG(active_op_array)-&gt;arg_info[CG(active_op_array)-&gt;num_args-1];</code></pre><p>以上的分析是针对函数定义时的参数设置，这些参数是固定的。而在实际编写程序时可能我们会用到可变参数。 此时我们会使用到函数 func_num_args 和 func_get_args。 它们是以内部函数存在。于是在 Zend\zend_builtin_functions.c 文件中找到这两个函数的实现。 首先我们来看func_num_args函数的实现。其代码如下：</p><pre><code>/* {{{ proto int func_num_args(void)       Get the number of arguments that were passed to the function */    ZEND_FUNCTION(func_num_args)    {        zend_execute_data *ex = EG(current_execute_data)->prev_execute_data;        if (ex && ex->function_state.arguments) {            RETURN_LONG((long)(zend_uintptr_t)*(ex->function_state.arguments));        } else {            zend_error(E_WARNING,    "func_num_args():  Called from the global scope - no function context");            RETURN_LONG(-1);        }    }    /* }}} */</code></pre><p>在存在 ex-&gt;function_state.arguments的情况下，即函数调用时，返回ex-&gt;function_state.arguments转化后的值 ，否则显示错误并返回-1。 这里最关键的一点是EG(current_execute_data)。这个变量存放的是当前执行程序或函数的数据。此时我们需要取前一个执行程序的数据，为什么呢？ 因为这个函数的调用是在进入函数后执行的。函数的相关数据等都在之前执行过程中。于是调用的是：</p><pre><code>zend_execute_data *ex = EG(current_execute_data)-&gt;prev_execute_data;</code></pre><p>在了解func_num_args函数的实现后，func_get_args函数的实现过程就简单了，它们的数据源是一样的， 只是前面返回的是长度，而这里返回了一个创建的数组。数组中存放的是从ex-&gt;function_state.arguments转化后的数据。</p><h2 id="内部函数的参数"><a href="#内部函数的参数" class="headerlink" title="内部函数的参数"></a>内部函数的参数</h2><p>以上我们所说的都是用户自定义函数中对于参数的相关内容。下面我们开始讲解内部函数是如何传递参数的。 以常见的count函数为例。其参数处理部分的代码如下：</p><pre><code>/* {{{ proto int count(mixed var [, int mode])   Count the number of elements in a variable (usually an array) */PHP_FUNCTION(count){    zval *array;    long mode = COUNT_NORMAL;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;z|l&quot;,         &amp;array, &amp;mode) == FAILURE) {        return;    }    ... //省略}</code></pre><p>这包括了两个操作：一个是取参数的个数，一个是解析参数列表。</p><h3 id="1-取参数的个数"><a href="#1-取参数的个数" class="headerlink" title="1. 取参数的个数"></a>1. 取参数的个数</h3><p>取参数的个数是通过ZEND_NUM_ARGS()宏来实现的。其定义如下：</p><pre><code>#define ZEND_NUM_ARGS()     (ht)</code></pre><p>ht是在 Zend/zend.h文件中定义的宏 INTERNAL_FUNCTION_PARAMETERS 中的ht，如下：</p><pre><code>#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value,zval **return_value_ptr, zval *this_ptr, int return_value_used TSRMLS_DC</code></pre><h3 id="2-解析参数列表"><a href="#2-解析参数列表" class="headerlink" title="2. 解析参数列表"></a>2. 解析参数列表</h3><p>PHP内部函数在解析参数时使用的是 zend_parse_parameters。 它可以大大简化参数的接收处理工作，虽然它在处理可变参数时还有点弱。</p><p>其声明如下：</p><pre><code>ZEND_API int zend_parse_parameters(int num_args TSRMLS_DC, char *type_spec, ...)</code></pre><ul><li>第一个参数num_args表明表示想要接收的参数个数，我们经常使用ZEND_NUM_ARGS() 来表示对传入的参数“有多少要多少”。</li><li>第二参数应该总是宏 TSRMLS_CC 。</li><li>第三个参数 type_spec 是一个字符串，用来指定我们所期待接收的各个参数的类型，有点类似于 printf 中指定输出格式的那个格式化字符串。</li><li>剩下的参数就是我们用来接收PHP参数值的变量的指针。</li></ul><p>zend_parse_parameters() 在解析参数的同时会尽可能地转换参数类型，这样就可以确保我们总是能得到所期望的类型的变量。 任何一种标量类型都可以转换为另外一种标量类型，但是不能在标量类型与复杂类型（比如数组、对象和资源等）之间进行转换。 如果成功地解析和接收到了参数并且在转换期间也没出现错误，那么这个函数就会返回 SUCCESS，否则返回 FAILURE。 如果这个函数不能接收到所预期的参数个数或者不能成功转换参数类型时就会抛出一些错误信息。</p><p>第三个参数指定的各个参数类型列表如下所示：</p><ul><li>l - 长整形</li><li>d - 双精度浮点类型</li><li>s - 字符串 (也可能是空字节)和其长度</li><li>b - 布尔型</li><li>r - 资源，保存在 zval*</li><li>a - 数组，保存在 zval*</li><li>o - （任何类的）对象，保存在 zval *</li><li>O - （由class entry 指定的类的）对象，保存在 zval *</li><li>z - 实际的 zval*</li></ul><p>除了各个参数类型，第三个参数还可以包含下面一些字符，它们的含义如下：</p><ul><li>| - 表明剩下的参数都是可选参数。如果用户没有传进来这些参数值，那么这些值就会被初始化成默认值。</li><li>/ - 表明参数解析函数将会对剩下的参数以 SEPARATE_ZVAL_IF_NOT_REF() 的方式来提供这个参数的一份拷贝，除非这些参数是一个引用。</li><li>! - 表明剩下的参数允许被设定为 NULL（仅用在 a、o、O、r和z身上）。如果用户传进来了一个 NULL 值，则存储该参数的变量将会设置为 NULL。</li></ul>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58-定义函数的过程</title>
      <link href="/posts/5e902bce.html"/>
      <url>/posts/5e902bce.html</url>
      
        <content type="html"><![CDATA[<h1 id="58-定义函数的过程"><a href="#58-定义函数的过程" class="headerlink" title="58-定义函数的过程"></a>58-定义函数的过程</h1><p>在PHP中，用户函数的定义从function关键字开始。如下所示简单示例：</p><pre><code>function foo($var) {    echo $var;}</code></pre><p>这是一个非常简单的函数，它所实现的功能是定义一个函数，函数有一个参数，函数的内容是在标准输出端输出传递给它的参数变量的值。</p><p>函数的一切从function开始。我们从function开始函数定义的探索之旅。</p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>在 Zend/zend_language_scanner.l中我们找到如下所示的代码：</p><pre><code>&quot;function&quot; {    return T_FUNCTION;}</code></pre><p>它所表示的含义是function将会生成T_FUNCTION标记。在获取这个标记后，我们开始语法分析。</p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>在 Zend/zend_language_parser.y文件中找到函数的声明过程标记如下：</p><pre><code>function:    T_FUNCTION { $$.u.opline_num = CG(zend_lineno); };is_reference:        /* empty */ { $$.op_type = ZEND_RETURN_VAL; }    |   &apos;&amp;&apos;         { $$.op_type = ZEND_RETURN_REF; };unticked_function_declaration_statement:        function is_reference T_STRING {zend_do_begin_function_declaration(&amp;$1, &amp;$3, 0, $2.op_type, NULL TSRMLS_CC); }            &apos;(&apos; parameter_list &apos;)&apos; &apos;{&apos; inner_statement_list &apos;}&apos; {                zend_do_end_function_declaration(&amp;$1 TSRMLS_CC); };</code></pre><p>关注点在 function is_reference T_STRING，表示function关键字，是否引用，函数名。</p><p>T_FUNCTION标记只是用来定位函数的声明，表示这是一个函数，而更多的工作是与这个函数相关的东西，包括参数，返回值等。</p><h2 id="生成中间代码"><a href="#生成中间代码" class="headerlink" title="生成中间代码"></a>生成中间代码</h2><p>语法解析后，我们看到所执行编译函数为zend_do_begin_function_declaration。在 Zend/zend_complie.c文件中找到其实现如下：</p><pre><code>void zend_do_begin_function_declaration(znode *function_token, znode *function_name, int is_method, int return_reference, znode *fn_flags_znode TSRMLS_DC) /* {{{ */    {        ...//省略        function_token->u.op_array = CG(active_op_array);        lcname = zend_str_tolower_dup(name, name_len);        orig_interactive = CG(interactive);        CG(interactive) = 0;        init_op_array(&op_array, ZEND_USER_FUNCTION, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);        CG(interactive) = orig_interactive;         ...//省略        if (is_method) {            ...//省略 类方法 在后面的类章节介绍        } else {            zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);            opline->opcode = ZEND_DECLARE_FUNCTION;            opline->op1.op_type = IS_CONST;            build_runtime_defined_function_key(&opline->op1.u.constant, lcname,                name_len TSRMLS_CC);            opline->op2.op_type = IS_CONST;            opline->op2.u.constant.type = IS_STRING;            opline->op2.u.constant.value.str.val = lcname;            opline->op2.u.constant.value.str.len = name_len;            Z_SET_REFCOUNT(opline->op2.u.constant, 1);            opline->extended_value = ZEND_DECLARE_FUNCTION;            zend_hash_update(CG(function_table), opline->op1.u.constant.value.str.val,                opline->op1.u.constant.value.str.len, &op_array, sizeof(zend_op_array),                 (void **) &CG(active_op_array));        }    }    /* }}} */</code></pre><p>生成的中间代码为 ZEND_DECLARE_FUNCTION ，根据这个中间代码及操作数对应的op_type。 我们可以找到中间代码的执行函数为 ZEND_DECLARE_FUNCTION_SPEC_HANDLER。</p><p>在生成中间代码时，可以看到已经统一了函数名全部为小写，表示函数的名称不是区分大小写的。</p><p>为验证这个实现，我们看一段代码：</p><pre><code>function T() {    echo 1;}function t() {    echo 2;}</code></pre><p>执行代码，可以看到屏幕上输出如下报错信息：</p><pre><code>Fatal error: Cannot redeclare t() (previously declared in ...)</code></pre><p>表示对于PHP来说T和t是同一个函数名。检验函数名是否重复，这个过程是在哪进行的呢？ 下面将要介绍的函数声明中间代码的执行过程包含了这个检查过程。</p><h2 id="执行中间代码"><a href="#执行中间代码" class="headerlink" title="执行中间代码"></a>执行中间代码</h2><p>在 Zend/zend_vm_execute.h 文件中找到 ZEND_DECLARE_FUNCTION中间代码对应的执行函数：ZEND_DECLARE_FUNCTION_SPEC_HANDLER。 此函数只调用了函数do_bind_function。其调用代码为：</p><pre><code>do_bind_function(EX(opline), EG(function_table), 0);</code></pre><p>在这个函数中将EX(opline)所指向的函数添加到EG(function_table)中，并判断是否已经存在相同名字的函数，如果存在则报错。 EG(function_table)用来存放执行过程中全部的函数信息，相当于函数的注册表。 它的结构是一个HashTable，所以在do_bind_function函数中添加新的函数使用的是HashTable的操作函数zend_hash_add。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>57-函数结构转换</title>
      <link href="/posts/a200388.html"/>
      <url>/posts/a200388.html</url>
      
        <content type="html"><![CDATA[<h1 id="57-函数结构转换"><a href="#57-函数结构转换" class="headerlink" title="57-函数结构转换"></a>57-函数结构转换</h1><p>在函数调用的执行代码中我们会看到这样一些强制转换：</p><pre><code>EX(function_state).function = (zend_function *) op_array;</code></pre><p>或者：</p><pre><code>EG(active_op_array) = (zend_op_array *) EX(function_state).function;</code></pre><p>这些不同结构间的强制转换是如何进行的呢？</p><p>首先我们来看zend_function的结构，在Zend/zend_compile.h文件中，其定义如下：</p><pre><code>typedef union _zend_function {    zend_uchar type;    /* MUST be the first element of this struct! */    struct {        zend_uchar type;  /* never used */        char *function_name;        zend_class_entry *scope;        zend_uint fn_flags;        union _zend_function *prototype;        zend_uint num_args;        zend_uint required_num_args;        zend_arg_info *arg_info;        zend_bool pass_rest_by_reference;        unsigned char return_reference;    } common;    zend_op_array op_array;    zend_internal_function internal_function;} zend_function;</code></pre><p>这是一个联合体，我们来温习一下联合体的一些特性。 联合体的所有成员变量共享内存中的一块内存，在某个时刻只能有一个成员使用这块内存， 并且当使用某一个成员时，其仅能按照它的类型和内存大小修改对应的内存空间。 我们来看看一个例子：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() {    typedef  union _utype    {        int i;        char ch[2];    } utype;    utype a;    a.i = 10;    a.ch[0] = &apos;1&apos;;    a.ch[1] = &apos;1&apos;;    printf(&quot;a.i= %d a.ch=%s&quot;,a.i, a.ch);    getchar();    return (EXIT_SUCCESS);}</code></pre><p>程序输出：a.i= 12593 a.ch=11 当修改ch的值时，它会依据自己的规则覆盖i字段对应的内存空间。 ‘1’对应的ASCII码值是49，二进制为00110001，当ch字段的两个元素都为’1’时，此时内存中存储的二进制为 00110001 00110001 转成十进制，其值为12593。</p><p>回过头来看zend_function的结构，它也是一个联合体，第一个字段为type， 在common中第一个字段也为type，并且其后面注释为/<em> Never used</em>/，此处的type字段的作用就是为第一个字段的type留下内存空间。并且不让其它字段干扰了第一个字段。 我们再看zend_op_array的结构：</p><pre><code>struct _zend_op_array {    /* Common elements */    zend_uchar type;    char *function_name;            zend_class_entry *scope;    zend_uint fn_flags;    union _zend_function *prototype;    zend_uint num_args;    zend_uint required_num_args;    zend_arg_info *arg_info;    zend_bool pass_rest_by_reference;    unsigned char return_reference;    /* END of common elements */    zend_bool done_pass_two;    ....//  其它字段}</code></pre><p>这里的字段集和common的一样，于是在将zend_function转化成zend_op_array时并不会产生影响，这种转变是双向的。</p><p>再看zend_internal_function的结构：</p><pre><code>typedef struct _zend_internal_function {    /* Common elements */    zend_uchar type;    char * function_name;    zend_class_entry *scope;    zend_uint fn_flags;    union _zend_function *prototype;    zend_uint num_args;    zend_uint required_num_args;    zend_arg_info *arg_info;    zend_bool pass_rest_by_reference;    unsigned char return_reference;    /* END of common elements */    void (*handler)(INTERNAL_FUNCTION_PARAMETERS);    struct _zend_module_entry *module;} zend_internal_function;</code></pre><p>同样存在公共元素，和common结构体一样，我们可以将zend_function结构强制转化成zend_internal_function结构，并且这种转变是双向的。</p><p>总的来说zend_internal_function，zend_function，zend_op_array这三种结构在一定程序上存在公共的元素， 于是这些元素以联合体的形式共享内存，并且在执行过程中对于一个函数，这三种结构对应的字段在值上都是一样的， 于是可以在一些结构间发生完美的强制类型转换。 可以转换的列表如下：</p><ul><li>zend_function可以与zend_op_array互换</li><li>zend_function可以与zend_internal_function互换</li></ul><p>但是一个zend_op_array结构转换成zend_function是不能再次转变成zend_internal_function结构的，反之亦然。</p><p>其实zend_function就是一个混合的数据结构，这种结构在一定程序上节省了内存空间。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56-函数的内部结构</title>
      <link href="/posts/f8809374.html"/>
      <url>/posts/f8809374.html</url>
      
        <content type="html"><![CDATA[<h1 id="56-函数的内部结构"><a href="#56-函数的内部结构" class="headerlink" title="56-函数的内部结构"></a>56-函数的内部结构</h1><p>在PHP中，函数有自己的作用域，同时在其内部可以实现各种语句的执行，最后返回最终结果值。 在PHP的源码中可以发现，PHP内核将函数分为以下类型：</p><pre><code>#define ZEND_INTERNAL_FUNCTION              1#define ZEND_USER_FUNCTION                  2  #define ZEND_OVERLOADED_FUNCTION            3#define ZEND_EVAL_CODE                      4#define ZEND_OVERLOADED_FUNCTION_TEMPORARY  5</code></pre><p>其中的ZEND_USER_FUNCTION是用户函数，ZEND_INTERNAL_FUNCTION是内置的函数。也就是说PHP将内置的函数和用户定义的函数分别保存。</p><h2 id="用户函数-ZEND-USER-FUNCTION"><a href="#用户函数-ZEND-USER-FUNCTION" class="headerlink" title="用户函数(ZEND_USER_FUNCTION)"></a>用户函数(ZEND_USER_FUNCTION)</h2><p>用户自定义函数是非常常用的函数种类，如下面的代码，定义了一个用户自定义的函数：</p><pre><code>&lt;?phpfunction nowamagic( $name ){    $return = &quot;Hi! &quot; . $name;    echo $return;    return $return;}?&gt;</code></pre><p>这个示例中，对自定义函数传入了一个参数，并将其与Hi! 一起输出并做为返回值返回。 从这个例子可以看出函数的基本特点：运行时声明、可以传参数、有值返回。 当然，有些函数只是进行一些操作，并不一定显式的有返回值，在PHP的实现中，即使没有显式的返回， PHP内核也会“帮你“返回NULL。</p><p>ZE在执行过程中，会将运行时信息存储于_zend_execute_data中：</p><pre><code>struct _zend_execute_data {    //...省略部分代码    zend_function_state function_state;    zend_function *fbc; /* Function Being Called */    //...省略部分代码};</code></pre><p>在程序初始化的过程中，function_state也会进行初始化，function_state由两个部分组成：</p><pre><code>typedef struct _zend_function_state {    zend_function *function;    void **arguments;} zend_function_state;</code></pre><p>*<em>arguments是一个指向函数参数的指针，而函数体本身则存储于</em>function中， *function是一个zend_function结构体， 它最终存储了用户自定义函数的一切信息，它的具体结构是这样的：</p><pre><code>typedef union _zend_function {    zend_uchar type;    /* 如用户自定义则为 #define ZEND_USER_FUNCTION 2                            MUST be the first element of this struct! */    struct {        zend_uchar type;  /* never used */        char *function_name;    //函数名称        zend_class_entry *scope; //函数所在的类作用域        zend_uint fn_flags;     // 作为方法时的访问类型等，如ZEND_ACC_STATIC等          union _zend_function *prototype; //函数原型        zend_uint num_args;     //参数数目        zend_uint required_num_args; //需要的参数数目        zend_arg_info *arg_info;  //参数信息指针        zend_bool pass_rest_by_reference;        unsigned char return_reference;  //返回值    } common;    zend_op_array op_array;   //函数中的操作    zend_internal_function internal_function;  } zend_function;</code></pre><p>zend_function的结构中的op_array存储了该函数中所有的操作，当函数被调用时，ZE就会将这个op_array中的opline一条条顺次执行， 并将最后的返回值返回。 从VLD扩展中查看的关于函数的信息可以看出，函数的定义和执行是分开的，一个函数可以作为一个独立的运行单元而存在。</p><h2 id="内部函数-ZEND-INTERNAL-FUNCTION"><a href="#内部函数-ZEND-INTERNAL-FUNCTION" class="headerlink" title="内部函数(ZEND_INTERNAL_FUNCTION)"></a>内部函数(ZEND_INTERNAL_FUNCTION)</h2><p>ZEND_INTERNAL_FUNCTION函数是由扩展或者Zend/PHP内核提供的，用“C/C++”编写的，可以直接执行的函数。如下为内部函数的结构：</p><pre><code>typedef struct _zend_internal_function {    /* Common elements */    zend_uchar type;    char * function_name;    zend_class_entry *scope;    zend_uint fn_flags;    union _zend_function *prototype;    zend_uint num_args;    zend_uint required_num_args;    zend_arg_info *arg_info;    zend_bool pass_rest_by_reference;    unsigned char return_reference;    /* END of common elements */    void (*handler)(INTERNAL_FUNCTION_PARAMETERS);    struct _zend_module_entry *module;} zend_internal_function;</code></pre><p>最常见的操作是在模块初始化时，ZE会遍历每个载入的扩展模块，然后将模块中function_entry中指明的每一个函数(module-&gt;functions)， 创建一个zend_internal_function结构， 并将其type设置为ZEND_INTERNAL_FUNCTION，将这个结构填入全局的函数表(HashTable结构）; 函数设置及注册过程见 Zend/zend_API.c文件中的zend_register_functions函数。这个函数除了处理函数，也处理类的方法，包括那些魔术方法。</p><p>内部函数的结构与用户自定义的函数结构基本类似，有一些不同，</p><pre><code>调用方法，handler字段. 如果是ZEND_INTERNAL_FUNCTION， 那么ZE就调用zend_execute_internal，通过zend_internal_function.handler来执行这个函数。 而用户自定义的函数需要生成中间代码，然后通过中间代码映射到相对就把方法调用。内置函数在结构中多了一个module字段，表示属于哪个模块。不同的扩展其模块不同。type字段，在用户自定义的函数中，type字段几科无用，而内置函数中的type字段作为几种内部函数的区分。</code></pre><h2 id="变量函数"><a href="#变量函数" class="headerlink" title="变量函数"></a>变量函数</h2><p>PHP 支持变量函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且将尝试执行它。 除此之外，这个可以被用于实现回调函数，函数表等。 对比使用变量函数和内部函数的调用：</p><p>变量函数$func</p><pre><code>$func = &apos;print_r&apos;;$func(&apos;i am print_r function.&apos;);</code></pre><p>通过VLD来查看这段代码编译后的中间代码：</p><pre><code>function name:  (null)number of ops:  9compiled vars:  !0 = $funcline     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------   2     0  &gt;   EXT_STMT         1      ASSIGN                                                   !0, &apos;print_r&apos;   3     2      EXT_STMT         3      INIT_FCALL_BY_NAME                                       !0         4      EXT_FCALL_BEGIN         5      SEND_VAL                                                 &apos;i+am+print_r+function.&apos;         6      DO_FCALL_BY_NAME                              1         7      EXT_FCALL_END         8    &gt; RETURN                                                   1</code></pre><p>内部函数print_r</p><pre><code>print_r(&apos;i am print_r function.&apos;);</code></pre><p>通过VLD来查看这段代码编译后的中间代码：</p><pre><code>function name:  (null)number of ops:  6compiled vars:  noneline     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------   2     0  &gt;   EXT_STMT         1      EXT_FCALL_BEGIN         2      SEND_VAL                                                 &apos;i+am+print_r+function.&apos;         3      DO_FCALL                                      1          &apos;print_r&apos;         4      EXT_FCALL_END         5    &gt; RETURN                                                   1</code></pre><p>对比发现，二者在调用的中间代码上存在一些区别。变量函数是DO_FCALL_BY_NAME，而内部函数是DO_FCALL。 这在语法解析时就已经决定了， 见Zend/zend_complie.c文件的zend_do_end_function_call函数中部分代码：</p><pre><code>if (!is_method &amp;&amp; !is_dynamic_fcall &amp;&amp; function_name-&gt;op_type==IS_CONST) {        opline-&gt;opcode = ZEND_DO_FCALL;        opline-&gt;op1 = *function_name;        ZVAL_LONG(&amp;opline-&gt;op2.u.constant, zend_hash_func(Z_STRVAL(function_name-&gt;u.constant), Z_STRLEN(function_name-&gt;u.constant) + 1));    } else {        opline-&gt;opcode = ZEND_DO_FCALL_BY_NAME;        SET_UNUSED(opline-&gt;op1);    }</code></pre><p>如果不是方法，并且不是动态调用，并且函数名为字符串常量，则其生成的中间代码为ZEND_DO_FCALL。其它情况则为ZEND_DO_FCALL_BY_NAME。 另外将变量函数作为回调函数，其处理过程在Zend/zend_complie.c文件的zend_do_pass_param函数中。 最终会体现在中间代码执行过程中的 ZEND_SEND_VAL_SPEC_CONST_HANDLER　等函数中。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数是一类不需要指定表示符，而又可以被调用的函数或子例程，匿名函数可以方便的作为参数传递给其他函数。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55-函数的分类</title>
      <link href="/posts/52f839a.html"/>
      <url>/posts/52f839a.html</url>
      
        <content type="html"><![CDATA[<h1 id="55-函数的分类"><a href="#55-函数的分类" class="headerlink" title="55-函数的分类"></a>55-函数的分类</h1><p>函数是一种可以在任何被需要的时候执行的代码块。它不仅仅包括用户自定义的函数，还包括程序语言实现的库函数。</p><h2 id="用户定义的函数"><a href="#用户定义的函数" class="headerlink" title="用户定义的函数"></a>用户定义的函数</h2><p>如下所示手册中的展示函数用途的伪代码：</p><pre><code>function foo($arg_1, $arg_2, ..., $arg_n) {    echo &quot;Example function.\n&quot;;    return $retval;}</code></pre><p>任何有效的 PHP 代码都可以编写在函数内部，甚至包括其它函数和类定义。</p><p>在 PHP 3 中，函数必须在被调用之前定义。而 PHP 4 则不再有这样的条件。除非函数如以下两个范例中有条件的定义。</p><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>PHP 有很多标准的函数和结构。如我们常见的count、strpos、implode等函数，这些都是标准函数，它们都是由标准扩展提供的； 如我们经常用到的isset、empty、eval等函数，这些结构被称之为语言结构。 还有一些函数需要和特定的PHP扩展模块一起编译并开启，否则无法使用。也就是有些扩展是可选的。</p><p>标准函数的实现存放在ext/standard扩展目录中。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>有时我们的一代代码并不需要为它指定一个名称，而只需要它完成特定的工作， 匿名函数的作用是为了扩大函数的使用功能，在PHP 5.3以前，传递函数回调的方式，我们只有两种选择：</p><ul><li>字符串的函数名</li><li>使用create_function创建的返回</li></ul><p>在PHP5.3以后，我们多了一个选择–Closure。在实现上PHP 5.3中对匿名函数的支持，采用的是把要保持的外部变量， 做为Closure对象的”Static属性”来实现的，关于如何实现我们将在后面的章节介绍。</p><h2 id="变量函数"><a href="#变量函数" class="headerlink" title="变量函数"></a>变量函数</h2><p>PHP 支持变量函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数， 并且将尝试执行它。除此之外，这个可以被用于实现回调函数，函数表等。 一个变量函数的简单例子：</p><pre><code>$func = &apos;print_r&apos;;$func(&apos;i am print_r function.&apos;);</code></pre><p>变量函数不能用于语言结构（echo等）</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54-数组源码分析</title>
      <link href="/posts/2a1c80ad.html"/>
      <url>/posts/2a1c80ad.html</url>
      
        <content type="html"><![CDATA[<h1 id="54-数组源码分析"><a href="#54-数组源码分析" class="headerlink" title="54-数组源码分析"></a>54-数组源码分析</h1><p>PHP中经常使用数组，使用数组最大的好处便是速度！读写都可以在O(1)内完成，因为它每个元素的大小都是一致的，只要知道下标，便可以瞬间计算出其对应的元素在内存中的位置，从而直接取出或者写入。那么内核中是如何实现的呢？</p><p>PHP大部分功能，都是通过HashTable来实现，其中就包括数组。HashTable即具有双向链表的优点，同时具有能与数据匹敌的操作性能。PHP中的定义的变量保存在一个符号表里，而这个符号表其实就是一个HashTable，它的每一个元素都是一个zval*类型的变量。不仅如此，保存用户定义的函数、类、资源等的容器都是以HashTable的形式在内核中实现的。</p><p>下面分别来看在PHP、内核中如何定义数组。</p><p>PHP中定义数组：</p><pre><code>&lt;?php      $array = array();      $array[&quot;key&quot;] = &quot;values&quot;;  ?&gt;  </code></pre><p>在内核中使用宏来实现：</p><pre><code>zval* array;  array_init(array);  add_assoc_string(array, &quot;key&quot;, &quot;value&quot;, 1);  </code></pre><p>将上述代码中的宏展开：</p><pre><code>zval* array;        ALLOC_INIT_ZVAL(array);        Z_TYPE_P(array) = IS_ARRAY;        HashTable *h;        ALLOC_HASHTABLE(h);        Z_ARRVAL_P(array)=h;        zend_hash_init(h, 50, NULL,ZVAL_PTR_DTOR, 0);        zval* barZval;        MAKE_STD_ZVAL(barZval);        ZVAL_STRING(barZval, &quot;value&quot;, 0);        zend_hash_add(h, &quot;key&quot;, 4, &amp;barZval, sizeof(zval*), NULL);  </code></pre><p>内核为我们提供了方便的宏来管理数组。</p><pre><code>//add_assoc_*系列函数：  add_assoc_null(zval *aval, char *key);  add_assoc_bool(zval *aval, char *key, zend_bool bval);  add_assoc_long(zval *aval, char *key, long lval);  add_assoc_double(zval *aval, char *key, double dval);  add_assoc_string(zval *aval, char *key, char *strval, int dup);  add_assoc_stringl(zval *aval, char *key,char *strval, uint strlen, int dup);  add_assoc_zval(zval *aval, char *key, zval *value);  //备注：其实这些函数都是宏，都是对add_assoc_*_ex函数的封装。  //add_index_*系列函数：  ZEND_API int add_index_long     (zval *arg, ulong idx, long n);  ZEND_API int add_index_null     (zval *arg, ulong idx           );  ZEND_API int add_index_bool     (zval *arg, ulong idx, int b    );  ZEND_API int add_index_resource (zval *arg, ulong idx, int r    );  ZEND_API int add_index_double   (zval *arg, ulong idx, double d);  ZEND_API int add_index_string   (zval *arg, ulong idx, const char *str, int duplicate);  ZEND_API int add_index_stringl  (zval *arg, ulong idx, const char *str, uint length, int duplicate);  ZEND_API int add_index_zval     (zval *arg, ulong index, zval *value);  //add_next_index_*函数：  ZEND_API int add_next_index_long        (zval *arg, long n  );  ZEND_API int add_next_index_null        (zval *arg          );  ZEND_API int add_next_index_bool        (zval *arg, int b   );  ZEND_API int add_next_index_resource    (zval *arg, int r   );  ZEND_API int add_next_index_double      (zval *arg, double d);  ZEND_API int add_next_index_string      (zval *arg, const char *str, int duplicate);  ZEND_API int add_next_index_stringl     (zval *arg, const char *str, uint length, int duplicate);  ZEND_API int add_next_index_zval        (zval *arg, zval *value);  add_next_index_*()PHP中        内核中  $arr[] = NULL;  add_next_index_null(arr);  $arr[] = 42;    add_next_index_long(arr, 42);  $arr[] = true;  add_next_index_bool(arr, 1);  $arr[] = 3.14;  add_next_index_double(arr, 3.14);  $arr[] = &apos;foo&apos;; add_next_index_string(arr, &quot;foo&quot;);  $arr[] = $var;  add_next_index_zval(arr, zval);  add_index_*()PHP中            内核中  $arr[0] = NULL; add_index_null(arr, 0);  $arr[1] = 42;       add_index_long(arr, 1, 42);  $arr[2] = true;     add_index_bool(arr, 2, 1);  $arr[3] = 3.14;     add_index_double(arr, 3, 3.14);  $arr[4] = &apos;foo&apos;;        add_index_string(arr, 4, &quot;foo&quot;, 1);  $arr[5] = $var;     add_index_zval(arr, 5, zval);  add_assoc_*()$arr[&quot;abc&quot;] = NULL; add_assoc_null(arr, &quot;abc&quot;);  $arr[&quot;def&quot;] = 42;   add_assoc_long(arr, &quot;def&quot;, 42);  $arr[&quot;ghi&quot;] = true; add_assoc_bool(arr, &quot;ghi&quot;, 1);  $arr[&quot;jkl&quot;]  = 3.14 add_assoc_double(arr, &quot;jkl&quot;, 3.14);  $arr[&quot;mno&quot;]=&quot;foo&quot;   add_assoc_string(arr, &quot;mno&quot;, &quot;foo&quot;, 1&quot;);  $arr[&quot;pqr&quot;] = $var; add_assoc_zval(arr, &quot;pqr&quot;, zval);  </code></pre><p>下面在PHP中定义一个函数，并在其中使用数组。然后来看在内核中如何实现。</p><pre><code>&lt;?php  function array_test(){      $mystr = &quot;Forty Five&quot;;      $return_value = array();      $return_value[42] = 123;      $return_value[] = &quot;test&quot;;      $return_value[] = $mystr;      $return_value[&quot;double&quot;] = 3.14;      $mysubarray;      $mysubarray = array();      $mysubarray[] = &quot;hello&quot;;      $return_value[&quot;subarray&quot;] = $mysubarray;      return $return_value;  }  ?&gt;  </code></pre><p>内核中实现：</p><pre><code>PHP_FUNCTION(array_test){      char* mystr;      zval* mysubarray;      array_init(return_value);      add_index_long(return_value, 42, 123);      add_next_index_string(return_value, &quot;test&quot;, 1);      add_next_index_stringl(return_value, &quot;test_stringl&quot;, 10, 1);      mystr = estrdup(&quot;Forty Five&quot;);      add_next_index_string(return_value, mystr, 0);      add_assoc_double(return_value, &quot;double&quot;, 3.14);      ALLOC_INIT_ZVAL(mysubarray);      array_init(mysubarray);      add_next_index_string(mysubarray, &quot;hello&quot;, 1);      add_assoc_zval(return_value, &quot;subarray&quot;, mysubarray);  }  </code></pre><p>你可能会疑问上面代码中的变量return_value在哪里定义的。下面将PHP_FUNCTION展开，你就明白了。</p><pre><code>zif_array_test(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used TSRMLS_DC);</code></pre><p>没错，实际上每个函数都有一个默认的返回值return_value。在使用RETVAL_<em>()、RETURN_</em>()作为函数返回值时，仅仅是修改return_value。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53-数组操作</title>
      <link href="/posts/6c2b7213.html"/>
      <url>/posts/6c2b7213.html</url>
      
        <content type="html"><![CDATA[<h1 id="53-数组操作"><a href="#53-数组操作" class="headerlink" title="53-数组操作"></a>53-数组操作</h1><p>当你在扩展中使用HashTable时候，95%是要存储用户端的变量，就像PHP语言中数组那样。为此，内核中已经准备好了相应的工具，来让我们更加的方便的操作HashTable存储zval*，也就是PHP语言中的数组，即IS_ARRAY常量代表的zval，以下用{数组}来代替PHP语言中的数组这个词。</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>创建HashTable有些繁琐，虽然有辅助的宏但还是不能一步完成，而创建数组便简单多了，直接使用array_init(zval <em>arrval)函数即可，注意它的参数是zval</em>类型的！这样，我们像用户端返回数组便简单多了：</p><pre><code>ZEND_FUNCTION(sample_array){    array_init(return_value);}//return_value是zval*类型的，所以我们直接对它调用array_init()函数即可，即把它初始化成了一个空数组。</code></pre><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>将数组初始化后，接下来就要向其添加元素了。因为PHP语言中有多种类型的变量，所以也对应的有多种类型的add_assoc_<em>()、add_index_</em>、add_next_index_*()函数。如：</p><pre><code>array_init(arrval);add_assoc_long(zval *arrval, char *key, long lval);add_index_long(zval *arrval, ulong idx, long lval);add_next_index_long(zval *arrval, long lval);</code></pre><p>这三个函数的第一个参数都要被操作的{数组}指针，然后是索引值，最后是变量，唯一不同的是add_next_index_long()函数的索引值是其自己计算出来的。根据上一节的内容我们可以知道，这三个函数分别在内部使用了zend_hash_update()、zend_hash_index_update()与zend_hash_next_index_insert函数。</p><pre><code>//add_assoc_*系列函数：add_assoc_null(zval *aval, char *key);add_assoc_bool(zval *aval, char *key, zend_bool bval);add_assoc_long(zval *aval, char *key, long lval);add_assoc_double(zval *aval, char *key, double dval);add_assoc_string(zval *aval, char *key, char *strval, int dup);add_assoc_stringl(zval *aval, char *key,char *strval, uint strlen, int dup);add_assoc_zval(zval *aval, char *key, zval *value);//备注：其实这些函数都是宏，都是对add_assoc_*_ex函数的封装。//add_index_*系列函数：ZEND_API int add_index_long        (zval *arg, ulong idx, long n);ZEND_API int add_index_null        (zval *arg, ulong idx            );ZEND_API int add_index_bool        (zval *arg, ulong idx, int b    );ZEND_API int add_index_resource    (zval *arg, ulong idx, int r    );ZEND_API int add_index_double    (zval *arg, ulong idx, double d);ZEND_API int add_index_string    (zval *arg, ulong idx, const char *str, int duplicate);ZEND_API int add_index_stringl    (zval *arg, ulong idx, const char *str, uint length, int duplicate);ZEND_API int add_index_zval        (zval *arg, ulong index, zval *value);//add_next_index_long函数：ZEND_API int add_next_index_long        (zval *arg, long n    );ZEND_API int add_next_index_null        (zval *arg            );ZEND_API int add_next_index_bool        (zval *arg, int b    );ZEND_API int add_next_index_resource    (zval *arg, int r    );ZEND_API int add_next_index_double        (zval *arg, double d);ZEND_API int add_next_index_string        (zval *arg, const char *str, int duplicate);ZEND_API int add_next_index_stringl        (zval *arg, const char *str, uint length, int duplicate);ZEND_API int add_next_index_zval        (zval *arg, zval *value);</code></pre><p>每组函数最后的一个，即zend…_zval()函数，允许我们像这个{数组}中添加资源、对象、{数组}等复合类型的PHP变量。下面让我们通过一个例子来演示下它们的用法：</p><pre><code>ZEND_FUNCTION(sample_array){    zval *subarray;    array_init(return_value);    /* Add some scalars */    add_assoc_long(return_value, &quot;life&quot;, 42);    add_index_bool(return_value, 123, 1);    add_next_index_double(return_value, 3.1415926535);    /* Toss in a static string, dup&apos;d by PHP */    add_next_index_string(return_value, &quot;Foo&quot;, 1);    /* Now a manually dup&apos;d string */    add_next_index_string(return_value, estrdup(&quot;Bar&quot;), 0);    /* Create a subarray */    MAKE_STD_ZVAL(subarray);    array_init(subarray);    /* Populate it with some numbers */    add_next_index_long(subarray, 1);    add_next_index_long(subarray, 20);    add_next_index_long(subarray, 300);    /* Place the subarray in the parent */    add_index_zval(return_value, 444, subarray);}</code></pre><p>这时如果我们用户端var_dump这个函数的返回值便会得到：</p><pre><code>&lt;?phpvar_dump(sample_array());?&gt;</code></pre><p>输出：</p><pre><code>array(6){    [&quot;life&quot;]=&gt; int(42)    [123]=&gt; bool(true)    [124]=&gt; float(3.1415926535)    [125]=&gt; string(3) &quot;Foo&quot;    [126]=&gt; string(3) &quot;Bar&quot;    [444]=&gt; array(3)    {        [0]=&gt; int(1)        [1]=&gt; int(20)        [2]=&gt; int(300)    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>52-使用哈希表API</title>
      <link href="/posts/472cce10.html"/>
      <url>/posts/472cce10.html</url>
      
        <content type="html"><![CDATA[<h1 id="52-使用哈希表API"><a href="#52-使用哈希表API" class="headerlink" title="52-使用哈希表API"></a>52-使用哈希表API</h1><p>Zend把与HashTable有关的API分成了好几类以便于我们寻找，这些API的返回值大多都是常量SUCCESS或者FAILURE。</p><h2 id="创建HashTable"><a href="#创建HashTable" class="headerlink" title="创建HashTable"></a>创建HashTable</h2><p>下面在介绍函数原型的时候都使用了ht名称，但是我们在编写扩展的时候，一定不要使用这个名称，因为一些PHP宏展开后会声明这个名称的变量，进而引发命名冲突。</p><p>创建并初始化一个HashTable非常简单，只要使用zend_hash_init函数即可，它的定义如下：</p><pre><code>int zend_hash_init(    HashTable *ht,    uint nSize,    hash_func_t pHashFunction,    dtor_func_t pDestructor,    zend_bool persistent);</code></pre><p>*ht是指针，指向一个HashTable，我们即可以&amp;一个已存在的HashTable变量，也可以通过emalloc()、pemalloc()等函数来直接申请一块内存，不过最常用的方法还是用ALLOC_HASHTABLE(ht)宏来让内核自动的替我们完成这项工作。ALLOC_HASHTABLE(ht)所做的工作相当于ht = emalloc(sizeof(HashTable));</p><p>nSize代表着这个HashTable可以拥有的元素的最大数量(HashTable能够包含任意数量的元素，这个值只是为了提前申请好内存，提高性能，省的不停的进行rehash操作)。在我们添加新的元素时，这个值会根据情况决定是否自动增长，有趣的是，这个值永远都是2的次方，如果你给它的值不是一个2的次方的形式，那它将自动调整成大于它的最小的2的次方值。它的计算方法就像这样：nSize = pow(2, ceil(log(nSize, 2)));</p><p>pHashFunction是早期的Zend Engine中的一个参数，为了兼容没有去掉它，但它已经没有用处了，所以我们直接赋成NULL就可以了。在原来，它其实是一个钩子，用来让用户自己hook一个散列函数，替换php默认的DJBX33A算法实现。</p><p>pDestructor也代表着一个回调函数，当我们删除或者修改HashTable中其中一个元素时候便会调用，它的函数原型必须是这样的：void method_name(void <em>pElement);这里的</em>pElement是一个指针，指向HashTable中那么将要被删除或者修改的那个数据，而数据的类型往往也是个指针。</p><p>persistent是最后一个参数，它的含义非常简单。如果它为true，那么这个HashTable将永远存在于内存中，而不会在RSHUTDOWN阶段自动被注销掉。此时第一个参数ht所指向的地址必须是通过pemalloc()函数申请的。</p><p>举个例子，PHP内核在每个Request请求的头部都调用了这个函数来初始化symbol_table。</p><pre><code>zend_hash_init(&amp;EG(symbol_table), 50, NULL, ZVAL_PTR_DTOR, 0);//#define ZVAL_PTR_DTOR (void (*)(void *)) zval_ptr_dtor_wrapper</code></pre><p>因为50不是2的整数幂形式，所以它会在函数执行时被调成成64。</p><h2 id="添加与修改"><a href="#添加与修改" class="headerlink" title="添加与修改"></a>添加与修改</h2><p>我们有四个常用的函数来完成这项操作，它们的原型分别如下：</p><pre><code>int zend_hash_add(    HashTable *ht,        //待操作的ht    char *arKey,            //索引，如&quot;my_key&quot;    uint nKeyLen,        //字符串索引的长度，如6    void **pData,        //要插入的数据，注意它是void **类型的。int *p,i=1;p=&amp;i,pData=&amp;p;。    uint nDataSize,    void *pDest            //如果操作成功，则pDest=*pData;);int zend_hash_update(    HashTable *ht,    char *arKey,    uint nKeyLen,    void *pData,    uint nDataSize,    void **pDest);int zend_hash_index_update(    HashTable *ht,    ulong h,    void *pData,    uint nDataSize,    void **pDest);int zend_hash_next_index_insert(    HashTable *ht,    void *pData,    uint nDataSize,    void **pDest);</code></pre><p>前两个函数用户添加带字符串索引的数据到HashTable中，就像我们在PHP中使用的那样:$foo[‘bar’] = ‘baz’;用C来完成便是：</p><pre><code>zend_hash_add(fooHashTbl, &quot;bar&quot;, sizeof(&quot;bar&quot;), &amp;barZval, sizeof(zval*), NULL);</code></pre><p>zend_hash_add()和zend_hash_update()唯一的区别就是如果这个key已经存在了，那么zend_hash_add()将返回FAILURE，而不会修改原有数据。</p><p>接下来的两个函数用于像HT中添加数字索引的数据，zend_hash_next_index_insert()函数则不需要索引值参数，而是自己直接计算出下一个数字索引值。</p><p>但是如果我们想获取下一个元素的数字索引值，也是有办法的，可以使用zend_hash_next_free_element()函数：</p><pre><code>ulong nextid = zend_hash_next_free_element(ht);zend_hash_index_update(ht, nextid, &amp;data, sizeof(data), NULL);</code></pre><p>所有这些函数中，如果pDest不为NULL，内核便会修改其值为被操作的那个元素的地址。在下面的代码中这个参数也有同样的功能。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>因为HashTable中有两种类型的索引值，所以需要两个函数来执行find操作。</p><pre><code>int zend_hash_find(HashTable *ht, char *arKey, uint nKeyLength,void **pData);int zend_hash_index_find(HashTable *ht, ulong h, void **pData);</code></pre><p>第一种就是我们处理PHP语言中字符串索引数组时使用的，第二种是我们处理PHP语言中数字索引数组使用的。</p><pre><code>void hash_sample(HashTable *ht, sample_data *data1){    sample_data *data2;    ulong targetID = zend_hash_next_free_element(ht);    if (zend_hash_index_update(ht, targetID,            data1, sizeof(sample_data), NULL) == FAILURE) {            /* Should never happen */            return;    }    if(zend_hash_index_find(ht, targetID, (void **)&amp;data2) == FAILURE) {        /* Very unlikely since we just added this element */        return;    }    /* data1 != data2, however *data1 == *data2 */}</code></pre><p>除了读取，我们还需要检测某个key是否存在：</p><pre><code>int zend_hash_exists(HashTable *ht, char *arKey, uint nKeyLen);int zend_hash_index_exists(HashTable *ht, ulong h);</code></pre><p>这两个函数返回SUCCESS或者FAILURE，分别代表着是否存在：</p><pre><code>if( zend_hash_exists(EG(active_symbol_table),&quot;foo&quot;, sizeof(&quot;foo&quot;)) == SUCCESS ){    /* $foo is set */}else{    /* $foo does not exist */}</code></pre><h2 id="提速"><a href="#提速" class="headerlink" title="提速"></a>提速</h2><pre><code>ulong zend_get_hash_value(char *arKey, uint nKeyLen);</code></pre><p>当我们需要对同一个字符串的key进行许多操作时候，比如先检测又没，然后插入，然后修改等等，这时我们便可以使用zend_get_hash_value函数来对我们的操作进行加速！这个函数的返回值可以和quick系列函数使用，达到加速的目的(就是不再重复计算这个字符串的散列值，而直接使用已准备好的)！</p><pre><code>int zend_hash_quick_add(    HashTable *ht,    char *arKey,    uint nKeyLen,    ulong hashval,    void *pData,    uint nDataSize,    void **pDest);int zend_hash_quick_update(    HashTable *ht,    char *arKey,    uint nKeyLen,    ulong hashval,    void *pData,    uint nDataSize,    void **pDest);int zend_hash_quick_find(    HashTable *ht,    char *arKey,    uint nKeyLen,    ulong hashval,    void **pData);int zend_hash_quick_exists(    HashTable *ht,    char *arKey,    uint nKeyLen,    ulong hashval);</code></pre><p>虽然很意外，但你还是要接受没有zend_hash_quick_del()这个函数呢。quick类函数会在下面这种场合中用到：</p><pre><code>void php_sample_hash_copy(HashTable *hta, HashTable *htb,char *arKey, uint nKeyLen TSRMLS_DC){    ulong hashval = zend_get_hash_value(arKey, nKeyLen);    zval **copyval;    if (zend_hash_quick_find(hta, arKey, nKeyLen,hashval, (void**)©val) == FAILURE)    {        //标明不存在这个索引        return;    }    //这个zval已经被其它的Hashtable使用了，这里我们进行引用计数操作。    (*copyval)-&gt;refcount__gc++;    zend_hash_quick_update(htb, arKey, nKeyLen, hashval,copyval, sizeof(zval*), NULL);}</code></pre><h2 id="复制与合并"><a href="#复制与合并" class="headerlink" title="复制与合并"></a>复制与合并</h2><p>在PHP语言中，我们经常需要进行数组间的Copy与Merge操作，所以php语言中的数组在C语言中的实现HashTable也肯定会经常碰到这种情况。为了简化这一类操作，内核中早已准备好了相应的API供我们使用。</p><pre><code>void zend_hash_copy(    HashTable *target,    HashTable *source,    copy_ctor_func_t pCopyConstructor,    void *tmp,    uint size);</code></pre><ul><li><em>source中的所有元素都会通过pCopyConstructor函数Copy到</em>target中去，我们还是以PHP语言中的数组举例，pCopyConstructor这个hook使得我们可以在copy变量的时候对他们的ref_count进行加一操作。target中原有的与source中索引位置的数据会被替换掉，而其它的元素则会被保留，原封不动。</li><li>tmp参数是为了兼容PHP4.0.3以前版本的，现在赋值为NULL即可。</li><li><p>size参数代表每个元素的大小，对于PHP语言中的数组来说，这里的便是sizeof(zval*)了。</p><p>void zend_hash_merge(</p><pre><code>HashTable *target,HashTable *source,copy_ctor_func_t pCopyConstructor,void *tmp,uint size,int overwrite</code></pre><p>);</p></li></ul><p>zend_hash_merge()与zend_hash_copy唯一的不同便是多了个int类型的overwrite参数，当其值非0的时候，两个函数的工作是完全一样的；如果overwrite参数为0，则zend_hash_merge函数就不会对target中已有索引的值进行替换了。</p><pre><code>typedef zend_bool (*merge_checker_func_t)(HashTable *target_ht,void *source_data, zend_hash_key *hash_key, void *pParam);void zend_hash_merge_ex(    HashTable *target,    HashTable *source,    copy_ctor_func_t pCopyConstructor,    uint size,    merge_checker_func_t pMergeSource,    void *pParam);</code></pre><p>这个函数又繁琐了些，与zend_hash_copy相比，其多了两个参数，多出来的pMergeSoure回调函数允许我们选择性的进行merge，而不是全都merge。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>在PHP语言中，我们有很多方法来遍历一个数组，对于数组的本质HashTable，我们也有很多办法来对其进行遍历操作。首先最简单的一种办法便是使用一种与PHP语言中forech语句功能类似的函数——zend_hash_apply，它接收一个回调函数，并将HashTable的每一个元素都传递给它。</p><pre><code>typedef int (*apply_func_t)(void *pDest TSRMLS_DC);void zend_hash_apply(HashTable *ht,apply_func_t apply_func TSRMLS_DC);</code></pre><p>下面是另外一种遍历函数：</p><pre><code>typedef int (*apply_func_arg_t)(void *pDest,void *argument TSRMLS_DC);void zend_hash_apply_with_argument(HashTable *ht,apply_func_arg_t apply_func, void *data TSRMLS_DC);</code></pre><p>通过上面的函数可以在执行遍历时向回调函数传递任意数量的值，这在一些diy操作中非常有用。</p><p>上述函数对传给它们的回调函数的返回值有一个共同的约定，详细介绍下下表：</p><p>回调函数的返回值</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">ZEND_HASH_APPLY_KEEP</td><td style="text-align:left">结束当前请求，进入下一个循环。与PHP语言forech语句中的一次循环执行完毕或者遇到continue关键字的作用一样。</td></tr><tr><td style="text-align:left">ZEND_HASH_APPLY_STOP</td><td style="text-align:left">跳出，与PHP语言forech语句中的break关键字的作用一样。</td></tr><tr><td style="text-align:left">ZEND_HASH_APPLY_REMOVE</td><td style="text-align:left">删除当前的元素，然后继续处理下一个。相当于在PHP语言中：unset($foo[$key]);continue;</td></tr></tbody></table><p>我们来一下PHP语言中的forech循环：</p><pre><code>&lt;?phpforeach($arr as $val) {    echo &quot;The value is: $val\n&quot;;}?&gt;</code></pre><p>那我们的回调函数在C语言中应该这样写：</p><pre><code>int php_sample_print_zval(zval **val TSRMLS_DC){    //重新copy一个zval，防止破坏原数据    zval tmpcopy = **val;    zval_copy_ctor(&amp;tmpcopy);    //转换为字符串    INIT_PZVAL(&amp;tmpcopy);    convert_to_string(&amp;tmpcopy);       //开始输出    php_printf(&quot;The value is: &quot;);    PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));    php_printf(&quot;\n&quot;);    //毁尸灭迹    zval_dtor(&amp;tmpcopy);       //返回，继续遍历下一个～    return ZEND_HASH_APPLY_KEEP;}</code></pre><p>遍历我们的HashTable：</p><pre><code>//生成一个名为arrht、元素为zval*类型的HashTablezend_hash_apply(arrht, php_sample_print_zval TSRMLS_CC);</code></pre><p>保存在HashTable中的元素并不是真正的最终变量，而是指向它的一个指针。我们的上面的遍历函数接收的是一个zval**类型的参数。</p><pre><code>typedef int (*apply_func_args_t)(void *pDest,int num_args, va_list args, zend_hash_key *hash_key);void zend_hash_apply_with_arguments(HashTable *ht,apply_func_args_t apply_func, int numargs, ...);</code></pre><p>为了能在遍历时同时接收索引的值，我们必须使用第三种形式的zend_hash_apply！就像PHP语言中这样的功能：</p><pre><code>&lt;?phpforeach($arr as $key =&gt; $val){    echo &quot;The value of $key is: $val\n&quot;;}?&gt;</code></pre><p>为了配合zend_hash_apply_with_arguments()函数，我们需要对我们的遍历执行函数做一下小小的改动，使其接受索引作为一个参数：</p><pre><code>int php_sample_print_zval_and_key(zval **val,int num_args,va_list args,zend_hash_key *hash_key){    //重新copy一个zval，防止破坏原数据    zval tmpcopy = **val;    /* tsrm_ls is needed by output functions */    TSRMLS_FETCH();    zval_copy_ctor(&amp;tmpcopy);    INIT_PZVAL(&amp;tmpcopy);    //转换为字符串    convert_to_string(&amp;tmpcopy);    //执行输出    php_printf(&quot;The value of &quot;);    if (hash_key-&gt;nKeyLength)    {        //如果是字符串类型的key        PHPWRITE(hash_key-&gt;arKey, hash_key-&gt;nKeyLength);    }    else    {        //如果是数字类型的key        php_printf(&quot;%ld&quot;, hash_key-&gt;h);    }    php_printf(&quot; is: &quot;);    PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));    php_printf(&quot;\n&quot;);    //毁尸灭迹    zval_dtor(&amp;tmpcopy);    /* continue; */    return ZEND_HASH_APPLY_KEEP;}</code></pre><p>执行遍历：</p><pre><code>zend_hash_apply_with_arguments(arrht,php_sample_print_zval_and_key, 0);</code></pre><p>这个函数通过C语言中的可变参数特性来接收参数。This particular example required no arguments to be passed; for information on extracting variable argument lists from va_list args, see the POSIX documentation pages for va_start(), va_arg(), and va_end().</p><p>当我们检查这个hash_key是字符串类型还是数字类型时，是通过nKeyLength属性来检测的,而不是arKey属性。这是因为内核有时候会留在arKey属性里些脏数据，但nKeyLength属性是安全的，可以安全的使用。甚至对于空字符串索引，它也照样能处理。比如：$foo[‘’] =”Bar”;索引的值是NULL字符，但它的长度却是包括最后这个NULL字符的，所以为1。</p><h2 id="向前遍历HashTable"><a href="#向前遍历HashTable" class="headerlink" title="向前遍历HashTable"></a>向前遍历HashTable</h2><p>有时我们希望不用回调函数也能遍历一个数组的数据，为了实现这个功能，内核特意的为每个HashTable加了个属性：The internal pointer（内部指针）。我们还是以PHP语言中的数组举例，有以下函数来处理它所对应的那个HashTable的内部指针：reset(), key(), current(), next(), prev(), each(), and end()。</p><pre><code>&lt;?php    $arr = array(&apos;a&apos;=&gt;1, &apos;b&apos;=&gt;2, &apos;c&apos;=&gt;3);    reset($arr);    while (list($key, $val) = each($arr)) {        /* Do something with $key and $val */    }    reset($arr);    $firstkey = key($arr);    $firstval = current($arr);    $bval = next($arr);    $cval = next($arr);?&gt;</code></pre><p>ZEND内核中有一组操作HashTable的功能与以上函数功能类似的函数：</p><pre><code>/* reset() */void zend_hash_internal_pointer_reset(HashTable *ht);/* key() */int zend_hash_get_current_key(HashTable *ht,char **strIdx, unit *strIdxLen,ulong *numIdx, zend_bool duplicate);/* current() */int zend_hash_get_current_data(HashTable *ht, void **pData);/* next()/each() */int zend_hash_move_forward(HashTable *ht);/* prev() */int zend_hash_move_backwards(HashTable *ht);/* end() */void zend_hash_internal_pointer_end(HashTable *ht);/* 其他的...... */int zend_hash_get_current_key_type(HashTable *ht);int zend_hash_has_more_elements(HashTable *ht);</code></pre><p>PHP语言中的next()、prev()、end()函数在移动完指针之后，都通过调用zend_hash_get_current_data()函数来获取当前所指的元素并返回。而each()虽然和next()很像，却是使用zend_hash_get_current_key()函数的返回值来作为它的返回值。</p><p>现在我们用另外一种方法来实现上面的forech：</p><pre><code>void php_sample_print_var_hash(HashTable *arrht){    for(        zend_hash_internal_pointer_reset(arrht);        zend_hash_has_more_elements(arrht) == SUCCESS;        zend_hash_move_forward(arrht))    {        char *key;        uint keylen;        ulong idx;        int type;        zval **ppzval, tmpcopy;        type = zend_hash_get_current_key_ex(arrht, &amp;key, &amp;keylen,&amp;idx, 0, NULL);        if (zend_hash_get_current_data(arrht, (void**)&amp;ppzval) == FAILURE)        {            /* Should never actually fail             * since the key is known to exist. */            continue;        }        //重新copy一个zval，防止破坏原数据        tmpcopy = **ppzval;        zval_copy_ctor(&amp;tmpcopy);        INIT_PZVAL(&amp;tmpcopy);        convert_to_string(&amp;tmpcopy);        /* Output */        php_printf(&quot;The value of &quot;);        if (type == HASH_KEY_IS_STRING)        {            /* String Key / Associative */            PHPWRITE(key, keylen);        } else {            /* Numeric Key */            php_printf(&quot;%ld&quot;, idx);        }        php_printf(&quot; is: &quot;);        PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));        php_printf(&quot;\n&quot;);        /* Toss out old copy */        zval_dtor(&amp;tmpcopy);    }}</code></pre><p>上面的代码你应该都能看懂了，唯一还没接触到的可能是zend_hash_get_current_key()函数的返回值。</p><p>在我们遍历一个HashTable时，一般是很难陷入死循环的。</p><pre><code>void php_sample_print_var_hash(HashTable *arrht){    HashPosition pos;    for(zend_hash_internal_pointer_reset_ex(arrht, &amp;pos);    zend_hash_has_more_elements_ex(arrht, &amp;pos) == SUCCESS;    zend_hash_move_forward_ex(arrht, &amp;pos)) {        char *key;        uint keylen;        ulong idx;        int type;        zval **ppzval, tmpcopy;        type = zend_hash_get_current_key_ex(arrht,                                &amp;key, &amp;keylen,                                &amp;idx, 0, &amp;pos);        if (zend_hash_get_current_data_ex(arrht,                    (void**)&amp;ppzval, &amp;pos) == FAILURE) {            /* Should never actually fail             * since the key is known to exist. */            continue;        }        /* Duplicate the zval so that         * the original&apos;s contents are not destroyed */        tmpcopy = **ppzval;        zval_copy_ctor(&amp;tmpcopy);        /* Reset refcount &amp; Convert */        INIT_PZVAL(&amp;tmpcopy);        convert_to_string(&amp;tmpcopy);        /* Output */        php_printf(&quot;The value of &quot;);        if (type == HASH_KEY_IS_STRING) {            /* String Key / Associative */            PHPWRITE(key, keylen);        } else {            /* Numeric Key */            php_printf(&quot;%ld&quot;, idx);        }        php_printf(&quot; is: &quot;);        PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));        php_printf(&quot;\n&quot;);        /* Toss out old copy */        zval_dtor(&amp;tmpcopy);    }}&lt;p&gt;With these very slight additions, the HashTable&apos;s true internal pointer is preserved in whatever state it was initially in on entering the function. When it comes to working with internal pointers of userspace variable HashTables (that is, arrays), this extra step will very likely make the difference between whether the scripter&apos;s code works as expected.&lt;/p&gt;&lt;h3&gt;删除&lt;/h3&gt;&lt;p&gt;内核中一共预置了四个删除HashTable元素的函数，头两个是用户删除某个确定索引的数据：&lt;/p&gt;&lt;code c&gt;int zend_hash_del(HashTable *ht, char *arKey, uint nKeyLen);int zend_hash_index_del(HashTable *ht, ulong h);</code></pre><p>它们两个分别用来删除字符串索引和数字索引的数据，操作完成后都返回SUCCESS或者FAILURE表示成功or失败。回顾一下最上面的叙述，当一个元素被删除时，会激活HashTable的destructor回调函数。</p><pre><code>void zend_hash_clean(HashTable *ht);void zend_hash_destroy(HashTable *ht);</code></pre><p>前者用于将HashTable中的元素全部删除，而后者是将这个HashTable自身也毁灭掉。</p><p>现在让我们来完整的回顾一下HashTable的创建、添加、删除操作。</p><pre><code>int sample_strvec_handler(int argc, char **argv TSRMLS_DC){    HashTable *ht;    //分配内存    ALLOC_HASHTABLE(ht);    //初始化    if (zend_hash_init(ht, argc, NULL,ZVAL_PTR_DTOR, 0) == FAILURE) {        FREE_HASHTABLE(ht);        return FAILURE;    }    //填充数据    while (argc) {        zval *value;        MAKE_STD_ZVAL(value);        ZVAL_STRING(value, argv[argc], 1);        argv++;        if (zend_hash_next_index_insert(ht, (void**)&amp;value,                            sizeof(zval*)) == FAILURE) {            /* Silently skip failed additions */            zval_ptr_dtor(&amp;value);        }    }    //完成工作    process_hashtable(ht);    //毁尸灭迹    zend_hash_destroy(ht);    //释放ht 为什么不在destroy里free呢，求解释！    FREE_HASHTABLE(ht);    return SUCCESS;}</code></pre><p>排序、比较</p><p>针对HashTable操作的Zend Api中有很多都需要回调函数。首先让我们来处理一下对HashTable中元素大小比较的问题：</p><pre><code>typedef int (*compare_func_t)(void *a, void *b TSRMLS_DC);</code></pre><p>这很像PHP语言中usort函数需要的函数，它将比较两个值<em>a与</em>b，如果<em>a&gt;</em>b,则返回1，相等则返回0，否则返回-1。下面是zend_hash_minmax函数的声明，它就需要我们上面声明的那个类型的函数作为回调函数： int zend_hash_minmax(HashTable *ht, compare_func_t compar,int flag, void **pData TSRMLS_DC); 这个函数的功能我们从它的名称中便能肯定，它用来比较HashTable中的元素大小。如果flag==0则返回最小值，否则返回最大值！</p><p>下面让我们来利用这个函数来对用户端定义的所有函数根据函数名找到最大值与最小值(大小写不敏感～)。</p><pre><code>//先定义一个比较函数，作为zend_hash_minmax的回调函数。int fname_compare(zend_function *a, zend_function *b TSRMLS_DC){    return strcasecmp(a-&gt;common.function_name, b-&gt;common.function_name);}void php_sample_funcname_sort(TSRMLS_D){    zend_function *fe;    if (zend_hash_minmax(EG(function_table), fname_compare,0, (void **)&amp;fe) == SUCCESS)    {        php_printf(&quot;Min function: %s\n&quot;, fe-&gt;common.function_name);    }    if (zend_hash_minmax(EG(function_table), fname_compare,1, (void **)&amp;fe) == SUCCESS)    {        php_printf(&quot;Max function: %s\n&quot;, fe-&gt;common.function_name);    }}</code></pre><p>zend_hash_compare()也许要回调函数，它的功能是将HashTable看作一个整体与另一个HashTable做比较，如果前者大于后者返回1，相等返回0，否则返回-1。</p><pre><code>int zend_hash_compare(HashTable *hta, HashTable *htb,compare_func_t compar, zend_bool ordered TSRMLS_DC);</code></pre><p>默认情况下它往往是先判断各个HashTable元素的个数，个数多的最大！ 如果两者的元素一样多，然后就比较它们各自的第一个元素。另外一个重要的需要回调函数的API便是排序函数，它需要的回调函数形式是这样的：</p><pre><code>typedef void (*sort_func_t)(void **Buckets, size_t numBuckets,size_t sizBucket, compare_func_t comp TSRMLS_DC);</code></pre><p>最后一个参数如果为处，则会抛弃HashTable中原有的索引-键关系，将对排列号的新值赋予新的数字键值。PHP语言中的sort函数实现如下：</p><pre><code>zend_hash_sort(target_hash, zend_qsort,array_data_compare, 1 TSRMLS_CC);</code></pre><p>array_data_compare是一个返回compare_func_t类型数据的函数，它将按照HashTable中zval*值的大小进行排序。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51-数组与链表</title>
      <link href="/posts/3f1e38db.html"/>
      <url>/posts/3f1e38db.html</url>
      
        <content type="html"><![CDATA[<h1 id="51-数组与链表"><a href="#51-数组与链表" class="headerlink" title="51-数组与链表"></a>51-数组与链表</h1><p>在C语言中，我们可以自定义各种各样的数据结构，用来把很多数据保存在一个变量里面，但是每种数据结构都有自己的优缺点，PHP内核规模如此庞大，是否已经找到了一些非常棒的解决方法呢？</p><p>我们在选择各种数据结构时，往往会考虑我们需要处理的数据规模以及需要的性能。下面让我们简要的看一下看C语言中数组和链表的一些事情。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>作者这里用的不是Array，而是Vector，可能指的是C++里的Vector，它与数组几乎是完全一样的，唯一的不同便是可以实现动态存储。本节下文都是用数组一词代替之，请各位注意。数组是内存中一块连续的区域，其每一个元素都具有一个唯一的下标值。</p><pre><code>int a[3];a[0]=1;a[2]=3;</code></pre><p>不仅是整数，其它类型的变量也可以保存在数组中，比如我们前面用到的zend_get_parameters_array_ex()，便把很多zval**类型的变量保存到一个数组里，为了使其正常工作，我们提前向系统申请了相应大小的内存空间。</p><pre><code>zval ***args = safe_emalloc(ZEND_NUM_ARGS(), sizeof(zval**), 0);</code></pre><p>这里我们仍然可以用一个整数来当作下标去数组中取出我们想要的数据，就像var_dump()的实现中通过args[i]来获取参数并把它传递给php_var_dump()函数那样。</p><p>使用数组最大的好处便是速度！读写都可以在O(1)内完成，因为它每个元素的大小都是一致的，只要知道下标，便可以瞬间计算出其对应的元素在内存中的位置，从而直接取出或者写入。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表也是一种经常被使用的一种数据结构。链表中的每一个元素都至少有两个元素，一个指向它的下一个元素，一个用来存放它自己的数据，就像下面定义的那样：</p><pre><code>typedef struct _namelist namelist;struct{    struct _namelist *next;    char *name;}_namelist;</code></pre><p>我们可以声明一个其类型的元素：</p><pre><code>static namelist *people;</code></pre><p>假设每一个元素都代表一个人，元素中的name属性便是这个人的名字，我们通过这样的语句来得到它：people-&gt;name; 第二个属性指向后面的一个元素，那我们便可以这样来访问下一个人的名字：people-&gt;next-&gt;name, 或者下一个人的下一个人的名字：people-&gt;next-&gt;next-&gt;name,一次类推，直到next的值是NULL，代表结束。</p><pre><code>//通过一个循环来遍历这个链表中的所有人～void name_show(namelist *p){    while (p)    {        printf(&quot;Name: %s\n&quot;, p-&gt;name);        p = p-&gt;next;    }}</code></pre><p>链表可以被用来实现FIFO模式，达到先进者先出的目的！</p><pre><code>static namelist *people = NULL, *last_person = NULL;void name_add(namelist *person){    person-&gt;next = NULL;    if (!last_person) {        /* No one in the list yet */        people = last_person = person;        return;    }    /* Append new person to the end of the list */    last_person-&gt;next = person;    /* Update the list tail */    last_person = person;}namelist *name_pop(void){    namelist *first_person = people;    if (people) {        people = people-&gt;next;    }    return first_person;}</code></pre><p>这样，我们便可以随意的向这个链表中添加或者删除数据，而不向数组那样，谨慎的考虑是否越界等问题。</p><p>上面实现的结构的学名叫做单向链表，也有地方叫单链表，反正是比较简单的意思～。它有一个致命的缺点，就是我们在插入或者读取某条数据的时候，都需要从这个链表的开始，一个个元素的向下寻找，直到找到这个元素为止。如果链表中的元素比较多，那它很容易成为我们程序中的CPU消耗大户，进而引起性能问题。为了解决这个问题，先人们发明了双向链表：</p><pre><code>typedef struct _namelist namelist;struct{    namelist *next, *prev;    char *name;} _namelist;</code></pre><p>改动其实不大，就是在每个元素中都添加了一个prev属性，用来指向它的上一个元素。</p><pre><code>void name_add(namelist *person){    person-&gt;next = NULL;    if (!last_person)    {        /* No one in the list yet */        people = last_person = person;        person-&gt;prev = NULL;        return;    }    /* Append new person to the end of the list */    last_person -&gt;next = person;    person-&gt;prev = last_person;    /* Update the list tail */    last_person = person;}</code></pre><p>单单通过上面的程序你还体会不到它的好处，但是设想一下，如果现在你有这个链表中其中一个元素的地址，并且想把它从链表中删除，那我们该怎么做呢？如果是单向链表的话，我们只能这样做：</p><pre><code>void name_remove(namelist *person){    namelist *p;    if (person == people) {        /* Happens to be the first person in the list */        people = person-&gt;next;        if (last_person == person) {            /* Also happens to be the last person */            last_person = NULL;        }        return;    }    /* Search for prior person */    p = people;    while (p) {        if (p-&gt;next == person) {            /* unlink */            p-&gt;next = person-&gt;next;            if (last_person == person) {                /* This was the last element */                last_person = p;            }            return;        }        p = p-&gt;next;    }    /* Not found in list */}</code></pre><p>现在让我们来看看双向链表是怎样来处理这个问题的：</p><pre><code>void name_remove(namelist *person){    if (people == person) {        people = person-&gt;next;    }    if (last_person == person) {        last_person = person-&gt;prev;    }    if (person-&gt;prev) {        person-&gt;prev-&gt;next = person-&gt;next;    }    if (person-&gt;next) {        person-&gt;next-&gt;prev = person-&gt;prev;    }}</code></pre><p>对元素的遍历查找不见了，取而代之的是一个O(1)的运算，这将极大的提升我们程序的性能。</p><h2 id="王者归来：HashTable才是我们的银弹！"><a href="#王者归来：HashTable才是我们的银弹！" class="headerlink" title="王者归来：HashTable才是我们的银弹！"></a>王者归来：HashTable才是我们的银弹！</h2><p>也许你已经非常喜欢使用数组或者链表了，但我还是要向你推荐一种威力极大的数据结构，有了它之后，你可能会立即抛弃前两者，它就是HashTable.</p><p>HashTable即具有双向链表的优点，同时具有能与数据匹敌的操作性能，这个数据结构几乎是PHP内核实现的基础，我们在内核代码的任何地方都发现它的痕迹。</p><p>前面我们接触过，所有的用户端定义的变量保存在一个符号表里，而这个符号表其实就是一个HashTable，它的每一个元素都是一个zval*类型的变量。不仅如此，保存用户定义的函数、类、资源等的容器都是以HashTable的形式在内核中实现的。</p><p>Zend Engine中HashTable的元素其实是指针，对其的这个改进使得HashTable能够包容各种类型的数据，从小小的标量，到复杂的PHP5中实现的类等复合数据。本章接下来的内容，我们将详细的研究如何使用zend内置的API来操作HashTable这个数据结构。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50-写时复制COW机制</title>
      <link href="/posts/dbbb6adc.html"/>
      <url>/posts/dbbb6adc.html</url>
      
        <content type="html"><![CDATA[<h1 id="50-写时复制COW机制"><a href="#50-写时复制COW机制" class="headerlink" title="50-写时复制COW机制"></a>50-写时复制COW机制</h1><p>写时复制（Copy-on-Write，也缩写为COW），顾名思义，就是在写入时才真正复制一份内存进行修改。 COW最早应用在*nix系统中对线程与内存使用的优化，后面广泛的被使用在各种编程语言中，如C++的STL等。 在PHP内核中，COW也是主要的内存优化手段。 在前面关于变量和内存的讨论中，引用计数对变量的销毁与回收中起着至关重要的标识作用。 引用计数存在的意义，就是为了使得COW可以正常运作，从而实现对内存的优化使用。</p><h2 id="写时复制的作用"><a href="#写时复制的作用" class="headerlink" title="写时复制的作用"></a>写时复制的作用</h2><p>经过上面的描述，大家可能会COW有了个主观的印象，下面让我们看一个小例子， 非常容易看到COW在内存使用优化方面的明显作用：</p><pre><code>&lt;?php$j = 1;var_dump(memory_get_usage());$tipi = array_fill(0, 100000, &apos;php-internal&apos;);var_dump(memory_get_usage());$tipi_copy = $tipi;var_dump(memory_get_usage());foreach($tipi_copy as $i){    $j += count($i);}var_dump(memory_get_usage());?&gt;//-----执行结果-----$ php t.phpint(630904)int(10479840)int(10479944)int(10480040)</code></pre><p>上面的代码比较典型的突出了COW的作用，在一个数组变量$tipi被赋值给$tipi_copy时， 内存的使用并没有立刻增加一半，甚至在循环遍历数 $tipi_copy时， 实际上遍历的，仍是$tipi指向的同一块内存。</p><p>也就是说，即使我们不使用引用，一个变量被赋值后，只要我们不改变变量的值 ，也与使用引用一样。 进一步讲，就算变量的值立刻被改变，新值的内存分配也会洽如其分。 据此我们很容易就可以想到一些COW可以非常有效的控制内存使用的场景， 如函数参数的传递，大数组的复制等等。</p><p>在这个例子中，如果$tipi_copy的值发生了变化，$tipi的值是不应该发生变化的， 那么，此时PHP内核又会如何去做呢？我们引入下面的示例：</p><pre><code>&lt;?php//$tipi = array_fill(0, 3, &apos;php-internal&apos;);  //这里不再使用array_fill来填充 ，为什么？$tipi[0] = &apos;php-internal&apos;;$tipi[1] = &apos;php-internal&apos;;$tipi[2] = &apos;php-internal&apos;;var_dump(memory_get_usage());$copy = $tipi;xdebug_debug_zval(&apos;tipi&apos;, &apos;copy&apos;);var_dump(memory_get_usage());$copy[0] = &apos;php-internal&apos;;xdebug_debug_zval(&apos;tipi&apos;, &apos;copy&apos;);var_dump(memory_get_usage());?&gt;//-----执行结果-----$ php t.phpint(629384)tipi: (refcount=2, is_ref=0)=array (0 =&gt; (refcount=1, is_ref=0)=&apos;php-internal&apos;, 1 =&gt; (refcount=1, is_ref=0)=&apos;php-internal&apos;, 2 =&gt; (refcount=1, is_ref=0)=&apos;php-internal&apos;)copy: (refcount=2, is_ref=0)=array (0 =&gt; (refcount=1, is_ref=0)=&apos;php-internal&apos;, 1 =&gt; (refcount=1, is_ref=0)=&apos;php-internal&apos;, 2 =&gt; (refcount=1, is_ref=0)=&apos;php-internal&apos;)int(629512)tipi: (refcount=1, is_ref=0)=array (0 =&gt; (refcount=1, is_ref=0)=&apos;php-internal&apos;, 1 =&gt; (refcount=2, is_ref=0)=&apos;php-internal&apos;, 2 =&gt; (refcount=2, is_ref=0)=&apos;php-internal&apos;)copy: (refcount=1, is_ref=0)=array (0 =&gt; (refcount=1, is_ref=0)=&apos;php-internal&apos;, 1 =&gt; (refcount=2, is_ref=0)=&apos;php-internal&apos;, 2 =&gt; (refcount=2, is_ref=0)=&apos;php-internal&apos;)int(630088)</code></pre><p>从上面例子我们可以看出，当一个数组整个被赋给一个变量时，只是将内存将内存地址赋值给变量。 当数组的值被改变时，Zend内核重新申请了一块内存，然后赋之以新值，但不影响其他值的内存状态。 写时复制的最小粒度，就是zval结构体， 而对于zval结构体组成的集合（如数组和对象等），在需要复制内存时，将复杂对象分解为最小粒度来处理。 这样做就使内存中复杂对象中某一部分做修改时，不必将该对象的所有元素全部“分离”出一份内存拷贝， 从而节省了内存的使用。</p><h2 id="写时复制的实现"><a href="#写时复制的实现" class="headerlink" title="写时复制的实现"></a>写时复制的实现</h2><p>由于内存块没有办法标识自己被几个指针同时使用， 仅仅通过内存本身并没有办法知道什么时候应该进行复制工作， 这样就需要一个变量来标识这块内存是“被多少个变量名指针同时指向的”， 这个变量，就是前面关于变量的章节提到的：引用计数。</p><p>这里有一个比较典型的例子：</p><pre><code>&lt;?php    $foo = 1;    xdebug_debug_zval(&apos;foo&apos;);    $bar = $foo;    xdebug_debug_zval(&apos;foo&apos;);    $bar = 2;    xdebug_debug_zval(&apos;foo&apos;);   ?&gt;//-----执行结果-----foo: (refcount=1, is_ref=0)=1foo: (refcount=2, is_ref=0)=1foo: (refcount=1, is_ref=0)=1</code></pre><p>经过前文对变量的章节，我们可以理解当$foo被赋值时，$foo变量的引用计数为1。 当$foo的值被赋给$bar时，PHP并没有将内存直接复制一份交给$bar， 而是直接把$foo和$bar指向同一个地址。这时，我们可以看到refcount=2; 最后，我们更改了$bar的值，这时如果两个变量再指向同一个内存地址的话， 其值就会同时改变，于是，PHP内核这时将内存复制出来一份，并将其值写为2 ，（这个操作也称为分离操作）， 同时维护原$foo变量的引用计数：refcount=1。</p><p>上面小例子中的xdebug_debug_zval()是xdebug扩展中的一个函数，用于输出变量在zend内部的引用信息。 如果你没有安装xdebug扩展，也可以使用debug_zval_dump()来代替。 参考：<a href="http://www.php.net/manual/zh/function.debug-zval-dump.php" target="_blank" rel="noopener">http://www.php.net/manual/zh/function.debug-zval-dump.php</a></p><p>写时复制应用的场景很多，最常见是赋值和函数传参。 在上面的例子中，就使用了zend_assign_to_variable()函数（Zend/zend_execute.c） 对变量的赋值进行了各种判断和处理。 其中最终处理代码如下：</p><pre><code>if (PZVAL_IS_REF(value) &amp;&amp; Z_REFCOUNT_P(value) &gt; 0) {    ALLOC_ZVAL(variable_ptr);    *variable_ptr_ptr = variable_ptr;    *variable_ptr = *value;    Z_SET_REFCOUNT_P(variable_ptr, 1);    zval_copy_ctor(variable_ptr);} else {    *variable_ptr_ptr = value;    Z_ADDREF_P(value);}</code></pre><p>从这段代码可以看出，如果要进行操作的值已经是引用类型（如已经被&amp;操作符操作过）, 则直接重新分配内存，否则只是将value的地址赋与变量，同时将值的zval_value.refcount进行加1操作。</p><p>如果大家看过前面的章节， 应该对变量存储的结构体zval（Zend/zend.h）还有印象：</p><pre><code>typedef struct _zval_struct zval;...struct _zval_struct {    /* Variable information */    zvalue_value value;     /* value */    zend_uint refcount__gc;    zend_uchar type;    /* active type */    zend_uchar is_ref__gc;};</code></pre><p>PHP对值的写时复制的操作，主要依赖于两个参数：refcount__gc与is_ref__gc。 如果是引用类型，则直接进行“分离”操作，即时分配内存， 否则会写时复制，也就是在修改其值的时候才进行内存的重新分配。</p><p>写时复制的规则比较繁琐，什么情况会导致写时复制及分离，是有非常多种情况的。 在这里只是举一个简单的例子帮助大家理解，后续会在附录中列举PHP中所有写时复制的相关规则。</p><h2 id="写时复制的矛盾，PHP中不推荐使用-amp-操作符的部分解释"><a href="#写时复制的矛盾，PHP中不推荐使用-amp-操作符的部分解释" class="headerlink" title="写时复制的矛盾，PHP中不推荐使用&amp;操作符的部分解释"></a>写时复制的矛盾，PHP中不推荐使用&amp;操作符的部分解释</h2><p>上面是一个比较典型的例子，但现实中的PHP实现经过各种权衡， 甚至有时对一个特性的支持与否，是互相矛盾且难以取舍的。 比如，unset()看上去是用来把变量释放，然后把内存标记于空闲的。 可是，在下面的例子中，unset并没有使内存池的内存增加：</p><pre><code>&lt;?php$nowamagic = 10;$o_o  = &amp;$nowamagic;unset($o_o);echo $nowamagic;?&gt;</code></pre><p>理论上$o_o是$nowamagic的引用，这两者应该指向同一块内存，其中一个被标识为回收， 另一个也应该被回收才是。但这是不可能的，因为内存本身并不知道都有哪些指针 指向了自已。在C中，o_o这时的值应该是无法预料的， 但PHP不想把这种维护变量引用的工作交给用户，于是， 使用了折中的方法，unset()此时只会把nowamagic变量名从hashtable中去掉， 而内存值的引用计数减1。实际的内存使用完全没有变化。</p><p>试想，如果$nowamagic是一个非常大的数组，或者是一个资源型的变量。 这种情形绝对是我们不想看到的。</p><p>上面这个例子我们还可以理解，如果每个这种类似操作都要用户来关心。 那PHP就是变换了语法的C了。而下面的这个例子，与其说是语言特性， 倒不如说是更像BUG多一些。（事实上对此在PHP官方的邮件组里有也争论）</p><pre><code>&lt;?php$foo [&apos;love&apos;] = 1;$bar  = &amp;$foo[&apos;love&apos;];$tipi = $foo;$tipi[&apos;love&apos;] = &apos;2&apos;;echo $foo[&apos;love&apos;];?&gt;</code></pre><p>这个例子最后会输出 2 ， 大家会非常惊讶于$nowamagic怎么会影响到$foo, 这完全是两个不同的变量么！至少我们希望是这样。</p><p>最后，不推荐大家使用 &amp; ，让PHP自己决定什么时候该使用引用好了， 除非你知道自己在做什么。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49-内存管理中的cache</title>
      <link href="/posts/b0c710fd.html"/>
      <url>/posts/b0c710fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="49-内存管理中的cache"><a href="#49-内存管理中的cache" class="headerlink" title="49-内存管理中的cache"></a>49-内存管理中的cache</h1><p>在维基百科中有这样一段描述： 凡是位于速度相差较大的两种硬件之间的，用于协调两者数据传输速度差异的结构，均可称之为Cache。 从最初始的处理器与内存间的Cache开始，都是为了让数据访问的速度适应CPU的处理速度， 其基于的原理是内存中“程序执行与数据访问的局域性行为”。 同样PHP内存管理中的缓存也是基于“程序执行与数据访问的局域性行为”的原理。 引入缓存，就是为了减少小块内存块的查询次数，为最近访问的数据提供更快的访问方式。</p><p>PHP将缓存添加到内存管理机制中做了如下一些操作：</p><ul><li>标识缓存和缓存的大小限制，即何时使用缓存，在某些情况下可以以最少的修改禁用掉缓存</li><li>缓存的存储结构，即缓存的存放位置、结构和存放的逻辑</li><li>初始化缓存</li><li>获取缓存中内容</li><li>写入缓存</li><li>释放缓存或者清空缓存列表</li></ul><p>首先我们看标识缓存和缓存的大小限制，在PHP内核中，是否使用缓存的标识是宏ZEND_MM_CACHE（Zend/zend_alloc.c 400行）， 缓存的大小限制与size_t结构大小有关，假设size_t占4位，则默认情况下，PHP内核给PHP内存管理的限制是128K(32 <em>4 </em>1024)。 如下所示代码：</p><pre><code>#define ZEND_MM_NUM_BUCKETS (sizeof(size_t) &lt;&lt; 3)#define ZEND_MM_CACHE 1#define ZEND_MM_CACHE_SIZE (ZEND_MM_NUM_BUCKETS * 4 * 1024)</code></pre><p>如果在某些应用下需要禁用缓存，则将ZEND_MM_CACHE宏设置为0，重新编译PHP即可。 为了实现这个一处修改所有地方都生效的功能，则在每个需要调用缓存的地方在编译时都会判断ZEND_MM_CACHE是否定义为1。</p><p>如果我们启用了缓存，则在堆层结构中增加了两个字段：</p><pre><code>struct _zend_mm_heap {#if ZEND_MM_CACHE    unsigned int        cached; //  已缓存元素使用内存的总大小    zend_mm_free_block *cache[ZEND_MM_NUM_BUCKETS]; //  存放被缓存的块#endif</code></pre><p>如上所示，cached表示已缓存元素使用内存的总大小，zend_mm_free_block结构的数组装载被缓存的块。 在初始化内存管理时，会调用zend_mm_init函数。在这个函数中，当缓存启用时会初始化上面所说的两个字段，如下所示：</p><pre><code>#if ZEND_MM_CACHE    heap-&gt;cached = 0;    memset(heap-&gt;cache, 0, sizeof(heap-&gt;cache));#endif</code></pre><p>程序会初始化已缓存元素的总大小为0，并给存放缓存块的数组分配内存。 初始化之后，如果外部调用需要PHP内核分配内存，此时可能会调用缓存， 之所以是可能是因为它有一个前提条件，即所有的缓存都只用于小于的内存块的申请。 所谓小块的内存块是其真实大小小于ZEND_MM_MAX_SMALL_SIZE(272)的。 比如，在缓存启用的情况下，我们申请一个100Byte的内存块，则PHP内核会首先判断其真实大小， 并进入小块内存分配的流程，在此流程中程序会先判断对应大小的块索引是否存在，如果存在则直接从缓存中返回， 否则继续走常规的分配流程。</p><p>当用户释放内存块空间时，程序最终会调用_zend_mm_free_int函数。在此函数中，如果启用了缓存并且所释放的是小块内存， 并且已分配的缓存大小小于缓存限制大小时，程序会将释放的块放到缓存列表中。如下代码：</p><pre><code>#if ZEND_MM_CACHE    if (EXPECTED(ZEND_MM_SMALL_SIZE(size)) &amp;&amp; EXPECTED(heap-&gt;cached &lt; ZEND_MM_CACHE_SIZE)) {        size_t index = ZEND_MM_BUCKET_INDEX(size);        zend_mm_free_block **cache = &amp;heap-&gt;cache[index];        ((zend_mm_free_block*)mm_block)-&gt;prev_free_block = *cache;        *cache = (zend_mm_free_block*)mm_block;        heap-&gt;cached += size;        ZEND_MM_SET_MAGIC(mm_block, MEM_BLOCK_CACHED);#if ZEND_MM_CACHE_STAT        if (++heap-&gt;cache_stat[index].count &gt; heap-&gt;cache_stat[index].max_count) {            heap-&gt;cache_stat[index].max_count = heap-&gt;cache_stat[index].count;        }#endif        return;    }#endif</code></pre><p>当堆的内存溢出时，程序会调用zend_mm_free_cache释放缓存中。整个释放的过程是一个遍历数组， 对于每个数组的元素程序都遍历其所在链表中在自己之前的元素，执行合并内存操作，减少堆结构中缓存计量数字。 具体实现参见Zend/zend_alloc.c的909行。</p><p>在上面的一些零碎的代码块中我们有看到在ZEND_MM_CACHE宏出现时经常会出现ZEND_MM_CACHE_STAT宏。 这个宏是标记是否启用缓存统计功能，默认情况下为不启用。缓存统计功能也有对应的存储结构，在分配，释放缓存中的值时， 缓存统计功能都会有相应的实现。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48-PHP5.3的垃圾回收机制</title>
      <link href="/posts/3008f030.html"/>
      <url>/posts/3008f030.html</url>
      
        <content type="html"><![CDATA[<h1 id="48-PHP5-3的垃圾回收机制"><a href="#48-PHP5-3的垃圾回收机制" class="headerlink" title="48-PHP5.3的垃圾回收机制"></a>48-PHP5.3的垃圾回收机制</h1><p>垃圾回收机制是一种动态存储分配方案。它会自动释放程序不再需要的已分配的内存块。 自动回收内存的过程叫垃圾收集。垃圾回收机制可以让程序员不必过分关心程序内存分配，从而将更多的精力投入到业务逻辑。 在现在的流行各种语言当中，垃圾回收机制是新一代语言所共有的特征，如Python、PHP、Eiffel、C#、Ruby等都使用了垃圾回收机制。 虽然垃圾回收是现在比较流行的做法，但是它的年纪已经不小了。早在20世纪60年代MIT开发的Lisp系统中就已经有了它的身影， 但是由于当时技术条件不成熟，从而使得垃圾回收机制成了一个看起来很美的技术，直到20世纪90年代Java的出现，垃圾回收机制才被广泛应用。</p><p>PHP也在语言层实现了内存的动态管理，这在前面的章节中已经有了详细的说明， 内存的动态管理将开发人员从繁琐的内存管理中解救出来。与此配套，PHP也提供了语言层的垃圾回收机制， 让程序员不必过分关心程序内存分配。</p><p>在PHP5.3版本之前，PHP只有简单的基于引用计数的垃圾回收，当一个变量的引用计数变为0时， PHP将在内存中销毁这个变量，只是这里的垃圾并不能称之为垃圾。 并且PHP在一个生命周期结束后就会释放此进程/线程所点的内容，这种方式决定了PHP在前期不需要过多考虑内存的泄露问题。 但是随着PHP的发展，PHP开发者的增加以及其所承载的业务范围的扩大，在PHP5.3中引入了更加完善的垃圾回收机制。 新的垃圾回收机制解决了无法处理循环的引用内存泄漏问题。PHP5.3中的垃圾回收机制使用了文章引用计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems) 中的同步算法。关于这个算法的介绍我们就不再赘述，在PHP的官方文档有图文并茂的介绍：回收周期(Collecting Cycles)。</p><p>如前面所说，在PHP中，主要的内存管理手段是引用计数，引入垃圾收集机制的目的是为了打破引用计数中的循环引用，从而防止因为这个而产生的内存泄露。 垃圾收集机制基于PHP的动态内存管理而存在。PHP5.3为引入垃圾收集机制，在变量存储的基本结构上有一些变动，如下所示：</p><pre><code>struct _zval_struct {    /* Variable information */    zvalue_value value;     /* value */    zend_uint refcount__gc;    zend_uchar type;    /* active type */    zend_uchar is_ref__gc;};</code></pre><p>与PHP5.3之前的版本相比，引用计数字段refcount和是否引用字段is_ref都在其后面添加了__gc以用于新的的垃圾回收机制。 在PHP的源码风格中，大量的宏是一个非常鲜明的特点。这些宏相当于一个接口层，它屏蔽了接口层以下的一些底层实现，如， ALLOC_ZVAL宏，这个宏在PHP5.3之前是直接调用PHP的内存管理分配函数emalloc分配内存，所分配的内存大小由变量的类型等大小决定。 在引入垃圾回收机制后，ALLOC_ZVAL宏直接采用新的垃圾回收单元结构，所分配的大小都是一样的，全部是zval_gc_info结构体所占内存大小， 并且在分配内存后，初始化这个结构体的垃圾回收机制。如下代码：</p><pre><code>/* The following macroses override macroses from zend_alloc.h */#undef  ALLOC_ZVAL#define ALLOC_ZVAL(z)                                   \    do {                                                \        (z) = (zval*)emalloc(sizeof(zval_gc_info));     \        GC_ZVAL_INIT(z);                                \    } while (0)</code></pre><p>zend_gc.h文件在zend.h的749行被引用：#include “zend_gc.h” 从而替换覆盖了在237行引用的zend_alloc.h文件中的ALLOC_ZVAL等宏 在新的的宏中，关键性的改变是对所分配内存大小和分配内容的改变，在以前纯粹的内存分配中添加了垃圾收集机制的内容， 所有的内容都包括在zval_gc_info结构体中：</p><pre><code>typedef struct _zval_gc_info {    zval z;    union {        gc_root_buffer       *buffered;        struct _zval_gc_info *next;    } u;} zval_gc_info;</code></pre><p>对于任何一个ZVAL容器存储的变量，分配了一个zval结构，这个结构确保其和以zval变量分配的内存的开始对齐， 从而在zval_gc_info类型指针的强制转换时，其可以作为zval使用。在zval字段后面有一个联合体:u。 u包括gc_root_buffer结构的buffered字段和zval_gc_info结构的next字段。 这两个字段一个是表示垃圾收集机制缓存的根结点，一个是zval_gc_info列表的下一个结点， 垃圾收集机制缓存的结点无论是作为根结点，还是列表结点，都可以在这里体现。 ALLOC_ZVAL在分配了内存后会调用GC_ZVAL_INIT用来初始化替代了zval的zval_gc_info， 它会把zval_gc_info中的成员u的buffered字段设置成NULL，此字段仅在将其放入垃圾回收缓冲区时才会有值，否则会一直是NULL。 由于PHP中所有的变量都是以zval变量的形式存在，这里以zval_gc_info替换zval，从而成功实现垃圾收集机制在原有系统中的集成。</p><p>PHP的垃圾回收机制在PHP5.3中默认为开启，但是我们可以通过配置文件直接设置为禁用，其对应的配置字段为：zend.enable_gc。 在php.ini文件中默认是没有这个字段的，如果我们需要禁用此功能，则在php.ini中添加zend.enable_gc=0或zend.enable_gc=off。 除了修改php.ini配置zend.enable_gc，也可以通过调用gc_enable()/gc_disable()函数来打开/关闭垃圾回收机制。 这些函数的调用效果与修改配置项来打开或关闭垃圾回收机制的效果是一样的。 除了这两个函数PHP提供了gc_collect_cycles()函数可以在根缓冲区还没满时强制执行周期回收。 与垃圾回收机制是否开启在PHP源码中有一些相关的操作和字段。在zend.c文件中有如下代码：</p><pre><code>static ZEND_INI_MH(OnUpdateGCEnabled) /* {{{ */    {        OnUpdateBool(entry, new_value, new_value_length, mh_arg1, mh_arg2, mh_arg3, stage TSRMLS_CC);        if (GC_G(gc_enabled)) {            gc_init(TSRMLS_C);        }        return SUCCESS;    }    /* }}} */ZEND_INI_BEGIN()    ZEND_INI_ENTRY(&quot;error_reporting&quot;,               NULL,       ZEND_INI_ALL,       OnUpdateErrorReporting)    STD_ZEND_INI_BOOLEAN(&quot;zend.enable_gc&quot;,              &quot;1&quot;,    ZEND_INI_ALL,       OnUpdateGCEnabled,      gc_enabled,     zend_gc_globals,        gc_globals)#ifdef ZEND_MULTIBYTE    STD_ZEND_INI_BOOLEAN(&quot;detect_unicode&quot;, &quot;1&quot;, ZEND_INI_ALL, OnUpdateBool, detect_unicode, zend_compiler_globals, compiler_globals)#endifZEND_INI_END()</code></pre><p>zend.enable_gc对应的操作函数为ZEND_INI_MH(OnUpdateGCEnabled)，如果开启了垃圾回收机制， 即GC_G(gc_enabled)为真，则会调用gc_init函数执行垃圾回收机制的初始化操作。 gc_init函数在zend/zend_gc.c 121行，此函数会判断是否开启垃圾回收机制， 如果开启，则初始化整个机制，即直接调用malloc给整个缓存列表分配10000个gc_root_buffer内存空间。 这里的10000是硬编码在代码中的，以宏GC_ROOT_BUFFER_MAX_ENTRIES存在，如果需要修改这个值，则需要修改源码，重新编译PHP。 gc_init函数在预分配内存后调用gc_reset函数重置整个机制用到的一些全局变量，如设置gc运行的次数统计(gc_runs)和gc中垃圾的个数(collected)为0， 设置双向链表头结点的上一个结点和下一个结点指向自己等。除了这种提的一些用于垃圾回收机制的全局变量，还有其它一些使用较多的变量，部分说明如下：</p><pre><code>typedef struct _zend_gc_globals {    zend_bool         gc_enabled;   /* 是否开启垃圾收集机制 */    zend_bool         gc_active;    /* 是否正在进行 */    gc_root_buffer   *buf;              /* 预分配的缓冲区数组，默认为10000（preallocated arrays of buffers）   */    gc_root_buffer    roots;            /* 列表的根结点（list of possible roots of cycles） */    gc_root_buffer   *unused;           /* 没有使用过的缓冲区列表(list of unused buffers)           */    gc_root_buffer   *first_unused;     /* 指向第一个没有使用过的缓冲区结点（pointer to first unused buffer）   */    gc_root_buffer   *last_unused;      /* 指向最后一个没有使用过的缓冲区结点，此处为标记结束用(pointer to last unused buffer)    */    zval_gc_info     *zval_to_free;     /* 将要释放的zval变量的临时列表（temporaryt list of zvals to free） */    zval_gc_info     *free_list;        /* 临时变量，需要释放的列表开头 */    zval_gc_info     *next_to_free;     /* 临时变量，下一个将要释放的变量位置*/    zend_uint gc_runs;  /* gc运行的次数统计 */    zend_uint collected;    /* gc中垃圾的个数 */    // 省略...}</code></pre><p>当我们使用一个unset操作想清除这个变量所占的内存时（可能只是引用计数减一），会从当前符号的哈希表中删除变量名对应的项， 在所有的操作执行完后，并对从符号表中删除的项调用一个析构函数，临时变量会调用zval_dtor，一般的变量会调用zval_ptr_dtor。</p><p>当然我们无法在PHP的函数集中找到unset函数，因为它是一种语言结构。 其对应的中间代码为ZEND_UNSET，在Zend/zend_vm_execute.h文件中你可以找到与它相关的实现。</p><p>zval_ptr_dtor并不是一个函数，只是一个长得有点像函数的宏。 在Zend/zend_variables.h文件中，这个宏指向函数_zval_ptr_dtor。 在Zend/zend_execute_API.c 424行，函数相关代码如下：</p><pre><code>ZEND_API void _zval_ptr_dtor(zval **zval_ptr ZEND_FILE_LINE_DC) /* {{{ */    {    #if DEBUG_ZEND>=2        printf("Reducing refcount for %x (%x): %d->%d\n", *zval_ptr, zval_ptr, Z_REFCOUNT_PP(zval_ptr), Z_REFCOUNT_PP(zval_ptr) - 1);    #endif        Z_DELREF_PP(zval_ptr);        if (Z_REFCOUNT_PP(zval_ptr) == 0) {            TSRMLS_FETCH();            if (*zval_ptr != &EG(uninitialized_zval)) {                GC_REMOVE_ZVAL_FROM_BUFFER(*zval_ptr);                zval_dtor(*zval_ptr);                efree_rel(*zval_ptr);            }        } else {            TSRMLS_FETCH();            if (Z_REFCOUNT_PP(zval_ptr) == 1) {                Z_UNSET_ISREF_PP(zval_ptr);            }            GC_ZVAL_CHECK_POSSIBLE_ROOT(*zval_ptr);        }    }    /* }}} */</code></pre><p>从代码我们可以很清晰的看出这个zval的析构过程，关于引用计数字段做了以下两个操作：</p><ul><li>如果变量的引用计数为1，即减一后引用计数为0，直接清除变量。如果当前变量如果被缓存，则需要清除缓存</li><li>如果变量的引用计数大于1，即减一后引用计数大于0，则将变量放入垃圾列表。如果变更存在引用，则去掉其引用。</li></ul><p>将变量放入垃圾列表的操作是GC_ZVAL_CHECK_POSSIBLE_ROOT，这也是一个宏，其对应函数gc_zval_check_possible_root， 但是此函数仅对数组和对象执行垃圾回收操作。对于数组和对象变量，它会调用gc_zval_possible_root函数。</p><pre><code>ZEND_API void gc_zval_possible_root(zval *zv TSRMLS_DC){    if (UNEXPECTED(GC_G(free_list) != NULL &amp;&amp;                   GC_ZVAL_ADDRESS(zv) != NULL &amp;&amp;                   GC_ZVAL_GET_COLOR(zv) == GC_BLACK) &amp;&amp;                   (GC_ZVAL_ADDRESS(zv) &lt; GC_G(buf) ||                    GC_ZVAL_ADDRESS(zv) &gt;= GC_G(last_unused))) {        /* The given zval is a garbage that is going to be deleted by         * currently running GC */        return;    }    if (zv-&gt;type == IS_OBJECT) {        GC_ZOBJ_CHECK_POSSIBLE_ROOT(zv);        return;    }    GC_BENCH_INC(zval_possible_root);    if (GC_ZVAL_GET_COLOR(zv) != GC_PURPLE) {        GC_ZVAL_SET_PURPLE(zv);        if (!GC_ZVAL_ADDRESS(zv)) {            gc_root_buffer *newRoot = GC_G(unused);            if (newRoot) {                GC_G(unused) = newRoot-&gt;prev;            } else if (GC_G(first_unused) != GC_G(last_unused)) {                newRoot = GC_G(first_unused);                GC_G(first_unused)++;            } else {                if (!GC_G(gc_enabled)) {                    GC_ZVAL_SET_BLACK(zv);                    return;                }                zv-&gt;refcount__gc++;                gc_collect_cycles(TSRMLS_C);                zv-&gt;refcount__gc--;                newRoot = GC_G(unused);                if (!newRoot) {                    return;                }                GC_ZVAL_SET_PURPLE(zv);                GC_G(unused) = newRoot-&gt;prev;            }            newRoot-&gt;next = GC_G(roots).next;            newRoot-&gt;prev = &amp;GC_G(roots);            GC_G(roots).next-&gt;prev = newRoot;            GC_G(roots).next = newRoot;            GC_ZVAL_SET_ADDRESS(zv, newRoot);            newRoot-&gt;handle = 0;            newRoot-&gt;u.pz = zv;            GC_BENCH_INC(zval_buffered);            GC_BENCH_INC(root_buf_length);            GC_BENCH_PEAK(root_buf_peak, root_buf_length);        }    }}</code></pre><p>在前面说到gc_zval_check_possible_root函数仅对数组和对象执行垃圾回收操作，然而在gc_zval_possible_root函数中， 针对对象类型的变量会去调用GC_ZOBJ_CHECK_POSSIBLE_ROOT宏。而对于其它的可用于垃圾回收的机制的变量类型其调用过程如下：</p><ul><li>检查zval结点信息是否已经放入到结点缓冲区，如果已经放入到结点缓冲区，则直接返回，这样可以优化其性能。 然后处理对象结点，直接返回，不再执行后面的操作</li><li>判断结点是否已经被标记为紫色，如果为紫色则不再添加到结点缓冲区，此处在于保证一个结点只执行一次添加到缓冲区的操作。</li><li>将结点的颜色标记为紫色，表示此结点已经添加到缓冲区，下次不用再做添加</li><li>找出新的结点的位置，如果缓冲区满了，则执行垃圾回收操作。</li><li>将新的结点添加到缓冲区所在的双向链表。</li></ul><p>在gc_zval_possible_root函数中，当缓冲区满时，程序调用gc_collect_cycles函数，执行垃圾回收操作。 其中最关键的几步就是：</p><ul><li>第628行 此处为其官方文档中算法的步骤 B ，算法使用深度优先搜索查找所有可能的根，找到后将每个变量容器中的引用计数减1， 为确保不会对同一个变量容器减两次“1”，用灰色标记已减过1的。</li><li>第629行 这是算法的步骤 C ，算法再一次对每个根节点使用深度优先搜索，检查每个变量容器的引用计数。 如果引用计数是 0 ，变量容器用白色来标记。如果引用次数大于0，则恢复在这个点上使用深度优先搜索而将引用计数减1的操作（即引用计数加1）， 然后将它们重新用黑色标记。</li><li>第630行 算法的最后一步 D ，算法遍历根缓冲区以从那里删除变量容器根(zval roots)， 同时，检查是否有在上一步中被白色标记的变量容器。每个被白色标记的变量容器都被清除。 在[gc_collect_cycles() -&gt; gc_collect_roots() -&gt; zval_collect_white() ]中我们可以看到， 对于白色标记的结点会被添加到全局变量zval_to_free列表中。此列表在后面的操作中有用到。</li></ul><p>PHP的垃圾回收机制在执行过程中以四种颜色标记状态。</p><ul><li>GC_WHITE 白色表示垃圾</li><li>GC_PURPLE 紫色表示已放入缓冲区</li><li>GC_GREY 灰色表示已经进行了一次refcount的减一操作</li><li>GC_BLACK 黑色是默认颜色，正常</li></ul><p>相关的标记以及操作代码如下：</p><pre><code>#define GC_COLOR  0x03#define GC_BLACK  0x00#define GC_WHITE  0x01#define GC_GREY   0x02#define GC_PURPLE 0x03#define GC_ADDRESS(v) \    ((gc_root_buffer*)(((zend_uintptr_t)(v)) &amp; ~GC_COLOR))#define GC_SET_ADDRESS(v, a) \    (v) = ((gc_root_buffer*)((((zend_uintptr_t)(v)) &amp; GC_COLOR) | ((zend_uintptr_t)(a))))#define GC_GET_COLOR(v) \    (((zend_uintptr_t)(v)) &amp; GC_COLOR)#define GC_SET_COLOR(v, c) \    (v) = ((gc_root_buffer*)((((zend_uintptr_t)(v)) &amp; ~GC_COLOR) | (c)))#define GC_SET_BLACK(v) \    (v) = ((gc_root_buffer*)(((zend_uintptr_t)(v)) &amp; ~GC_COLOR))#define GC_SET_PURPLE(v) \    (v) = ((gc_root_buffer*)(((zend_uintptr_t)(v)) | GC_PURPLE))</code></pre><p>以上的这种以位来标记状态的方式在PHP的源码中使用频率较高，如内存管理等都有用到， 这是一种比较高效及节省的方案。但是在我们做数据库设计时可能对于字段不能使用这种方式， 应该是以一种更加直观，更加具有可读性的方式实现。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47-引用计数与写时复制</title>
      <link href="/posts/fe831e56.html"/>
      <url>/posts/fe831e56.html</url>
      
        <content type="html"><![CDATA[<h1 id="47-引用计数与写时复制"><a href="#47-引用计数与写时复制" class="headerlink" title="47-引用计数与写时复制"></a>47-引用计数与写时复制</h1><p>对于PHP这种需要同时处理多个请求的程序来说，申请和释放内存的时候应该慎之又慎，一不小心便会酿成大错。另一方面，除了要安全的申请和释放内存外，还应该做到内存的最小化使用，因为它可能要处理每秒钟数以千计的请求，为了提高系统整体的性能，每一次操作都应该只使用最少的内存，对于不必要的相同数据的复制则应该能免则免。我们来看下面这段PHP代码：</p><pre><code>&lt;?php$a = &apos;Hello NowaMagic!&apos;;$b = $a;unset($a);?&gt;</code></pre><p>第一条语句执行后，PHP创建了$a这个变量，并为它申请了12B的内存来存放”hello world”这个字符串（最后加个NULL字符，你懂的）。紧接着把$a赋给了$b，并释放掉$a;</p><p>对于PHP来说，如果每一次变量赋值都执行一次内存复制的话，那需要额外申请12B的内存来存放这个重复的数据,当然为了复制内存，还需要cpu执行某些计算，这当然会加重cpu的负载。当第三句执行后，$a被释放了，我们刚才的设想突然变的这么滑稽，这次赋值显得好多余哦。如果早就知道$a不用了，那我们直接让$b用$a的内存不就行了，还赋值干嘛？如果你觉得12B没什么，那设想下如果$a是个10M的文件内容，或者20M，是不是我们的计算机资源消耗的有点冤枉呢？</p><p>别担心，PHP很聪明！</p><p>前面说过，PHP变量的名称和值在内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？</p><pre><code>zval *helloval;MAKE_STD_ZVAL(helloval);ZVAL_STRING(helloval, &quot;Hello NowaMagic!&quot;, 1);zend_hash_add(EG(active_symbol_table), &quot;a&quot;, sizeof(&quot;a&quot;),&amp;helloval, sizeof(zval*), NULL);zend_hash_add(EG(active_symbol_table), &quot;b&quot;, sizeof(&quot;b&quot;),&amp;helloval, sizeof(zval*), NULL);//通过这个例子我们看出了，我们可以把$a和$b都指向helloval~!</code></pre><p>现在我们检查$a和$b两个变量，他们的值指向了”Hello NowaMagic!”这个字符串在内存中的位置。但是在第三行：unset($a);这条语句释放了$a。在这种情况下，unset函数并不知道$a的值同时被$b用着，所以如果它直接释放内存，则会导致$b的值也被清空了，从而导致逻辑错误，甚至可能会导致系统崩溃。</p><p>呵呵，其实你心里明白，PHP不会让上述问题发生的！回顾一下zval的四个成员value、type、is_ref__gc、refcount__gc，我们对value和type已经很熟了，现在则是后两个成员发挥威力的时候了，这里我们主要讲解refcount__gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount__gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！</p><p>以上描述转为内核中的代码大体如下：</p><pre><code>zval *helloval;MAKE_STD_ZVAL(helloval);ZVAL_STRING(helloval, &quot;Hello World&quot;, 1);zend_hash_add(EG(active_symbol_table), &quot;a&quot;, sizeof(&quot;a&quot;),&amp;helloval, sizeof(zval*), NULL);ZVAL_ADDREF(helloval); //这句很特殊，我们显示的增加了helloval结构体的refcountzend_hash_add(EG(active_symbol_table), &quot;b&quot;, sizeof(&quot;b&quot;),&amp;helloval, sizeof(zval*), NULL);</code></pre><p>这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！</p><h2 id="写时复制机制"><a href="#写时复制机制" class="headerlink" title="写时复制机制"></a>写时复制机制</h2><p>引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？</p><pre><code>$a = 1;$b = $a;$b += 5;</code></pre><p>从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？</p><p>答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。</p><pre><code>zval *get_var_and_separate(char *varname, int varname_len TSRMLS_DC){    zval **varval, *varcopy;    if (zend_hash_find(EG(active_symbol_table),varname, varname_len + 1, (void**)&amp;varval) == FAILURE)    {        /* 如果在符号表里找不到这个变量则直接return */        return NULL;    }    if ((*varval)-&gt;refcount &lt; 2)    {        //如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return        return *varval;    }    /* 否则，复制一份zval*的值 */    MAKE_STD_ZVAL(varcopy);    varcopy = *varval;    /* Duplicate any allocated structures within the zval* */    zval_copy_ctor(varcopy);    /* 从符号表中删除原来的变量     * This will decrease the refcount of varval in the process     */    zend_hash_del(EG(active_symbol_table), varname, varname_len + 1);    /* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/    varcopy-&gt;refcount = 1;    varcopy-&gt;is_ref = 0;    zend_hash_add(EG(active_symbol_table), varname, varname_len + 1,&amp;varcopy, sizeof(zval*), NULL);    /* 返回新zval的地址 */    return varcopy;}</code></pre><p>现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。</p><h2 id="Change-on-Write-写时复制"><a href="#Change-on-Write-写时复制" class="headerlink" title="Change on Write 写时复制"></a>Change on Write 写时复制</h2><p>如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？</p><pre><code>$a = 1;$b = &amp;$a;$b += 5;  </code></pre><p>作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！</p><p>但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &amp;$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！</p><p>最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：</p><pre><code>/* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不许要复制。*/if ((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; 2) {    return *varval;}</code></pre><p>这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。</p><h2 id="Separation-Anxiety"><a href="#Separation-Anxiety" class="headerlink" title="Separation Anxiety"></a>Separation Anxiety</h2><p>我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：</p><pre><code>$a = 1;$b = $a;$c = &amp;$a;  </code></pre><p>这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref__gc和refcount__gc该怎样工作，才能正确的处理好这段复杂的关系呢？</p><p>The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见下图【在引用时强制复制！】</p><center><br><img src="images/2012_02_24_08.jpg" alt><br></center><p>同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！</p><center><br><img src="images/2012_02_24_09.jpg" alt><br></center><pre><code>//上图对应的代码$a = 1;$b = &amp;$a;$c = $a;</code></pre><p>需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46-内存的申请与销毁</title>
      <link href="/posts/97e33c57.html"/>
      <url>/posts/97e33c57.html</url>
      
        <content type="html"><![CDATA[<h1 id="46-内存的申请与销毁"><a href="#46-内存的申请与销毁" class="headerlink" title="46-内存的申请与销毁"></a>46-内存的申请与销毁</h1><p>PHP底层对内存的管理， 围绕着小块内存列表（free_buckets）、 大块内存列表（large_free_buckets）和 剩余内存列表（rest_buckets）三个列表来分层进行的。 ZendMM向系统进行的内存申请，并不是有需要时向系统即时申请， 而是由ZendMM的最底层（heap层）先向系统申请一大块的内存，通过对上面三种列表的填充， 建立一个类似于内存池的管理机制。 在程序运行需要使用内存的时候，ZendMM会在内存池中分配相应的内存供使用。 这样做的好处是避免了PHP向系统频繁的内存申请操作，如下面的代码：</p><pre><code>&lt;?php$nowamagic = &quot;o_o\n&quot;;echo $nowamagic;?&gt;</code></pre><p>这是一个简单的php程序，但通过对emalloc的调用计数，发现对内存的请求有数百次之多， 当然这非常容易解释，因为PHP脚本的执行，需要大量的环境变量以及内部变量的定义， 这些定义本身都是需要在内存中进行存储的。</p><p>在编写PHP的扩展时，推荐使用emalloc来代替malloc，其实也就是使用PHP的ZendMM来代替 手动直接调用系统级的内存管理。（除非，你自己知道自已在做什么。）</p><p>那么在上面这个小程序的执行过程中，ZendMM是如何使用自身的heap层存储空间的呢？ 经过对源码的追踪我们可以找到：</p><pre><code>ZEND_ASSIGN_SPEC_CV_CONST_HANDLER (......)-&gt; ALLOC_ZVAL(......)-&gt; ZEND_FAST_ALLOC(......)-&gt; emalloc (......)-&gt; _emalloc(......)-&gt; _zend_mm_alloc_int(.....)</code></pre><p>void *_emalloc 实现了对内存的申请操作，在_emalloc的处理过程中， 对是否使用ZendMM进行了判断，如果heap层没有使用ZendMM来管理， 就直接使用_zend_mm_heap结构中定义的_malloc函数进行内存的分配; （我们通过上节可以知道，这里的_malloc可以是malloc，win32，mmap_anon，mmap_zero中的一种）。</p><p>就目前所知，不使用ZendMM进行内存管理，唯一的用途是打开enable-debug开关后， 可以更方便的追踪内存的使用情况。所以，在这里我们关注ZendMM使用_zend_mm_alloc_int函数进行内存分配：</p><center><br><img src="images/2012_02_24_07.jpg" alt><br></center><br><center><br>PHP内存管理器<br></center><p>结合上图，再加上内存分配之前的验证，ZendMM对内存分配的处理主要有以下步骤：</p><ol><li>内存检查。 对要申请的内存大小进行检查，如果太大（超出memory_limit则报 Out of Memory）;</li><li>如果命中缓存，使用fastcache得到内存块(详见第五节)，然后直接进行第5步;</li><li>在ZendMM管理的heap层存储中搜索合适大小的内存块, 在这一步骤ZendMM通过与ZEND_MM_MAX_SMALL_SIZE进行大小比较， 把内存请求分为两种类型： large和small。small类型的的请求会先使用zend_mm_low_bit函数 在mm_heap中的free_buckets中查找，未找到则使用与large类型相同的方式： 使用zend_mm_search_large_block函数在“大块”内存（_zend_mm_heap-&gt;large_free_buckets）中进行查找。 如果还没有可以满足大小需求的内存，最后在rest_buckets中进行查找。 也就是说，内存的分配是在三种列表中小到大进行的。 找到可以使用的block后，进行第5步;</li><li>如果经过第3步的查找还没有找到可以使用的资源（请求的内存过大），需要使用ZEND_MM_STORAGE_ALLOC函数向系统再申请一块内存（大小至少为ZEND_MM_SEG_SIZE），然后直接将对齐后的地址分配给本次请求。跳到第6步;</li><li>使用zend_mm_remove_from_free_list函数将已经使用block节点在zend_mm_free_block中移除;</li><li>内存分配完毕，对zend_mm_heap结构中的各种标识型变量进行维护，包括large_free_buckets， peak，size等;</li><li>返回分配的内存地址;</li></ol><p>从上面的分配可以看出，PHP对内存的分配，是结合PHP的用途来设计的，PHP一般用于web应用程序的数据支持， 单个脚本的运行周期一般比较短（最多达到秒级），内存大块整块的申请，自主进行小块的分配， 没有进行比较复杂的不相临地址的空闲内存合并，而是集中再次向系统请求。 这样做的好处就是运行速度会更快，缺点是随着程序的运行时间的变长， 内存的使用情况会“越来越多”（PHP5.2及更早版本）。 所以PHP5.3之前的版本并不适合做为守护进程长期运行。 （当然，可以有其他方法解决，而且在PHP5.3中引入了新的GC机制，详见下一小节）</p><h2 id="内存的销毁"><a href="#内存的销毁" class="headerlink" title="内存的销毁"></a>内存的销毁</h2><p>ZendMM在内存销毁的处理上采用与内存申请相同的策略，当程序unset一个变量或者是其他的释放行为时， ZendMM并不会直接立刻将内存交回给系统，而是只在自身维护的内存池中将其重新标识为可用， 按照内存的大小整理到上面所说的三种列表（small,large,free）之中，以备下次内存申请时使用。</p><p>内存销毁的最终实现函数是_efree。在_efree中，内存的销毁首先要进行是否放回cache的判断。 如果内存的大小满足ZEND_MM_SMALL_SIZE并且cache还没有超过系统设置的ZEND_MM_CACHE_SIZE， 那么，当前内存块zend_mm_block就会被放回mm_heap-&gt;cache中。 如果内存块没有被放回cache，则使用下面的代码进行处理：</p><pre><code>zend_mm_block *mm_block; //要销毁的内存块zend_mm_block *next_block;...next_block = ZEND_MM_BLOCK_AT(mm_block, size);if (ZEND_MM_IS_FREE_BLOCK(next_block)) {    zend_mm_remove_from_free_list(heap, (zend_mm_free_block *) next_block);    size += ZEND_MM_FREE_BLOCK_SIZE(next_block);}    if (ZEND_MM_PREV_BLOCK_IS_FREE(mm_block)) {    mm_block = ZEND_MM_PREV_BLOCK(mm_block);    zend_mm_remove_from_free_list(heap, (zend_mm_free_block *) mm_block);    size += ZEND_MM_FREE_BLOCK_SIZE(mm_block);}    if (ZEND_MM_IS_FIRST_BLOCK(mm_block) &amp;&amp;    ZEND_MM_IS_GUARD_BLOCK(ZEND_MM_BLOCK_AT(mm_block, size))) {    zend_mm_del_segment(heap, (zend_mm_segment *) ((char *)mm_block - ZEND_MM_ALIGNED_SEGMENT_SIZE));} else {    ZEND_MM_BLOCK(mm_block, ZEND_MM_FREE_BLOCK, size);    zend_mm_add_to_free_list(heap, (zend_mm_free_block *) mm_block);}</code></pre><p>这段代码逻辑比较清晰，主要是根据当前要销毁的内存块mm_block在zend_mm_heap 双向链表中所处的位置进行不同的操作。如果下一个节点还是free的内存，则将下一个节点合并; 如果上一相邻节点内存块为free，则合并到上一个节点; 如果只是普通节点，刚使用 zend_mm_add_to_free_list或者zend_mm_del_segment 进行回收。</p><p>就这样，ZendMM将内存块以整理收回到zend_mm_heap的方式，回收到内存池中。 程序使用的所有内存，将在进程结束时统一交还给系统。在内存的销毁过程中，还涉及到引用计数和垃圾回收（GC），将在下一小节进行讨论。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45-PHP的内存管理</title>
      <link href="/posts/524450fa.html"/>
      <url>/posts/524450fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="45-PHP的内存管理"><a href="#45-PHP的内存管理" class="headerlink" title="45-PHP的内存管理"></a>45-PHP的内存管理</h1><p>内存管理一般会包括以下内容：</p><ul><li>是否有足够的内存供我们的程序使用；</li><li>如何从足够可用的内存中获取部分内存；</li><li>对于使用后的内存，是否可以将其销毁并将其重新分配给其它程序使用。</li></ul><p>与此对应，PHP的内容管理也包含这样的内容，只是这些内容在ZEND内核中是以宏的形式作为接口提供给外部使用。 后面两个操作分别对应emalloc宏，efree宏，而第一个操作可以根据emalloc宏返回结果检测。</p><p>PHP的内存管理可以被看作是分层（hierarchical）的。 它分为三层：存储层（storage）、堆层（heap）和接口层（emalloc/efree）。 存储层通过 malloc()、mmap() 等函数向系统真正的申请内存，并通过 free() 函数释放所申请的内存。 存储层通常申请的内存块都比较大，这里申请的内存大并不是指storage层结构所需要的内存大， 只是堆层通过调用存储层的分配方法时，其以大块大块的方式申请的内存，存储层的作用是将内存分配的方式对堆层透明化。 如下图所示，PHP内存管理器。PHP在存储层共有4种内存分配方案: malloc，win32，mmap_anon，mmap_zero， 默认使用malloc分配内存，如果设置了ZEND_WIN32宏，则为windows版本，调用HeapAlloc分配内存， 剩下两种内存方案为匿名内存映射，并且PHP的内存方案可以通过设置环境变量来修改。</p><center><br><img src="images/2012_02_24_04.jpg" alt><br></center><br><center><br>PHP内存管理器<br></center><p>首先我们看下接口层的实现，接口层是一些宏定义，如下：</p><pre><code>/* Standard wrapper macros */#define emalloc(size)                       _emalloc((size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define safe_emalloc(nmemb, size, offset)   _safe_emalloc((nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define efree(ptr)                          _efree((ptr) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define ecalloc(nmemb, size)                _ecalloc((nmemb), (size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define erealloc(ptr, size)                 _erealloc((ptr), (size), 0 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define safe_erealloc(ptr, nmemb, size, offset) _safe_erealloc((ptr), (nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define erealloc_recoverable(ptr, size)     _erealloc((ptr), (size), 1 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define estrdup(s)                          _estrdup((s) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define estrndup(s, length)                 _estrndup((s), (length) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)#define zend_mem_block_size(ptr)            _zend_mem_block_size((ptr) TSRMLS_CC ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</code></pre><p>这里为什么没有直接调用函数？因为这些宏相当于一个接口层或中间层，定义了一个高层次的接口，使得调用更加容易它隔离了外部调用和PHP内存管理的内部实现，实现了一种松耦合关系。虽然PHP不限制这些函数的使用， 但是官方文档还是建议使用这些宏。这里的接口层有点门面模式(facade模式)的味道。</p><p>在接口层下面是PHP内存管理的核心实现，我们称之为heap层。 这个层控制整个PHP内存管理的过程，首先我们看这个层的结构：</p><pre><code>/* mm block type */typedef struct _zend_mm_block_info {    size_t _size;   /* block的大小*/    size_t _prev;   /* 计算前一个块有用到*/} zend_mm_block_info;typedef struct _zend_mm_block {    zend_mm_block_info info;} zend_mm_block;typedef struct _zend_mm_small_free_block {  /* 双向链表 */    zend_mm_block_info info;    struct _zend_mm_free_block *prev_free_block;    /* 前一个块 */    struct _zend_mm_free_block *next_free_block;    /* 后一个块 */} zend_mm_small_free_block; /* 小的空闲块*/typedef struct _zend_mm_free_block {    /* 双向链表 + 树结构 */    zend_mm_block_info info;    struct _zend_mm_free_block *prev_free_block;    /* 前一个块 */    struct _zend_mm_free_block *next_free_block;    /* 后一个块 */    struct _zend_mm_free_block **parent;    /* 父结点 */    struct _zend_mm_free_block *child[2];   /* 两个子结点*/} zend_mm_free_block;struct _zend_mm_heap {    int                 use_zend_alloc; /* 是否使用zend内存管理器 */    void               *(*_malloc)(size_t); /* 内存分配函数*/    void                (*_free)(void*);    /* 内存释放函数*/    void               *(*_realloc)(void*, size_t);    size_t              free_bitmap;    /* 小块空闲内存标识 */    size_t              large_free_bitmap;  /* 大块空闲内存标识*/    size_t              block_size;     /* 一次内存分配的段大小，即ZEND_MM_SEG_SIZE指定的大小，默认为ZEND_MM_SEG_SIZE   (256 * 1024)*/    size_t              compact_size;   /* 压缩操作边界值，为ZEND_MM_COMPACT指定大小，默认为 2 * 1024 * 1024*/    zend_mm_segment    *segments_list;  /* 段指针列表 */    zend_mm_storage    *storage;    /* 所调用的存储层 */    size_t              real_size;  /* 堆的真实大小 */    size_t              real_peak;  /* 堆真实大小的峰值 */    size_t              limit;  /* 堆的内存边界 */    size_t              size;   /* 堆大小 */    size_t              peak;   /* 堆大小的峰值*/    size_t              reserve_size;   /* 备用堆大小*/    void               *reserve;    /* 备用堆 */    int                 overflow;   /* 内存溢出数*/    int                 internal;#if ZEND_MM_CACHE    unsigned int        cached; /* 已缓存大小 */    zend_mm_free_block *cache[ZEND_MM_NUM_BUCKETS]; /* 缓存数组/#endif    zend_mm_free_block *free_buckets[ZEND_MM_NUM_BUCKETS*2];    /* 小块内存数组，相当索引的角色 */    zend_mm_free_block *large_free_buckets[ZEND_MM_NUM_BUCKETS];    /* 大块内存数组，相当索引的角色 */    zend_mm_free_block *rest_buckets[2];    /* 剩余内存数组*/};</code></pre><p>当初始化内存管理时，调用函数是zend_mm_startup。它会初始化storage层的分配方案， 初始化段大小，压缩边界值，并调用zend_mm_startup_ex()初始化堆层。 这里的分配方案就是图6.1所示的四种方案，它对应的环境变量名为：ZEND_MM_MEM_TYPE。 这里的初始化的段大小可以通过ZEND_MM_SEG_SIZE设置，如果没设置这个环境变量，程序中默认为256 * 1024。 这个值存储在_zend_mm_heap结构的block_size字段中，将来在维护的三个列表中都没有可用的内存中，会参考这个值的大小来申请内存的大小。</p><p>PHP中的内存管理主要工作就是维护三个列表：小块内存列表（free_buckets）、 大块内存列表（large_free_buckets）和剩余内存列表（rest_buckets）。 看到bucket这个单词是不是很熟悉？在前面我们介绍HashTable时，这就是一个重要的角色，它作为HashTable中的一个单元角色。 在这里，每个bucket也对应一定大小的内存块列表，这样的列表都包含双向链表的实现。</p><p>我们可以把维护的前面两个表看作是两个HashTable，那么，每个HashTable都会有自己的hash函数。 首先我们来看free_buckets列表，这个列表用来存储小块的内存分配，其hash函数为：</p><pre><code>#define ZEND_MM_BUCKET_INDEX(true_size)     ((true_size&gt;&gt;ZEND_MM_ALIGNMENT_LOG2)-(ZEND_MM_ALIGNED_MIN_HEADER_SIZE&gt;&gt;ZEND_MM_ALIGNMENT_LOG2))</code></pre><p>假设ZEND_MM_ALIGNMENT为8（如果没有特殊说明，本章的ZEND_MM_ALIGNMENT的值都为8），则ZEND_MM_ALIGNED_MIN_HEADER_SIZE=16， 若此时true_size=256，则((256&gt;&gt;3)-(16&gt;&gt;3))= 30。 当ZEND_MM_BUCKET_INDEX宏出现时，ZEND_MM_SMALL_SIZE宏一般也会同时出现， ZEND_MM_SMALL_SIZE宏的作用是判断所申请的内存大小是否为小块的内存， 在上面的示例中，小于272Byte的内存为小块内存，则index最多只能为31， 这样就保证了free_buckets不会出现数组溢出的情况。</p><p>在内存管理初始化时，PHP内核对初始化free_buckets列表。 从heap的定义我们可知free_buckets是一个数组指针，其存储的本质是指向zend_mm_free_block结构体的指针。 开始时这些指针都没有指向具体的元素，只是一个简单的指针空间。 free_buckets列表在实际使用过程中只存储指针，这些指针以两个为一对（即数组从0开始，两个为一对），分别存储一个个双向链表的头尾指针。 其结构如下图所示。</p><center><br><img src="images/2012_02_24_05.jpg" alt><br></center><p>对于free_buckets列表位置的获取，关键在于ZEND_MM_SMALL_FREE_BUCKET宏，宏代码如下：</p><pre><code>#define ZEND_MM_SMALL_FREE_BUCKET(heap, index) \(zend_mm_free_block*) ((char*)&amp;heap-&gt;free_buckets[index * 2] + \    sizeof(zend_mm_free_block*) * 2 - \    sizeof(zend_mm_small_free_block))</code></pre><p>仔细看这个宏实现，发现在它的计算过程是取free_buckets列表的偶数位的内存地址加上 两个指针的内存大小并减去zend_mm_small_free_block结构所占空间的大小。 而zend_mm_free_block结构和zend_mm_small_free_block结构的差距在于两个指针。 据此计算过程可知，ZEND_MM_SMALL_FREE_BUCKET宏会获取free_buckets列表 index对应双向链表的第一个zend_mm_free_block的prev_free_block指向的位置。 free_buckets的计算仅仅与prev_free_block指针和next_free_block指针相关， 所以free_buckets列表也仅仅需要存储这两个指针。</p><p>那么，这个数组在最开始是怎样的呢？ 在初始化函数zend_mm_init中free_buckets与large_free_buckts列表一起被初始化。 如下代码：</p><pre><code>p = ZEND_MM_SMALL_FREE_BUCKET(heap, 0);for (i = 0; i &lt; ZEND_MM_NUM_BUCKETS; i++) {    p-&gt;next_free_block = p;    p-&gt;prev_free_block = p;    p = (zend_mm_free_block*)((char*)p + sizeof(zend_mm_free_block*) * 2);    heap-&gt;large_free_buckets[i] = NULL;}</code></pre><p>对于free_buckets列表来说，在循环中，偶数位的元素（索引从0开始）将其next_free_block和prev_free_block都指向自己， 以i=0为例，free_buckets的第一个元素(free_buckets[0])存储的是第二个元素(free_buckets[1])的地址， 第二个元素存储的是第一个元素的地址。 此时将可能会想一个问题，在整个free_buckets列表没有内容时，ZEND_MM_SMALL_FREE_BUCKET在获取第一个zend_mm_free_block时， 此zend_mm_free_block的next_free_block元素和prev_free_block元素却分别指向free_buckets[0]和free_buckets[1]。</p><p>在整个循环初始化过程中都没有free_buckets数组的下标操作，它的移动是通过地址操作，以加两个sizeof(zend_mm_free_block<em>)实现， 这里的sizeof(zend_mm_free_block</em>)是获取指针的大小。比如现在是在下标为0的元素的位置， 加上两个指针的值后，指针会指向下标为2的地址空间，从而实现数组元素的向后移动， 也就是zend_mm_free_block-&gt;next_free_block和zend_mm_free_block-&gt;prev_free_block位置的后移。 这种不存储zend_mm_free_block数组，仅存储其指针的方式不可不说精妙。虽然在理解上有一些困难，但是节省了内存。</p><p>free_buckets列表使用free_bitmap标记是否该双向链表已经使用过时有用。 当有新的元素需要插入到列表时，需要先根据块的大小查找index， 查找到index后，在此index对应的双向链表的头部插入新的元素。</p><p>free_buckets列表的作用是存储小块内存，而与之对应的large_free_buckets列表的作用是存储大块的内存， 虽然large_free_buckets列表也类似于一个hash表，但是这个与前面的free_buckets列表一些区别。 它是一个集成了数组，树型结构和双向链表三种数据结构的混合体。 我们先看其数组结构，数组是一个hash映射，其hash函数为：</p><pre><code>#define ZEND_MM_LARGE_BUCKET_INDEX(S) zend_mm_high_bit(S)static inline unsigned int zend_mm_high_bit(size_t _size){..//省略若干不同环境的实现    unsigned int n = 0;    while (_size != 0) {        _size = _size &gt;&gt; 1;        n++;    }    return n-1;}</code></pre><p>这个hash函数用来计算size的位数，返回值为size二进码中1的个数-1。 假设此时size为512Byte，则这段内存会放在large_free_buckets列表， 512的二进制码为1000000000，其中仅包含一个1，则其对应的列表index为0。 关于右移操作，这里有一点说明：</p><p>一般来说，右移分为逻辑右移和算术右移。逻辑位移在在左端补K个0，算术右移在左端补K个最高有效位的值。 C语言标准没有明确定义应该使用哪种方式。对于无符号数据，右移必须是逻辑的。对于有符号的数据，则二者都可以。 但是，现实中都会默认为算术右移。</p><p>我们通过一次列表的元素插入操作来理解列表的结果。 首先确定当前需要内存所在的数组元素位置，然后查找此内存大小所在的位置。 这个查找行为是发生在树型结构中，而树型结构的位置与内存的大小有关。 其查找过程如下：</p><ul><li>第一步 通过索引获取树型结构第一个结点并作为当前结点，如果第一个结点为空，则将内存放到第一个元素的结点位置，返回，否则转第二步</li><li>第二步 从当前结点出发，查找下一个结点，并将其作为当前结点</li><li>第三步 判断当前结点内存的大小与需要分配的内存大小是否一样 如果大小一样则以双向链表的结构将新的元素添加到结点元素的后面第一个元素的位置。否则转四步</li><li>第四步 判断当前结点是否为空，如果为空，则占据结点位置，结束查找，否则第二步。</li></ul><p>从以上的过程我们可以画出large_free_buckets列表的结构如下图所示：</p><center><br><img src="images/2012_02_24_06.jpg" alt><br></center><br><center><br>large_free_buckets列表结构<br></center><p>从内存分配的过程中可以看出，内存块查找判断顺序依次是小块内存列表，大块内存列表，剩余内存列表。 在heap结构中，剩余内存列表对应rest_buckets字段，这是一个包含两个元素的数组， 并且也是一个双向链表队列，其中rest_buckets[0]为队列的头，rest_buckets[1]为队列的尾。 而我们常用的插入和查找操作是针对第一个元素，即heap-&gt;rest_buckets[0]， 当然，这是一个双向链表队列，队列的头和尾并没有很明显的区别。它们仅仅是作为一种认知上的区分。 在添加内存时，如果所需要的内存块的大小大于初始化时设置的ZEND_MM_SEG_SIZE的值（在heap结构中为block_size字段） 与ZEND_MM_ALIGNED_SEGMENT_SIZE(等于8)和ZEND_MM_ALIGNED_HEADER_SIZE(等于8)的和的差，则会将新生成的块插入 rest_buckts所在的双向链表中，这个操作和前面的双向链表操作一样，都是从”队列头“插入新的元素。 此列表的结构和free_bucket类似，只是这个列表所在的数组没有那么多元素，也没有相应的hash函数。</p><p>在heap层下面是存储层，存储层的作用是将内存分配的方式对堆层透明化，实现存储层和heap层的分离。 在PHP的源码中有注释显示相关代码为”Storage Manager”。 存储层的主要结构代码如下：</p><pre><code>/* Heaps with user defined storage */typedef struct _zend_mm_storage zend_mm_storage;typedef struct _zend_mm_segment {    size_t    size;    struct _zend_mm_segment *next_segment;} zend_mm_segment;typedef struct _zend_mm_mem_handlers {    const char *name;    zend_mm_storage* (*init)(void *params);    //    初始化函数    void (*dtor)(zend_mm_storage *storage);    //    析构函数    void (*compact)(zend_mm_storage *storage);    zend_mm_segment* (*_alloc)(zend_mm_storage *storage, size_t size);    //    内存分配函数    zend_mm_segment* (*_realloc)(zend_mm_storage *storage, zend_mm_segment *ptr, size_t size);    //    重新分配内存函数    void (*_free)(zend_mm_storage *storage, zend_mm_segment *ptr);    //    释放内存函数} zend_mm_mem_handlers;struct _zend_mm_storage {    const zend_mm_mem_handlers *handlers;    //    处理函数集    void *data;};</code></pre><p>以上代码的关键在于存储层处理函数的结构体，对于不同的内存分配方案，所不同的就是内存分配的处理函数。 其中以name字段标识不同的分配方案。在图6.1中，我们可以看到PHP在存储层共有4种内存分配方案: malloc，win32，mmap_anon，mmap_zero默认使用malloc分配内存， 如果设置了ZEND_WIN32宏，则为windows版本，调用HeapAlloc分配内存，剩下两种内存方案为匿名内存映射， 并且PHP的内存方案可以通过设置变量来修改。其官方说明如下：</p><pre><code>The Zend MM can be tweaked using ZEND_MM_MEM_TYPE and ZEND_MM_SEG_SIZE environmentvariables. Default values are “malloc” and “256K”. Dependent on target system youcan also use “mmap_anon”, “mmap_zero” and “win32″ storage managers.</code></pre><p>在代码中，对于这4种内存分配方案，分别对应实现了zend_mm_mem_handlers中的各个处理函数。 配合代码的简单说明如下：</p><pre><code>/* 使用mmap内存映射函数分配内存 写入时拷贝的私有映射，并且匿名映射，映射区不与任何文件关联。*/# define ZEND_MM_MEM_MMAP_ANON_DSC {&quot;mmap_anon&quot;, zend_mm_mem_dummy_init, zend_mm_mem_dummy_dtor, zend_mm_mem_dummy_compact, zend_mm_mem_mmap_anon_alloc, zend_mm_mem_mmap_realloc, zend_mm_mem_mmap_free}/* 使用mmap内存映射函数分配内存 写入时拷贝的私有映射，并且映射到/dev/zero。*/# define ZEND_MM_MEM_MMAP_ZERO_DSC {&quot;mmap_zero&quot;, zend_mm_mem_mmap_zero_init, zend_mm_mem_mmap_zero_dtor, zend_mm_mem_dummy_compact, zend_mm_mem_mmap_zero_alloc, zend_mm_mem_mmap_realloc, zend_mm_mem_mmap_free}/* 使用HeapAlloc分配内存 windows版本 关于这点，注释中写的是VirtualAlloc() to allocate memory，实际在程序中使用的是HeapAlloc*/# define ZEND_MM_MEM_WIN32_DSC {&quot;win32&quot;, zend_mm_mem_win32_init, zend_mm_mem_win32_dtor, zend_mm_mem_win32_compact, zend_mm_mem_win32_alloc, zend_mm_mem_win32_realloc, zend_mm_mem_win32_free}/* 使用malloc分配内存 默认为此种分配 如果有加ZEND_WIN32宏，则使用win32的分配方案*/# define ZEND_MM_MEM_MALLOC_DSC {&quot;malloc&quot;, zend_mm_mem_dummy_init, zend_mm_mem_dummy_dtor, zend_mm_mem_dummy_compact, zend_mm_mem_malloc_alloc, zend_mm_mem_malloc_realloc, zend_mm_mem_malloc_free}static const zend_mm_mem_handlers mem_handlers[] = {#ifdef HAVE_MEM_WIN32    ZEND_MM_MEM_WIN32_DSC,#endif#ifdef HAVE_MEM_MALLOC    ZEND_MM_MEM_MALLOC_DSC,#endif#ifdef HAVE_MEM_MMAP_ANON    ZEND_MM_MEM_MMAP_ANON_DSC,#endif#ifdef HAVE_MEM_MMAP_ZERO    ZEND_MM_MEM_MMAP_ZERO_DSC,#endif    {NULL, NULL, NULL, NULL, NULL, NULL}};</code></pre><p>假设我们使用的是win32内存方案，则在PHP编译时，编译器会选择将ZEND_MM_MEM_WIN32_DSC宏所代码的所有处理函数赋值给mem_handlers。 在之后我们调用内存分配时，将会使用此数组中对应的相关函数。当然，在指定环境变量 USE_ZEND_ALLOC 时，可用于允许在运行时选择 malloc 或 emalloc 内存分配。 使用 malloc-type 内存分配将允许外部调试器观察内存使用情况，而 emalloc 分配将使用 Zend 内存管理器抽象，要求进行内部调试。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44-Zend内存管理器</title>
      <link href="/posts/4cb0ca52.html"/>
      <url>/posts/4cb0ca52.html</url>
      
        <content type="html"><![CDATA[<h1 id="44-Zend内存管理器"><a href="#44-Zend内存管理器" class="headerlink" title="44-Zend内存管理器"></a>44-Zend内存管理器</h1><p>在PHP里，我们可以定义字符串变量，比如 &lt;?php $str=”nowamagic”; ?&gt;，$str这个字符串变量可以被自由的修改与复制等。这一切在C语言里看起来都是不可能的事情，我们用#char *p = “hello”;#来定义一个字符串，但它是常量，是不能被修改的，如果你用p[1]=’c’;来修改这个字符串会引发段错误(Gcc,c99)，为了修改C语言里的字符串常量，我们往往需要定义字符串数组。为了得到一个能够让我们自由修改的字符串，我们往往需要用strdup函数来复制一个字符串出来。</p><pre><code>{    char *p = &quot;hello world&quot;;    // p[0] = &apos;a&apos;; 如果这么做，就等着运行时段错误吧。    char *str;    str = strdup(p);    str[0] = &apos;a&apos;; //这时就能自由修改了。}</code></pre><p>在PHP内核中，大多数情况下都不应改直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。</p><h2 id="Free-the-Mallocs"><a href="#Free-the-Mallocs" class="headerlink" title="Free the Mallocs"></a>Free the Mallocs</h2><p>每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。那么，我们就称其为”内存泄漏”，那么这部分内存就无法再为其它程序所用了。</p><p>在一个典型的客户端应用程序中，偶尔的小量的内存泄漏是可以被操作系统容忍的，因为在进程结束后该泄漏内存会被返回给OS。这并没有什么高科技含量，因为OS知道它把该内存分配给了哪个程序，并且它能够在一个程序结束后把这些内存给回收回来。</p><p>但是，世界总是不缺乏特例！对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。现在，我们来在C语言中故意错误的模拟一下PHP的stristr()函数为例，为了使用大小写不敏感的方式来搜索一个字符串，我们需要创建两个辅助的字符串，它们分别是被查找字符串和待查找字符串的小写化副本，然后由这两个副本来帮助我们来完成这次搜索。如果我们在执行这个函数后不释放这些副本占用的资源，那么每一次stristr函数都将是对内存的一次永远的侵占，最终导致这个函数占用了所有的系统内存，而没有实际意义！</p><p>大多数人提出来的理想的解决方案是：书写优秀，整洁并且风格一致的代码，这当然是毫无疑问的。但是在PHP扩展开发这样的底层环境中，这并不能解决全部的问题。比如，你需要自己保证在层层嵌套调用中对某块内存的使用都是正确的，且会及时释放的。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>为了实现从用户端(PHP语言中)”跳出”，需要使用一种方法来完全”跳出”一个活动请求。这个功能是在内核中实现的：在一个请求的开始设置一个”跳出”地址，然后在任何die()或exit()调用或在遇到任何关键错误(E_ERROR)时执行一个longjmp()以跳转到该”跳出”地址。</p><pre><code>void call_function(const char *fname, int fname_len TSRMLS_DC){    zend_function *fe;    char *lcase_fname;    /* php函数的名字是大小写不敏感的     * 我们可以在function tables里找到他们     * 保存的所有函数名都是小写的。     */    lcase_fname = estrndup(fname, fname_len);    zend_str_tolower(lcase_fname, fname_len);    if (zend_hash_find(EG(function_table),lcase_fname, fname_len + 1, (void **)&amp;fe) == FAILURE)    {        zend_execute(fe-&gt;op_array TSRMLS_CC);    }    else    {        php_error_docref(NULL TSRMLS_CC, E_ERROR,&quot;Call to undefined function: %s()&quot;, fname);    }    efree(lcase_fname);}</code></pre><p>当php_error_docref这个函数被调用的时候，便会触发内核中的错误处理机制，根据错误级别来决定是否调用longjmp来终止当前请求并退出call_function函数，从而efree函数便永远不会被执行了。</p><p>其实php_error_docref()函数就相当与php语言里的trigger_error()函数.它的第一个参数是一个将被添加到docref的可选的文档引用第三个参数可以是任何我们熟悉的E_*家族常量，用于指示错误的严重程度。后面的两个参数就像printf()风格的格式化和变量参数列表式样。</p><h2 id="Zend内存管理器"><a href="#Zend内存管理器" class="headerlink" title="Zend内存管理器"></a>Zend内存管理器</h2><p>在上面的”跳出”请求期间解决内存泄漏的方案之一是：使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是”请求感知”的；这样以来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。下图展示了ZendMM与OS以及PHP进程之间的关系。</p><center><br><img src="images/2012_02_24_03.jpg" alt><br></center><p>除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。</p><p>把PHP内核代码和OS的实际的内存管理层”钩”在一起的原理并不复杂：所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求”跳出”时，ZendMM可以隐式地释放它。</p><p>有些事后，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为”永久性分配”），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。</p><p>如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。</p><p>例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：</p><pre><code>//define in Zend/zend_alloc.h:#define pemalloc(size, persistent)    ((persistent)?malloc(size): emalloc(size))</code></pre><p>所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。</p><table><br><tr><td>C语言原生函数</td><td>PHP内核封装后的函数</td></tr><br><tr><td><br>void <em>malloc(size_t count);<br></em></td><td><br>void emalloc(size_t count);<br>void <em>pemalloc(size_t count, char persistent);<br></em></td></tr><br><tr><td><br>void calloc(size_t count);<br></td><td><br>void <em>ecalloc(size_t count);<br>void </em>pecalloc(size_t count, char persistent);<br></td></tr><br><tr><td><br>void <em>realloc(void </em>ptr, size_t count);<br></td><td><br>void <em>erealloc(void </em>ptr, size_t count);<br>void <em>perealloc(void </em>ptr, size_t count, char persistent);<br></td></tr><br><tr><td><br>void <em>strdup(void </em>ptr);<br></td><td><br>void <em>estrdup(void </em>ptr);<br>void <em>pestrdup(void </em>ptr, char persistent);<br></td></tr><br><tr><td><br>void free(void <em>ptr);<br></em></td><td><br>void efree(void ptr);<br>void pefree(void *ptr, char persistent);<br></td></tr><br></table><p>你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。</p><p>除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如：</p><pre><code>void *estrndup(void *ptr，int len);</code></pre><p>该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：</p><pre><code>ZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC){    char *p;    p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);    if (UNEXPECTED(p == NULL))    {        return p;    }    memcpy(p, s, length);    p[length] = 0;    return p;}</code></pre><p>在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。</p><pre><code>void *safe_emalloc(size_t size, size_t count, size_t addtl);void *safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);</code></pre><p>这些函数分配的内存空间最终大小都是((size*count)+addtl)。你可以会问：”为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？”原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一”可能性相当小”的结果导致宿主平台的内存溢出。这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。</p><p>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43-内存管理开篇</title>
      <link href="/posts/1e922daf.html"/>
      <url>/posts/1e922daf.html</url>
      
        <content type="html"><![CDATA[<h1 id="43-内存管理开篇"><a href="#43-内存管理开篇" class="headerlink" title="43-内存管理开篇"></a>43-内存管理开篇</h1><p>内存是计算机非常关键的部件之一，是暂时存储程序以及数据的空间，CPU只有有限的寄存器可以用于存储计算数据，而大部分的数据都是存储在内存中的，程序运行都是在内存中进行的。和CPU计算能力一样， 内存也是决定计算效率的一个关键部分。</p><p>计算中的资源中主要包含：CPU计算能力，内存资源以及I/O。现代计算机为了充分利用资源， 而出现了多任务操作系统，通过进程调度来共享CPU计算资源，通过虚拟存储来分享内存存储能力。 本章的内存管理中不会介绍操作系统级别的虚拟存储技术，而是关注在应用层面： 如何高效的利用有限的内存资源。</p><p>目前除了使用C/C++等这类的低层编程语言以外，很多编程语言都将内存管理移到了语言之后， 例如Java, 各种脚本语言：PHP/Python/Ruby等等，程序手动维护内存的成本非常大， 而这些脚本语言或新型语言都专注于特定领域，这样能将程序员从内存管理中解放出来专注于业务的实现。 虽然程序员不需要手动维护内存，而在程序运行过程中内存的使用还是要进行管理的， 内存管理的工作也就编程语言实现程序员的工作了。</p><p>内存管理的主要工作是尽可能高效的利用内存。</p><p>内存的使用操作包括申请内存，销毁内存，修改内存的大小等。 如果申请了内存在使用完后没有及时释放则可能会造成内存泄露，如果这种情况出现在常驻程序中， 久而久之，程序会把机器的内存耗光。所以对于类似于PHP这样没有低层内存管理的语言来说， 内存管理是其至关重要的一个模块，它在很大程序上决定了程序的执行效率，</p><p>在PHP层面来看，定义的变量、类、函数等等实体在运行过程中都会涉及到内存的申请和释放， 例如变量可能会在超出作用域后会进行销毁，在计算过程中会产生的临时数据等都会有内存操作， 像类对象，函数定义等数据则会在请求结束之后才会被释放。在这过程中合适申请内存合适释放内存就比较关键了。 PHP从开始就有一套属于自己的内存管理机制，在5.3之前使用的是经典的引用计数技术， 但引用技术存在一定的技术缺陷，在PHP5.3之后，引入了新的垃圾回收机制，至此，PHP的内存管理机制更加完善。</p><p>从某个意义上讲，资源总是有限的，计算机资源也是如此，衡量一个计算机处理能里的指标有很多， 同时也根据不同的应用需要会有不同的指标，比如3D游戏对显卡就有些要求，而Web服务器对吞吐量及响应时间有要求， 通常CPU、内存及硬盘的读取和计算速度具有决定性的作用，在同一时刻这些资源是有限的， 真是因为有限我们才需要合理的利用他们。</p><h2 id="操作系统的内存管理"><a href="#操作系统的内存管理" class="headerlink" title="操作系统的内存管理"></a>操作系统的内存管理</h2><p>当计算机的电源被打开之后，不管你使用的是什么操作系统，这些软件可能已经在使用内存了。 这是由计算机的结构决定的，操作系统也是一种软件，只不过它是比较特殊的软件， 管理计算机的所有资源，普通应用程序和操作系统的关系有点像老师和学生，老师通常管理一切， 而学生的行为会收到老师或学校规定的限制，例如应用程序无法直接访问物理内存或者其他硬件资源。</p><p>操作系统直接管理着内存，所以操作系统也需要进行内存管理，内存管理是如此之重要， 计算机中通常都有内存管理单元(MMU) 用于处理CPU对内存的访问。</p><h2 id="应用层的内存管理"><a href="#应用层的内存管理" class="headerlink" title="应用层的内存管理"></a>应用层的内存管理</h2><p>由于计算机的内存由操作系统进行管理，所以普通应用程序是无法直接对内存进行访问的， 应用程序只能向操作系统申请内存，通常的应用也是这么做的，在需要的时候通过类似malloc之类的库函数 想操作系统申请内存，在一些对性能要求较高的应用场景下是需要频繁的使用和释放内存的， 比如Web服务器，编程语言等，由于向操作系统申请内存空间会引发系统调用， 系统调用和普通的应用层函数调用差别非常大，因为系统调用会将CPU从用户态切换到内核， 因为涉及到物理内存的操作，只有操作系统才能进行，而这种切换的成本是非常大的， 如果频繁的在内核态和用户态之间切换会产生性能问题。</p><p>鉴于系统调用的开销，一些对性能有要求的应用通常会自己在用户态进行内存管理， 例如第一次申请稍大的内存留着备用，而使用完释放的内存并不是马上归还给操作系统， 比如可以将内存进行复用，这样也可以避免多次的内存申请和释放。</p><p>PHP不需要显式的对内存进行管理，这些工作都由PHP解释器进行了。由此PHP内部有一个内存管理体系， 它会自动将不再使用的内存垃圾进行释放，这部分的内容后面的小节会介绍到。</p><h2 id="PHP中内存相关的功能特性"><a href="#PHP中内存相关的功能特性" class="headerlink" title="PHP中内存相关的功能特性"></a>PHP中内存相关的功能特性</h2><p>可能有的读者碰到过类似下面的错误吧：</p><pre><code>Fatal error: Allowed memory size of X bytes exhausted (tried to allocate Y bytes)</code></pre><p>这个错误的信息很明确，PHP已经达到了允许使用的最大内存了，通常上来说这很有可能是我们的程序编写的有些问题。 比如：一次性读取超大的文件到内存中，或者出现超大的数组，或者在大循环中的没有及时是放掉不再使用的变量， 这些都有可能会造成内存占用过大而被终止。</p><p>PHP默认的最大内存使用大小是32M, 如果你真的需要使用超过32M的内存可以修改php.ini配置文件的如下配置：</p><pre><code>memory_limit = 32M</code></pre><p>如果你无法修改php配置文件，同时你的PHP环境没有禁用ini_set()函数，也可以动态的修改最大的内存占用大小：</p><pre><code>&lt;?phpini_set(&quot;memory_limit&quot;, &quot;128M&quot;);?&gt;</code></pre><p>既然我们能动态的调整最大的内存占用，那我们是否有办法获取目前的内存占用情况呢？答案是肯定的。</p><ol><li>memory_get_usage()，这个函数的作用是获取 目前PHP脚本所用的内存大小。</li><li>memory_get_peak_usage()，这个函数的作用返回 当前脚本到目前位置所占用的内存峰值，这样就可能获取到目前的脚本的内存需求情况。</li></ol><p>单就PHP用户空间提供的功能来说，我们似乎无法控制内存的使用，只能被动的获取内存的占用情况， 这样的话我们学习内存管理有什么用呢？</p><p>前面的章节有介绍到引用计数，函数表，符号表，常量表等。当我们明白这些信息都会占用内存的时候， 我们可以有意的避免不必要的浪费内存，比如我们在项目中通常会使用autoload来避免一次性把不一定会使用的类 包含进来，而这些信息是会占用内存的，如果我们及时把不再使用的变量unset掉之后可能会释放掉它所占用的空间，</p><p>后面的章节主要介绍PHP在运行时的内存使用和管理细节。这也能帮助我们写出更为内存友好的PHP代码。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42-变量类型的转换</title>
      <link href="/posts/d8f25252.html"/>
      <url>/posts/d8f25252.html</url>
      
        <content type="html"><![CDATA[<h1 id="42-变量类型的转换"><a href="#42-变量类型的转换" class="headerlink" title="42-变量类型的转换"></a>42-变量类型的转换</h1><p>PHP是弱类型的动态语言，在前面的章节中我们已经介绍了PHP的变量都存放在一个名为ZVAL的容器中， ZVAL包含了变量的类型和各种类型变量的值。 PHP中的变量不需要显式的数据类型定义，可以给变量赋值任意类型的数据， PHP变量之间的数据类型转换有两种：隐式和显式转换。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>隐式类型转换也被称为自动类型转换，是指不需要程序员书写代码，由编程语言自动完成的类型转换。 在PHP中，我们经常遇到的隐式转换有：</p><h3 id="1．直接的变量赋值操作"><a href="#1．直接的变量赋值操作" class="headerlink" title="1．直接的变量赋值操作"></a>1．直接的变量赋值操作</h3><p>在PHP中，直接对变量的赋值操作是隐式类型转换最简单的方式，也是我们最常见的一种方式，或许我们已经习以为常，从而没有感觉到变量的变化。 在直接赋值的操作中，变量的数据类型由赋予的值决定，即左值的数据类型由右值的数据类型决定。 比如，当把一个字符串类型的数据赋值给变量时，不管该变量以前是什么类型的变量，此时该变量就是一个字符串类型的变量。 看一段代码：</p><pre><code>$string = &quot;To love someone sincerely means to love all the people,  to love the world and life,  too.&quot;$integer = 10;$string = $integer;</code></pre><p>上面的代码，当执行完第三行代码，$string变量的类型就是一个整形了。 通过VLD扩展可以查到第三次赋值操作的中间代码及操作数的类型，再找到赋值的最后实现为zend_assign_to_variable函数。 这在前面的小节中已经详细介绍过了。我们这个例子是很简单的一种赋值，在源码中是直接将$string的ZVAL容器的指针指向$integer变量指向的指针， 并将$integer的引用计数加1。这个操作在本质上改变了$string变量的内容，而原有的变量内容则被垃圾收集机制回收。关于赋值的具体细节，请返回上一节查看。</p><h3 id="2．运算式结果对变量的赋值操作"><a href="#2．运算式结果对变量的赋值操作" class="headerlink" title="2．运算式结果对变量的赋值操作"></a>2．运算式结果对变量的赋值操作</h3><p>我们常说的隐式类型转换是将一个表达式的结果赋值给一个变量，在运算的过程中发生了隐式的类型转换。 这种类型转换不仅仅在PHP语言，在其它众多的语言中也有见到，这是我们常规意义上的隐式类型转换。 这种类型转换又分为两种情况：</p><ul><li>表达式的操作数为同一数据类型 这种情况的作用以上面的直接变量的类型转换是同一种情况，只是此时右值变成了表达式的运算结果。</li><li>表达式的操作数不为同的数据类型 这种情况的类型转换发生在表达式的运算符的计算过程中，在源码中也就是发生在运行符的实现过程中。</li></ul><p>看一个字符串和整数的隐式数据类型转换：</p><pre><code>&lt;?php$a = 10;$b = &apos;a string &apos;;echo $a . $b;?&gt;</code></pre><p>上面例子中字符串连接操作就存在自动数据类型转化，$a变量是数值类型，$b变量是字符串类型， 这里$b变量就是隐式(自动)的转换为字符串类型了。通常自动数据类型转换发生在特定的操作上下文中， 类似的还有求和操作”+”。具体的自动类型转换方式和特定的操作有关。 下面就以字符串连接操作为例说明隐式转换的实现：</p><p>脚本执行的时候字符串的连接操作是通过Zend/zend_operators.c文件中的如下函数进行：</p><pre><code>ZEND_API int concat_function(zval *result, zval *op1, zval *op2 TSRMLS_DC) /* {{{ */{                  zval op1_copy, op2_copy;        int use_copy1 = 0, use_copy2 = 0;        if (Z_TYPE_P(op1) != IS_STRING) {                zend_make_printable_zval(op1, &amp;op1_copy, &amp;use_copy1);        }                  if (Z_TYPE_P(op2) != IS_STRING) {                zend_make_printable_zval(op2, &amp;op2_copy, &amp;use_copy2);        }              // 省略}</code></pre><p>可用看出如果字符串链接的两个操作数如果不是字符串的话， 则调用zend_make_printable_zval函数将操作数转换为”printable_zval”也就是字符串。</p><pre><code>ZEND_API void zend_make_printable_zval(zval *expr, zval *expr_copy, int *use_copy){    if (Z_TYPE_P(expr)==IS_STRING) {        *use_copy = 0;        return;    }    switch (Z_TYPE_P(expr)) {        case IS_NULL:            Z_STRLEN_P(expr_copy) = 0;            Z_STRVAL_P(expr_copy) = STR_EMPTY_ALLOC();            break;        case IS_BOOL:            if (Z_LVAL_P(expr)) {                Z_STRLEN_P(expr_copy) = 1;                Z_STRVAL_P(expr_copy) = estrndup(&quot;1&quot;, 1);            } else {                Z_STRLEN_P(expr_copy) = 0;                Z_STRVAL_P(expr_copy) = STR_EMPTY_ALLOC();            }            break;        case IS_RESOURCE:            // ...省略        case IS_ARRAY:            Z_STRLEN_P(expr_copy) = sizeof(&quot;Array&quot;) - 1;            Z_STRVAL_P(expr_copy) = estrndup(&quot;Array&quot;, Z_STRLEN_P(expr_copy));            break;        case IS_OBJECT:                // ... 省略        case IS_DOUBLE:            *expr_copy = *expr;            zval_copy_ctor(expr_copy);            zend_locale_sprintf_double(expr_copy ZEND_FILE_LINE_CC);            break;        default:            *expr_copy = *expr;            zval_copy_ctor(expr_copy);            convert_to_string(expr_copy);            break;    }    Z_TYPE_P(expr_copy) = IS_STRING;    *use_copy = 1;}</code></pre><p>这个函数根据不同的变量类型来返回不同的字符串类型，例如BOOL类型的数据返回0和1， 数组只是简单的返回Array等等，类似其他类型的数据转换也是类型， 都是根据操作数的不同类型的转换为相应的目标类型。在表达式计算完成后，表达式最后会有一个结果， 这个结果的数据类型就是整个表达式的数据类型。当执行赋值操作时，如果再有数据类型的转换发生， 则是直接变量赋值的数据类型转换了。</p><h2 id="显式类型转换-强制类型转换"><a href="#显式类型转换-强制类型转换" class="headerlink" title="显式类型转换(强制类型转换)"></a>显式类型转换(强制类型转换)</h2><p>在前面介绍了隐式类型转换，在我们的日常编码过程也会小心的使用这种转换， 这种不可见的操作可能与我们想象中的不一样，如整形和浮点数之间的转换。 当我们是一定需要某个数据类型的变量时，可以使用强制的数据类型转换，这样在代码的可读性等方面都会好些。 在PHP中的强制类型转换和C中的非常像：</p><pre><code>&lt;?php$double = 20.10;echo (int)$double;?&gt;</code></pre><p>PHP中允许的强制类型有:</p><ul><li>(int), (integer) 转换为整型</li><li>(bool), (boolean) 转换为布尔类型</li><li>(float), (double) 转换为浮点类型</li><li>(string) 转换为字符串</li><li>(array) 转换为数组</li><li>(object) 转换为对象</li><li>(unset) 转换为NULL</li></ul><p>在Zend/zend_operators.c中实现了转换为这些目标类型的实现函数convert_to_*系列函数， 读者自行查看这些函数即可，这些数据类型转换类型中有一个我们比较少见的unset类型转换：</p><pre><code>ZEND_API void convert_to_null(zval *op) /* {{{ */{    if (Z_TYPE_P(op) == IS_OBJECT) {        if (Z_OBJ_HT_P(op)-&gt;cast_object) {            zval *org;            TSRMLS_FETCH();            ALLOC_ZVAL(org);            *org = *op;            if (Z_OBJ_HT_P(op)-&gt;cast_object(org, op, IS_NULL TSRMLS_CC) == SUCCESS) {                zval_dtor(org);                return;            }            *op = *org;            FREE_ZVAL(org);        }    }    zval_dtor(op);    Z_TYPE_P(op) = IS_NULL;}</code></pre><p>转换为NULL非常简单，对变量进行析构操作，然后将数据类型设为IS_NULL即可。 可能读者会好奇(unset)$a和unset($a)这两者有没有关系，其实并没有关系， 前者是将变量$a的类型变为NULL，这只是一个类型的变化，而后者是将这个变量释放，释放后当前作用域内该变量及不存在了。</p><p>除了上面提到的与C语言很像，在其它语言中也经常见到的强制数据转换，PHP中有一个极具PHP特色的强制类型转换。 PHP的标准扩展中提供了两个有用的方法settype()以及gettype()方法，前者可以动态的改变变量的数据类型， gettype()方法则是返回变量的数据类型。在ext/standard/type.c文件中找到settype的实现源码：</p><pre><code>PHP_FUNCTION(settype){    zval **var;    char *type;    int type_len = 0;    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;Zs&quot;, &amp;var, &amp;type, &amp;type_len) == FAILURE) {        return;    }    if (!strcasecmp(type, &quot;integer&quot;)) {        convert_to_long(*var);    } else if (!strcasecmp(type, &quot;int&quot;)) {        convert_to_long(*var);    } else if (!strcasecmp(type, &quot;float&quot;)) {        convert_to_double(*var);    } else if (!strcasecmp(type, &quot;double&quot;)) { /* deprecated */        convert_to_double(*var);    } else if (!strcasecmp(type, &quot;string&quot;)) {        convert_to_string(*var);    } else if (!strcasecmp(type, &quot;array&quot;)) {        convert_to_array(*var);    } else if (!strcasecmp(type, &quot;object&quot;)) {        convert_to_object(*var);    } else if (!strcasecmp(type, &quot;bool&quot;)) {        convert_to_boolean(*var);    } else if (!strcasecmp(type, &quot;boolean&quot;)) {        convert_to_boolean(*var);    } else if (!strcasecmp(type, &quot;null&quot;)) {        convert_to_null(*var);    } else if (!strcasecmp(type, &quot;resource&quot;)) {        php_error_docref(NULL TSRMLS_CC, E_WARNING, &quot;Cannot convert to resource type&quot;);        RETURN_FALSE;    } else {        php_error_docref(NULL TSRMLS_CC, E_WARNING, &quot;Invalid type&quot;);        RETURN_FALSE;    }    RETVAL_TRUE;}</code></pre><p>这个极具PHP特色的强制类型转换就是这个函数，而这个函数是作为一个代理方法存在， 具体的转换规则由各个类型的处理函数处理，不管是自动还是强制类型转换，最终都会调用这些内部转换方法， 这和前面的强制类型转换在本质上是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41-全局变量Global</title>
      <link href="/posts/f979a6f5.html"/>
      <url>/posts/f979a6f5.html</url>
      
        <content type="html"><![CDATA[<h1 id="41-全局变量Global"><a href="#41-全局变量Global" class="headerlink" title="41-全局变量Global"></a>41-全局变量Global</h1><p>global语句的作用是定义全局变量，例如如果想在函数内访问全局作用域内的变量则可以通过global声明来定义。 下面从语法解释开始分析。</p><h2 id="1-词法解析"><a href="#1-词法解析" class="headerlink" title="1. 词法解析"></a>1. 词法解析</h2><p>查看 Zend/zend_language_scanner.l文件，搜索 global关键字。我们可以找到如下代码：</p><pre><code>&lt;ST_IN_SCRIPTING&gt;&quot;global&quot; {return T_GLOBAL;}</code></pre><h2 id="2-语法解析"><a href="#2-语法解析" class="headerlink" title="2. 语法解析"></a>2. 语法解析</h2><p>在词法解析完后，获得了token，此时通过这个token，我们去Zend/zend_language_parser.y文件中查找。找到相关代码如下：</p><pre><code>|   T_GLOBAL global_var_list &apos;;&apos;global_var_list:    global_var_list &apos;,&apos; global_var  { zend_do_fetch_global_variable(&amp;$3, NULL, ZEND_FETCH_GLOBAL_LOCK TSRMLS_CC); }|   global_var                      { zend_do_fetch_global_variable(&amp;$1, NULL, ZEND_FETCH_GLOBAL_LOCK TSRMLS_CC); };</code></pre><p>上面代码中的$3是指global_var（如果不清楚yacc的语法，可以查阅yacc入门类的文章。）</p><p>从上面的代码可以知道，对于全局变量的声明调用的是zend_do_fetch_global_variable函数，查找此函数的实现在Zend/zend_compile.c文件。</p><pre><code>void zend_do_fetch_global_variable(znode *varname, const znode *static_assignment, int fetch_type TSRMLS_DC){        ...//省略        opline-&gt;opcode = ZEND_FETCH_W;      /* the default mode must be Write, since fetch_simple_variable() is used to define function arguments */        opline-&gt;result.op_type = IS_VAR;        opline-&gt;result.u.EA.type = 0;        opline-&gt;result.u.var = get_temporary_variable(CG(active_op_array));        opline-&gt;op1 = *varname;        SET_UNUSED(opline-&gt;op2);        opline-&gt;op2.u.EA.type = fetch_type;        result = opline-&gt;result;        ... // 省略        fetch_simple_variable(&amp;lval, varname, 0 TSRMLS_CC); /* Relies on the fact that the default fetch is BP_VAR_W */        zend_do_assign_ref(NULL, &amp;lval, &amp;result TSRMLS_CC);        CG(active_op_array)-&gt;opcodes[CG(active_op_array)-&gt;last-1].result.u.EA.type |= EXT_TYPE_UNUSED;}/* }}} */</code></pre><p>上面的代码确认了opcode为ZEND_FETCH_W外，还执行了zend_do_assign_ref函数。zend_do_assign_ref函数的实现如下：</p><pre><code>void zend_do_assign_ref(znode *result, const znode *lvar, const znode *rvar TSRMLS_DC) /* {{{ */{        zend_op *opline;       ... //省略        opline = get_next_op(CG(active_op_array) TSRMLS_CC);        opline-&gt;opcode = ZEND_ASSIGN_REF;       ...//省略        if (result) {                opline-&gt;result.op_type = IS_VAR;                opline-&gt;result.u.EA.type = 0;                opline-&gt;result.u.var = get_temporary_variable(CG(active_op_array));                *result = opline-&gt;result;        } else {                /* SET_UNUSED(opline-&gt;result); */                opline-&gt;result.u.EA.type |= EXT_TYPE_UNUSED;        }        opline-&gt;op1 = *lvar;        opline-&gt;op2 = *rvar;}</code></pre><p>从上面的zend_do_fetch_global_variable函数和zend_do_assign_ref函数的实现可以看出， 使用global声明一个全局变量后，其执行了两步操作，ZEND_FETCH_W和ZEND_ASSIGN_REF。</p><h2 id="3-生成并执行中间代码"><a href="#3-生成并执行中间代码" class="headerlink" title="3. 生成并执行中间代码"></a>3. 生成并执行中间代码</h2><p>我们看下ZEND_FETCH_W的最后执行。从代码中我们可以知道：</p><ul><li>ZEND_FETCH_W = 83</li><li>op-&gt;op1.op_type = 4</li><li>op-&gt;op2.op_type = 0</li></ul><p>而计算最后调用的方法在代码中的体现为：</p><pre><code>zend_opcode_handlers[opcode * 25 + zend_vm_decode[op-&gt;op1.op_type] * 5 + zend_vm_decode[op-&gt;op2.op_type]];</code></pre><p>计算，最后调用ZEND_FETCH_W_SPEC_CV_HANDLER函数。即</p><pre><code>static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS){    return zend_fetch_var_address_helper_SPEC_CV(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);}</code></pre><p>在zend_fetch_var_address_helper_SPEC_CV中调用如下代码获取符号表</p><pre><code>target_symbol_table = zend_get_target_symbol_table(opline, EX(Ts), type, varname TSRMLS_CC);</code></pre><p>在zend_get_target_symbol_table函数的实现如下：</p><pre><code>static inline HashTable *zend_get_target_symbol_table(const zend_op *opline, const temp_variable *Ts, int type, const zval *variable TSRMLS_DC){        switch (opline-&gt;op2.u.EA.type) {                ... //  省略                case ZEND_FETCH_GLOBAL:                case ZEND_FETCH_GLOBAL_LOCK:                        return &amp;EG(symbol_table);                        break;               ...  //  省略        }        return NULL;}</code></pre><p>在前面语法分析过程中，程序传递的参数是 ZEND_FETCH_GLOBAL_LOCK，于是如上所示。我们取&amp;EG(symbol_table);的值。这也是全局变量的存放位置。</p><p>如上就是整个global的解析过程。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40-变量的value和type存储</title>
      <link href="/posts/fab9b467.html"/>
      <url>/posts/fab9b467.html</url>
      
        <content type="html"><![CDATA[<h1 id="40-变量的value和type存储"><a href="#40-变量的value和type存储" class="headerlink" title="40-变量的value和type存储"></a>40-变量的value和type存储</h1><p>PHP是一种弱类型的脚本语言，弱类型不表示PHP的变量没有类型区分，PHP变量有8种原始类型：</p><p>四种标量类型：</p><ul><li>boolean（布尔型）</li><li>integer（整型）</li><li>float（浮点型）</li><li>string（字符串）</li></ul><p>两种复合类型：</p><ul><li>array（数组）</li><li>object（对象）</li></ul><p>两种特殊类型：</p><ul><li>resource（资源）</li><li>NULL</li></ul><p>一个变量能在运行期间从一种类型转换为另一种类型，那么PHP是如何实现这种变量的类型戏法的呢？</p><p>在引擎内部，变量都是用一个结构体来表示，这个结构体可以在{PHPSRC}/Zend/zend.h中找到：</p><pre><code>struct _zval_struct {      /* Variable information */      zvalue_value value;     /* value */      zend_uint refcount__gc;      zend_uchar type;    /* active type */      zend_uchar is_ref__gc;  };</code></pre><p>这里我们暂时只关心 value和type两个成员，其中value是一个联合, 也就是变量的实际值，type是变量的动态类型，根据类型的不同，value使用不同的成员。</p><p>type的各种类型都被定义成了宏，同样在此文件中定义了这些宏：</p><pre><code>#define IS_NULL     0  #define IS_LONG     1  #define IS_DOUBLE   2  #define IS_BOOL     3  #define IS_ARRAY    4  #define IS_OBJECT   5  #define IS_STRING   6  #define IS_RESOURCE 7  #define IS_CONSTANT 8  #define IS_CONSTANT_ARRAY   9value的类型zvalue_value同样定义在此文件中：typedef union _zvalue_value {      long lval;                  /* long value */      double dval;                /* double value */      struct {          char *val;          int len;      } str;      HashTable *ht;              /* hash table value */      zend_object_value obj;  } zvalue_value;  </code></pre><p>1.布尔类型变量。type=IS_BOOL，value中的lval字段为值，lval取值为(0,1)。在{PHPSRC}/Zend/zend_operators.h中定义了取一个zval的布尔值的宏：#define Z_BVAL(zval) ((zend_bool)(zval).value.lval)</p><p>2.整形变量。type=IS_LONG, value中的lval字段为值。#define Z_LVAL(zval) (zval).value.lval</p><p>3.浮点型变量。type=IS_DOUBLE, value中的dval字段为值。#define Z_DVAL(zval) (zval).value.dval</p><p>4.字符串变量。type=IS_STRING, value中的str结构有效，该结构中var为字符串的指针，len为字符串的长度。#define Z_STRVAL(zval) (zval).value.str.val //取字符串指针，#define Z_STRLEN(zval) (zval).value.str.len //取字符串长度</p><p>另外的复杂类型这里暂不详细介绍，对于数组类型，ht字段生效，ht是一个哈希表的指针，数组都是哈希表的形式存在，对于对象类型变量，obj保存这对象的信息，对于资源类型变量，用lval间接保存这资源得一个标识符。</p><p>这样引擎就用一个zval类型来实现了所有的PHP变量类型，知道以上原理之后，变量的类型转换就容易实现了，在{PHPSRC}/Zend/zend_operators.c中定义了各种类型转换的宏，比如转换成布尔类型的宏zendi_convert_to_boolean，主要的思路就是先把type变成IS_BOOL,然后根据原变量的不同类型的值按照一定规则转换成lval的0或则1。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39-诡异的变量名</title>
      <link href="/posts/e5a10a77.html"/>
      <url>/posts/e5a10a77.html</url>
      
        <content type="html"><![CDATA[<h1 id="39-诡异的变量名"><a href="#39-诡异的变量名" class="headerlink" title="39-诡异的变量名"></a>39-诡异的变量名</h1><p>在PHP语言中，变量都是保存在哈希表中，称为变量符号表，其中变量名为哈希表的键，变量名对应的容器zval的指针为哈希表中的值。所有全局变量放在一张主符号表中(也就是数组$GLOBALS对应的哈希表)。PHP语言有个特性，变量在命名时，$变量标识符后不能以数字开头。例如我们在以下代码：</p><pre><code>&lt;?php$111= &quot;nowamagic&quot;;?&gt;</code></pre><p>会报如下错误:Parse error: syntax error, unexpected T_LNUMBER, expecting T_VARIABLE or ‘$’ in…</p><p>从错误的描叙来看，这是一个语法错误，于是我们推论对变量名合法性的判断应该是在编译时的语法分析阶段。为了证明观点，我们可以试着在执行阶段定义一个数字字符开头的变量：</p><pre><code>&lt;?php$a = 111;$$a = &quot;nowamagic&quot;; //以变量$a的值作为变量名echo $$a;var_dump($GLOBALS);?&gt;</code></pre><p>运行之后发现不报错，并且在全局符号表$GLOBALS中发现相关符号：</p><pre><code>[&quot;a&quot;]=&gt;int(111)[&quot;111&quot;]=&gt;string(2) &quot;nowamagic&quot;</code></pre><p>这样我们就定义了一个全数字字符命名的变量，似乎违背了PHP的规则，但是确实做到了。（读者可以试着输出$GLOBALS[“111”]的值，虽然有值，但是结果却为NULL，这个是PHP中一个类型转换的特性）</p><p>在这段代码中，$$a = “nowamagic”这条语句具有多态性，只有当实际执行到这条语句的时候，我们才能确定变量名，PHP在语法分析阶段无法知道这个变量名会是什么，所以就不会报错，在执行阶段，PHP语言不判断变量名的合法性，于是就产生了这样一个叛逆的变量。</p><p>知道了这个特性之后，马上会想到一个另外一个特殊的变量:$this，在类的方法中，$this关键字用来指向当前类的对象实例，如果对$this进行赋值操作，会发生什么事情？</p><pre><code>&lt;?php  class Person  {      protected $_name = &quot;phper&quot;;      protected $_age  = 18;      public function getName()      {          $this = 123;          return $this-&gt;_name;      }      public function getAge()      {          return $this-&gt;_age;      }  }  $p = new Person();  $p-&gt;getName();  ?&gt;  </code></pre><p>执行代码，报错：</p><pre><code>Fatal error: Cannot re-assign $this in...</code></pre><p>PHP对$this变量做了一定保护措施，但是这个保护措施也不是完全的，我们利用前面的方法在执行期改变$this的值, 修改后的getName方法为：</p><pre><code>public function getName()  {      $a = &quot;this&quot;;      $$a = 123;      echo $this;      return $this-&gt;_name;  }  </code></pre><p>然后执行代码，发现能够顺利执行，$this的值变成了123, 由此可以判断对$this关键字的保护也仅限与语法分析阶段。</p><p>当$this的值变成123之后，按理说$this-&gt;_name肯定会报错的，但是居然代码能正常执行，这个确实很让人觉得不可思议。于是推断 $this-&gt;_name这样的引用方式和一般的对象变量引用方式在有差异，我们继续对getName做修改:</p><pre><code>public function getName()  {      $a = &quot;this&quot;;      $$a = 123;      $b = 123;      echo $this;      echo $b;      $this-&gt;getAge();      $b-&gt;getAge();      return $this-&gt;_name;  }</code></pre><p>这段代码中，$this和$b的值都等于123，但是$this-&gt;getAge()可以顺利执行，$b-&gt;getAge()却报错：Fatal error: Call to a member function getAge() on a non-object…</p><p>这是一个诡异的问题，于是可以推断$this-&gt;getAge()和$b-&gt;getAge()在编译之后对应的op handler肯定有所差异，于是查看之。</p><p>通过vld查看op的信息：</p><ul><li>$this-&gt;getAge()对应的为: ZEND_INIT_METHOD_CALL RES[ IS_UNUSED ] OP1[ IS_UNUSED ] OP2[ IS_CONST (8142027) ‘getAge’ ]</li><li>$b-&gt;getAge()在对应的为: ZEND_INIT_METHOD_CALL RES[ IS_UNUSED ] OP1[ IS_CV !0 ] OP2[ , IS_CONST (8142039) ‘getAge’ ]</li></ul><p>虽然对应了同样的op code,但是由于操作数的不同(前者不使用OP1,后者使用OP1, 且OP1的值!0表示$b)，同一个op code对应同一类handler，然后根据操作数的类型确定到此类handler中的某一个handler。</p><ul><li>$this-&gt;getAge()对应的handler处理为:ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER</li><li>$b-&gt;getAge() 对应的handler处理为:ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER</li></ul><p>这就是它们的差异了，在执行：</p><pre><code>$my = new Person();$name = $my-&gt;getName();</code></pre><p>调用getName的时候，getName()的作用域(scope)已经被设置成$name对象中，语法分析的时候对于getName中$this-&gt;getAge()这样的调用时只是在当前作用域(scope)中调用getAge()函数，不会理会$this的具体值，而在$b-&gt;getAge()这样的调用时，会关心$b所对应的值。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>38-变量作用域</title>
      <link href="/posts/9ba9fe26.html"/>
      <url>/posts/9ba9fe26.html</url>
      
        <content type="html"><![CDATA[<h1 id="38-变量作用域"><a href="#38-变量作用域" class="headerlink" title="38-变量作用域"></a>38-变量作用域</h1><p>变量的作用域是变量的一个作用范围，在这个范围内变量为可见的，即可以访问该变量的代码区域， 相反，如果不在这个范围内，变量是不可见的，无法被调用。 （全局变量可以将作用范围看作为整个程序） 如下面的例子：（会输出什么样的结果呢？）</p><pre><code>&lt;?php    $foo = &apos;nowamagic&apos;;    function variable_scope(){        $foo = &apos;foo&apos;;        print $foo ;        print $bar ;    }?&gt;</code></pre><p>由此可见，变量的作用域是一个很基础的概念，在变量的实现中比较重要。<br>全局变量与局部变量</p><p>变量按作用域类型分为：全局变量和局部变量。全局变量是在整个程序中任何地方随意调用的变量， 在PHP中，全局变量的“全局化”使用gloal语句来实现。 相对于全局变量，局部变量的作用域是程序中的部分代码（如函数中），而不是程序的全部。</p><p>变量的作用域与变量的生命周期有一定的联系， 如在一个函数中定义的变量， 这个变量的作用域从变量声明的时候开始到这个函数结束的时候。 这种变量我们称之为局部变量。它的生命周期开始于函数开始，结束于函数的调用完成之时。</p><p>变量的作用域决定其生命周期吗？程序运行到变量作用域范围之外，就会将变量进行销毁吗？</p><p>对于不同作用域的变量，如果存在冲突情况，就像上面的例子中，全局变量中有一个名为$bar的变量， 在局部变量中也存在一个名为$bar的变量， 此时如何区分呢？</p><p>对于全局变量，ZEND内核有一个_zend_executor_globals结构，该结构中的symbol_table就是全局符号表， 其中保存了在顶层作用域中的变量。同样，函数或者对象的方法在被调用时会创建active_symbol_table来保存局部变量。 当程序在顶层中使用某个变量时，ZE就会在symbol_table中进行遍历， 同理，如果程序运行于某个函数中，Zend内核会遍历查询与其对应的active_symbol_table， 而每个函数的active_symbol_table是相对独立的，由此而实现的作用域的独立。</p><p>展开来看，如果我们调用的一个函数中的变量，ZE使用_zend_execute_data来存储 某个单独的op_array（每个函数都会生成单独的op_array)执行过程中所需要的信息，它的结构如下：</p><pre><code>struct _zend_execute_data {    struct _zend_op *opline;    zend_function_state function_state;    zend_function *fbc; /* Function Being Called */    zend_class_entry *called_scope;    zend_op_array *op_array;    zval *object;    union _temp_variable *Ts;    zval ***CVs;    HashTable *symbol_table;    struct _zend_execute_data *prev_execute_data;    zval *old_error_reporting;    zend_bool nested;    zval **original_return_value;    zend_class_entry *current_scope;    zend_class_entry *current_called_scope;    zval *current_this;    zval *current_object;    struct _zend_op *call_opline;};</code></pre><p>函数中的局部变量就存储在_zend_execute_data的symbol_table中，在执行当前函数的op_array时， 全局zend_executor_globals中的<em>active_symbol_table会指向当前_zend_execute_data中的</em>symbol_table。 因为每个函数调用开始时都会重新初始化EG(active_symbol_table)为NULL， 在这个函数的所有opcode的执行过程中这个全局变量会一直存在，并且所有的局部变量修改都是在它上面操作完成的，如前面的赋值操作等。 而此时，其他函数中的symbol_table会存放在栈中，将当前函数执行完并返回时，程序会将之前保存的zend_execute_data恢复， 从而其他函数中的变量也就不会被找到，局部变量的作用域就是以这种方式来实现的。 相关操作在 Zend/zend_vm_execute.h 文件中定义的execute函数中一目了然，如下所示代码：</p><pre><code>zend_vm_enter:/* Initialize execute_data */execute_data = (zend_execute_data *)zend_vm_stack_alloc(    sizeof(zend_execute_data) +    sizeof(zval**) * op_array-&gt;last_var * (EG(active_symbol_table) ? 1 : 2) +    sizeof(temp_variable) * op_array-&gt;T TSRMLS_CC);EX(symbol_table) = EG(active_symbol_table);EX(prev_execute_data) = EG(current_execute_data);EG(current_execute_data) = execute_data;</code></pre><p>所以，变量的作用域是使用不同的符号表来实现的，于是顶层的全局变量在函数内部使用时， 需要先使用global语句来将变量“挪”到函数独立的*active_symbol_table中， 即变量的跨域操作。</p><p>在PHP的源码中，EX宏经常出现，它的作用是获取结构体zend_execute_data的字段值，它的实现是：#define EX(element) execute_data-&gt;element</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37-变量赋值与销毁</title>
      <link href="/posts/802546e3.html"/>
      <url>/posts/802546e3.html</url>
      
        <content type="html"><![CDATA[<h1 id="37-变量赋值与销毁"><a href="#37-变量赋值与销毁" class="headerlink" title="37-变量赋值与销毁"></a>37-变量赋值与销毁</h1><p>在强类型的语言当中，当使用一个变量之前，我们需要先声明这个变量。然而，对于PHP来说， 在使用一个变量时，我们不需要声明，也不需要初始化，直接对其赋值就可以使用，这是如何实现的？</p><p>在PHP中没有对常规变量的声明操作，如果要使用一个变量，直接进行赋值操作即可。在赋值操作的同时已经进行声明操作。 一个简单的赋值操作：</p><pre><code>$a = 10;</code></pre><p>使用VLD扩展查看其生成的中间代码为 ASSIGN。 依此，我们找到其执行的函数为 ZEND_ASSIGN_SPEC_CV_CONST_HANDLER。 （找到这个函数的方法之一：$a为CV，10为CONST，操作为ASSIGN。） CV是PHP在5.1后增加的一个在编译期的缓存。如我们在使用VLD查看上面的PHP代码生成的中间代码时会看到：</p><pre><code>compiled vars:  !0 = $a</code></pre><p>这个$a变量就是op_type为IS_CV的变量。IS_CV值的设置是在语法解析时进行的。可以参见Zend/zend_complie.c文件中的zend_do_end_variable_parse函数。</p><p>在这个函数中，获取这个赋值操作的左值和右值的代码为：</p><pre><code>zval *value = &amp;opline-&gt;op2.u.constant;zval **variable_ptr_ptr = _get_zval_ptr_ptr_cv(&amp;opline-&gt;op1,                                    EX(Ts), BP_VAR_W TSRMLS_CC);</code></pre><p>由于右值为一个数值，我们可以理解为一个常量，则直接取操作数存储的constant字段， 关于这个字段的说明将在后面的虚拟机章节说明。 左值是通过 _get_zval_ptr_ptr_cv函数获取zval值。这个函数最后的调用顺序为： [_get_zval_ptr_ptr_cv] –&gt; [_get_zval_cv_lookup]</p><p>在_get_zval_cv_lookup函数中关键代码为：</p><pre><code>zend_hash_quick_find(EG(active_symbol_table), cv-&gt;name, cv-&gt;name_len+1,                                    cv-&gt;hash_value, (void **)ptr)</code></pre><p>这是一个HashTable的查找函数，它的作用是从EG(active_symbol_table)中查找名称为cv-&gt;name的变量，并将这个值赋值给ptr。 最后，这个在符号表中找到的值将传递给ZEND_ASSIGN_SPEC_CV_CONST_HANDLER函数的variable_ptr_ptr变量。</p><p>以上是获取左值和右值的过程，在这步操作后将执行赋值操作的核心操作–赋值。赋值操作是通过调用zend_assign_to_variable函数实现。 在zend_assign_to_variable函数中，赋值操作分为好几种情况来处理，在程序中就是以几层的if语句体现。</p><h2 id="情况一：赋值的左值存在引用（即zval变量中is-ref-gc字段不为0），并且左值不等于右值"><a href="#情况一：赋值的左值存在引用（即zval变量中is-ref-gc字段不为0），并且左值不等于右值" class="headerlink" title="情况一：赋值的左值存在引用（即zval变量中is_ref__gc字段不为0），并且左值不等于右值"></a>情况一：赋值的左值存在引用（即zval变量中is_ref__gc字段不为0），并且左值不等于右值</h2><p>这种情形描述起来比较抽象，如下面的示例：</p><pre><code>$a = 10;$b = &amp;$a;xdebug_debug_zval(&apos;a&apos;);$a = 20;xdebug_debug_zval(&apos;a&apos;);</code></pre><p>试想，如果我们来做这个$b = &amp;$a;的底层实现，我们可能会这样做：</p><ul><li>判断左值是不是已经被引用过了;</li><li>左值已经被引用，则不改变左值的引用计数，将右值赋与左值;</li></ul><p>事实上，ZE也是用同样的方法来实现，其代码如下：</p><pre><code>if (PZVAL_IS_REF(variable_ptr)) {    if (variable_ptr!=value) {        zend_uint refcount = Z_REFCOUNT_P(variable_ptr);        garbage = *variable_ptr;        *variable_ptr = *value;        Z_SET_REFCOUNT_P(variable_ptr, refcount);        Z_SET_ISREF_P(variable_ptr);        if (!is_tmp_var) {            zendi_zval_copy_ctor(*variable_ptr);        }        zendi_zval_dtor(garbage);        return variable_ptr;    }}</code></pre><p>PZVAL_IS_REF(variable_ptr)判断is_ref__gc字段是否为0。在左值不等于右值的情况下执行操作。 所有指向这个zval容器的变量的值都变成了*value。并且引用计数的值不变。下面是这种情况的一个示例：</p><p>上面的例子的输出结果：</p><pre><code>a:(refcount=2, is_ref=1),int 10a:(refcount=2, is_ref=1),int 20</code></pre><h2 id="情况二：赋值的左值不存在引用，左值的引用计数为1，左值等于右值"><a href="#情况二：赋值的左值不存在引用，左值的引用计数为1，左值等于右值" class="headerlink" title="情况二：赋值的左值不存在引用，左值的引用计数为1，左值等于右值"></a>情况二：赋值的左值不存在引用，左值的引用计数为1，左值等于右值</h2><p>在这种情况下，应该是什么都不会发生吗？看一个示例：</p><pre><code>$a = 10;$a = $a;</code></pre><p>看上去真的像是什么都没有发生， 左值的引用计数还是1，值仍是10 。 然而在这个赋值过程中，$a的引用计数经历了一次加一和一次减一的操作。 如以下代码：</p><pre><code>if (Z_DELREF_P(variable_ptr)==0) {  //  引用计数减一操作        if (!is_tmp_var) {            if (variable_ptr==value) {                Z_ADDREF_P(variable_ptr);   //  引用计数加一操作            }...//省略</code></pre><h2 id="情况三：赋值的左值不存在引用，左值的引用计数为1，右值存在引用"><a href="#情况三：赋值的左值不存在引用，左值的引用计数为1，右值存在引用" class="headerlink" title="情况三：赋值的左值不存在引用，左值的引用计数为1，右值存在引用"></a>情况三：赋值的左值不存在引用，左值的引用计数为1，右值存在引用</h2><p>用一个PHP的示例来描述一下这种情况：</p><pre><code>$a = 10;$b = &amp;$a;$c = $a;</code></pre><p>这里的$c = $a;的操作就是我们所示的第三种情况。 对于这种情况，ZEND内核直接创建一个新的zval容器，左值的值为右值，并且左值的引用计数为1。 也就是说，这种情形$c不会与$a指向同一个zval。 其内核实现代码如下：</p><pre><code>garbage = *variable_ptr;*variable_ptr = *value;INIT_PZVAL(variable_ptr);   //  初始化一个新的zval变量容器zval_copy_ctor(variable_ptr);   zendi_zval_dtor(garbage);return variable_ptr;</code></pre><p>在这个例子中，若将 $c = $a; 换成 $c = &amp;$a;，$a，$b和$c三个变量的引用计数会发生什么变化？将 $b = &amp;$a; 换成 $b = $a; 呢？<br>情况四：赋值的左值不存在引用，左值的引用计数为1，右值不存在引用</p><p>这种情形如下面的例子：</p><pre><code>$a = 10;$c = $a;</code></pre><p>这时，右值的引用计数加上，一般情况下，会对左值进行垃圾收集操作，将其移入垃圾缓冲池。垃圾缓冲池的功能是在PHP5.3后才有的。 在PHP内核中的代码体现为：</p><pre><code>Z_ADDREF_P(value);  //  引用计数加1*variable_ptr_ptr = value;if (variable_ptr != &amp;EG(uninitialized_zval)) {    GC_REMOVE_ZVAL_FROM_BUFFER(variable_ptr);   //  调用垃圾收集机制    zval_dtor(variable_ptr);    efree(variable_ptr);    //  释放变量内存空间}return value;</code></pre><h2 id="情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0"><a href="#情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0" class="headerlink" title="情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0"></a>情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0</h2><p>一个演示这种情况的PHP示例：</p><pre><code>$a = 10;$b = $a;$va = 20;$vb = &amp;$va;$a = $va;</code></pre><p>最后一个操作就是我们的情况五。 使用xdebug看引用计数发现，最终$a变量的引用计数为1，$va变量的引用计数为2，并且$va存在引用。 从源码层分析这个原因：</p><pre><code>ALLOC_ZVAL(variable_ptr);   //  分配新的zval容器*variable_ptr_ptr = variable_ptr;*variable_ptr = *value;zval_copy_ctor(variable_ptr);Z_SET_REFCOUNT_P(variable_ptr, 1);  //  设置引用计数为1</code></pre><p>从代码可以看出是新分配了一个zval容器，并设置了引用计数为1，印证了我们之前的例子$a变量的结果。</p><p>除上述五种情况之外，zend_assign_to_variable函数还对全部的临时变量做了处理。 变量赋值的各种操作全部由此函数完成。</p><h2 id="变量的销毁"><a href="#变量的销毁" class="headerlink" title="变量的销毁"></a>变量的销毁</h2><p>在PHP中销毁变量最常用的方法是使用unset函数。 unset函数并不是一个真正意义上的函数，它是一种语言结构。 在使用此函数时，它会根据变量的不同触发不同的操作。</p><p>一个简洁的例子：</p><pre><code>$a = 10;unset($a);</code></pre><p>使用VLD扩展查看其生成的中间代码：</p><pre><code>compiled vars:  !0 = $aline     # *  op                           fetch          ext  return  operands---------------------------------------------------------------------------------   2     0  &gt;   EXT_STMT         1      ASSIGN                                                   !0, 10   3     2      EXT_STMT         3      UNSET_VAR                                                !0         4    &gt; RETURN                                                   1</code></pre><p>去掉关于赋值的中间代码，得到unset函数生成的中间代码为 UNSET_VAR，由于我们unse的是一个变量， 在Zend/zend_vm_execute.h文件中查找到其最终调用的执行中间代码的函数为： ZEND_UNSET_VAR_SPEC_CV_HANDLER 关键代码代码如下：</p><pre><code>target_symbol_table = zend_get_target_symbol_table(opline, EX(Ts),        BP_VAR_IS, varname TSRMLS_CC);    if (zend_hash_quick_del(target_symbol_table, varname-&gt;value.str.val,            varname-&gt;value.str.len+1, hash_value) == SUCCESS) {        ...//省略    }</code></pre><p>程序会先获取目标符号表，这个符号表是一个HashTable，然后将我们需要unset掉的变量从这个HashTable中删除。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36-变量的生命周期</title>
      <link href="/posts/1929a5cc.html"/>
      <url>/posts/1929a5cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="36-变量的生命周期"><a href="#36-变量的生命周期" class="headerlink" title="36-变量的生命周期"></a>36-变量的生命周期</h1><p>通过前面章节的描述，我们已经知道了PHP中变量的存储方式－－所有的变量都保存在zval结构中。 下面介绍一下PHP内核如何实现变量的定义方式以及作用域。</p><p>在ZE进行词法和语法的分析之后，生成具体的opcode，这些opcode最终被execute函数(Zend/zend_vm_execute.h:46)解释执行。 在excute函数中，有以下代码：</p><pre><code>while (1) {    ...    if ((ret = EX(opline)-&gt;handler(execute_data TSRMLS_CC)) &gt; 0) {        switch (ret) {            case 1:                EG(in_execution) = original_in_execution;                return;            case 2:                op_array = EG(active_op_array);                goto zend_vm_enter;            case 3:                execute_data = EG(current_execute_data);            default:                break;        }         }         ...}</code></pre><p>这里的EX(opline)-&gt;handler(…)将op_array中的操作顺序执行， 其中变量赋值操作在ZEND_ASSIGN_SPEC_CV_CONST_HANDLER()函数中进行。 ZEND_ASSIGN_SPEC_CV_CONST_HANDLER中进行一些变量类型的判断并在内存中分配一个zval，然后将变量的值存储其中。 变量名和指向这个zval的指针，则会存储于符号表内。 ZEND_ASSIGN_SPEC_CV_CONST_HANDLER的最后会调用ZEND_VM_NEXT_OPCODE()将op_array的指针移到下一条opline， 这样就会形成循环执行的效果。</p><p>在ZE执行的过程中，有四个全局的变量，这些变量都是用于ZE运行时所需信息的存储：</p><pre><code>//_zend_compiler_globals 编译时信息，包括函数表等zend_compiler_globals    *compiler_globals;  //_zend_executor_globals 执行时信息zend_executor_globals    *executor_globals;//_php_core_globals 主要存储php.ini内的信息php_core_globals         *core_globals;//_sapi_globals_struct SAPI的信息sapi_globals_struct      *sapi_globals;</code></pre><p>在执行的过程中，变量名及指针主要存储于_zend_executor_globals的符号表中，_zend_executor_globals的结构这样的：</p><pre><code>struct _zend_executor_globals {.../* symbol table cache */HashTable *symtable_cache[SYMTABLE_CACHE_SIZE];HashTable **symtable_cache_limit;HashTable **symtable_cache_ptr;zend_op **opline_ptr;HashTable *active_symbol_table;  /* active symbol table */HashTable symbol_table;     /* main symbol table */HashTable included_files;   /* files already included */...}</code></pre><p>在执行的过程中，active_symbol_table会根据执行的具体语句不断发生变化，针对线程安全的EG宏就是用来取此变量中的值。 ZE将op_array执行完毕以后，HashTable会被FREE_HASHTABLE()释放掉。 如果程序使用了unset语句来主动消毁变量，则会调用ZEND_UNSET_VAR_SPEC_CV_HANDLER来将变量销毁， 回收内存，</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35-变量类型提示</title>
      <link href="/posts/32e66df8.html"/>
      <url>/posts/32e66df8.html</url>
      
        <content type="html"><![CDATA[<h1 id="35-变量类型提示"><a href="#35-变量类型提示" class="headerlink" title="35-变量类型提示"></a>35-变量类型提示</h1><p>PHP是弱类型语言，向方法传递参数时候也并不严格检查数据类型。 不过有时需要判断传递到方法中的参数，为此PHP中提供了一些函数，来判断数据的类型。 比如is_numeric()，判断是否是一个数值或者可转换为数值的字符串，比如用于判断对象的类型运算符：instanceof。 instanceof 用来测定一个给定的对象是否来自指定的对象类。instanceof 运算符是 PHP 5 引进的。 在此之前是使用的is_a()，不过现在已经不推荐使用。</p><p>为了避免对象类型不规范引起的问题，PHP5中引入了类型提示这个概念。在定义方法参数时，同时定义参数的对象类型。 如果在调用的时候，传入参数的类型与定义的参数类型不符，则会报错。这样就可以过滤对象的类型，或者说保证了数据的安全性。</p><p>PHP中的类型提示功能只能用于参数为对象的提示，而无法用于为整数，字串，浮点等类型提示。在PHP5.1之后，PHP支持对数组的类型提示。</p><p>要使用类型提示，只要在方法（或函数）的对象型参数前加一个已存在的类的名称，当使用类型提示时， 你不仅可以指定对象类型，还可以指定抽象类和接口。</p><p>一个数组的类型提示示例：</p><pre><code>function array_print(Array $arr) {    print_r($arr);}array_print(1);</code></pre><p>以上的这段代码有一点问题，它触发了我们这次所介绍的类型提示，这段代码在PHP5.1之后的版本执行，会报错如下：</p><pre><code>Catchable fatal error: Argument 1 passed to array_print() must be an array,integer given, called in  ...</code></pre><p>当我们把函数参数中的整形变量变为数组时，程序会正常运行，调用print_r函数输出数组。 那么这个类型提示是如何实现的呢？ 不管是在类中的方法，还是我们调用的函数，都是使用function关键字作为其声明的标记， 而类型提示的实现是与函数的声明相关的，在声明时就已经确定了参数的类型是哪些，但是需要在调用时才会显示出来。 这里，我们从两个方面说明类型提示的实现：</p><ol><li>参数声明时的类型提示</li><li>函数或方法调用时的类型提示</li></ol><p>将刚才的那个例子修改一下：</p><pre><code>function array_print(Array $arr = 1) {    print_r($arr);}array_print(array(1));</code></pre><p>这段代码与前面的那个示例相比，函数的参数设置了一个默认值，但是这个默认值是一个整形变量， 它与参数给定的类型提示Array不一样，因此，当我们运行这段代码时会很快看到程序会报错如下：</p><pre><code>Fatal error: Default value for parameters with array type hintcan only be an array or NULL</code></pre><p>为什么会很快看到报错呢？ 因为默认值的检测过程发生在成中间代码生成阶段，与运行时的报错不同，它还没有生成中间代码，也没有执行中间代码的过程。 在Zend/zend_language_parser.y文件中，我们找到函数的参数列表在编译时都会调用zend_do_receive_arg函数。 而在这个函数的参数列表中，第5个参数（ znode *class_type）与我们这节所要表述的类型提示密切相关。 这个参数的作用是声明类型提示中的类型，这里的类型有三种：</p><ol><li>空，即没有类型提示</li><li>类名，用户定义或PHP自定义的类、接口等</li><li>数组，编译期间对应的token是T_ARRAY，即Array字符串</li></ol><p>在zend_do_receive_arg函数中，针对class_type参数做了一系列的操作，基本上是针对上面列出的三种类型， 其中对于类名，程序并没有判断这个类是否存在，即使你使用了一个不存在的类名， 程序在报错时，显示的也会是实参所给的对象并不是给定类的实例。</p><p>以上是声明类型提示的过程以及在声明过程中对参数默认值的判断过程，下面我们看下在函数或方法调用时类型提示的实现。</p><p>从上面的声明过程我们知道PHP在编译类型提示的相关代码时调用的是Zend/zend_complie.c文件中的zend_do_receive_arg函数， 在这个函数中将类型提示的判断的opcode被赋值为ZEND_RECV。根据opcode的映射计算规则得出其在执行时调用的是ZEND_RECV_SPEC_HANDLER。 其代码如下：</p><pre><code>static int ZEND_FASTCALL  ZEND_RECV_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS){       ...//省略        if (param == NULL) {                char *space;                char *class_name = get_active_class_name(&amp;space TSRMLS_CC);                zend_execute_data *ptr = EX(prev_execute_data);                if (zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, NULL, opline-&gt;extended_value TSRMLS_CC)) {                       ...//省略                }               ...//省略        } else {              ...//省略                zend_verify_arg_type((zend_function *) EG(active_op_array), arg_num, *param, opline-&gt;extended_value TSRMLS_CC);              ...//省略        }      ...//省略}</code></pre><p>如上所示：在ZEND_RECV_SPEC_HANDLER中最后调用的是zend_verify_arg_type。其代码如下：</p><pre><code>static inline int zend_verify_arg_type(zend_function *zf, zend_uint arg_num, zval *arg, ulong fetch_type TSRMLS_DC){   ...//省略    if (cur_arg_info-&gt;class_name) {        const char *class_name;        if (!arg) {            need_msg = zend_verify_arg_class_kind(cur_arg_info, fetch_type, &amp;class_name, &amp;ce TSRMLS_CC);            return zend_verify_arg_error(zf, arg_num, cur_arg_info, need_msg, class_name, &quot;none&quot;, &quot;&quot; TSRMLS_CC);        }        if (Z_TYPE_P(arg) == IS_OBJECT) { // 既然是类对象参数, 传递的参数需要是对象类型            // 下面检查这个对象是否是参数提示类的实例对象, 这里是允许传递子类实力对象            need_msg = zend_verify_arg_class_kind(cur_arg_info, fetch_type, &amp;class_name, &amp;ce TSRMLS_CC);            if (!ce || !instanceof_function(Z_OBJCE_P(arg), ce TSRMLS_CC)) {                return zend_verify_arg_error(zf, arg_num, cur_arg_info, need_msg, class_name, &quot;instance of &quot;, Z_OBJCE_P(arg)-&gt;name TSRMLS_CC);            }        } else if (Z_TYPE_P(arg) != IS_NULL || !cur_arg_info-&gt;allow_null) { // 参数为NULL, 也是可以通过检查的,                                                                            // 如果函数定义了参数默认值, 不传递参数调用也是可以通过检查的            need_msg = zend_verify_arg_class_kind(cur_arg_info, fetch_type, &amp;class_name, &amp;ce TSRMLS_CC);            return zend_verify_arg_error(zf, arg_num, cur_arg_info, need_msg, class_name, zend_zval_type_name(arg), &quot;&quot; TSRMLS_CC);        }    } else if (cur_arg_info-&gt;array_type_hint) { //  数组        if (!arg) {            return zend_verify_arg_error(zf, arg_num, cur_arg_info, &quot;be an array&quot;, &quot;&quot;, &quot;none&quot;, &quot;&quot; TSRMLS_CC);        }        if (Z_TYPE_P(arg) != IS_ARRAY &amp;&amp; (Z_TYPE_P(arg) != IS_NULL || !cur_arg_info-&gt;allow_null)) {            return zend_verify_arg_error(zf, arg_num, cur_arg_info, &quot;be an array&quot;, &quot;&quot;, zend_zval_type_name(arg), &quot;&quot; TSRMLS_CC);        }    }    return 1;}</code></pre><p>zend_verify_arg_type的整个流程如图3.1所示：</p><center><br><img src="images/2012_02_21_01.jpg" alt><br></center><p>如果类型提示报错，zend_verify_arg_type函数最后都会调用 zend_verify_arg_class_kind 生成报错信息， 并且调用 zend_verify_arg_error 报错。如下所示代码：</p><pre><code>static inline char * zend_verify_arg_class_kind(const zend_arg_info *cur_arg_info, ulong fetch_type, const char **class_name, zend_class_entry **pce TSRMLS_DC){    *pce = zend_fetch_class(cur_arg_info-&gt;class_name, cur_arg_info-&gt;class_name_len, (fetch_type | ZEND_FETCH_CLASS_AUTO | ZEND_FETCH_CLASS_NO_AUTOLOAD) TSRMLS_CC);    *class_name = (*pce) ? (*pce)-&gt;name: cur_arg_info-&gt;class_name;    if (*pce &amp;&amp; (*pce)-&gt;ce_flags &amp; ZEND_ACC_INTERFACE) {        return &quot;implement interface &quot;;    } else {        return &quot;be an instance of &quot;;    }}static inline int zend_verify_arg_error(const zend_function *zf, zend_uint arg_num, const zend_arg_info *cur_arg_info, const char *need_msg, const char *need_kind, const char *given_msg, char *given_kind TSRMLS_DC){    zend_execute_data *ptr = EG(current_execute_data)-&gt;prev_execute_data;    char *fname = zf-&gt;common.function_name;    char *fsep;    char *fclass;    if (zf-&gt;common.scope) {        fsep =  &quot;::&quot;;        fclass = zf-&gt;common.scope-&gt;name;    } else {        fsep =  &quot;&quot;;        fclass = &quot;&quot;;    }    if (ptr &amp;&amp; ptr-&gt;op_array) {        zend_error(E_RECOVERABLE_ERROR, &quot;Argument %d passed to %s%s%s() must %s%s, %s%s given, called in %s on line %d and defined&quot;, arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind, ptr-&gt;op_array-&gt;filename, ptr-&gt;opline-&gt;lineno);    } else {        zend_error(E_RECOVERABLE_ERROR, &quot;Argument %d passed to %s%s%s() must %s%s, %s%s given&quot;, arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind);    }    return 0;}</code></pre><p>在上面的代码中，我们可以找到前面的报错信息中的一些关键字Argument、 passed to、called in等。 这就是我们在调用函数或方法时类型提示显示错误信息的最终执行位置。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34-静态变量的实现</title>
      <link href="/posts/3f217fda.html"/>
      <url>/posts/3f217fda.html</url>
      
        <content type="html"><![CDATA[<h1 id="34-静态变量的实现"><a href="#34-静态变量的实现" class="headerlink" title="34-静态变量的实现"></a>34-静态变量的实现</h1><p>通常意义上静态变量是静态分配的，他们的生命周期和程序的生命周期一样， 只有在程序退出时才结束期生命周期，这和局部变量相反，有的语言中全局变量也是静态分配的。 例如PHP和Javascript中的全局变量。</p><p>静态变量可以分为：</p><ul><li>静态全局变量，PHP中的全局变量也可以理解为静态全局变量，因为除非明确unset释放，在程序运行过程中始终存在。</li><li>静态局部变量，也就是在函数内定义的静态变量，函数在执行时对变量的操作会保持到下一次函数被调用。</li><li>静态成员变量，这是在类中定义的静态变量，和实例变量相对应，静态成员变量可以在所有实例中共享。</li></ul><p>最常见的是静态局部变量及静态成员变量。局部变量只有在函数执行时才会存在。 通常，当一个函数执行完毕，它的局部变量的值就已经不存在，而且变量所占据的内存也被释放。 当下一次执行该过程时，它的所有局部变量将重新初始化。如果某个局部变量定义为静态的， 则它的值不会在函数调用结束后释放，而是继续保留变量的值。</p><p>在本小节将介绍静态局部变量，有关静态成员变量的内容将在类与对象章节进行介绍。</p><p>先看看如下局部变量的使用：</p><pre><code>function t() {    static $i = 0;    $i++;    echo $i, &apos; &apos;;}t();t();t();</code></pre><p>上面的程序会输出1 2 3。从这个示例可以看出，$i变量的值在改变后函数继续执行还能访问到， $i变量就像是只有函数t()才能访问到的一个全局变量。 那PHP是怎么实现的呢？</p><p>static是PHP的关键字，我们需要从词法分析，语法分析，中间代码生成到执行中间代码这几个部分探讨整个实现过程。</p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>首先查看 Zend/zend_language_scanner.l文件，搜索 static关键字。我们可以找到如下代码：</p><pre><code>&lt;ST_IN_SCRIPTING&gt;&quot;static&quot; {    return T_STATIC;}</code></pre><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>在词法分析找到token后，通过这个token，在Zend/zend_language_parser.y文件中查找。找到相关代码如下：</p><pre><code>|   T_STATIC static_var_list &apos;;&apos;static_var_list:        static_var_list &apos;,&apos; T_VARIABLE { zend_do_fetch_static_variable(&amp;$3, NULL, ZEND_FETCH_STATIC TSRMLS_CC); }    |   static_var_list &apos;,&apos; T_VARIABLE &apos;=&apos; static_scalar { zend_do_fetch_static_variable(&amp;$3, &amp;$5, ZEND_FETCH_STATIC TSRMLS_CC); }    |   T_VARIABLE  { zend_do_fetch_static_variable(&amp;$1, NULL, ZEND_FETCH_STATIC TSRMLS_CC); }    |   T_VARIABLE &apos;=&apos; static_scalar { zend_do_fetch_static_variable(&amp;$1, &amp;$3, ZEND_FETCH_STATIC TSRMLS_CC); };</code></pre><p>语法分析的过程中如果匹配到相应的模式则会进行相应的处理动作，通常是进行opcode的编译。 在本例中的static关键字匹配中，是由函数zend_do_fetch_static_variable处理的。</p><h2 id="生成opcode中间代码"><a href="#生成opcode中间代码" class="headerlink" title="生成opcode中间代码"></a>生成opcode中间代码</h2><pre><code>zend_do_fetch_static_variable函数的作用就是生成opcode，定义如下：void zend_do_fetch_static_variable(znode *varname, const znode        *static_assignment, int fetch_type TSRMLS_DC){    zval *tmp;    zend_op *opline;    znode lval;    znode result;    ALLOC_ZVAL(tmp);    if (static_assignment) {        *tmp = static_assignment-&gt;u.constant;    } else {        INIT_ZVAL(*tmp);    }    if (!CG(active_op_array)-&gt;static_variables) {   /* 初始化此时的静态变量存放位置 */        ALLOC_HASHTABLE(CG(active_op_array)-&gt;static_variables);        zend_hash_init(CG(active_op_array)-&gt;static_variables, 2, NULL, ZVAL_PTR_DTOR, 0);    }    //  将新的静态变量放进来    zend_hash_update(CG(active_op_array)-&gt;static_variables, varname-&gt;u.constant.value.str.val,        varname-&gt;u.constant.value.str.len+1, &amp;tmp, sizeof(zval *), NULL);    ...//省略    opline = get_next_op(CG(active_op_array) TSRMLS_CC);    opline-&gt;opcode = (fetch_type == ZEND_FETCH_LEXICAL) ? ZEND_FETCH_R : ZEND_FETCH_W;      /* 由于fetch_type=ZEND_FETCH_STATIC，程序会选择ZEND_FETCH_W*/    opline-&gt;result.op_type = IS_VAR;    opline-&gt;result.u.EA.type = 0;    opline-&gt;result.u.var = get_temporary_variable(CG(active_op_array));    opline-&gt;op1 = *varname;    SET_UNUSED(opline-&gt;op2);    opline-&gt;op2.u.EA.type = ZEND_FETCH_STATIC;  /* 这在中间代码执行时会有大用 */    result = opline-&gt;result;    if (varname-&gt;op_type == IS_CONST) {        zval_copy_ctor(&amp;varname-&gt;u.constant);    }    fetch_simple_variable(&amp;lval, varname, 0 TSRMLS_CC); /* Relies on the fact that the default fetch is BP_VAR_W */    if (fetch_type == ZEND_FETCH_LEXICAL) {        ...//省略    } else {        zend_do_assign_ref(NULL, &amp;lval, &amp;result TSRMLS_CC); //  赋值操作中间代码生成    }    CG(active_op_array)-&gt;opcodes[CG(active_op_array)-&gt;last-1].result.u.EA.type |= EXT_TYPE_UNUSED;}</code></pre><p>从上面的代码我们可知，在解释成中间代码时，静态变量是存放在CG(active_op_array)-&gt;static_variables中的。 并且生成的中间代码为：ZEND_FETCH_W 和 ZEND_ASSIGN_REF 。 其中ZEND_FETCH_W中间代码是在zend_do_fetch_static_variable中直接赋值，而ZEND_ASSIGN_REF中间代码是在zend_do_fetch_static_variable中调用zend_do_assign_ref生成的。</p><h2 id="执行中间代码"><a href="#执行中间代码" class="headerlink" title="执行中间代码"></a>执行中间代码</h2><p>opcode的编译阶段完成后就开始opcode的执行了。 在Zend/zend_vm_opcodes.h文件中包含所有opcode的宏定义，这些宏丙没有特殊含义，只是作为opcode的唯一标示， 包含本例中相关的如下两个宏的定义：</p><pre><code>#define ZEND_FETCH_W                          83#define ZEND_ASSIGN_REF                       39</code></pre><p>前面第二章 [脚本的执行一节][from-op-code-to-handler]介绍了根据opcode查找到相应处理函数的方法。 通过中间代码调用映射方法计算得此时ZEND_FETCH_W 对应的操作为ZEND_FETCH_W_SPEC_CV_HANDLER。其代码如下：</p><pre><code>static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS){    return zend_fetch_var_address_helper_SPEC_CV(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);}static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CV(int type, ZEND_OPCODE_HANDLER_ARGS){    ...//省略    if (opline-&gt;op2.u.EA.type == ZEND_FETCH_STATIC_MEMBER) {        retval = zend_std_get_static_property(EX_T(opline-&gt;op2.u.var).class_entry, Z_STRVAL_P(varname), Z_STRLEN_P(varname), 0 TSRMLS_CC);    } else {        // 取符号表，这里我们取的是EG(active_op_array)-&gt;static_variables        target_symbol_table = zend_get_target_symbol_table(opline, EX(Ts), type, varname TSRMLS_CC);            ...//   省略        if (zend_hash_find(target_symbol_table, varname-&gt;value.str.val, varname-&gt;value.str.len+1, (void **) &amp;retval) == FAILURE) {            switch (type) {                ...//省略                //  在前面的调用中我们知道type = case BP_VAR_W，于是程序会走按case BP_VAR_W的流程走。                case BP_VAR_W: {                        zval *new_zval = &amp;EG(uninitialized_zval);                        Z_ADDREF_P(new_zval);                        zend_hash_update(target_symbol_table, varname-&gt;value.str.val, varname-&gt;value.str.len+1, &amp;new_zval, sizeof(zval *), (void **) &amp;retval);                        // 更新符号表，执行赋值操作                    }                    break;                EMPTY_SWITCH_DEFAULT_CASE()            }        }        switch (opline-&gt;op2.u.EA.type) {            ...//省略            case ZEND_FETCH_STATIC:                zval_update_constant(retval, (void*) 1 TSRMLS_CC);                break;            case ZEND_FETCH_GLOBAL_LOCK:                if (IS_CV == IS_VAR &amp;&amp; !free_op1.var) {                    PZVAL_LOCK(*EX_T(opline-&gt;op1.u.var).var.ptr_ptr);                }                break;        }    }    ...//省略}</code></pre><p>在上面的代码中有一个关键的函数zend_get_target_symbol_table。它的作用是获取当前正在执行的目标符号表， 而在函数执行时当前的op_array则是函数体本身，先看看zend_op_array的结构。</p><pre><code>struct _zend_op_array {    /* Common elements */    zend_uchar type;    char *function_name;    zend_uint num_args;    zend_uint required_num_args;    zend_arg_info *arg_info;    zend_bool pass_rest_by_reference;    unsigned char return_reference;    /* END of common elements */    zend_bool done_pass_two;    zend_uint *refcount;    zend_op *opcodes;    zend_uint last, size;    /* static variables support */    HashTable *static_variables;    zend_op *start_op;    int backpatch_count;    zend_uint this_var;    // ...}</code></pre><p>由上可以看到zend_op_array中包含function_name字段，也就是当前函数的名称。 再看看获取当前符号标的函数：</p><pre><code>static inline HashTable *zend_get_target_symbol_table(const zend_op *opline, const temp_variable *Ts, int type, const zval *variable TSRMLS_DC){    switch (opline-&gt;op2.u.EA.type) {        ...//   省略        case ZEND_FETCH_STATIC:            if (!EG(active_op_array)-&gt;static_variables) {                ALLOC_HASHTABLE(EG(active_op_array)-&gt;static_variables);                zend_hash_init(EG(active_op_array)-&gt;static_variables, 2, NULL, ZVAL_PTR_DTOR, 0);            }            return EG(active_op_array)-&gt;static_variables;            break;        EMPTY_SWITCH_DEFAULT_CASE()    }    return NULL;}</code></pre><p>在前面的zend_do_fetch_static_variable执行时，op2.u.EA.type的值为ZEND_FETCH_STATIC， 从而这zend_get_target_symbol_table函数中我们返回的是EG(active_op_array)-&gt;static_variables。 也就是当前函数的的静态变量哈希表。每次执行时都会从该符号表中查找相应的值，由于op_array在程序执行时始终存在。 所有对静态符号表中数值的修改会继续保留，下次函数执行时继续从该符号表获取信息。 也就是说Zend为每个函数(准确的说是zend_op_array)分配了一个私有的符号表来保存该函数的静态变量。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33-弱类型变量的实现</title>
      <link href="/posts/6ec3ccb0.html"/>
      <url>/posts/6ec3ccb0.html</url>
      
        <content type="html"><![CDATA[<h1 id="33-弱类型变量的实现"><a href="#33-弱类型变量的实现" class="headerlink" title="33-弱类型变量的实现"></a>33-弱类型变量的实现</h1><p>PHP是弱类型，动态的语言脚本。在申明一个变量的时候，并不需要指明它保存的数据类型。</p><pre><code>&lt;?php  $var = 1;  $var = &quot;variable&quot;;  $var = 1.00;  $var = array();  $var = new Object();  ?&gt;</code></pre><p>动态变量，在运行期间是可以改变的，并且在使用前无需声明变量类型。</p><p>那么，问题一、Zend引擎是如何用C实现这种弱类型的呢？</p><p>实际上，在PHP中声明的变量，在ZE中都是用结构体zval来保存的。首先我们打开Zend/zend.h来看zval的定义：</p><pre><code>typedef struct _zval_struct zval;  struct _zval_struct {      /* Variable information */      zvalue_value value;     /* value */      zend_uint refcount__gc;      zend_uchar type;    /* active type */      zend_uchar is_ref__gc;  };  typedef union _zvalue_value {      long lval;  /* long value */      double dval;    /* double value */      struct {          char *val;          int len;      } str;      HashTable *ht;  /* hash table value */      zend_object_value obj;  } zvalue_value;Zend/zend_types.h：typedef unsigned char zend_bool;  typedef unsigned char zend_uchar;  typedef unsigned int zend_uint;  typedef unsigned long zend_ulong;  typedef unsigned short zend_ushort;  </code></pre><p>从上述代码中，可以看到_zvalue_value是真正保存数据的关键部分。通过共用体实现的弱类型变量声明。</p><p>问题二、Zend引擎是如何判别、存储PHP中的多种数据类型的呢？</p><p>_zval_struct.type中存储着一个变量的真正类型，根据type来选择如何获取zvalue_value的值。</p><p>type值列表(Zend/zend.h)：</p><pre><code>#define IS_NULL     0  #define IS_LONG     1  #define IS_DOUBLE   2  #define IS_BOOL     3  #define IS_ARRAY    4  #define IS_OBJECT   5  #define IS_STRING   6  #define IS_RESOURCE 7  #define IS_CONSTANT 8  #define IS_CONSTANT_ARRAY   9  </code></pre><p>来看一个简单的例子：</p><pre><code>&lt;?php      $a = 1;      //此时zval.type = IS_LONG,那么zval.value就去取lval.      $a = array();      //此时zval.type = IS_ARRAY,那么zval.value就去取ht.  ?&gt;</code></pre><p>这其中最复杂的，并且在开发第三方扩展中经常需要用到的是”资源类型”。在PHP中，任何不属于PHP的内建的变量类型的变量，都会被看作资源来进行保存。比如：数据库句柄、打开的文件句柄、打开的socket句柄。</p><p>资源类型，需要使用ZE提供的API函数来注册，资源变量的声明和使用将在单独的篇目中进行详细介绍。正是因为ZE这样的处理方式，使PHP就实现了弱类型，而对于ZE的来说，它所面对的永远都是同一种类型zval。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32-变量的类型转换</title>
      <link href="/posts/86e72f29.html"/>
      <url>/posts/86e72f29.html</url>
      
        <content type="html"><![CDATA[<h1 id="32-变量的类型转换"><a href="#32-变量的类型转换" class="headerlink" title="32-变量的类型转换"></a>32-变量的类型转换</h1><p>现在我们已经可以从符号表中获取用户在PHP语言里定义的变量了，是该做点其它事的时候了，举个比例，比如给它来个类型转换:-)。想想C语言中的类型转换细则，你的头是不是已经大了？但是变量的类型转换就是如此重要，如果没有，那我们的代码就会是下面这样了:</p><pre><code>void display_zval(zval *value){    switch (Z_TYPE_P(value)) {        case IS_NULL:            /* 如果是NULL，则不输出任何东西 */            break;        case IS_BOOL:            /* 如果是bool类型，并且true，则输出1，否则什么也不干 */            if (Z_BVAL_P(value)) {                php_printf(&quot;1&quot;);            }            break;        case IS_LONG:            /* 如果是long整型，则输出数字形式 */            php_printf(&quot;%ld&quot;, Z_LVAL_P(value));            break;        case IS_DOUBLE:            /* 如果是double型，则输出浮点数 */            php_printf(&quot;%f&quot;, Z_DVAL_P(value));            break;        case IS_STRING:            /* 如果是string型，则二进制安全的输出这个字符串 */            PHPWRITE(Z_STRVAL_P(value), Z_STRLEN_P(value));            break;        case IS_RESOURCE:            /* 如果是资源，则输出Resource #10 格式的东东 */            php_printf(&quot;Resource #%ld&quot;, Z_RESVAL_P(value));            break;        case IS_ARRAY:            /* 如果是Array，则输出Array5个字母！ */            php_printf(&quot;Array&quot;);            break;        case IS_OBJECT:            php_printf(&quot;Object&quot;);            break;        default:            /* Should never happen in practice,             * but it&apos;s dangerous to make assumptions             */             php_printf(&quot;Unknown&quot;);             break;    }}</code></pre><p>看完上面的代码，你是不是有点似曾相识的感觉？o(∩∩)o…哈哈，和直接&lt;?php echo $foo;?&gt;这个简单到极点的php语句来比，上面的实现算是天书了。当然，真正的环境并没有这么囧，内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()</p><pre><code>//将任意类型的zval转换成字符串void change_zval_to_string(zval *value){    convert_to_string(value);}//其它基本的类型转换函数ZEND_API void convert_to_long(zval *op);ZEND_API void convert_to_double(zval *op);ZEND_API void convert_to_null(zval *op);ZEND_API void convert_to_boolean(zval *op);ZEND_API void convert_to_array(zval *op);ZEND_API void convert_to_object(zval *op);ZEND_API void _convert_to_string(zval *op ZEND_FILE_LINE_DC);#define convert_to_string(op) if ((op)-&gt;type != IS_STRING) { _convert_to_string((op) ZEND_FILE_LINE_CC); }</code></pre><p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。</p><p>好了，我们用php的echo的时候会先把变量转换成字符串，但是我们看见convert_to_string的参数是zval*的，你是不是开始担心在进行数据转换时破坏了原来数据的值？而我们&lt;?php $a=intval($b);?&gt;并不会破坏$b的值。把原来的值破坏掉的做法绝对不是一个好主意，内核中在echo一个变量的时候也不是这样做的。在下一章，我们将知道怎样便可以在不损坏原变量值的情况下，进行convert_to_类操作。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31-变量的检索</title>
      <link href="/posts/f457aa2c.html"/>
      <url>/posts/f457aa2c.html</url>
      
        <content type="html"><![CDATA[<h1 id="31-变量的检索"><a href="#31-变量的检索" class="headerlink" title="31-变量的检索"></a>31-变量的检索</h1><p>用户在PHP语言里定义的变量，我们能否在内核中获取到呢？答案当然是肯定的，下面我们就看如何通过zend_hash_find()函数来找到当前某个作用域下用户已经定义好的变量。zend_hash_find()函数是内核提供的操作HashTable的API之一，如果你没有接触过，可以先记住这么使用就可以了。</p><pre><code>{    zval **fooval;    if (zend_hash_find(            EG(active_symbol_table), //这个参数是地址，如果我们操作全局作用域，则需要&amp;EG(symbol_table)            &quot;foo&quot;,            sizeof(&quot;foo&quot;),            (void**)&amp;fooval        ) == SUCCESS    )    {        php_printf(&quot;成功发现$foo!&quot;);    }    else    {        php_printf(&quot;当前作用域下无法发现$foo.&quot;);    }}</code></pre><p>首先我们定义了一个指向指针的指针，然后通过zend_hash_find去EG(active_symbol_table)作用域下寻找名称为foo($foo)的变量，如果成功找到，此函数将返回SUCCESS。看完代码，你肯定有很多疑问。为什么还要进行sizeof(“foo”)运算，fooval明明是zval<strong>型的，为什么转成void</strong>的？而且为什么还要进行&amp;fooval运算，fooval本身不就已经是指向指针的指针了吗？:-)，该回答的问题确实很多，不要过于担心，让我们带着这些问题继续往下走。</p><p>首先要说明的是，内核定义HashTable这个结构，并不是单单用来储存PHP语言里的变量的，其它很多地方都在应用HashTable(这就是个神器)。一个HashTable有很多元素，在内核里叫做bucket。然而每个bucket的大小是固定的，所以如果我们想在bucket里存储任意数据时，最好的办法便是申请一块内存保存数据，然后在bucket里保存它的指针。以zval <em>foo为例，内核会先申请一块足够保存指针内存来保存foo，比如这块内存的地址是p，也就是p=&amp;foo，并在bucket里保存p，这时我们便明白了，p其实就是zval<strong>类型的。至于bucket为什么保存zval</strong>类型的指针，而不是直接保存zval</em>类型的指针，我们到下一章在详细叙述。</p><p>所以当我们去HashTable里寻找变量的时候，得到的值其实是一个zval的指针。In order to populate that pointer into a calling function’s local storage, the calling function will naturally dereference the local pointer, resulting in a variable of indeterminate type with two levels of indirection (such as void*<em>). Knowing that your “indeterminate type” in this case is zval</em>, you can see where the type being passed into zend_hash_find() will look different to the compiler, having three levels of indirection rather than two. This is done on purpose here so a simple typecast is added to the function call to silence compiler warnings.</p><p>如果zend_hash_find()函数找到了我们需要的数据，它将返回SUCCESS常量，并把它的地址赋给我们在调用zend_hash_find()函数传递的fooval参数，也就是说此时fooval就指向了我们要找的数据。如果没有找到，那它不会对我们fooval参数做任何修改，并返回FAILURE常量。</p><p>就去符号表里找变量而言，SUCCESS和FAILURE仅代表这个变量是否存在而已。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30-预定义变量</title>
      <link href="/posts/d8fa8a72.html"/>
      <url>/posts/d8fa8a72.html</url>
      
        <content type="html"><![CDATA[<h1 id="30-预定义变量"><a href="#30-预定义变量" class="headerlink" title="30-预定义变量"></a>30-预定义变量</h1><p>大家都知道PHP脚本在执行的时候用户全局变量(在用户空间显式定义的变量)会保存在一个HashTable数据类型的符号表(symbol_table)中， 在PHP中有一些比较特殊的全局变量例如: $_GET，$_POST，$_SERVER等变量，我们并没有在程序中定义这些变量，并且这些变量也同样保存在符号表中， 从这些表象我们不难得出结论：PHP是在脚本运行之前就将这些特殊的变量加入到了符号表中了。</p><h2 id="GLOBALS的初始化"><a href="#GLOBALS的初始化" class="headerlink" title="$GLOBALS的初始化"></a>$GLOBALS的初始化</h2><p>我们以cgi模式为例说明$GLOBALS的初始化。 从cgi_main.c文件main函数开始。 整个调用顺序如下所示：</p><pre><code>[main() -&gt; php_request_startup() -&gt; zend_activate() -&gt; init_executor() ]... //  省略zend_hash_init(&amp;EG(symbol_table), 50, NULL, ZVAL_PTR_DTOR, 0);{    zval *globals;    ALLOC_ZVAL(globals);    Z_SET_REFCOUNT_P(globals, 1);    Z_SET_ISREF_P(globals);    Z_TYPE_P(globals) = IS_ARRAY;    Z_ARRVAL_P(globals) = &amp;EG(symbol_table);    zend_hash_update(&amp;EG(symbol_table), &quot;GLOBALS&quot;, sizeof(&quot;GLOBALS&quot;),        &amp;globals, sizeof(zval *), NULL);      //  添加全局变量GLOBALS}... //  省略</code></pre><p>上面的代码的关键点zend_hash_update函数的调用，它将变量名为GLOBALS的变量注册到EG(symbol_table)中， EG(symbol_table)是一个HashTable的结构，用来存放所有的全局变量。 这在下面将要提到的$_GET等变量初始化时也会用到。</p><h2 id="GET、-POST等变量的初始化"><a href="#GET、-POST等变量的初始化" class="headerlink" title="$_GET、$_POST等变量的初始化"></a>$_GET、$_POST等变量的初始化</h2><p>$_GET、$_COOKIE、$_SERVER、$_ENV、$_FILES、$_REQUEST这六个变量都是通过如下的调用序列进行初始化。 [main() -&gt; php_request_startup() -&gt; php_hash_environment() ]</p><p>在请求初始化时，通过调用 php_hash_environment 函数初始化以上的六个预定义的变量。 如下所示为php_hash_environment函数的代码。在代码之后我们以$_POST为例说明整个初始化的过程。</p><pre><code>/* {{{ php_hash_environment */int php_hash_environment(TSRMLS_D){        char *p;        unsigned char _gpc_flags[5] = {0, 0, 0, 0, 0};        zend_bool jit_initialization = (PG(auto_globals_jit) &amp;&amp; !PG(register_globals) &amp;&amp; !PG(register_long_arrays));        struct auto_global_record {                char *name;                uint name_len;                char *long_name;                uint long_name_len;                zend_bool jit_initialization;        } auto_global_records[] = {                { &quot;_POST&quot;, sizeof(&quot;_POST&quot;), &quot;HTTP_POST_VARS&quot;, sizeof(&quot;HTTP_POST_VARS&quot;), 0 },                { &quot;_GET&quot;, sizeof(&quot;_GET&quot;), &quot;HTTP_GET_VARS&quot;, sizeof(&quot;HTTP_GET_VARS&quot;), 0 },                { &quot;_COOKIE&quot;, sizeof(&quot;_COOKIE&quot;), &quot;HTTP_COOKIE_VARS&quot;, sizeof(&quot;HTTP_COOKIE_VARS&quot;), 0 },                { &quot;_SERVER&quot;, sizeof(&quot;_SERVER&quot;), &quot;HTTP_SERVER_VARS&quot;, sizeof(&quot;HTTP_SERVER_VARS&quot;), 1 },                { &quot;_ENV&quot;, sizeof(&quot;_ENV&quot;), &quot;HTTP_ENV_VARS&quot;, sizeof(&quot;HTTP_ENV_VARS&quot;), 1 },                { &quot;_FILES&quot;, sizeof(&quot;_FILES&quot;), &quot;HTTP_POST_FILES&quot;, sizeof(&quot;HTTP_POST_FILES&quot;), 0 },        };        size_t num_track_vars = sizeof(auto_global_records)/sizeof(struct auto_global_record);        size_t i;        /* jit_initialization = 0; */        for (i=0; i&lt; num_track_vars; i++) {                PG(http_globals)[i] = NULL;        }        for (p=PG(variables_order); p &amp;&amp; *p; p++) {                switch(*p) {                        case &apos;p&apos;:                        case &apos;P&apos;:                                if (!_gpc_flags[0] &amp;&amp; !SG(headers_sent) &amp;&amp; SG(request_info).request_method &amp;&amp; !strcasecmp(SG(request_info).request_method, &quot;POST&quot;)) {                                        sapi_module.treat_data(PARSE_POST, NULL, NULL TSRMLS_CC);   /* POST Data */                                        _gpc_flags[0] = 1;                                        if (PG(register_globals)) {                                                php_autoglobal_merge(&amp;EG(symbol_table), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_POST]) TSRMLS_CC);                                        }                                }                                break;                        case &apos;c&apos;:                        case &apos;C&apos;:                                if (!_gpc_flags[1]) {                                        sapi_module.treat_data(PARSE_COOKIE, NULL, NULL TSRMLS_CC); /* Cookie Data */                                        _gpc_flags[1] = 1;                                        if (PG(register_globals)) {                                                php_autoglobal_merge(&amp;EG(symbol_table), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) TSRMLS_CC);                                        }                                }                                break;                        case &apos;g&apos;:                        case &apos;G&apos;:                                if (!_gpc_flags[2]) {                                        sapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);    /* GET Data */                                        _gpc_flags[2] = 1;                                        if (PG(register_globals)) {                                                php_autoglobal_merge(&amp;EG(symbol_table), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_GET]) TSRMLS_CC);                                        }                                }                                break;                        case &apos;e&apos;:                        case &apos;E&apos;:                                if (!jit_initialization &amp;&amp; !_gpc_flags[3]) {                                        zend_auto_global_disable_jit(&quot;_ENV&quot;, sizeof(&quot;_ENV&quot;)-1 TSRMLS_CC);                                        php_auto_globals_create_env(&quot;_ENV&quot;, sizeof(&quot;_ENV&quot;)-1 TSRMLS_CC);                                        _gpc_flags[3] = 1;                                        if (PG(register_globals)) {                                                php_autoglobal_merge(&amp;EG(symbol_table), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_ENV]) TSRMLS_CC);                                        }                                }                                break;                        case &apos;s&apos;:                        case &apos;S&apos;:                                if (!jit_initialization &amp;&amp; !_gpc_flags[4]) {                                        zend_auto_global_disable_jit(&quot;_SERVER&quot;, sizeof(&quot;_SERVER&quot;)-1 TSRMLS_CC);                                        php_register_server_variables(TSRMLS_C);                                        _gpc_flags[4] = 1;                                        if (PG(register_globals)) {                                                php_autoglobal_merge(&amp;EG(symbol_table), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]) TSRMLS_CC);                                        }                                }                                break;                }        }        /* argv/argc support */        if (PG(register_argc_argv)) {                php_build_argv(SG(request_info).query_string, PG(http_globals)[TRACK_VARS_SERVER] TSRMLS_CC);        }        for (i=0; i &lt; num_track_vars; i++) {                if (jit_initialization &amp;&amp; auto_global_records[i].jit_initialization) {                        continue;                }                if (!PG(http_globals)[i]) {                        ALLOC_ZVAL(PG(http_globals)[i]);                        array_init(PG(http_globals)[i]);                        INIT_PZVAL(PG(http_globals)[i]);                }                Z_ADDREF_P(PG(http_globals)[i]);                zend_hash_update(&amp;EG(symbol_table), auto_global_records[i].name, auto_global_records[i].name_len, &amp;PG(http_globals)[i], sizeof(zval *), NULL);                if (PG(register_long_arrays)) {                        zend_hash_update(&amp;EG(symbol_table), auto_global_records[i].long_name, auto_global_records[i].long_name_len, &amp;PG(http_globals)[i], sizeof(zval *), NULL);                        Z_ADDREF_P(PG(http_globals)[i]);                }        }        /* Create _REQUEST */        if (!jit_initialization) {                zend_auto_global_disable_jit(&quot;_REQUEST&quot;, sizeof(&quot;_REQUEST&quot;)-1 TSRMLS_CC);                php_auto_globals_create_request(&quot;_REQUEST&quot;, sizeof(&quot;_REQUEST&quot;)-1 TSRMLS_CC);        }        return SUCCESS;}</code></pre><p>以$_POST为例，首先以 auto_global_record 数组形式定义好将要初始化的变量的相关信息。 在变量初始化完成后，按照PG(variables_order)指定的顺序（在php.ini中指定），通过调用sapi_module.treat_data处理数据。</p><p>从PHP实现的架构设计看，treat_data函数在SAPI目录下不同的服务器应该有不同的实现，只是现在大部分都是使用的默认实现。</p><p>在treat_data后，如果打开了PG(register_globals)，则会调用php_autoglobal_merge将相关变量的值写到符号表。</p><p>以上的所有数据处理是一个赋值前的初始化行为。在此之后，通过遍历之前定义的结构体， 调用zend_hash_update，将相关变量的值赋值给&amp;EG(symbol_table)。 另外对于$_REQUEST有独立的处理方法。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29-变量的创建</title>
      <link href="/posts/ddf8bf81.html"/>
      <url>/posts/ddf8bf81.html</url>
      
        <content type="html"><![CDATA[<h1 id="29-变量的创建"><a href="#29-变量的创建" class="headerlink" title="29-变量的创建"></a>29-变量的创建</h1><p>我们已经知道php变量在内核中其实是通过zval结构来实现的，也初步了如果设置一个zval结构的类型和值，这一节我们的目的便是在前两节的基础上，彻底掌握对zval结构的操控，其间将引入很多超棒的新的宏。</p><p>在code的时候，我们很希望在内核中创建的zval可以让用户在PHP语言里以变量的形式使用，为了实现这个功能，我们首先要创建一个zval。最容易想到的办法便是创建一个zval指针，然后申请一块内存并让指针指向它。如果你脑海里浮现出了malloc(sizeof(zval))的影子，那么请你立即刹车，不要用malloc来做这件事情，内核给我们提供了相应的宏来处理这件事，理由和以前一样：为了代码漂亮并保持版本升级时的兼容性。这个宏的是：MAKE_STD_ZVAL(pzv)。这个宏会用内核的方式来申请一块内存并将其地址付给pzv，并初始化它的refcount和is_ref连个属性，更棒的是，它不但会自动的处理内存不足问题，还会在内存中选个最优的位置来申请。</p><p>除了MAKE_STD_ZVAL()宏函数，ALLOC_INIT_ZVAL()宏函数也是用来干这件事的，唯一的不同便是它会将pzv所指的zval的类型设置为IS_NULL;</p><p>申请完空间后，我们便可以给这个zval赋值了。基于咱已经介绍的宏，也许我们需要Z_TYPE_P(p) = IS_NULL来设置其是null类型，并过Z_SOMEVAL形式的宏来为它赋值，但是现在你有了更好更短的选择！</p><p>内核中提供一些宏来简化我们的操作，可以只用一步便设置好zval的类型和值。</p><table><br><tr><td>新宏</td><td>其它宏的实现方法</td></tr><br><tr><td><br>ZVAL_NULL(pvz); (注意这个Z和VAL之间没有下划线！)<br></td><td><br>Z_TYPE_P(pzv) = IS_NULL;(IS_NULL型不用赋值，因为这个类型只有一个值就是null，^_^)<br></td></tr><br><tr><td><br>ZVAL_BOOL(pzv, b); (将pzv所指的zval设置为IS_BOOL类型，值是b)<br></td><td><br>Z_TYPE_P(pzv) = IS_BOOL;<br>Z_BVAL_P(pzv) = b ? 1 : 0;<br></td></tr><br><tr><td><br>ZVAL_TRUE(pzv); (将pzv所指的zval设置为IS_BOOL类型，值是true)<br></td><td><br>ZVAL_BOOL(pzv, 1);<br><br></td></tr><br><tr><td><br>ZVAL_FALSE(pzv); (将pzv所指的zval设置为IS_BOOL类型，值是false)<br></td><td><br>ZVAL_BOOL(pzv, 0);<br></td></tr><br><tr><td><br>ZVAL_LONG(pzv, l); (将pzv所指的zval设置为IS_LONG类型，值是l)<br></td><td><br>Z_TYPE_P(pzv) = IS_LONG;<br>Z_LVAL_P(pzv) = l;<br></td></tr><br><tr><td><br>ZVAL_DOUBLE(pzv, d); (将pzv所指的zval设置为IS_DOUBLE类型，值是d)<br></td><td><br>Z_TYPE_P(pzv) = IS_DOUBLE;<br>Z_DVAL_P(pzv) = d;<br></td></tr><br><tr><td><br>ZVAL_STRINGL(pzv,str,len,dup);(下面单独解释)<br></td><td><br>Z_TYPE_P(pzv) = IS_STRING;<br>Z_STRLEN_P(pzv) = len;<br>if (dup)<br>{Z_STRVAL_P(pzv) =estrndup(str, len + 1);}<br>else<br>{Z_STRVAL_P(pzv) = str;}<br></td></tr><br><tr><td><br>ZVAL_STRING(pzv, str, dup);<br></td><td><br>ZVAL _STRINGL(pzv, str,strlen(str), dup);<br></td></tr><br><tr><td><br>ZVAL_RESOURCE(pzv, res);<br></td><td><br>Z_TYPE_P(pzv) = IS_RESOURCE;<br>Z_RESVAL_P(pzv) = res;<br></td></tr><br></table><h2 id="ZVAL-STRINGL-pzv-str-len-dup-中的dup参数"><a href="#ZVAL-STRINGL-pzv-str-len-dup-中的dup参数" class="headerlink" title="ZVAL_STRINGL(pzv,str,len,dup)中的dup参数"></a>ZVAL_STRINGL(pzv,str,len,dup)中的dup参数</h2><p>先阐述一下ZVAL_STRINGL(pzv,str,len,dup); str和len两个参数很好理解，因为我们知道内核中保存了字符串的地址和它的长度，后面的dup的意思其实很简单，它指明了该字符串是否需要被复制。值为 1 将先申请一块新内存并赋值该字符串，然后把新内存的地址复制给pzv，为 0 时则是直接把str的地址赋值给zval。《抚琴居》上的一篇文章说这项特性将会在你仅仅需要创建一个变量并将其指向一个已经由 Zend 内部数据内存时变得很有用。</p><h2 id="ZVAL-STRINGL与ZVAL-STRING的区别"><a href="#ZVAL-STRINGL与ZVAL-STRING的区别" class="headerlink" title="ZVAL_STRINGL与ZVAL_STRING的区别"></a>ZVAL_STRINGL与ZVAL_STRING的区别</h2><p>如果你想在某一位置截取该字符串或已经知道了这个字符串的长度，那么可以使用宏 ZVAL_STRINGL(zval, string, length, duplicate) ，它显示的指定字符串长度，而不是使用strlen()。这个宏该字符串长度作为参数。但它是二进制安全的，而且速度也比ZVAL_STRING快，因为少了个strlen。</p><h2 id="ZVAL-RESOURCE约等于ZVAL-LONG"><a href="#ZVAL-RESOURCE约等于ZVAL-LONG" class="headerlink" title="ZVAL_RESOURCE约等于ZVAL_LONG"></a>ZVAL_RESOURCE约等于ZVAL_LONG</h2><p>上一节中我们说过PHP中的资源类型的值其实就是一个整数，所以ZVAL_RESOURCE和ZVAL_LONG的工作差不多，只不过它会把zval的类型设置为 IS_RESOURCE.</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28-变量的值操作</title>
      <link href="/posts/6ff5e655.html"/>
      <url>/posts/6ff5e655.html</url>
      
        <content type="html"><![CDATA[<h1 id="28-变量的值操作"><a href="#28-变量的值操作" class="headerlink" title="28-变量的值操作"></a>28-变量的值操作</h1><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头，并且P结尾和PP结尾的同上一节中的宏一样，分别代表这参数是指针还是指针的指针。此外，为了进一步方便我们的工作，内核中针对具体的数据类型分别定义了相应的宏。如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。我们通过下面这个例子来应用一下这几个宏:</p><pre><code>void display_value(zval zv,zval *zv_p,zval **zv_pp){    if( Z_TYPE(zv) == IS_NULL )    {        php_printf(&quot;类型是 IS_NULL!\n&quot;);    }    if( Z_TYPE_P(zv_p) == IS_LONG )    {        php_printf(&quot;类型是 IS_LONG，值是：%ld&quot; , Z_LVAL_P(zv_p));    }    if(Z_TYPE_PP(zv_pp) == IS_DOUBLE )    {        php_printf(&quot;类型是 IS_DOUBLE,值是：%f&quot; , Z_DVAL_PP(zv_pp) );    }}</code></pre><p>String型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度，所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。</p><pre><code>void display_string(zval *zstr){    if (Z_TYPE_P(zstr) != IS_STRING) {        php_printf(&quot;这个变量不是字符串!\n&quot;);        return;    }    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));    //这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。}</code></pre><p>Array型变量的值其实是存储在C语言实现的HashTable中的，我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()，但不推荐在新代码中再使用了。</p><p>对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。内核中定义了以下组合宏让我们方便的操作对象：OBJ_HANDLE, which returns the handle identifier, OBJ_HT for the handler table, OBJCE for the class definition, OBJPROP for the property HashTable, and OBJ_HANDLER for manipulating a specific handler method in the OBJ_HT table. Don’t worry about the meaning of these various object macros just yet; they’ll be covered in detail in Chapter 10, “PHP4 Objects,” and Chapter 11, “PHP5 Objects.”</p><p>资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。有关资源的内容我们将在第9章展开叙述。</p><p>有关值操作的宏都定义在./Zend/zend_operators.h文件里：</p><pre><code>//操作整数的#define Z_LVAL(zval)            (zval).value.lval#define Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)#define Z_LVAL_PP(zval_pp)        Z_LVAL(**zval_pp)//操作IS_BOOL布尔型的#define Z_BVAL(zval)            ((zend_bool)(zval).value.lval)#define Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)#define Z_BVAL_PP(zval_pp)        Z_BVAL(**zval_pp)//操作浮点数的#define Z_DVAL(zval)            (zval).value.dval#define Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)#define Z_DVAL_PP(zval_pp)        Z_DVAL(**zval_pp)//操作字符串的值和长度的#define Z_STRVAL(zval)            (zval).value.str.val#define Z_STRVAL_P(zval_p)        Z_STRVAL(*zval_p)#define Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)#define Z_STRLEN(zval)            (zval).value.str.len#define Z_STRLEN_P(zval_p)        Z_STRLEN(*zval_p)#define Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)//操作数组的#define Z_ARRVAL(zval)            (zval).value.ht#define Z_ARRVAL_P(zval_p)        Z_ARRVAL(*zval_p)#define Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)//操作对象的#define Z_OBJVAL(zval)            (zval).value.obj#define Z_OBJVAL_P(zval_p)        Z_OBJVAL(*zval_p)#define Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)#define Z_OBJ_HANDLE(zval)        Z_OBJVAL(zval).handle#define Z_OBJ_HANDLE_P(zval_p)        Z_OBJ_HANDLE(*zval_p)#define Z_OBJ_HANDLE_PP(zval_p)        Z_OBJ_HANDLE(**zval_p)#define Z_OBJ_HT(zval)            Z_OBJVAL(zval).handlers#define Z_OBJ_HT_P(zval_p)        Z_OBJ_HT(*zval_p)#define Z_OBJ_HT_PP(zval_p)        Z_OBJ_HT(**zval_p)#define Z_OBJCE(zval)            zend_get_class_entry(&amp;(zval) TSRMLS_CC)#define Z_OBJCE_P(zval_p)        Z_OBJCE(*zval_p)#define Z_OBJCE_PP(zval_pp)        Z_OBJCE(**zval_pp)#define Z_OBJPROP(zval)            Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)#define Z_OBJPROP_P(zval_p)        Z_OBJPROP(*zval_p)#define Z_OBJPROP_PP(zval_pp)        Z_OBJPROP(**zval_pp)#define Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf#define Z_OBJ_HANDLER_P(zval_p, h)    Z_OBJ_HANDLER(*zval_p, h)#define Z_OBJ_HANDLER_PP(zval_p, h)        Z_OBJ_HANDLER(**zval_p, h)#define Z_OBJDEBUG(zval,is_tmp)        (Z_OBJ_HANDLER((zval),get_debug_info)?    \                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \                        (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL))#define Z_OBJDEBUG_P(zval_p,is_tmp)    Z_OBJDEBUG(*zval_p,is_tmp)#define Z_OBJDEBUG_PP(zval_pp,is_tmp)    Z_OBJDEBUG(**zval_pp,is_tmp)//操作资源的#define Z_RESVAL(zval)            (zval).value.lval#define Z_RESVAL_P(zval_p)        Z_RESVAL(*zval_p)#define Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27-变量的类型</title>
      <link href="/posts/643a4308.html"/>
      <url>/posts/643a4308.html</url>
      
        <content type="html"><![CDATA[<h1 id="27-变量的类型"><a href="#27-变量的类型" class="headerlink" title="27-变量的类型"></a>27-变量的类型</h1><p>所有的编程语言都要提供一种数据的存储与检索机制，PHP也不例外。其它语言大都需要在使用变量之前先定义，并且它的类型也是无法再次改变的，而PHP却允许程序猿自由的使用变量而无须提前定义，甚至可以随时随意的对已存在的变量转换成其它任何PHP支持的数据类型。在程序在运行的时候，PHP还会自动的根据需求转换变量的类型。</p><p>如果你用过PHP，肯定体验过PHP的弱类型的变量体系。众所周知，PHP引擎是用C写的，而C确实一种强类型的编程语言，PHP内核中是如何用C来实现自己的这种弱类型特性的？下面谈谈变量的类型。</p><p>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：</p><pre><code>struct _zval_struct {    zvalue_value value;    /* 变量的值 */    zend_uint refcount__gc;    zend_uchar type;    /* 变量当前的数据类型 */    zend_uchar is_ref__gc;};typedef struct _zval_struct zval;//在Zend/zend_types.h里定义的：typedef unsigned int zend_uint;typedef unsigned char zend_uchar;</code></pre><p>zval里的refcout__gc是zend_uint类型，也就是unsinged int型，is_ref__gc和type则是unsigned char型的。保存变量值的value则是zvalue_value类型(PHP5)，它是一个Union，同样定义在了Zend/zend.h文件里：</p><pre><code>typedef union _zvalue_value {    long lval;    /* long value */    double dval;    /* double value */    struct {        char *val;        int len;    } str;    HashTable *ht;    /* hash table value */    zend_object_value obj;} zvalue_value;</code></pre><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p><table><br><td></td><tr>常量名称：</tr><tr>备注</tr><br><td></td><tr>IS_NULL</tr><tr><br>第一次使用的变量如果没有初始化过，则会自动的赋予这个变量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。<br></tr><br><td></td><tr>IS_BOOL</tr><tr><br>布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。<br></tr><br><td></td><tr>IS_LONG</tr><tr><br>PHP语言中的整型，在内核中是通过所在操作系统的singed long数据类型来表示的。在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出，而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。再者，因为使用了singed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。<br>$a=2147483647;<br>$a++;<br>echo $a;//会正确的输出 2147483648；<br></tr><br><td></td><tr>IS_DOUBLE</tr><tr><br>PHP中的浮点数据是通过C语言中的singed double型变量来存储的，这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的，而是采用了科学计数法来保存某个精度的浮点数。用科学计数法，计算机只用8位便可以保存2.225x10^(-308)1.798x10^308之间的浮点数。用计算机来处理浮点数简直就是一场噩梦，十进制的0.5专成二进制是0.1，0.8转换后是0.1100110011….。但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数，但是计算机可能只能精确存储到0.333333，当我们再乘以三时，其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.<br></tr><br><td></td><tr>IS_STRING</tr><tr><br>PHP中最常用的数据类型——字符串，在内存中的存储和C差不多，就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度，这个设计使PHP可以在字符串中嵌入‘\0’字符，也使PHP的字符串是二进制安全的，可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存，最后一个字节存储的是‘\0’字符，所以在不需要二进制安全操作的时候，我们可以像通常C语言的概念那样来使用它。<br></tr><br><td></td><tr>IS_ARRAY</tr><tr><br>数组是一个非常特殊的数据类型，它唯一的功能就是包含别的变量。在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多，它可以承载任意类型的数据，这一切都是HashTable的功劳，每个HashTable中的元素都有两部分组成：索引与值，每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。<br></tr><br><td></td><tr>IS_OBJECT</tr><tr><br>和数组一样，对象也是用来存储复合数据的，但是与数组不同的是，对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。相对与zend engine V1，V2中的对象实现已经被彻底修改，所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式，则应该对PHP5和PHP4分别对待！<br></tr><br><td></td><tr>IS_RESOURCE</tr><tr><br>有一些数据的内容可能无法直接呈现给PHP用户的，比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。<br></tr><br></table><p>zval结构体里的type成员的值便是以上某个IS_*常量之一。内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。</p><p>如果要我们检测一个变量的类型，最直接的办法便是去读取它的type成员的值：</p><pre><code>void describe_zval(zval *foo){    if (foo-&gt;type == IS_NULL)    {        php_printf(&quot;这个变量的数据类型是： NULL&quot;);    }    else    {        php_printf(&quot;这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d&quot;, foo-&gt;type);    }}</code></pre><p>上述做法看起来没有错误，但它是一种被强烈禁止一种做法！</p><p>PHP内核以后可能会修改变量的实现方式，所以检测type的方法可能在以后就不能用了。为了解决这个兼容问题，zend头文件中定义了大量的宏，供我们检测、操作变量使用，使用这些宏不但让我们的程序更易读，还具有更好的兼容性。这里我们用Z_TYPE_P()宏来改写上面那个程序。</p><pre><code>void describe_zval(zval *foo){    if ( Z_TYPE_P(foo) == IS_NULL )    {        php_printf(&quot;这个变量的数据类型是： NULL&quot;);    }    else    {        php_printf(&quot;这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d&quot;, foo-&gt;type);    }}</code></pre><p>php_printf()函数是内核对printf()函数的一层封装，我们可以像使用printf()函数那样使用它。</p><p>以_P一个p结尾的宏的参数大多是*zval型变量，此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。这样我们便可以猜测一下php内核是如何实现gettype这个函数了，代码如下：</p><pre><code>//开始定义php语言中的函数gettypePHP_FUNCTION(gettype){    //这个arg间接指向就是我们传给gettype函数的参数。是一个zval**结构    //所以我们要对他使用__PP后缀的宏。    zval **arg;    //这个if的操作主要是让arg指向参数～    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;Z&quot;, &amp;arg) == FAILURE) {        return;    }    //调用Z_TYPE_PP宏来获取arg指向zval的类型。    //然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值    switch (Z_TYPE_PP(arg)) {        case IS_NULL:            RETVAL_STRING(&quot;NULL&quot;, 1);            break;        case IS_BOOL:            RETVAL_STRING(&quot;boolean&quot;, 1);            break;        case IS_LONG:            RETVAL_STRING(&quot;integer&quot;, 1);            break;        case IS_DOUBLE:            RETVAL_STRING(&quot;double&quot;, 1);            break;        case IS_STRING:            RETVAL_STRING(&quot;string&quot;, 1);            break;        case IS_ARRAY:            RETVAL_STRING(&quot;array&quot;, 1);            break;        case IS_OBJECT:            RETVAL_STRING(&quot;object&quot;, 1);            break;        case IS_RESOURCE:            {                char *type_name;                type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);                if (type_name) {                    RETVAL_STRING(&quot;resource&quot;, 1);                    break;                }            }        default:            RETVAL_STRING(&quot;unknown type&quot;, 1);    }}</code></pre><p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p><pre><code>#define Z_TYPE(zval) (zval).type #define Z_TYPE_P(zval_p) Z_TYPE(*zval_p) #define Z_TYPE_PP(zval_pp) Z_TYPE(**zval_pp)</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26-变量的存储</title>
      <link href="/posts/fdd37f3c.html"/>
      <url>/posts/fdd37f3c.html</url>
      
        <content type="html"><![CDATA[<h1 id="26-变量的存储"><a href="#26-变量的存储" class="headerlink" title="26-变量的存储"></a>26-变量的存储</h1><p>PHP中的变量类型和值是通过C语言实现的，内核具体是如何组织用户在PHP中定义的变量呢？</p><p>Hash Table在ZE内核中被广泛使用，PHP变量也正是存储在一个HashTable实现的符号表里。当在PHP中调用一个函数或者类时，内核会创建一个新的符号表，这也是为什么在函数中无法使用函数外部定义的变量的原因。因为他们分属两个符号表，一个当前作用域，一个全局作用域。</p><p>现在来看内核中是如何定义作用域的：</p><pre><code>struct _zend_executor_globals {      //略      HashTable symbol_table;//全局变量的符号表      HashTable *active_symbol_table;//局部变量的符号表      //略  };  </code></pre><p>可以通过EG宏来访问变量符号表，EG(symbol_table)访问全局作用域的变量符号表，EG(active_symbol_table)访问当前作用域的变量符号表。</p><pre><code>&lt;?php  $foo=&apos;bar&apos;;  ?&gt;</code></pre><p>上面这段代码很简单，创建变量foo，并赋值bar。之后的PHP代码中就可以调用$foo变量了。现在看看PHP中定义的变量，内核中是如何实现的。伪代码：</p><pre><code>zval* foo;  MAKE_STD_ZVAL(foo);  ZVAL_STRING(foo, &quot;bar&quot;, 1);  ZEND_SET_SYMBOL( EG(active_symbol_table), &quot;foo&quot;, foo);  </code></pre><ul><li>第一步：创建一个zval结构，并设置类型。</li><li>第二步：赋值为bar。</li><li>第三步：将其加入当前作用域符号表，只有这样用户才能在PHP里使用这个变量。</li></ul><p>通过简单的这三步，即可实现定义PHP变量。简单的原因，在于内核为我们提供了强大的宏。现在我们将宏分别展开。</p><p>MAKE_STD_ZVAL应用到的宏有：</p><pre><code>#define     MAKE_STD_ZVAL(zv)               ALLOC_ZVAL(zv);INIT_PZVAL(zv)  #define     ALLOC_ZVAL(z)                   ZEND_FAST_ALLOC(z, zval, ZVAL_CACHE_LIST)  #define     ZEND_FAST_ALLOC(p, type, fc_type)       (p) = (type *) emalloc(sizeof(type))  #define     INIT_PZVAL(z)                       (z)-&gt;refcount__gc = 1;(z)-&gt;is_ref__gc = 0;  </code></pre><p>MAKE_STD_ZVAL(foo)展开后得到：</p><pre><code>(foo) = (zval *) emalloc(sizeof(zval));  (foo)-&gt;refcount__gc = 1;  (foo)-&gt;is_ref__gc = 0;</code></pre><p>可以看出，MAKE_STD_ZVAL做了三件事：分配内存、初始化zval结构中的refcount、is_ref。</p><p>ZVAL_STRING应用到的宏有：</p><pre><code>#define ZVAL_STRING(z, s, duplicate) {  \          const char *__s=(s);            \          Z_STRLEN_P(z) = strlen(__s);    \          Z_STRVAL_P(z) = (duplicate?estrndup(__s, Z_STRLEN_P(z)):(char*)__s);\          Z_TYPE_P(z) = IS_STRING;        \      }  #define Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)  #define Z_STRLEN(zval)          (zval).value.str.len  #define Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)  #define Z_STRVAL(zval)          (zval).value.str.val  #define Z_TYPE_P(zval_p)            Z_TYPE(*zval_p)  #define Z_TYPE(zval)            (zval).type  #define IS_STRING               6  </code></pre><p>展开后得到：</p><pre><code>const char *__s=(&quot;foo&quot;);  (foo).value.str.len=strlen(__s);  (foo).value.str.val=(duplicate?estrndup(__s, (zval).value.str.len):(char*)__s);  (foo).type=6;</code></pre><p>ZVAL_STRING做的工作是设置数据类型并赋值。</p><p>ZEND_SET_SYMBOL这里只展开一部分宏，因为它展开后过于复杂。</p><pre><code># define EG(v) (executor_globals.v)</code></pre><p>展开部分后得到：</p><pre><code>ZEND_SET_SYMBOL(executor_globals.active_symbol_table, &quot;foo&quot;, foo);  </code></pre><p>将变量名入当前作用域符号表。之所以使用内核提供的宏来分配内存、注册变量作用域，是因为这样能提高兼容性。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25-常量的实现</title>
      <link href="/posts/dbaa701.html"/>
      <url>/posts/dbaa701.html</url>
      
        <content type="html"><![CDATA[<h1 id="25-常量的实现"><a href="#25-常量的实现" class="headerlink" title="25-常量的实现"></a>25-常量的实现</h1><p>常量，顾名思义是一个常态的量值。它与值只绑定一次，它的作用在于有肋于增加程序的可读性和可靠性。 在PHP中，常量的名字是一个简单值的标识符，在脚本执行期间该值不能改变。 和变量一样，常量默认为大小写敏感，但是按照我们的习惯常量标识符总是大写的。 常量名和其它任何 PHP 标签遵循同样的命名规则。合法的常量名以字母或下划线开始，后面跟着任何字母，数字或下划线。</p><ul><li>在设定以后，常量的值无法更改</li><li>常量名不需要开头的美元符号 ($)</li><li>作用域不影响对常量的访问</li><li>常量值只能是字符串或数字</li></ul><p>在这一小节我们一起看下常量与我们常见的变量有啥区别，它在执行期间的不可改变的特性是如何实现的以及常量的定义过程。</p><p>首先看下常量与变量的区别，常量是在变量的zval结构的基础上添加了一额外的元素。如下所示为PHP中常量的内部结构。</p><h2 id="常量的内部结构"><a href="#常量的内部结构" class="headerlink" title="常量的内部结构"></a>常量的内部结构</h2><pre><code>typedef struct _zend_constant {    zval value; /* zval结构，PHP内部变量的存储结构，在第一小节有说明 */    int flags;  /* 常量的标记如 CONST_PERSISTENT | CONST_CS */    char *name; /* 常量名称 */    uint name_len;      int module_number;  /* 模块号 */} zend_constant;</code></pre><p>在Zend/zend_constants.h文件的33行可以看到如上所示的结构定义。 在常量的结构中，除了与变量一样的zval结构，它还包括属于常量的标记，常量名以及常量所在的模块号。</p><p>在了解了常量的存储结构后，我们来看PHP常量的定义过程。一个例子。</p><pre><code>define(&apos;NOWAMAGIC&apos;, &apos;www.nowamagic.net&apos;);</code></pre><p>这是一个很常规的常量定义过程，它使用了PHP的内置函数define。常量名为NOWAMAGIC，值为一个字符串，存放在zval结构中。 从这个例子出发，我们看下define定义常量的过程实现。</p><h2 id="define定义常量"><a href="#define定义常量" class="headerlink" title="define定义常量"></a>define定义常量</h2><p>define是PHP的内置函数，在Zend/zend_builtin_functions.c文件中定义了此函数的实现。如下所示为部分源码：</p><pre><code>/* {{{ proto bool define(string constant_name, mixed value, boolean case_insensitive=false)       Define a new constant */    ZEND_FUNCTION(define)    {            if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz|b", &name,                    &name_len, &val, &non_cs) == FAILURE) {                    return;            }            ... // 类常量定义 此处不做介绍            ... // 值类型判断和处理            c.value = *val;            zval_copy_ctor(&c.value);            if (val_free) {                    zval_ptr_dtor(&val_free);            }            c.flags = case_sensitive; /* non persistent */            c.name = zend_strndup(name, name_len);            c.name_len = name_len+1;            c.module_number = PHP_USER_CONSTANT;            if (zend_register_constant(&c TSRMLS_CC) == SUCCESS) {                    RETURN_TRUE;            } else {                    RETURN_FALSE;            }    }    /* }}} */</code></pre><p>上面的代码已经对对象和类常量做了简化处理， 其实现基本上是一个将传递的参数传递给新建的zend_constant结构，并将这个结构体注册到常量列表中的过程。 关于大小写敏感，函数的第三个参数表示是否大小不敏感，默认为false（大小写敏感）。这个参数最后会赋值给zend_constant结构体的flags字段。其在函数中实现代码如下：</p><pre><code>zend_bool non_cs = 0;   //  第三个参数的临时存储变量int case_sensitive = CONST_CS;  //  是否大小写敏感，默认为1if(non_cs) {    //  输入为真，大小写不敏感    case_sensitive = 0;}c.flags = case_sensitive; //     赋值给结构体字段</code></pre><p>从上面的define函数的实现来看，PHP对于常量的名称在定义时其实是没有所谓的限制。如下所示代码：</p><pre><code>define(&apos;^_^&apos;, &apos;smile&apos;);if (defined(&apos;^_^&apos;)) {    echo &apos;yes&apos;;}else{    echo &apos;no&apos;;}//$var = ^_^;   //语法错误$var = constant(&quot;^_^&quot;);</code></pre><p>通过defined函数测试表示，‘^_^’这个常量已经定义好，这样的常量无法直接调用， 只能使用constant语句来使用， 否则在语法解析时会显示错误。 在上面的代码中有用到一个判断常量是否定义的函数，下面我们看看这个函数是如何实现的。</p><h2 id="判断常量是否设置"><a href="#判断常量是否设置" class="headerlink" title="判断常量是否设置"></a>判断常量是否设置</h2><p>和define一样， defined的实现也在Zend/zend_builtin_functions.c文件， 其实现是一个读取参数变量，调用 zend_get_constant_ex函数获取常量的值来判断常量是否存在的过程。 而zend_get_constant_ex函数不仅包括了常规的常规的常量获取，还包括类常量的获取， 最后是通过zend_get_constant函数获取常量的值。在zend_get_constant函数中，基本上是通过下面的代码来获取常量的值。</p><pre><code>zend_hash_find(EG(zend_constants), name, name_len+1, (void **) &amp;c)</code></pre><p>除此之外，只是调用这个函数之前和之后对name有一些特殊的处理。</p><h2 id="常量的初始化"><a href="#常量的初始化" class="headerlink" title="常量的初始化"></a>常量的初始化</h2><p>以上通过define定义的常量的模块编号都是PHP_USER_CONSTANT，这表示是用户定义的常量。 除此之外我们在平时使用较多的，如在显示所有级别错误报告时使用的E_ALL常量就有点不同了。 这里我们以cgi模式为例说明标准常量的定义过程。 整个调用顺序如下所示：</p><pre><code>[php_cgi_startup() -&gt; php_module_startup() -&gt; zend_startup() -&gt; zend_register_standard_constants()]void zend_register_standard_constants(TSRMLS_D){    ... //  若干常量以REGISTER_MAIN_LONG_CONSTANT设置，    REGISTER_MAIN_LONG_CONSTANT(&quot;E_ALL&quot;, E_ALL, CONST_PERSISTENT | CONST_CS);    ...}</code></pre><p>REGISTER_MAIN_LONG_CONSTANT宏展开是以zend_register_long_constant实现。 zend_register_long_constant函数将常量中值的类型，值，名称及模块号赋值给新的zend_constant。 并调用zend_register_constant添加到全局的常量列表中。</p><pre><code>[php_cgi_startup() -&gt; php_module_startup() -&gt; zend_startup() -&gt; zend_register_standard_constants() -&gt; zend_register_constant]ZEND_API void zend_register_long_constant(const char *name, uint name_len,        long lval, int flags, int module_number TSRMLS_DC){    zend_constant c;    c.value.type = IS_LONG;    c.value.value.lval = lval;    c.flags = flags;    c.name = zend_strndup(name, name_len-1);    c.name_len = name_len;    c.module_number = module_number;    zend_register_constant(&amp;c TSRMLS_CC);}</code></pre><p>zend_register_constant函数首先根据常量中的c-&gt;flags判断是否区分大小写， 如果不区分，则名字统一为小写，如果包含”\“，也统一成小写。否则为定义的名字 然后将调用下面的语句将当前常量添加到EG(zend_constants)。 EG(zend_constants)是一个HashTable（这在前面的章节中说明）， 下面的代码是将常量添加到这个HashTable中。</p><pre><code>zend_hash_add(EG(zend_constants), name, c-&gt;name_len, (void *) c,        sizeof(zend_constant), NULL)==FAILURE)</code></pre><p>在php_module_startup函数中，除了zend_startup函数中有注册标准的常量， 它本身体通过宏REGISTER_MAIN_LONG_CONSTANT等注册了一些常量，如：PHP_VERSION，PHP_OS等。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-哈希碰撞攻击是什么？</title>
      <link href="/posts/96e95fa9.html"/>
      <url>/posts/96e95fa9.html</url>
      
        <content type="html"><![CDATA[<h1 id="24-哈希碰撞攻击是什么？"><a href="#24-哈希碰撞攻击是什么？" class="headerlink" title="24-哈希碰撞攻击是什么？"></a>24-哈希碰撞攻击是什么？</h1><p>最近哈希表碰撞攻击（Hashtable collisions as DOS attack）的话题不断被提起，各种语言纷纷中招。本文结合PHP内核源码，聊一聊这种攻击的原理及实现。</p><h2 id="哈希表碰撞攻击的基本原理"><a href="#哈希表碰撞攻击的基本原理" class="headerlink" title="哈希表碰撞攻击的基本原理"></a>哈希表碰撞攻击的基本原理</h2><p>哈希表是一种查找效率极高的数据结构，很多语言都在内部实现了哈希表。PHP中的哈希表是一种极为重要的数据结构，不但用于表示Array数据类型，还在Zend虚拟机内部用于存储上下文环境信息（执行上下文的变量及函数均使用哈希表结构存储）。</p><p>理想情况下哈希表插入和查找操作的时间复杂度均为O(1)，任何一个数据项可以在一个与哈希表长度无关的时间内计算出一个哈希值（key），然后在常量时间内定位到一个桶（术语bucket，表示哈希表中的一个位置）。当然这是理想情况下，因为任何哈希表的长度都是有限的，所以一定存在不同的数据项具有相同哈希值的情况，此时不同数据项被定为到同一个桶，称为碰撞（collision）。哈希表的实现需要解决碰撞问题，碰撞解决大体有两种思路，第一种是根据某种原则将被碰撞数据定为到其它桶，例如线性探测——如果数据在插入时发生了碰撞，则顺序查找这个桶后面的桶，将其放入第一个没有被使用的桶；第二种策略是每个桶不是一个只能容纳单个数据项的位置，而是一个可容纳多个数据的数据结构（例如链表或红黑树），所有碰撞的数据以某种数据结构的形式组织起来。</p><p>不论使用了哪种碰撞解决策略，都导致插入和查找操作的时间复杂度不再是O(1)。以查找为例，不能通过key定位到桶就结束，必须还要比较原始key（即未做哈希之前的key）是否相等，如果不相等，则要使用与插入相同的算法继续查找，直到找到匹配的值或确认数据不在哈希表中。</p><p>PHP是使用单链表存储碰撞的数据，因此实际上PHP哈希表的平均查找复杂度为O(L)，其中L为桶链表的平均长度；而最坏复杂度为O(N)，此时所有数据全部碰撞，哈希表退化成单链表。下图PHP中正常哈希表和退化哈希表的示意图。</p><center><br><img src="images/2012_02_14_01.png" alt><br></center><p>哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量CPU资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。</p><p>可以看到，进行哈希碰撞攻击的前提是哈希算法特别容易找出碰撞，如果是MD5或者SHA1那基本就没戏了，幸运的是（也可以说不幸的是）大多数编程语言使用的哈希算法都十分简单（这是为了效率考虑），因此可以不费吹灰之力之力构造出攻击数据。下一节将通过分析Zend相关内核代码，找出攻击哈希表碰撞攻击PHP的方法。</p><h2 id="Zend哈希表的内部实现"><a href="#Zend哈希表的内部实现" class="headerlink" title="Zend哈希表的内部实现"></a>Zend哈希表的内部实现</h2><p>PHP中使用一个叫Backet的结构体表示桶，同一哈希值的所有桶被组织为一个单链表。哈希表使用HashTable结构体表示。相关源码在zend/Zend_hash.h下：</p><pre><code>typedef struct bucket {    ulong h;                        /* Used for numeric indexing */    uint nKeyLength;    void *pData;    void *pDataPtr;    struct bucket *pListNext;    struct bucket *pListLast;    struct bucket *pNext;    struct bucket *pLast;    char arKey[1]; /* Must be last element */} Bucket;typedef struct _hashtable {    uint nTableSize;    uint nTableMask;    uint nNumOfElements;    ulong nNextFreeElement;    Bucket *pInternalPointer;   /* Used for element traversal */    Bucket *pListHead;    Bucket *pListTail;    Bucket **arBuckets;    dtor_func_t pDestructor;    zend_bool persistent;    unsigned char nApplyCount;    zend_bool bApplyProtection;#if ZEND_DEBUG    int inconsistent;#endif} HashTable;</code></pre><p>字段名很清楚的表明其用途，因此不做过多解释。重点明确下面几个字段：Bucket中的“h”用于存储原始key；HashTable中的nTableMask是一个掩码，一般被设为nTableSize – 1，与哈希算法有密切关系，后面讨论哈希算法时会详述；arBuckets指向一个指针数组，其中每个元素是一个指向Bucket链表的头指针。</p><p>哈希算法：PHP哈希表最小容量是8（2^3），最大容量是0×80000000（2^31），并向2的整数次幂圆整（即长度会自动扩展为2的整数次幂，如13个元素的哈希表长度为16；100个元素的哈希表长度为128）。nTableMask被初始化为哈希表长度（圆整后）减1。具体代码在zend/Zend_hash.c的_zend_hash_init函数中，这里截取与本文相关的部分并加上少量注释。</p><pre><code>ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC){    uint i = 3;    Bucket **tmp;    SET_INCONSISTENT(HT_OK);    //长度向2的整数次幂圆整    if (nSize &gt;= 0x80000000) {        /* prevent overflow */        ht-&gt;nTableSize = 0x80000000;    } else {        while ((1U &lt;&lt; i) &lt; nSize) {            i++;        }        ht-&gt;nTableSize = 1 &lt;&lt; i;    }    ht-&gt;nTableMask = ht-&gt;nTableSize - 1;    /*此处省略若干代码…*/    return SUCCESS;}</code></pre><p>值得一提的是PHP向2的整数次幂取圆整方法非常巧妙，可以背下来在需要的时候使用。</p><p>Zend HashTable的哈希算法很简单：hash(key)=key&amp;nTableMask</p><p>即简单将数据的原始key与HashTable的nTableMask进行按位与即可。如果原始key为字符串，则首先使用Times33算法将字符串转为整形再与nTableMask按位与：hash(strkey)=time33(strkey)&amp;nTableMask</p><p>下面是Zend源码中查找哈希表的代码：</p><pre><code>ZEND_API int zend_hash_index_find(const HashTable *ht, ulong h, void **pData){    uint nIndex;    Bucket *p;    IS_CONSISTENT(ht);    nIndex = h &amp; ht-&gt;nTableMask;    p = ht-&gt;arBuckets[nIndex];    while (p != NULL) {        if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == 0)) {            *pData = p-&gt;pData;            return SUCCESS;        }        p = p-&gt;pNext;    }    return FAILURE;}ZEND_API int zend_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData){    ulong h;    uint nIndex;    Bucket *p;    IS_CONSISTENT(ht);    h = zend_inline_hash_func(arKey, nKeyLength);    nIndex = h &amp; ht-&gt;nTableMask;    p = ht-&gt;arBuckets[nIndex];    while (p != NULL) {        if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == nKeyLength)) {            if (!memcmp(p-&gt;arKey, arKey, nKeyLength)) {                *pData = p-&gt;pData;                return SUCCESS;            }        }        p = p-&gt;pNext;    }    return FAILURE;}</code></pre><p>其中zend_hash_index_find用于查找整数key的情况，zend_hash_find用于查找字符串key。逻辑基本一致，只是字符串key会通过zend_inline_hash_func转为整数key，zend_inline_hash_func封装了times33算法，具体代码就不贴出了。</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>知道了PHP内部哈希表的算法，就可以利用其原理构造用于攻击的数据。一种最简单的方法是利用掩码规律制造碰撞。上文提到Zend HashTable的长度nTableSize会被圆整为2的整数次幂，假设我们构造一个2^16的哈希表，则nTableSize的二进制表示为：1 0000 0000 0000 0000，而nTableMask = nTableSize – 1为：0 1111 1111 1111 1111。接下来，可以以0为初始值，以2^16为步长，制造足够多的数据，可以得到如下推测：</p><pre><code>0000 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 00001 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 00010 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 00011 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 00100 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0……</code></pre><p>概况来说只要保证后16位均为0，则与掩码位于后得到的哈希值全部碰撞在位置0。下面是利用这个原理写的一段攻击代码：</p><pre><code>&lt;?php$size = pow(2, 16);$startTime = microtime(true);$array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) {    $array[$key] = 0;}$endTime = microtime(true);echo $endTime - $startTime, &apos; seconds&apos;, &quot;\n&quot;;?&gt;</code></pre><p>这段代码在我的VPS上（单CPU，512M内存）上用了近88秒才完成，并且在此期间CPU资源几乎被用尽。</p><p>而普通的同样大小的哈希表插入仅用时0.036秒：</p><pre><code>&lt;?php$size = pow(2, 16);$startTime = microtime(true);$array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $size; $key += 1) {    $array[$key] = 0;}$endTime = microtime(true);echo $endTime - $startTime, &apos; seconds&apos;, &quot;\n&quot;;?&gt;</code></pre><p>可以证明第二段代码插入N个元素的时间在O(N)水平，而第一段攻击代码则需O(N^2)的时间去插入N个元素。</p><p>当然，一般情况下很难遇到攻击者可以直接修改PHP代码的情况，但是攻击者仍可以通过一些方法间接构造哈希表来进行攻击。例如PHP会将接收到的HTTP POST请求中的数据构造为$_POST，而这是一个Array，内部就是通过Zend HashTable表示，因此攻击者只要构造一个含有大量碰撞key的post请求，就可以达到攻击的目的。具体做法不再演示。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>POST攻击的防护：针对POST方式的哈希碰撞攻击，目前PHP的防护措施是控制POST数据的数量。在&gt;=PHP5.3.9的版本中增加了一个配置项max_input_vars，用于标识一次http请求最大接收的参数个数，默认为1000。因此PHP5.3.x的用户可以通过升级至5.3.9来避免哈希碰撞攻击。5.2.x的用户可以使用这个patch：<a href="http://www.laruence.com/2011/12/30/2440.html。" target="_blank" rel="noopener">http://www.laruence.com/2011/12/30/2440.html。</a></p><p>另外的防护方法是在Web服务器层面进行处理，例如限制http请求body的大小和参数的数量等，这个是现在用的最多的临时处理方案。具体做法与不同Web服务器相关，不再详述。</p><p>上面的防护方法只是限制POST数据的数量，而不能彻底解决这个问题。例如，如果某个POST字段是一个json数据类型，会被PHP json_decode，那么只要构造一个超大的json攻击数据照样可以达到攻击目的。理论上，只要PHP代码中某处构造Array的数据依赖于外部输入，则都可能造成这个问题，因此彻底的解决方案要从Zend底层HashTable的实现动手。一般来说有两种方式，一是限制每个桶链表的最长长度；二是使用其它数据结构如红黑树取代链表组织碰撞哈希（并不解决哈希碰撞，只是减轻攻击影响，将N个数据的操作时间从O(N^2)降至O(NlogN)，代价是普通情况下接近O(1)的操作均变为O(logN)）。</p><p>目前使用最多的仍然是POST数据攻击，因此建议生产环境的PHP均进行升级或打补丁。至于从数据结构层面修复这个问题，目前还没有任何方面的消息。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23-翻译一篇HashTables文章</title>
      <link href="/posts/9ac2a355.html"/>
      <url>/posts/9ac2a355.html</url>
      
        <content type="html"><![CDATA[<h1 id="23-翻译一篇HashTables文章"><a href="#23-翻译一篇HashTables文章" class="headerlink" title="23-翻译一篇HashTables文章"></a>23-翻译一篇HashTables文章</h1><p>In case you ever heard me talking about PHP internals I certainly mentioned something along the lines of “Everything in PHP is a HashTable” that’s not true, but next to a zval the HashTable is one of the most important structures in PHP. While preparing my “PHP Under The Hood” talk for the Dutch PHP Conference there was a question on IRC about extension_loaded() being faster thanfunction_exists(), which might be strange as both of them are simple hash lookups and a hash lookup is said to be O(1). I started to write some slides for it but figured out that I won’t have the time to go through it during that presentation, so I’m doing this now, here:</p><p>如果你以前看过我写的PHP内核相关的内容，那么你一定记得我说过PHP中的任何东西都是哈希表。这不一定是真的，但是除了zval，哈希表确实是PHP中的最重要的结构了。在为Dutch PHP 大会准备”PHP Under The Hood” 演讲时，IRC上有个关于extension_loaded()比function_exists()快的问题，这让人感到疑惑，它们底层都是简单的哈希查找，而哈希查找的时间复杂度为O(1)。我写了一些相关的幻灯片，但是那个大会上已经没有时间了，所以放在了这里。</p><p>You all should know PHP arrays. They allow you to create a list of elements where every element may be identified by a key. This key may either be an integer or a string. Now we need a way to store this association in an effective way in memory. An efficient way to store a collection of data in memory is a “real” array, an array of elements indexed by a sequence of numbers, starting at 0, up to n. As memory is essentially a sequence of numbered storage blocks (this obviously is simplified, there might be segments and offsets, there might be virtual pages, etc.) we can efficiently access an element by knowing the address of the first element, the size of the elements (we assume all have the same size, which is the case here), and the index: The address of the n-th element is start_address + (n * size_of_element). That’s basically what C arrays are.</p><p>大家都应该知道PHP数组，它可以保存一系列元素，并且可以用一个key来标识每个元素，这个key可以是整数或字符串。因而我们需要在内存中有一个高效的方案来保存这种关联关系。其中一个高效的方案是把内存中的这些数据存储为”真正“的数组，一个从索引0开始到n的连续序列。内存从本质上讲就是一个连续的存储块（这么说是简化了的结果，其实这里有段、偏移以及虚拟页等概念）。我们可以快速地访问一个元素：只要我们知道第一个元素的地址，元素的大小（这里假设每个元素大小一致）和待查找元素的索引值。第n个元素的地址计算公式为：第一个元素地址 + (n * 元素大小)，C语言中的数组就是这么实现的。</p><p>Now we’re not dealing with C and C arrays but also want to use string offsets so we need a function to calculate a numeric value, a hash, for each key. An hash function you most likely know is MD5, MD5 is creating a 128 bit numeric value which is often represented using 32 hexadecimal characters. For our purpose 128 bit is a bit much and MD5 is too slow so the PHP developers have chosen the “DJBX33A (Daniel J. Bernstein, Times 33 with Addition)” algorithm. This hash function is relatively fast and gives us an integer of the value, the trouble with this algorithm is that it is more likely to produce conflicts, that means to string values which create the same numeric value.</p><p>现在我们处理的不是C语言和它的数组，我们想用字符串偏移量，所以我们需要一个哈希函数，为每个键值计算出一个数值。大家最熟悉的哈希函数可能是MD5，它产生一个128比特的数值，且通常用32个十六进制的字符表示。对于我们的目的而言，128比特的数值太大了，MD5计算过程缓慢，因而PHP开发者选择了”DJBX33A (Daniel J. Bernstein, Times 33 with Addition)”算法。这个哈希函数相对快地从一个字符串计算出一个整数，缺点是冲突的概率增大了，即不同的字符串产生了相同的数值。</p><p>Now back to our C array: For being able to safely read any element, to see whether it is used, we need to pre-allocate the entire array with space for all possible elements. Given our hash function returning a system dependent (32 bit or 64 bit) integer this is quite a lot (size of an element multiplied wit the max int value), so PHP does another trick: It throws some digits away. For this a table mask is calculated. The a table mask is a number which is a power of two and then one subtracted and ideally higher than the number elements in the hash table. If one looks at this in binary representation this is a number where all bits are set. Doing a binary AND operation of our hash value and the table this gives us a number which is smaller than our table mask. Let’s look at an example: The hash value of “foobar” equals, in decimal digits, to 3127933054. We assume a table mask of 2047 (2¹¹-1).</p><p>回到C数组：为了安全地读到任何一个元素，不管它是否用到，我们需要为所有可能元素预先分配空间。假设我们的哈希函数返回一个系统相关（32位或64位）的整数，数值非常大，这时PHP需要另外一个技巧：抛弃一些比特。这是通过表掩码实现的，表掩码是这样一个数，不小于哈希表的元素个数值且为2的次方减一。如果查看它的二进制表现形式，即各个位都设置为1的数。把哈希值和表掩码做二进制与操作，得到一个小于表掩码的数值。如：”foobar”的十进制格式的哈希值为3127933054，假设表掩码为2047 (2¹¹-1)。</p><pre><code>3127933054    10111010011100000111100001111110&amp; 2047 00000000000000000000011111111111=        126    00000000000000000000000001111110</code></pre><p>Wonderful - we have an array Index, 126, for this string and can set the value in memory!</p><p>好——我们得到这个字符串的数组索引值126，就可以在内存中操作了。</p><p>If life were that easy. Remember: We used a hashing function which is by far not collision free and then dropped almost two thirds of the binary digits by using the table mask. This makes it rather likely that some collisions appear. These collisions are handled by storing values with the same hash in a linked list. So for accessing the an element one has to</p><ol><li>Calculate the hash</li><li>Apply the table mask</li><li>locate the memory offset</li><li>check whether this is the element we need, traverse the linked list.</li></ol><p>生活并不如此简单，我们使用的哈希函数不能避免碰撞，并通过表掩码抛弃了几乎三分之二的位，这更增大了碰撞的几率。解决办法是把相同哈希值的元素保存在链表中，所以访问一个元素的时候：</p><ol><li>计算哈希值</li><li>应用表掩码</li><li>找到内存位置</li><li>遍历链表，检查是否是查找的元素</li></ol><p>Now the question initially asked was why extension_loaded() might be faster than function_exists() and we can tell: For many random reasons and since you have chosen a value which probably conflicts in the first, not in the second. So now the question is how often such collisions happen for this I did a quick analysis: Given the function table of a random PHP build of mine with 1106 functions listed I have 634 unique hash values and 210 hash values calculated from different functions. Worst is the value of 471 which represents 6 functions.</p><p>现在可以回答文章开头提出的为什么extension_loaded()可能比function_exists() 快的问题了：它可以在第一次查找时即找到对应元素。现在的问题是这种冲突的概率有多大，我做了一个快速的分析：我的PHP构建版本的函数表中有1106个函数，计算得到634个唯一的哈希值，210个有冲突的哈希值，最差的哈希值471对应了6个函数。</p><p>Full results are online but please mind: These results are very specific to my environment. Also mind that the code actually works on a copy of my function table so the table mask might be different, which changes results. Also note that the given PHP code won’t work for you as I added special functions exporting the table mask and hash function to mz version of PHP. And then yet another note: doing performance optimizations on this level is the by far worst place as to many unknown factors go in. And you don’t have any measurable performance win. Mind readability. Clear code is worth way more than the 2 CPU cycles you probably gain! But you may have learned how hash tables work.</p><p>全部的结果在这里，不过请注意，这个结果是在我的环境里测试的，而且即使是我这个版本的代码拷贝，也会因为表掩码不同而导致结果不同。另外要注意的是，这些代码在你的环境中是无法工作的，因为我在PHP源码中添加了一些表掩码和哈希函数相关的代码。另外一个提示：由于各种未知的因素，想在这个地方进行优化并不合适，你很难获得明显的性能提升。清晰可读的代码远比两个CPU周期重要，不过通过它你可以学习哈希表是如何工作的。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-PHP哈希算法设计</title>
      <link href="/posts/aa43efb9.html"/>
      <url>/posts/aa43efb9.html</url>
      
        <content type="html"><![CDATA[<h1 id="22-PHP哈希算法设计"><a href="#22-PHP哈希算法设计" class="headerlink" title="22-PHP哈希算法设计"></a>22-PHP哈希算法设计</h1><p>Hash Table是PHP的核心，这话一点都不过分。PHP的数组、关联数组、对象属性、函数表、符号表等等都是用HashTable来做为容器的。</p><p>PHP的HashTable采用的拉链法来解决冲突，这个自不用多说，我今天主要关注的就是PHP的Hash算法，和这个算法本身透露出来的一些思想。</p><p>PHP的Hash采用的是目前最为普遍的DJBX33A (Daniel J. Bernstein, Times 33 with Addition)，这个算法被广泛运用与多个软件项目，Apache、Perl和Berkeley DB等。对于字符串而言这是目前所知道的最好的哈希算法，原因在于该算法的速度非常快，而且分类非常好(冲突小，分布均匀)。</p><p>算法的核心思想就是：</p><pre><code>hash(i) = hash(i-1) * 33 + str[i]</code></pre><p>在zend_hash.h中，我们可以找到在PHP中的这个算法：</p><pre><code>static inline ulong zend_inline_hash_func(char *arKey, uint nKeyLength){    register ulong hash = 5381;    /* variant with the hash unrolled eight times */    for (; nKeyLength &gt;= 8; nKeyLength -= 8) {        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;        hash = ((hash &lt;&lt; 5) + hash) + *arKey++;    }    switch (nKeyLength) {        case 7: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */        case 6: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */        case 5: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */        case 4: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */        case 3: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */        case 2: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */        case 1: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; break;        case 0: break;EMPTY_SWITCH_DEFAULT_CASE()    }    return hash;}相比在Apache和Perl中直接采用的经典Times 33算法：  hashing function used in Perl 5.005:  # Return the hashed value of a string: $hash = perlhash(&quot;key&quot;)  # (Defined by the PERL_HASH macro in hv.h)  sub perlhash  {      $hash = 0;      foreach (split //, shift) {          $hash = $hash*33 + ord($_);      }      return $hash;  }</code></pre><p>在PHP的hash算法中，我们可以看出很处细致的不同。首先，最不一样的就是，PHP中并没有使用直接乘33，而是采用了：</p><pre><code>hash &lt;&lt; 5 + hash</code></pre><p>这样当然会比用乘快了。</p><p>然后，特别要主意的就是使用的unrolled，我前几天看过一篇文章讲Discuz的缓存机制，其中就有一条说是Discuz会根据帖子的热度不同采用不同的缓存策略，根据用户习惯，而只缓存帖子的第一页(因为很少有人会翻帖子)。</p><p>于此类似的思想，PHP鼓励8位一下的字符索引，他以8为单位使用unrolled来提高效率，这不得不说也是个很细节的，很细致的地方。</p><p>另外还有inline，register变量 … 可以看出PHP的开发者在hash的优化上也是煞费苦心。</p><p>最后就是，hash的初始值设置成了5381，相比在Apache中的times算法和Perl中的Hash算法(都采用初始hash为0)，为什么选5381呢？具体的原因我也不知道，但是我发现了5381的一些特性：</p><pre><code>Magic Constant 5381:  1. odd number  2. prime number  3. deficient number  4. 001/010/100/000/101 b</code></pre><p>看了这些，我有理由相信这个初始值的选定能提供更好的分类。</p><p>至于说，为什么是Times 33而不是Times 其他数字，在PHP Hash算法的注释中也有一些说明，希望对有兴趣的同学有用：</p><pre><code>DJBX33A (Daniel J. Bernstein, Times 33 with Addition)This is Daniel J. Bernstein&apos;s popular `times 33&apos; hash function asposted by him years ago on comp.lang.c. It basically uses a functionlike ``hash(i) = hash(i-1) * 33 + str[i]&apos;&apos;. This is one of the bestknown hash functions for strings. Because it is both computed veryfast and distributes very well.The magic of number 33, i.e. why it works better than many otherconstants, prime or not, has never been adequately explained byanyone. So I try an explanation: if one experimentally tests allmultipliers between 1 and 256 (as RSE did now) one detects that evennumbers are not useable at all. The remaining 128 odd numbers(except for the number 1) work more or less all equally well. Theyall distribute in an acceptable way and this way fill a hash tablewith an average percent of approx. 86%.If one compares the Chi^2 values of the variants, the number 33 noteven has the best value. But the number 33 and a few other equallygood numbers like 17, 31, 63, 127 and 129 have nevertheless a greatadvantage to the remaining numbers in the large set of possiblemultipliers: their multiply operation can be replaced by a fasteroperation based on just one shift plus either a single additionor subtraction operation. And because a hash function has to bothdistribute good _and_ has to be very fast to compute, those fewnumbers should be preferred and seems to be the reason why Daniel J.Bernstein also preferred it.               -- Ralf S. Engelschall &lt;rse@engelschall.com&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-理解Zend里的哈希表</title>
      <link href="/posts/fd0a7d4d.html"/>
      <url>/posts/fd0a7d4d.html</url>
      
        <content type="html"><![CDATA[<h1 id="21-理解Zend里的哈希表"><a href="#21-理解Zend里的哈希表" class="headerlink" title="21-理解Zend里的哈希表"></a>21-理解Zend里的哈希表</h1><p>在PHP的Zend引擎中，有一个数据结构非常重要，它无处不在，是PHP数据存储的核心，各种常量、变量、函数、类、对象等都用它来组织，这个数据结构就是HashTable。</p><p>HashTable在通常的数据结构教材中也称作散列表，哈希表。其基本原理比较简单（如果你对其不熟悉，请查阅随便一本数据结构教材或在网上搜索），但PHP的实现有其独特的地方。理解了HashTable的数据存储结构，对我们分析PHP的源代码，特别是Zend Engine中的虚拟机的实现时，有很重要的帮助。它可以帮助我们在大脑中模拟一个完整的虚拟机的形象。它也是PHP中其它一些数据结构如数组实现的基础。</p><p>Zend HashTable的实现结合了双向链表和向量（数组）两种数据结构的优点，为PHP提供了非常高效的数据存储和查询机制。</p><p>Let’s begin!</p><h2 id="HashTable的数据结构"><a href="#HashTable的数据结构" class="headerlink" title="HashTable的数据结构"></a>HashTable的数据结构</h2><p>在Zend Engine中的HashTable的实现代码主要包括zend_hash.h, zend_hash.c这两个文件中。Zend HashTable包括两个主要的数据结构，其一是Bucket（桶）结构，另一个是HashTable结构。Bucket结构是用于保存数据的容器，而 HashTable结构则提供了对所有这些Bucket（或桶列）进行管理的机制。</p><pre><code>typedef struct bucket {ulong h;       /* Used for numeric indexing */uint nKeyLength;     /* key 长度 */void *pData;      /* 指向Bucket中保存的数据的指针 */void *pDataPtr;     /* 指针数据 */struct bucket *pListNext;   /* 指向HashTable桶列中下一个元素 */struct bucket *pListLast;    /* 指向HashTable桶列中前一个元素 */struct bucket *pNext;    /* 指向具有同一个hash值的桶列的后一个元素 */struct bucket *pLast;    /* 指向具有同一个hash值的桶列的前一个元素 */char arKey[1];      /* 必须是最后一个成员，key名称*/} Bucket;</code></pre><p>在Zend HashTable中，每个数据元素(Bucket)有一个键名(key)，它在整个HashTable中是唯一的，不能重复。根据键名可以唯一确定 HashTable中的数据元素。键名有两种表示方式。第一种方式使用字符串arKey作为键名，该字符串的长度为nKeyLength。注意到在上面的数据结构中arKey虽然只是一个长度为1的字符数组，但它并不意味着key只能是一个字符。实际上Bucket是一个可变长的结构体，由于arKey是 Bucket的最后一个成员变量，通过arKey与nKeyLength结合可确定一个长度为nKeyLength的key。这是C语言编程中的一个比较 常用的技巧。另一种键名的表示方式是索引方式，这时nKeyLength总是0，长整型字段h就表示该数据元素的键名。简单的来说，即如果 nKeyLength=0，则键名为h；否则键名为arKey, 键名的长度为nKeyLength。</p><p>当nKeyLength &gt; 0时，并不表示这时的h值就没有意义。事实上，此时它保存的是arKey对应的hash值。不管hash函数怎么设计，冲突都是不可避免的，也就是说不同 的arKey可能有相同的hash值。具有相同hash值的Bucket保存在HashTable的arBuckets数组(参考下面的解释)的同一个索 引对应的桶列中。这个桶列是一个双向链表，其前向元素，后向元素分别用pLast, pNext来表示。新插入的Bucket放在该桶列的最前面。</p><p>在Bucket中，实际的数据是保存在pData指针指向的内存块中，通常这个内存块是系统另外分配的。但有一种情况例外，就是当Bucket保存的数据是一个指针时，HashTable将不会另外请求系统分配空间来保存这个指针，而是直接将该指针保存到pDataPtr中，然后再将pData指向 本结构成员的地址。这样可以提高效率，减少内存碎片。由此我们可以看到PHP HashTable设计的精妙之处。如果Bucket中的数据不是一个指针，pDataPtr为NULL。</p><p>HashTable中所有的Bucket通过pListNext, pListLast构成了一个双向链表。最新插入的Bucket放在这个双向链表的最后。</p><p>注意在一般情况下，Bucket并不能提供它所存储的数据大小的信息。所以在PHP的实现中，Bucket中保存的数据必须具有管理自身大小的能力。</p><pre><code>typedef struct _hashtable {uint nTableSize;uint nTableMask;uint nNumOfElements;ulong nNextFreeElement;Bucket *pInternalPointer;Bucket *pListHead;Bucket *pListTail;Bucket **arBuckets;dtor_func_t pDestructor;zend_bool persistent;unsigned char nApplyCount;zend_bool bApplyProtection;#if ZEND_DEBUGint inconsistent;#endif} HashTable;</code></pre><p>在HashTable结构中，nTableSize指定了HashTable的大小，同时它限定了HashTable中能保存Bucket的最大数量，此 数越大，系统为HashTable分配的内存就越多。为了提高计算效率，系统自动会将nTableSize调整到最小一个不小于nTableSize的2 的整数次方。也就是说，如果在初始化HashTable时指定一个nTableSize不是2的整数次方，系统将会自动调整nTableSize的值。即</p><pre><code>nTableSize = 2ceil(log(nTableSize, 2)) 或 nTableSize = pow(ceil(log(nTableSize,2)))</code></pre><p>例如，如果在初始化HashTable的时候指定nTableSize = 11，HashTable初始化程序会自动将nTableSize增大到16。</p><p>arBuckets是HashTable的关键，HashTable初始化程序会自动申请一块内存，并将其地址赋值给arBuckets，该内存大 小正好能容纳nTableSize个指针。我们可以将arBuckets看作一个大小为nTableSize的数组，每个数组元素都是一个指针，用于指向 实际存放数据的Bucket。当然刚开始时每个指针均为NULL。</p><p>nTableMask的值永远是nTableSize – 1，引入这个字段的主要目的是为了提高计算效率，是为了快速计算Bucket键名在arBuckets数组中的索引。</p><p>nNumberOfElements记录了HashTable当前保存的数据元素的个数。当nNumberOfElement大于nTableSize时，HashTable将自动扩展为原来的两倍大小。</p><p>nNextFreeElement记录HashTable中下一个可用于插入数据元素的arBuckets的索引。</p><p>pListHead, pListTail则分别表示Bucket双向链表的第一个和最后一个元素，这些数据元素通常是根据插入的顺序排列的。也可以通过各种排序函数对其进行重 新排列。pInternalPointer则用于在遍历HashTable时记录当前遍历的位置，它是一个指针，指向当前遍历到的Bucket，初始值是 pListHead。</p><p>pDestructor是一个函数指针，在HashTable的增加、修改、删除Bucket时自动调用，用于处理相关数据的清理工作。</p><p>persistent标志位指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。具体请参考PHP的内存管理。</p><p>nApplyCount与bApplyProtection结合提供了一个防止在遍历HashTable时进入递归循环时的一种机制。</p><p>inconsistent成员用于调试目的，只在PHP编译成调试版本时有效。表示HashTable的状态，状态有四种：</p><p>状态值的含义：</p><ul><li>HT_IS_DESTROYING 正在删除所有的内容，包括arBuckets本身</li><li>HT_IS_DESTROYED 已删除，包括arBuckets本身</li><li>HT_CLEANING 正在清除所有的arBuckets指向的内容，但不包括arBuckets本身</li><li><p>HT_OK 正常状态，各种数据完全一致</p><p>typedef struct _zend_hash_key {<br>char <em>arKey; /</em> hash元素key名称 <em>/<br>uint nKeyLength; /</em> hash 元素key长度 <em>/<br>ulong h; /</em> key计算出的hash值或直接指定的数值下标 */<br>} zend_hash_key;</p></li></ul><p>现在来看zend_hash_key结构就比较容易理解了。它通过arKey, nKeyLength, h三个字段唯一确定了HashTable中的一个元素。</p><p>根据上面对HashTable相关数据结构的解释，我们可以画出HashTable的内存结构图：</p><center><br><img src="images/2012_02_10_02.png" alt><br></center><br><center><br>HashTable 结构<br></center><h2 id="Zend-HashTable的实现"><a href="#Zend-HashTable的实现" class="headerlink" title="Zend HashTable的实现"></a>Zend HashTable的实现</h2><p>本节具体介绍一下PHP中HashTable的实现。以下函数均取自于zend_hash.c。只要充分理解了上述数据结构，HashTable实现的代码并不难理解。</p><ol><li>HashTable初始化</li></ol><p>HashTable提供了一个zend_hash_init宏来完成HashTable的初始化操作。实际上它是通过下面的内部函数来实现的：</p><pre><code>ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC){uint i = 3;Bucket **tmp;SET_INCONSISTENT(HT_OK);if (nSize &gt;= 0×80000000) {/* prevent overflow */ht-&gt;nTableSize = 0×80000000;} else {while ((1U &lt;&lt; i) &lt; nSize) { /* 自动调整nTableSize至2的n次方 */ i++; } ht-&gt;nTableSize = 1 &lt;&lt; i;     /* i的最小值为3，因此HashTable大小最小为8 */ } ht-&gt;nTableMask = ht-&gt;nTableSize - 1;ht-&gt;pDestructor = pDestructor;ht-&gt;arBuckets = NULL;ht-&gt;pListHead = NULL;ht-&gt;pListTail = NULL;ht-&gt;nNumOfElements = 0;ht-&gt;nNextFreeElement = 0;ht-&gt;pInternalPointer = NULL;ht-&gt;persistent = persistent;ht-&gt;nApplyCount = 0;ht-&gt;bApplyProtection = 1;/* 根据persistent使用不同方式分配arBuckets内存，并将其所有指针初始化为NULL*//* Uses ecalloc() so that Bucket* == NULL */if (persistent) {tmp = (Bucket **) calloc(ht-&gt;nTableSize, sizeof(Bucket *));if (!tmp) {return FAILURE;}ht-&gt;arBuckets = tmp;} else {tmp = (Bucket **) ecalloc_rel(ht-&gt;nTableSize, sizeof(Bucket *));if (tmp) {ht-&gt;arBuckets = tmp;}}return SUCCESS;}</code></pre><p>在以前的版本中，可以使用pHashFunction来指定hash函数。但现PHP已强制使用DJBX33A算法，因此实际上pHashFunction这个参数并不会用到，保留在这里只是为了与以前的代码兼容。</p><p>2.增加、插入和修改元素</p><p>向HashTable中添加一个新的元素最关键的就是要确定将这个元素插入到arBuckets数组中的哪个位置。根据上面对Bucket结构键名 的解释，我们可以知道有两种方式向HashTable添加一个新的元素。第一种方法是使用字符串作为键名来插入Bucket；第二种方法是使用索引作为键 名来插入Bucket。第二种方法具体又可以分为两种情况：指定索引或不指定索引，指定索引指的是强制将Bucket插入到指定的索引位置中；不指定索引 则将Bucket插入到nNextFreeElement对应的索引位置中。这几种插入数据的方法实现比较类似，不同的只是定位Bucket的方法。</p><p>修改HashTable中的数据的方法与增加数据的方法也很类似。</p><p>我们先看第一种使用字符串作为键名增加或修改Bucket的方法：</p><pre><code>ZEND_API int _zend_hash_add_or_update(HashTable *ht, char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC){ulong h;uint nIndex;Bucket *p;IS_CONSISTENT(ht);     // 调试信息输出if (nKeyLength &lt;= 0) { #if ZEND_DEBUG ZEND_PUTS(”zend_hash_update: Can’t put in empty key\n”); #endif return FAILURE; } /* 使用hash函数计算arKey的hash值 */ h = zend_inline_hash_func(arKey, nKeyLength); /* 将hash值和nTableMask按位与后生成该元素在arBuckets中的索引。让它和 * nTableMask按位与是保证不会产生一个使得arBuckets越界的数组下标。 */ nIndex = h &amp; ht-&gt;nTableMask;p = ht-&gt;arBuckets[nIndex];   /* 取得相应索引对应的Bucket的指针 *//* 检查对应的桶列中是否包含有数据元素(key, hash) */while (p != NULL) {if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == nKeyLength)) {if (!memcmp(p-&gt;arKey, arKey, nKeyLength)) {if (flag &amp; HASH_ADD) {return FAILURE; // 对应的数据元素已存在，不能进行插入操作}HANDLE_BLOCK_INTERRUPTIONS();#if ZEND_DEBUGif (p-&gt;pData == pData) {ZEND_PUTS(”Fatal error in zend_hash_update: p-&gt;pData == pData\n”);HANDLE_UNBLOCK_INTERRUPTIONS();return FAILURE;}#endifif (ht-&gt;pDestructor) {/* 如果数据元素存在，对原来的数据进行析构操作 */ht-&gt;pDestructor(p-&gt;pData);}/* 用新的数据来更新原来的数据 */UPDATE_DATA(ht, p, pData, nDataSize);if (pDest) {*pDest = p-&gt;pData;}HANDLE_UNBLOCK_INTERRUPTIONS();return SUCCESS;}}p = p-&gt;pNext;}/* HashTable中没有key对应的数据，新增一个Bucket　*/p = (Bucket *) pemalloc(sizeof(Bucket) - 1 + nKeyLength, ht-&gt;persistent);if (!p) {return FAILURE;}memcpy(p-&gt;arKey, arKey, nKeyLength);p-&gt;nKeyLength = nKeyLength;INIT_DATA(ht, p, pData, nDataSize);p-&gt;h = h;//　将Bucket加入到相应的桶列中CONNECT_TO_BUCKET_DLLIST(p, ht-&gt;arBuckets[nIndex]);if (pDest) {*pDest = p-&gt;pData;}HANDLE_BLOCK_INTERRUPTIONS();//　将Bucket 加入到HashTable的双向链表中CONNECT_TO_GLOBAL_DLLIST(p, ht);ht-&gt;arBuckets[nIndex] = p;HANDLE_UNBLOCK_INTERRUPTIONS();ht-&gt;nNumOfElements++;// 如果HashTable已满，重新调整HashTable的大小。ZEND_HASH_IF_FULL_DO_RESIZE(ht);   /* If the Hash table is full, resize it */return SUCCESS;}</code></pre><p>因为这个函数是使用字符串作为键名来插入数据的，因此它首先检查nKeyLength的值是否大于0，如果不是的话就直接退出。然后计算arKey对应的 hash值h，将其与nTableMask按位与后得到一个无符号整数nIndex。这个nIndex就是将要插入的Bucket在arBuckets数 组中的索引位置。</p><p>现在已经有了arBuckets数组的一个索引，我们知道它包括的数据是一个指向Bucket的双向链表的指针。如果这个双向链表不为空的话我们首先检查 这个双向链表中是否已经包含了用字符串arKey指定的键名的Bucket，这样的Bucket如果存在，并且我们要做的操作是插入新Bucket(通过 flag标识)，这时就应该报错 – 因为在HashTable中键名不可以重复。如果存在，并且是修改操作，则使用在HashTable中指定了析构函数pDestructor对原来的 pData指向的数据进行析构操作；然后将用新的数据替换原来的数据即可成功返回修改操作。</p><p>如果在HashTable中没有找到键名指定的数据，就将该数据封装到Bucket中，然后插入HashTable。这里要注意的是如下的两个宏：</p><ul><li>CONNECT_TO_BUCKET_DLLIST(p, ht-&gt;arBuckets[nIndex])</li><li>CONNECT_TO_GLOBAL_DLLIST(p, ht)</li></ul><p>前者是将该Bucket插入到指定索引的Bucket双向链表中，后者是插入到整个HashTable的Bucket双向链表中。两者的插入方式也不同，前者是将该Bucket插入到双向链表的最前面，后者是插入到双向链表的最末端。</p><p>下面是第二种插入或修改Bucket的方法，即使用索引的方法：</p><pre><code>ZEND_API int _zend_hash_index_update_or_next_insert(HashTable *ht, ulong h, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC){uint nIndex;Bucket *p;IS_CONSISTENT(ht);if (flag &amp; HASH_NEXT_INSERT) {h = ht-&gt;nNextFreeElement;}nIndex = h &amp; ht-&gt;nTableMask;p = ht-&gt;arBuckets[nIndex];// 检查是否含有相应的数据while (p != NULL) {if ((p-&gt;nKeyLength == 0) &amp;&amp; (p-&gt;h == h)) {if (flag &amp; HASH_NEXT_INSERT || flag &amp; HASH_ADD) {return FAILURE;}////　…… 修改Bucket数据，略//if ((long)h &gt;= (long)ht-&gt;nNextFreeElement) {ht-&gt;nNextFreeElement = h + 1;}if (pDest) {*pDest = p-&gt;pData;}return SUCCESS;}p = p-&gt;pNext;}p = (Bucket *) pemalloc_rel(sizeof(Bucket) - 1, ht-&gt;persistent);if (!p) {return FAILURE;}p-&gt;nKeyLength = 0; /* Numeric indices are marked by making the nKeyLength == 0 */p-&gt;h = h;INIT_DATA(ht, p, pData, nDataSize);if (pDest) {*pDest = p-&gt;pData;}CONNECT_TO_BUCKET_DLLIST(p, ht-&gt;arBuckets[nIndex]);HANDLE_BLOCK_INTERRUPTIONS();ht-&gt;arBuckets[nIndex] = p;CONNECT_TO_GLOBAL_DLLIST(p, ht);HANDLE_UNBLOCK_INTERRUPTIONS();if ((long)h &gt;= (long)ht-&gt;nNextFreeElement) {ht-&gt;nNextFreeElement = h + 1;}ht-&gt;nNumOfElements++;ZEND_HASH_IF_FULL_DO_RESIZE(ht);return SUCCESS;}</code></pre><p>flag标志指明当前操作是HASH_NEXT_INSERT(不指定索引插入或修改), HASH_ADD(指定索引插入)还是HASH_UPDATE(指定索引修改)。由于这些操作的实现代码基本相同，因此统一合并成了一个函数，再用flag加以区分。</p><p>本函数基本与前一个相同，不同的是如果确定插入到arBuckets数组中的索引的方法。如果操作是HASH_NEXT_INSERT，则直接使用nNextFreeElement作为插入的索引。注意nNextFreeElement的值是如何使用和更新的。</p><p>3.访问元素</p><p>同样，HashTable用两种方式来访问元素，一种是使用字符串arKey的zend_hash_find()；另一种是使用索引的访问方式zend_hash_index_find()。由于其实现的代码很简单，分析工作就留给读者自已完成。</p><p>4.删除元素</p><p>HashTable删除数据均使用zend_hash_del_key_or_index()函数来完成，其代码也较为简单，这里也不再详细分析。需要的是注意如何根据arKey或h来计算出相应的下标，以及两个双向链表的指针的处理。</p><p>5.遍历元素</p><pre><code>/* This is used to recurse elements and selectively delete certain entries* from a hashtable. apply_func() receives the data and decides if the entry* should be deleted or recursion should be stopped. The following three* return codes are possible:* ZEND_HASH_APPLY_KEEP   - continue* ZEND_HASH_APPLY_STOP   - stop iteration* ZEND_HASH_APPLY_REMOVE - delete the element, combineable with the former*/ZEND_API void zend_hash_apply(HashTable *ht, apply_func_t apply_func TSRMLS_DC){Bucket *p;IS_CONSISTENT(ht);HASH_PROTECT_RECURSION(ht);p = ht-&gt;pListHead;while (p != NULL) {int result = apply_func(p-&gt;pData TSRMLS_CC);if (result &amp; ZEND_HASH_APPLY_REMOVE) {p = zend_hash_apply_deleter(ht, p);} else {p = p-&gt;pListNext;}if (result &amp; ZEND_HASH_APPLY_STOP) {break;}}HASH_UNPROTECT_RECURSION(ht);}</code></pre><p>因为HashTable中所有Bucket都可以通过pListHead指向的双向链表来访问，因此遍历HashTable的实现也比较简单。这里值得一 提的是对当前遍历到的Bucket的处理使用了一个apply_func_t类型的回调函数。根据实际需要，该回调函数返回下面值之一：</p><ul><li>ZEND_HASH_APPLY_KEEP</li><li>ZEND_HASH_APPLY_STOP</li><li>ZEND_HASH_APPLY_REMOVE</li></ul><p>它们分别表示继续遍历，停止遍历或删除相应元素后继续遍历。</p><p>还有一个要注意的问题就是遍历时的防止递归的问题，也就是防止对同一个HashTable同时进行多次遍历。这是用下面两个宏来实现的：</p><ul><li>HASH_PROTECT_RECURSION(ht)</li><li>HASH_UNPROTECT_RECURSION(ht)</li></ul><p>其主要原理是如果遍历保护标志bApplyProtection为真，则每次进入遍历函数时将nApplyCount值加1，退出遍历函数时将nApplyCount值减1。开始遍历之前如果发现nApplyCount &gt; 3就直接报告错误信息并退出遍历。</p><p>上面的apply_func_t不带参数。HashTable还提供带一个参数或可变参数的回调方式，对应的遍历函数分别为：</p><pre><code>typedef int (*apply_func_arg_t)(void *pDest,void *argument TSRMLS_DC);void zend_hash_apply_with_argument(HashTable *ht,apply_func_arg_t apply_func, void *data TSRMLS_DC);typedef int (*apply_func_args_t)(void *pDest,int num_args, va_list args, zend_hash_key *hash_key);void zend_hash_apply_with_arguments(HashTable *ht,apply_func_args_t apply_func, int numargs, …);</code></pre><p>除了上面提供的几种提供外，还有许多其它操作HashTable的API。如排序、HashTable的拷贝与合并等等。只要充分理解了上述HashTable的数据结构，理解这些代码并不困难。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20-PHP中的哈希表</title>
      <link href="/posts/37049594.html"/>
      <url>/posts/37049594.html</url>
      
        <content type="html"><![CDATA[<h1 id="20-PHP中的哈希表"><a href="#20-PHP中的哈希表" class="headerlink" title="20-PHP中的哈希表"></a>20-PHP中的哈希表</h1><p>PHP中使用最为频繁的数据类型非字符串和数组莫属，PHP比较容易上手也得益于非常灵活的数组类型。 在开始详细介绍这些数据类型之前有必要介绍一下哈希表(HashTable)。 哈希表是PHP实现中尤为关键的数据结构。</p><p>哈希表在实践中使用的非常广泛，例如编译器通常会维护的一个符号表来保存标记，很多高级语言中也显式的支持哈希表。 哈希表通常提供查找(Search)，插入(Insert)，删除(Delete)等操作，这些操作在最坏的情况下和链表的性能一样为O(n)。 不过通常并不会这么坏，合理设计的哈希算法能有效的避免这类情况，通常哈希表的这些操作时间复杂度为O(1)。 这也是它被钟爱的原因。</p><p>正是因为哈希表在使用上的便利性及效率上的表现，目前大部分动态语言的实现中都使用了哈希表。</p><p>为了方便读者阅读后面的内容，这里提前列举一下HashTable实现中出现的基本概念。 哈希表是一种通过哈希函数，将特定的键映射到特定值的一种数据结构，它维护键和值之间一一对应关系。</p><ul><li>键(key)：用于操作数据的标示，例如PHP数组中的索引，或者字符串键等等。</li><li>槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li><li>哈希函数(hash function)：将key映射(map)到数据应该存放的slot所在位置的函数。</li><li>哈希冲突(hash collision)：哈希函数将两个不同的key映射到同一个索引的情况。</li></ul><p>哈希表可以理解为数组的扩展或者关联数组，数组使用数字下标来寻址，如果关键字(key)的范围较小且是数字的话， 我们可以直接使用数组来完成哈希表，而如果关键字范围太大，如果直接使用数组我们需要为所有可能的key申请空间。 很多情况下这是不现实的。即使空间足够，空间利用率也会很低，这并不理想。同时键也可能并不是数字， 在PHP中尤为如此，所以人们使用一种映射函数(哈希函数)来将key映射到特定的域中：</p><pre><code>h(key) -&gt; index</code></pre><p>通过合理设计的哈希函数，我们就能将key映射到合适的范围，因为我们的key空间可以很大(例如字符串key)， 在映射到一个较小的空间中时可能会出现两个不同的key映射被到同一个index上的情况， 这就是我们所说的出现了冲突。 目前解决hash冲突的方法主要有两种：链接法和开放寻址法。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>链接法：链接法通过使用一个链表来保存slot值的方式来解决冲突，也就是当不同的key映射到一个槽中的时候使用链表来保存这些值。 所以使用链接法是在最坏的情况下，也就是所有的key都映射到同一个槽中了，操作链表的时间复杂度为O(n)。 所以选择一个合适的哈希函数是最为关键的。目前PHP中HashTable的实现就是采用这种方式来解决冲突的。</p><p>开放寻址法：通常还有另外一种解决冲突的方法：开放寻址法。使用开放寻址法是槽本身直接存放数据， 在插入数据时如果key所映射到的索引已经有数据了，这说明发生了冲突，这是会寻找下一个槽， 如果该槽也被占用了则继续寻找下一个槽，直到寻找到没有被占用的槽，在查找时也使用同样的策律来进行。</p><h2 id="哈希表的实现"><a href="#哈希表的实现" class="headerlink" title="哈希表的实现"></a>哈希表的实现</h2><p>在了解到哈希表的原理之后要实现一个哈希表也很容易，主要需要完成的工作只有三点：</p><ol><li>实现哈希函数</li><li>冲突的解决</li><li>操作接口的实现</li></ol><p>首先我们需要一个容器来保存我们的哈希表，哈希表需要保存的内容主要是保存进来的的数据， 同时为了方便的得知哈希表中存储的元素个数，需要保存一个大小字段， 第二个需要的就是保存数据的容器了。作为实例，下面将实现一个简易的哈希表。基本的数据结构主要有两个， 一个用于保存哈希表本身，另外一个就是用于实际保存数据的单链表了，定义如下：</p><pre><code>typedef struct _Bucket{    char *key;    void *value;    struct _Bucket *next;} Bucket;typedef struct _HashTable{    int size;    Bucket* buckets;} HashTable;</code></pre><p>上面的定义和PHP中的实现类似，为了便于理解裁剪了大部分无关的细节，在本节中为了简化， key的数据类型为字符串，而存储的数据类型可以为任意类型。</p><p>Bucket结构体是一个单链表，这是为了解决多个key哈希冲突的问题，也就是前面所提到的的链接法。 当多个key映射到同一个index的时候将冲突的元素链接起来。</p><p>哈希函数需要尽可能的将不同的key映射到不同的槽(slot或者bucket)中，首先我们采用一种最为简单的哈希算法实现： 将key字符串的所有字符加起来，然后以结果对哈希表的大小取模，这样索引就能落在数组索引的范围之内了。</p><pre><code>static int hash_str(char *key){    int hash = 0;    char *cur = key;    while(*(cur++) != &apos;\0&apos;) {        hash += *cur;    }    return hash;}// 使用这个宏来求得key在哈希表中的索引#define HASH_INDEX(ht, key) (hash_str((key)) % (ht)-&gt;size)</code></pre><p>这个哈希算法比较简单，它的效果并不好，在实际场景下不会使用这种哈希算法， 例如PHP中使用的是称为DJBX33A算法， 这里列举了Mysql，OpenSSL等开源软件使用的哈希算法， 有兴趣的读者可以前往参考。<br>操作接口的实现</p><p>为了操作哈希表，实现了如下几个操作函数：</p><pre><code>int hash_init(HashTable *ht);                               // 初始化哈希表int hash_lookup(HashTable *ht, char *key, void **result);   // 根据key查找内容int hash_insert(HashTable *ht, char *key, void *value);     // 将内容插入到哈希表中int hash_remove(HashTable *ht, char *key);                  // 删除key所指向的内容int hash_destroy(HashTable *ht);</code></pre><p>下面以插入和获取操作函数为例：</p><pre><code>int hash_insert(HashTable *ht, char *key, void *value){    // check if we need to resize the hashtable    resize_hash_table_if_needed(ht);    // 哈希表不固定大小，当插入的内容快占满哈表的存储空间                                        // 将对哈希表进行扩容， 以便容纳所有的元素    int index = HASH_INDEX(ht, key);    // 找到key所映射到的索引    Bucket *org_bucket = ht-&gt;buckets[index];    Bucket *bucket = (Bucket *)malloc(sizeof(Bucket)); // 为新元素申请空间    bucket-&gt;key   = strdup(key);    // 将值内容保存进来， 这里只是简单的将指针指向要存储的内容，而没有将内容复制。    bucket-&gt;value = value;      LOG_MSG(&quot;Insert data p: %p\n&quot;, value);    ht-&gt;elem_num += 1; // 记录一下现在哈希表中的元素个数    if(org_bucket != NULL) { // 发生了碰撞，将新元素放置在链表的头部        LOG_MSG(&quot;Index collision found with org hashtable: %p\n&quot;, org_bucket);        bucket-&gt;next = org_bucket;    }    ht-&gt;buckets[index]= bucket;    LOG_MSG(&quot;Element inserted at index %i, now we have: %i elements\n&quot;,        index, ht-&gt;elem_num);    return SUCCESS;}</code></pre><p>上面这个哈希表的插入操作比较简单，简单的以key做哈希，找到元素应该存储的位置，并检查该位置是否已经有了内容， 如果发生碰撞则将新元素链接到原有元素链表头部。在查找时也按照同样的策略，找到元素所在的位置，如果存在元素， 则将该链表的所有元素的key和要查找的key依次对比， 直到找到一致的元素，否则说明该值没有匹配的内容。</p><pre><code>int hash_lookup(HashTable *ht, char *key, void **result){    int index = HASH_INDEX(ht, key);    Bucket *bucket = ht-&gt;buckets[index];    if(bucket == NULL) return FAILED;    // 查找这个链表以便找到正确的元素，通常这个链表应该是只有一个元素的，也就不用多次    // 循环。要保证这一点需要有一个合适的哈希算法，见前面相关哈希函数的链接。    while(bucket)    {        if(strcmp(bucket-&gt;key, key) == 0)        {            LOG_MSG(&quot;HashTable found key in index: %i with  key: %s value: %p\n&quot;,                index, key, bucket-&gt;value);            *result = bucket-&gt;value;                return SUCCESS;        }        bucket = bucket-&gt;next;    }    LOG_MSG(&quot;HashTable lookup missed the key: %s\n&quot;, key);    return FAILED;}</code></pre><p>PHP中数组是基于哈希表实现的，依次给数组添加元素时，元素之间是有先后顺序的，而这里的哈希表在物理位置上显然是接近平均分布的， 这样是无法根据插入的先后顺序获取到这些元素的，在PHP的实现中Bucket结构体还维护了另一个指针字段来维护元素之间的关系。 具体内容在后一小节PHP中的HashTable中进行详细说明。上面的例子就是PHP中实现的一个精简版。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19-变量存储与类型</title>
      <link href="/posts/52a357f0.html"/>
      <url>/posts/52a357f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="19-变量存储与类型"><a href="#19-变量存储与类型" class="headerlink" title="19-变量存储与类型"></a>19-变量存储与类型</h1><p>先回答前面一节的那个问题吧。</p><pre><code>&lt;?php$foo = 10;$bar = 20;function change() {    global $foo;    //echo &apos;函数内部$foo = &apos;.$foo.&apos;&lt;br /&gt;&apos;;    //如果不把$bar定义为global变量，函数体内是不能访问$bar的    $bar = 0;    $foo++;}change();echo $foo, &apos; &apos;, $bar;?&gt;</code></pre><p>程序输出 11 20。原因是，方法内部无法访问$bar变量，所以它的值还是20。使用global之后，可以取得$foo的值，自增后$foo的值就是11。</p><p>Global的作用是定义全局变量，但是这个全局变量不是应用于整个网站，而是应用于当前页面，包括include或require的所有文件。</p><p>前言中提到变量的三个基本特性，其中的有一个特性为变量的类型，变量都有特定的类型， 如：字符串、数组、对象等等。编程语言的类型系统可以分为强类型和弱类型两种：</p><p>强类型语言是一旦某个变量被申明为某个类型的变量，则在程序运行过程中，该不能将该变量的类型以外的值赋予给它 （当然并不完全如此，这可能会涉及到类型的转换，后面的小节会有相应介绍），C/C++/Java等语言就属于这类。</p><p>PHP及Ruby，JavaScript等脚本语言属于弱类型语言：一个变量可以表示任意的数据类型。</p><p>PHP之所以成为一个简单而强大的语言，很大一部分的原因是它拥有弱类型的变量。 但是有些时候这也是一把双刃剑，使用不当也会带来一些问题。就像仪器一样，越是功能强大， 出现错误的可能性也就越大。</p><p>在官方的PHP实现内部，所有变量使用同一种数据结构(zval)来保存，而这个结构同时表示PHP中的各种数据类型。 它不仅仅包含变量的值，也包含变量的类型。这就是PHP弱类型的核心。</p><p>那zval结构具体是如何实现弱类型的呢，下面我们一起来揭开面纱。<br>变量存储结构</p><p>PHP在声明或使用变量的时候，并不需要显式指明其数据类型。</p><p>PHP是弱类型语言，这并不表示PHP没有类型，在PHP中，存在8种变量类型，可以分为三类</p><pre><code>* 标量类型：boolean、integer、float(double)、string* 复合类型： array、object* 特殊类型： resource、NULL</code></pre><p>官方PHP是用C实现的，而C是强类型的语言，那这是怎么实现PHP中的弱类型的呢？</p><p>变量的值存储到以下所示zval结构体中。 zval结构体定义在Zend/zend.h文件，其结构如下：</p><pre><code>typedef struct _zval_struct zval;...struct _zval_struct {    /* Variable information */    zvalue_value value;     /* value */    zend_uint refcount__gc;    zend_uchar type;    /* active type */    zend_uchar is_ref__gc;};</code></pre><p>PHP使用这个结构来存储变量的所有数据。和其他编译性静态语言不同， PHP在存储变量时将PHP用户空间的变量类型也保存在同一个结构体中。这样我们就能通过这些信息获取到变量的类型。</p><p>zval结构体中有四个字段，其含义分别为：</p><table><thead><tr><th>属性名</th><th style="text-align:center">含义</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td>refcount__gc</td><td style="text-align:center">表示引用计数</td><td style="text-align:center">1</td></tr><tr><td>is_ref__gc</td><td style="text-align:center">表示是否为引用</td><td style="text-align:center">0</td></tr><tr><td>value</td><td style="text-align:center">存储变量的值</td><td style="text-align:center"></td></tr><tr><td>type</td><td style="text-align:center">变量具体的类型</td></tr></tbody></table><p>在PHP5.3之后，引入了新的垃圾收集机制，引用计数和引用的字段名改为refcount__gc和is_ref__gc。在此之前为refcount和is__ref。</p><p>而变量的值则存储在另外一个结构体zvalue_value中。值存储见下面的介绍。</p><p>PHP用户空间指的在PHP语言这一层面，而本书中大部分地方都在探讨PHP的实现。 这些实现可以理解为内核空间。由于PHP使用C实现，而这个空间的范畴就会限制在C语言。 而PHP用户空间则会受限于PHP语法及功能提供的范畴之内。 例如有些PHP扩展会提供一些PHP函数或者类，这就是向PHP用户空间导出了方法或类。<br>变量类型</p><p>zval结构体的type字段就是实现弱类型最关键的字段了，type的值可以为： IS_NULL、IS_BOOL、IS_LONG、IS_DOUBLE、IS_STRING、IS_ARRAY、IS_OBJECT和IS_RESOURCE 之一。 从字面上就很好理解，他们只是类型的唯一标示，根据类型的不同将不同的值存储到value字段。 除此之外，和他们定义在一起的类型还有IS_CONSTANT和IS_CONSTANT_ARRAY。</p><p>这和我们设计数据库时的做法类似，为了避免重复设计类似的表，使用一个标示字段来记录不同类型的数据。<br>变量的值存储</p><p>前面提到变量的值存储在zvalue_value联合体中，结构体定义如下：</p><pre><code>typedef union _zvalue_value {    long lval;                  /* long value */    double dval;                /* double value */    struct {        char *val;        int len;    } str;    HashTable *ht;              /* hash table value */    zend_object_value obj;} zvalue_value;</code></pre><p>这里使用联合体而不是用结构体是出于空间利用率的考虑，因为一个变量同时只能属于一种类型。 如果使用结构体的话将会不必要的浪费空间，而PHP中的所有逻辑都围绕变量来进行的，这样的话， 内存浪费将是十分大的。这种做法成本小但收益非常大。</p><p>各种类型的数据会使用不同的方法来进行变量值的存储，其对应赋值方式如下：</p><p>1.一般类型</p><table><thead><tr><th>变量类型</th><th style="text-align:center">宏</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td>boolean</td><td style="text-align:center">ZVAL_BOOL</td><td style="text-align:center">布尔型/整型的变量值存储于(zval).value.lval中，其类型也会以相应的IS_*进行存储.Z_TYPE_P(z)=IS_BOOL/LONG; Z_LVAL_P(z)=((b)!=0);</td></tr><tr><td>integer</td><td style="text-align:center">ZVAL_LONG</td><td style="text-align:center">同上</td></tr><tr><td>float</td><td style="text-align:center">ZVAL_DOUBLE</td><td style="text-align:center">同上</td></tr><tr><td>null</td><td style="text-align:center">ZVAL_NULL</td><td style="text-align:center">NULL值的变量值不需要存储，只需要把(zval).type标为IS_NULL。 Z_TYPE_P(z)=IS_NULL;</td></tr><tr><td>resource</td><td style="text-align:center">ZVAL_RESOURCE</td><td style="text-align:center">资源类型的存储与其他一般变量无异，但其初始化及存取实现则不同。 Z_TYPE_P(z) = IS_RESOURCE; Z_LVAL_P(z) = l;</td></tr></tbody></table><p>2.字符串Sting</p><p>字符串的类型标示和其他数据类型一样，不过在存储字符串时多了一个字符串长度的字段。</p><pre><code>struct {    char *val;    int len;} str;</code></pre><p>C中字符串是以\0结尾的字符数组，这里多存储了字符串的长度，这和我们在设计数据库时增加的冗余字段异曲同工。 因为要实时获取到字符串的长度的时间复杂度是O(n)，而字符串的操作在PHP中是非常频繁的，这样能避免重复计算字符串的长度， 这能节省大量的时间，是空间换时间的做法。 这么看在PHP中strlen()函数可以在常数时间内获取到字符串的长度。 计算机语言中字符串的操作都非常之多，所以大部分高级语言中都会存储字符串的长度。</p><p>3.数组Array</p><p>数组是PHP中最常用，也是最强大变量类型，它可以存储其他类型的数据，而且提供各种内置操作函数。数组的存储相对于其他变量要复杂一些， 数组的值存储在zvalue_value.ht字段中，它是一个HashTable类型的数据。 PHP的数组使用哈希表来存储关联数据。哈希表是一种高效的键值对存储结构。PHP的哈希表实现中使用了两个数据结构HashTable和Bucket。 PHP所有的工作都由哈希表实现，在下节HashTable中将进行哈希表基本概念的介绍以及PHP的哈希表实现。</p><p>4.对象Object</p><p>在面向对象语言中，我们能自己定义自己需要的数据类型，包括类的属性，方法等数据。而对象则是类的一个具体实现。 对象有自身的状态和所能完成的操作。</p><p>PHP的对象是一种复合型的数据，使用一种zend_object_value的结构体来存放。其定义如下：</p><pre><code>typedef struct _zend_object_value {    zend_object_handle handle;  //  unsigned int类型，EG(objects_store).object_buckets的索引    zend_object_handlers *handlers;} zend_object_value;</code></pre><p>PHP的对象只有在运行时才会被创建，前面的章节介绍了EG宏，这是一个全局结构体用于保存在运行时的数据。 其中就包括了用来保存所有被创建的对象的对象池，EG(objects_store)，而object对象值内容的zend_object_handle域就是当前 对象在对象池中所在的索引，handlers字段则是将对象进行操作时的处理函数保存起来。 这个结构体及对象相关的类的结构_zend_class_entry，后面会介绍到。</p><p>PHP的弱变量容器的实现方式是兼容并包的形式体现，针对每种类型的变量都有其对应的标记和存储空间。 使用强类型的语言在效率上通常会比弱类型高，因为很多信息能在运行之前就能确定，这也能帮助排除程序错误。 而这带来的问题是编写代码相对会受制约。</p><p>PHP主要的用途是作为Web开发语言，在普通的Web应用中瓶颈通常在业务和数据访问这一层。不过在大型应用下语言也会是一个关键因素。 facebook因此就使用了自己的php实现。将PHP编译为C++代码来提高性能。不过facebook的hiphop并不是完整的php实现， 由于它是直接将php编译为C++，有一些PHP的动态特性比如eval结构就无法实现。当然非要实现也是有方法的， hiphop不实现应该也是做了一个权衡。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-变量概述</title>
      <link href="/posts/eed338f9.html"/>
      <url>/posts/eed338f9.html</url>
      
        <content type="html"><![CDATA[<h1 id="18-变量概述"><a href="#18-变量概述" class="headerlink" title="18-变量概述"></a>18-变量概述</h1><p>现代编程语言中的基本元素主要有：变量，流程控制接口，函数等等。我能否不使用变量来编写程序呢？ 这显然是可以的，例如：</p><pre><code>&lt;?phpecho &quot;Hello NowaMagic&quot;;?&gt;</code></pre><p>这个程序很简单，输出一个字符串内容。</p><p>就和我们仅仅使用二进制也能编程一样，不使用变量也能完成大部分的工作，不使用变量我们的程序将丧失极大的灵活性， 变量可以让我们将值存储起来，以便在程序的其他地方使用，或者通过计算保存新的值。 变量具有三个基本特性：</p><ol><li>名称。变量的标示符。就像小狗一样，主人可能会给这些小狗起个喜欢的名称。 变量命名上，PHP继承了Perl的语法风格，变量以美元符号开始，后面跟变量名。 一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。 PHP同时还支持复合变量，也就是类似$$a的变量，它会进行两次的解释。这给PHP带来了非常灵活的动态特性。</li><li>类型。变量的类型，就像小狗的品种，不同的小狗血统可能会不一样，有的聪明， 有的会购物等等。 在很多静态语言中，变量在定义时就指定了，在程序运行过程中都不允许进行变更， 那如果你有一只能随便指定品种的小狗会不会很拉风呢;-) PHP就是这样，属于弱类型语言，可以随便赋予它任何类型的值。</li><li>值内容。 这是标示所代表的具体内容。这就像是实实在在的小狗的这个实物。 你可以给任何一条小狗起名为：小七，在编程语言中也是如此，你可以给变量赋予它 所能表示范围的值。不过在同一时间，变量只能有一个值。</li></ol><p>PHP中组成变量名的字母可以是英文字母 a-z，A-Z，还可以是 ASCII 字符从 127 到 255（0x7f-0xff）。 变量名是区分大小写的。</p><p>除了变量本身，在PHP中我们经常会接触到与变量相关的一些概念，比如：常量，全局变量，静态变量以及类型转换等。 本章我们将介绍这些与变量相关的实现。其中包括PHP本身的变量低层存储结构以及弱类型系统的实现， 以及这些类型之间的相互转换等。</p><p>先看一段PHP代码：</p><pre><code>&lt;?php$foo = 10;$bar = 20;function change() {    global $foo;    $bar = 0;    $foo++;}change();echo $foo, &apos; &apos;, $bar;?&gt;</code></pre><p>运行代码会输出11 20。</p><p>可是为什么会有这样的输出呢？变量在PHP的内部是如何实现的呢？ 变量的作用域又是怎么实现的呢？ 这是本章将对围绕变量这个主题展开讨论，下面我们从最基本的变量实现开始。</p><p>不是所有编程语言中的变量的值都可以改变的。想想我们学过的数学中的变量。 他们的值也是不可改变的。例如： x + y = 10; 变量x和y的值是不能发生变化的。 在某个具体场景，也就是某个方程式中只有表示特定的值，变量的值不能改变的好处是： 这样就能尽可能少的产生副作用， 在Erlang语言中就是如此，它是一门函数式编程语言，非常值得学习。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17-解释器的执行过程</title>
      <link href="/posts/9016daf3.html"/>
      <url>/posts/9016daf3.html</url>
      
        <content type="html"><![CDATA[<h1 id="17-解释器的执行过程"><a href="#17-解释器的执行过程" class="headerlink" title="17-解释器的执行过程"></a>17-解释器的执行过程</h1><p>这里将介绍引擎内部执行一个PHP脚本的流程，以CLI SAPI为例子来对流程中核心的部分做简单介绍，省去一些初始化及清理操作。</p><p>CLI（Command Line Interface）即PHP的命令行模式，现在此SAPI是默认安装的，我们在服务器上安装完PHP之后，一般会生成一个可执行文件，假设此文件为/usr/local/bin/php ,那么我们在SHELL下可以用以下命令来执行一个PHP脚本：</p><p>/usr/local/bin/php -f test.php</p><p>这个命令将执行当前目录下的test.php脚本，我们暂且不关心test.php具体内容，只关心一下这个执行的内部过程是怎么样的。</p><p>CLI的主源代码文件在{PHPSRC}/sapi/cli/php_cli.c,整个过程就从这个文件中的 main()函数执行，整个函数比较长，主要可以分为以下几个阶段：</p><ol><li>解析命令行参数</li><li>初始化环境</li><li>编译执行PHP代码</li><li>清理环境并返回退出</li></ol><p>在第1个阶段中，解析-f参数为执行一个PHP文件，-f后面的test.php就是需要被执行的文件。</p><p>这里我们将关注第3个阶段，如何执行test.php中的PHP代码。</p><p>最终是通过php_execute_script(&amp;file_handle TSRMLS_CC)来执行PHP的脚本，这个函数定义在{PHPSRC}/main/main.c,原型为</p><p>PHPAPI int php_execute_script(zend_file_handle *primary_file TSRMLS_DC)</p><p>file_handle的类型为zend_file_handle，这个是zend对文件句柄的一个封装，里面的内容就是和test.php相关的了。</p><p>php_execute_script最终是调用的zend_execute_scripts，这个函数定义在{PHPSRC}/Zend/zend.c，原型为：</p><p>ZEND_API int zend_execute_scripts(int type TSRMLS_DC, zval **retval, int file_count, …)</p><p>此函数具有可变参数，可以一次执行多个PHP文件，在此函数中最核心的是调用zend_compile_file和zend_execute，zend_compile_file是一个函数指针，其声明在{PHPSRC}/Zend/zend_compile.c:</p><p>ZEND_API zend_op_array <em>(</em>zend_compile_file)(zend_file_handle *file_handle, int type TSRMLS_DC);</p><p>在引擎初始化的时候，会将compile_file函数的地址赋值给zend_compile_file，compile_file函数定义在{PHPSRC}/Zend/zend_language_scanner.c，通过声明可以看到这个函数以zend_file_handle指针作为参数，返回一个指向zend_op_array的指针。</p><p>zend_execute也是一个函数指针，其声明在{PHPSRC}/Zend/zend_execute.c:</p><p>ZEND_API extern void (<em>zend_execute)(zend_op_array </em>op_array TSRMLS_DC);</p><p>同样在引擎初始化的时候，会将execute函数的地址赋值给zend_execute，execute的定义在{PHPSRC}/Zend/zend_vm_execute.h。</p><p>通过声明知道zend_execute以一个指向zend_op_array结构的指针作为参数，这个指针即前面zend_compile_file的返回值，zend_execute就开始执行op_array中的op code，在执行op code的过程中，就实现了PHP语言的各种功能。</p><p>到这里主要的执行工作基本就完成。</p><p>PS：为什么要把zend_execute和zend_compile_file定义为函数指针？</p><p>在引擎初始化(zend_startup)的时候，将zend_execute指向了默认的execute,zend_compile_file指向了默认的compile_file。我们可以在实际编译和执行之前将zend_execute和zend_compile_file重写为其他的编译和执行函数，这样就为我们扩展引擎留下了钩子，比如一个比较有名的查看PHP的op code的扩展vld(<a href="http://www.derickrethans.nl/projects.html#vld)，此扩展就是在每次请求初始化的钩子函数（PHP_RINIT_FUNCTION）中，将zend_execute和zend_compile_file替换成自己的vld_execute和vld_compile_file，这两个函数其实是对原始函数进行了封装，添加了输出opcode信息的附加功能，因为引擎初始化是发生在模块请求初始化之前，而模块请求初始化又是在编译和执行之前，所以这样的覆盖能达到目的。" target="_blank" rel="noopener">http://www.derickrethans.nl/projects.html#vld)，此扩展就是在每次请求初始化的钩子函数（PHP_RINIT_FUNCTION）中，将zend_execute和zend_compile_file替换成自己的vld_execute和vld_compile_file，这两个函数其实是对原始函数进行了封装，添加了输出opcode信息的附加功能，因为引擎初始化是发生在模块请求初始化之前，而模块请求初始化又是在编译和执行之前，所以这样的覆盖能达到目的。</a></p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16-PHP里的opcode</title>
      <link href="/posts/335c4a7f.html"/>
      <url>/posts/335c4a7f.html</url>
      
        <content type="html"><![CDATA[<h1 id="16-PHP里的opcode"><a href="#16-PHP里的opcode" class="headerlink" title="16-PHP里的opcode"></a>16-PHP里的opcode</h1><p>opcode是计算机指令中的一部分，用于指定要执行的操作， 指令的格式和规范由处理器的指令规范指定。 除了指令本身以外通常还有指令所需要的操作数，可能有的指令不需要显式的操作数。 这些操作数可能是寄存器中的值，堆栈中的值，某块内存的值或者IO端口中的值等等。</p><p>通常opcode还有另一种称谓：字节码(byte codes)。 例如Java虚拟机(JVM)，.NET的通用中间语言(CIL: Common Intermeditate Language)等等。</p><p>PHP中的opcode则属于前面介绍中的后着，PHP是构建在Zend虚拟机(Zend VM)之上的。PHP的opcode就是Zend虚拟机中的指令。</p><p>在PHP实现内部，opcode由如下的结构体表示：</p><pre><code>struct _zend_op {    opcode_handler_t handler; // 执行该opcode时调用的处理函数    znode result;    znode op1;    znode op2;    ulong extended_value;    uint lineno;    zend_uchar opcode;  // opcode代码};</code></pre><p>和CPU的指令类似，有一个标示指令的opcode字段，以及这个opcode所操作的操作数，PHP不像汇编那么底层， 在脚本实际执行的时候可能还需要其他更多的信息，extended_value字段就保存了这类信息， 其中的result域则是保存该指令执行完成后的结果。</p><p>例如如下代码是在编译器遇到print语句的时候进行编译的函数：</p><pre><code>void zend_do_print(znode *result，const znode *arg TSRMLS_DC){    zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);    opline-&gt;result.op_type = IS_TMP_VAR;    opline-&gt;result.u.var = get_temporary_variable(CG(active_op_array));    opline-&gt;opcode = ZEND_PRINT;    opline-&gt;op1 = *arg;    SET_UNUSED(opline-&gt;op2);    *result = opline-&gt;result;}</code></pre><p>这个函数新创建一条zend_op，将返回值的类型设置为临时变量(IS_TMP_VAR)，并为临时变量申请空间， 随后指定opcode为ZEND_PRINT，并将传递进来的参数赋值给这条opcode的第一个操作数。这样在最终执行这条opcode的时候， Zend引擎能获取到足够的信息以便输出内容。</p><p>下面这个函数是在编译器遇到echo语句的时候进行编译的函数：</p><pre><code>void zend_do_echo(const znode *arg TSRMLS_DC){    zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);    opline-&gt;opcode = ZEND_ECHO;    opline-&gt;op1 = *arg;    SET_UNUSED(opline-&gt;op2);}</code></pre><p>可以看到echo处理除了指定opcode以外，还将echo的参数传递给op1，这里并没有设置opcode的result结果字段。 从这里我们也能看出print和echo的区别来，print有返回值，而echo没有，这里的没有和返回null是不同的， 如果尝试将echo的值赋值给某个变量或者传递给函数都会出现语法错误。</p><p>PHP脚本编译为opcode保存在op_array中，其内部存储的结构如下：</p><pre><code>struct _zend_op_array {    /* Common elements */    zend_uchar type;    char *function_name;  // 如果是用户定义的函数则，这里将保存函数的名字    zend_class_entry *scope;    zend_uint fn_flags;    union _zend_function *prototype;    zend_uint num_args;    zend_uint required_num_args;    zend_arg_info *arg_info;    zend_bool pass_rest_by_reference;    unsigned char return_reference;    /* END of common elements */    zend_bool done_pass_two;    zend_uint *refcount;    zend_op *opcodes;  // opcode数组    zend_uint last，size;    zend_compiled_variable *vars;    int last_var，size_var;    // ...}</code></pre><p>如上面的注释，opcodes保存在这里，在执行的时候由下面的execute函数执行：</p><pre><code>ZEND_API void execute(zend_op_array *op_array TSRMLS_DC){    // ... 循环执行op_array中的opcode或者执行其他op_array中的opcode}</code></pre><p>前面提到每条opcode都有一个opcode_handler_t的函数指针字段，用于执行该opcode， 这里并没有给没有指定处理函数，那在执行的时候该由哪个函数来执行呢? 更多信息请参考后面的详细介绍。</p><p>PHP有三种方式来进行opcode的处理:CALL，SWITCH和GOTO，PHP默认使用CALL的方式，也就是函数调用的方式， 由于opcode执行是每个PHP程序频繁需要进行的操作，可以使用SWITCH或者GOTO的方式来分发， 通常GOTO的效率相对会高一些，不过效率是否提高依赖于不同的CPU。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-操作码OpCode</title>
      <link href="/posts/57ffa06d.html"/>
      <url>/posts/57ffa06d.html</url>
      
        <content type="html"><![CDATA[<h1 id="15-操作码OpCode"><a href="#15-操作码OpCode" class="headerlink" title="15-操作码OpCode"></a>15-操作码OpCode</h1><p>运行一段PHP代码主要有两个阶段：编译和执行。 当然编译过程中还包括词法分析语法分析不同阶段和细节，这里我们将其作为一个整体。在这两个阶段之间，PHP代码会被编译成op code，可以将其认为是引擎的一个中间语言，编辑阶段把PHP源码生成op code，然后在执行阶段执行这些op code。这篇文章将简单的介绍op code。</p><p>PHP代码编译之后会生成许多的op，每一个op都是一个zend_op类型的c变量。相关的定义可以在{PHPSRC}/Zend/zend_compile.h中看到：</p><pre><code>struct _zend_op {      opcode_handler_t handler;      znode result;      znode op1;      znode op2;      ulong extended_value;      uint lineno;      zend_uchar opcode;  };  typedef struct _zend_op zend_op;  </code></pre><p>简单的说说这几个字段：</p><p>1.result,op1,op2</p><p>这三个字段都是znode类型，它们是op的操作数和操作结果载体，当然并不是每个op都需要使用这三个字段，根据op的功能不同，会使用其中某些字段。比如类型为ZEND_ECHO的op值需要使用op1，功能就是将op1中的相应的值输出。一会再单独介绍znode类型。</p><p>2.opcode</p><p>opcode的类型为zend_uchar，zend_uchar实际上就是unsigned char，此字段保存的整形值即为op的编号，用来区分不同的op类型，opcode的可取值都被定义成了宏，可以在{PHPSRC}/Zend/zend_vm_opcodes.h中看到这些宏的定义，类似如下：</p><pre><code>#define ZEND_NOP                               0  #define ZEND_ADD                               1  #define ZEND_SUB                               2  #define ZEND_MUL                               3  #define ZEND_DIV                               4  #define ZEND_MOD                               5  #define ZEND_SL                                6  #define ZEND_SR                                7  #define ZEND_CONCAT                            8  #define ZEND_BW_OR                             9  #define ZEND_BW_AND                           10  //......  </code></pre><p>3.handler</p><p>op的执行句柄，其类型为opcode_handler_t，opcode_handler_t的类型定义为typedef int (ZEND_FASTCALL *opcode_handler_t) (ZEND_OPCODE_HANDLER_ARGS); 这个函数指针为op定义了执行方式，每一种opcode字段都对应一个种类的handler,比如opcode= 38 (ZEND_ASSIGN), 那么其对应的handler对应的就是static int ZEND_FASTCALL ZEND_ASSIGN_**种类的handler，根据op操作数类型的不同，可以确定到这个种类中的某一个具体的函数，比如如果$a = 1;这样的代码生成的op，操作数为const和cv，最后就能确定handler为函数ZEND_ASSIGN_SPEC_CV_CONST_HANDLER，这些handler函数都定义在{PHPSRC}/Zend/zend_vm_execute.h中，此文件可以由一个PHP脚本生成，其中也定义了通过op来映射得到其hander的算法。</p><p>4.lineno</p><p>op对应源代码文件中的行号。</p><p>5.extended_value</p><p>扩展字段暂时不介绍</p><h2 id="操作数znode简介"><a href="#操作数znode简介" class="headerlink" title="操作数znode简介"></a>操作数znode简介</h2><p>操作数字段是这个类型中比较重要的部分了，其中op1,op2,result三个操作数定义为znode类型，znode相关定义在此文件中：</p><pre><code>typedef struct _znode {      int op_type;      union {          zval constant;          zend_uint var;          zend_uint opline_num; /*  Needs to be signed */          zend_op_array *op_array;          zend_op *jmp_addr;          struct {              zend_uint var;  /* dummy */              zend_uint type;          } EA;      } u;  } znode;  </code></pre><p>znode类型中定义了两个字段：</p><p>1.op_type</p><p>这个int类型的字段定义znode操作数的类型，这些类型的可取值的宏定义在此文件中</p><pre><code>#define IS_CONST    (1&lt;&lt;0)  #define IS_TMP_VAR  (1&lt;&lt;1)  #define IS_VAR      (1&lt;&lt;2)  #define IS_UNUSED   (1&lt;&lt;3)    /* Unused variable */  #define IS_CV       (1&lt;&lt;4)    /* Compiled variable */  </code></pre><ul><li>IS_CONST：表示常量，例如$a = 123; $b = “hello”;这些代码生成OP后，123和”hello”都是以常量类型操作数存在。</li><li>IS_TMP_VAR：表示临时变量，临时变量一般在前面加~来表示，这是一些OP执行过程中需要用到的中间变量，例如初始化一个数组的时候，就需要一个临时变量来暂时存储数组zval，然后将数组赋值给变量。</li><li>IS_VAR： 一般意义上的变量，以$开发表示，此种变量本人目前研究的较少，暂不介绍</li><li>IS_UNUSED ： 暂时不介绍，从名字来看应该是标识为不使用</li><li>IS_CV：这种类型的操作数比较重要，此类型是在PHP后来的版本中(大概5.1)中才出现，CV的意思是compiled variable，即编译后的变量，变量都是保存在一个符号表中，这个符号表是一个哈希表，试想如果每次读写变量的时候都需要到哈希表中去检索，势必会对效率有一定的影响，因此在执行上下文环境中，会将一些编译期间生成的变量缓存起来，此过程以后再详细介绍。此类型操作数一般以!开头表示，比如变量$a=123;$b=”hello”这段代码，$a和$b对应的操作数可能就是!0和!1, 0和1相当于一个索引号，通过索引号从缓存中取得相应的值。</li></ul><p>2.u</p><p>此字段为一个联合体，根据op_type的不同，u取不同的值。比如op_type=IS_CONST的时候，u中的constant保存的就是操作数对应的zval结构。例如$a=123时，123这个操作数中，u中的constant是一个IS_LONG类型的zval,其值lval为123。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-PHP脚本的执行细节</title>
      <link href="/posts/1b30d6ec.html"/>
      <url>/posts/1b30d6ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="14-PHP脚本的执行细节"><a href="#14-PHP脚本的执行细节" class="headerlink" title="14-PHP脚本的执行细节"></a>14-PHP脚本的执行细节</h1><p>众所周知，计算机的CPU只能执行二进制的机器码，每种CPU都有对应的汇编语言，汇编语言编译器将汇编语言翻译成二进制的机器语言，然后CPU开始执行这些机器码。汇编语言作为机器语言与程序设计者之间的一个层，给我们带来了很多方便，程序员不需要用晦涩的01数字来书写程序，当然人们并不满足这样的一个进步，于是在汇编语言之上又多了一个层——C语言，C语言更贴近人类熟悉的“自然语言”，程序设计者可以通过C语言编译器将C源代码文件编译成目标文件（二进制文件，中间会先翻译成汇编语言，然后由汇编语言生成机器码），然后将各个目标文件连接在一起就组成了一个可执行文件。正如有人说过的一句名言“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”（“Any problem in computer science can be solved by another layer of indirection.”） PHP语言就是在C语言之上的一个层，PHP引擎是由C语言来实现的，因此PHP语言这一个在C之上抽象出来的层使用起来比C更简单方便，入门门槛更低。</p><p>那么，PHP语言究竟如何被执行呢？</p><p>PHP语言到C语言之间的转换如果使用“翻译”这个词是不够准确的，因为引擎不是将PHP语言转换成C语言，然后将转换后的C语言编译链接执行。引擎在解析PHP代码的时候通常是分为两个部分，编译和执行：</p><ul><li>编译阶段：引擎把PHP代码转换成op code中间代码</li><li>执行阶段：引擎解释并执行编译阶段产生的op code</li></ul><p>关于op code会有专门的文章来介绍，现在网络上也已经有很多相关内容的文章，总之PHP代码会被编译成_zend_op_array的形式，这是一个结构体，其中包括很多相关属性，以及最重要的成员zend_op *opcodes，即opcode的数组。执行阶段引擎会按照顺序执行各个opcode。</p><p>目前5.3.2版本的PHP中，opcode一共有154种，可以在{PHPSRC}/Zend/zend_vm_opcodes.h看到这些opcode的宏定义。op的结构定义为：</p><pre><code>struct _zend_op {    opcode_handler_t handler;    znode result;    znode op1;    znode op2;    ulong extended_value;    uint lineno;    zend_uchar opcode;};</code></pre><p>其中的成员opcode就对应154个opcode宏定义中的一个，每一个op根据opcode和操作数的类型不同都会对应一个相关的执行句柄(opcode_handler_t handler)，执行句柄是一个函数指针，op的执行执行句柄都定义在{PHPSRC}/Zend/zend_vm_execute.h中，这个文件可以通过一个PHP脚本({PHPSRC}/Zend/zend_vm_gen.php)来生成，这个PHP脚本用来生成zend_vm_opcodes.h和zend_vm_execute.h两个文件，zend_vm_execute.h的内容会根据生成时的参数不同而不同，这里主要是可以定置zend 引擎对op的分发方式，比如用CALL,SWITCH,GOTO,默认的是用CALL，也就是函数调用，所以这里就以函数调用来简单的介绍下这个文件的功能（文件极大，有近36000行，所以不要仔细啃），在这个文件中所有定义为 static int ZEND_FASTCALL 并且以 ZEND_<em> 开头的函数就是op的句柄，此文件中第一个函数execute是执行op的主方法，以这里作为入口执行一连串的op。可以说整个PHP的功能特性都是通过这些op句柄完成的(当然这些句柄会间接调用其他模块中的功能)，那么这154个opcode如何对应到这些static int ZEND_FASTCALL ZEND_</em>的执行句柄的呢？同样在这个文件中，可以看到zend_init_opcodes_handlers函数，这个函数初始化一个 static const opcode_handler_t labels[]数组，这个 labels数组就是handlers的一张表，这个表有近4000个项，有一个算法将一个opcode映射到这个表中的一个元素，算法同样在zend_vm_execute.h中可以找到，靠近文件结尾zend_vm_set_opcode_handler和zend_vm_get_opcode_handler就是这个算法的实现。</p><p>那么引擎是如何通过这些op handler实现PHP语言的特性的呢？这里我举一个最简单的例子，考虑下面只有一行的PHP代码：</p><pre><code>&lt;?php    $a = 123;?&gt;</code></pre><p>通过某种方法（以后再介绍这些方法）我们可以知道这行代码主要生成一个zend_op，其主要成员值为:</p><ul><li>opcode = 38 (对应#define ZEND_ASSIGN 38)</li><li>op1 = $a ($a变量实际上是以cv形式存在，以后介绍)</li><li>op2 = 123 (以const常量形式存在)</li></ul><p>handler = ZEND_ASSIGN_SPEC_CV_CONST_HANDLER（得到这个handler的名字不是一件容易的事，以后给出方法）</p><p>opcode ZEND_ASSIGN的意思是将一个常量赋值给一个cv(compiled variable)，这个cv其实就是$a变量的一种存在形式。在zend_vm_execute.h中搜索到ZEND_ASSIGN_SPEC_CV_CONST_HANDLER的定义，其主要功能就是取op2的值123，将其赋值给op1的变量，当然这个过程比想象中的要复杂一些，会有变量的初始化，变量的写时赋值等过程，以后会介绍每一个过程。这样这条PHP语句的功能就完成了。可以看出，op handler只是按照一些固定的方式来对操作数op1 op2（可能还有result）进行操作，handler不理会这些操作数中的具体值，这些值是在编译阶段生成op的时候确定的，比如如果$a = 123 改成 $a =456，那么生成的op中op2就是456了，handler始终按照固定的方式来处理。</p><p>因此我们能知道，PHP的执行过程是先通过编译器将PHP代码编译成op code,然后然后zend虚拟机按照一定顺序执行这些opcode，具体是将每个opcode分发给特定的op code handler。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-如何执行PHP脚本</title>
      <link href="/posts/ffdd5200.html"/>
      <url>/posts/ffdd5200.html</url>
      
        <content type="html"><![CDATA[<h1 id="13-如何执行PHP脚本"><a href="#13-如何执行PHP脚本" class="headerlink" title="13-如何执行PHP脚本"></a>13-如何执行PHP脚本</h1><p>前面介绍了PHP的生命周期，PHP的SAPI，SAPI处于PHP整个架构较上层，而真正脚本的执行主要由Zend引擎来完成， 这一小节我们介绍PHP脚本的执行。</p><p>目前编程语言可以分为两大类：</p><ul><li>第一类是像C/C++， .NET， Java之类的编译型语言， 它们的共性是：运行之前必须对源代码进行编译，然后运行编译后的目标文件。</li><li>第二类比如PHP， Javascript， Ruby， Python这些解释型语言， 他们都无需经过编译即可“运行”。</li></ul><p>虽然可以理解为直接运行，但它们并不是真的直接就被能被机器理解， 机器只能理解机器语言，那这些语言是怎么被执行的呢， 一般这些语言都需要一个解释器， 由解释器来执行这些源码， 实际上这些语言还是会经过编译环节，只不过它们一般会在运行的时候实时进行编译。为了效率，并不是所有语言在每次执行的时候都会重新编译一遍， 比如PHP的各种opcode缓存扩展(如APC， xcache， eAccelerator等)，比如Python会将编译的中间文件保存成pyc/pyo文件， 避免每次运行重新进行编译所带来的性能损失。</p><p>PHP的脚本的执行也需要一个解释器， 比如命令行下的php程序，或者apache的mod_php模块等等。 前面提到了PHP的SAPI接口， 下面就以PHP命令行程序为例解释PHP脚本是怎么被执行的。 例如如下的这段PHP脚本：</p><pre><code>&lt;?php$str = &quot;Hello, nowamagic!\n&quot;;echo $str;?&gt;</code></pre><p>假设上面的代码保存在名为hello.php的文件中， 用PHP命令行程序执行这个脚本：</p><pre><code>$ php ./hello.php</code></pre><p>这段代码的输出显然是Hello， nowamagic!， 那么在执行脚本的时候PHP/Zend都做了些什么呢？ 这些语句是怎么样让php输出这段话的呢? 下面将一步一步的进行介绍。<br>程序的执行</p><ol><li>如上例中， 传递给php程序需要执行的文件， php程序完成基本的准备工作后启动PHP及Zend引擎， 加载注册的扩展模块。</li><li>初始化完成后读取脚本文件，Zend引擎对脚本文件进行词法分析，语法分析。然后编译成opcode执行。 如过安装了apc之类的opcode缓存， 编译环节可能会被跳过而直接从缓存中读取opcode执行。</li></ol><p>PHP在读取到脚本文件后首先对代码进行词法分析，PHP的词法分析器是通过lex生成的， 词法规则文件在$PHP_SRC/Zend/zend_language_scanner.l， 这一阶段lex会会将源代码按照词法规则切分一个一个的标记(token)。PHP中提供了一个函数token_get_all()， 该函数接收一个字符串参数， 返回一个按照词法规则切分好的数组。 例如将上面的php代码作为参数传递给这个函数：</p><pre><code>&lt;?php$code =&lt;&lt;&lt;PHP_CODE&lt;?php$str = &quot;Hello, nowamagic\n&quot;;echo $str;PHP_CODE;var_dump(token_get_all($code));?&gt;</code></pre><p>运行上面的脚本你将会看到一如下的输出：</p><pre><code>array (  0 =&gt;  array (    0 =&gt; 368,       // 脚本开始标记    1 =&gt; &apos;&lt;?php     // 匹配到的字符串&apos;,    2 =&gt; 1,  ),  1 =&gt;  array (    0 =&gt; 371,    1 =&gt; &apos; &apos;,    2 =&gt; 2,  ),  2 =&gt; &apos;=&apos;,  3 =&gt;  array (    0 =&gt; 371,    1 =&gt; &apos; &apos;,    2 =&gt; 2,  ),  4 =&gt;  array (    0 =&gt; 315,    1 =&gt; &apos;&quot;Hello, nowamagic&quot;&apos;,    2 =&gt; 2,  ),  5 =&gt; &apos;;&apos;,  6 =&gt;  array (    0 =&gt; 371,    1 =&gt; &apos;&apos;,    2 =&gt; 3,  ),  7 =&gt;  array (    0 =&gt; 316,    1 =&gt; &apos;echo&apos;,    2 =&gt; 4,  ),  8 =&gt;  array (    0 =&gt; 371,    1 =&gt; &apos; &apos;,    2 =&gt; 4,  ),  9 =&gt; &apos;;&apos;,</code></pre><p>这也是Zend引擎词法分析做的事情，将代码切分为一个个的标记，然后使用语法分析器(PHP使用bison生成语法分析器， 规则见$PHP_SRC/Zend/zend_language_parser。y)， bison根据规则进行相应的处理， 如果代码找不到匹配的规则，也就是语法错误时Zend引擎会停止，并输出错误信息。 比如缺少括号，或者不符合语法规则的情况都会在这个环节检查。 在匹配到相应的语法规则后，Zend引擎还会进行编译， 将代码编译为opcode， 完成后，Zend引擎会执行这些opcode， 在执行opcode的过程中还有可能会继续重复进行编译-执行， 例如执行eval，include/require等语句， 因为这些语句还会包含或者执行其他文件或者字符串中的脚本。</p><p>例如上例中的echo语句会编译为一条ZEND_ECHO指令， 执行过程中，该指令由C函数zend_print_variable(zval* z)执行，将传递进来的字符串打印出来。 为了方便理解， 本例中省去了一些细节，例如opcode指令和处理函数之间的映射关系等。 后面的章节将会详细介绍。</p><p>如果想直接查看生成的Opcode，可以使用php的vld扩展查看。扩展下载地址: <a href="http://pecl.php.net/package/vld。Win下需要自己编译生成dll文件。" target="_blank" rel="noopener">http://pecl.php.net/package/vld。Win下需要自己编译生成dll文件。</a></p><p>有关PHP脚本编译执行的细节，请阅读后面有关词法分析，语法分析及opcode编译相关内容。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-PHP的FastCGI</title>
      <link href="/posts/cb63db30.html"/>
      <url>/posts/cb63db30.html</url>
      
        <content type="html"><![CDATA[<h1 id="12-PHP的FastCGI"><a href="#12-PHP的FastCGI" class="headerlink" title="12-PHP的FastCGI"></a>12-PHP的FastCGI</h1><p>CGI全称是“通用网关接口”(Common Gateway Interface)， 它可以让一个客户端，从网页浏览器向执行在Web服务器上的程序请求数据。 CGI描述了客户端和这个程序之间传输数据的一种标准。 CGI的一个目的是要独立于任何语言的，所以CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。 如php，perl，tcl等。</p><p>FastCGI是Web服务器和处理程序之间通信的一种协议， 是CGI的一种改进方案，FastCGI像是一个常驻(long-live)型的CGI， 它可以一直执行，在请求到达时不会花费时间去fork一个进程来处理(这是CGI最为人诟病的fork-and-execute模式)。 正是因为他只是一个通信协议，它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p><p>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，将CGI解释器进程保持在内存中，以此获得较高的性能。 CGI程序反复加载是CGI性能低下的主要原因，如果CGI程序保持在内存中并接受FastCGI进程管理器调度， 则可以提供良好的性能、伸缩性、Fail-Over特性等。</p><p>一般情况下，FastCGI的整个工作流程是这样的：</p><ol><li>Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)</li><li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。</li><li>当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。 Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</li><li>FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时， 请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</li></ol><p>PHP的CGI实现了Fastcgi协议，是一个TCP或UDP协议的服务器接受来自Web服务器的请求， 当启动时创建TCP/UDP协议的服务器的socket监听，并接收相关请求进行处理。随后就进入了PHP的生命周期： 模块初始化，sapi初始化，处理PHP请求，模块关闭，sapi关闭等就构成了整个CGI的生命周期。</p><p>以TCP为例，在TCP的服务端，一般会执行这样几个操作步骤：</p><ol><li>调用socket函数创建一个TCP用的流式套接字；</li><li>调用bind函数将服务器的本地地址与前面创建的套接字绑定；</li><li>调用listen函数将新创建的套接字作为监听，等待客户端发起的连接，当客户端有多个连接连接到这个套接字时，可能需要排队处理；</li><li>服务器进程调用accept函数进入阻塞状态，直到有客户进程调用connect函数而建立起一个连接；</li><li>当与客户端创建连接后，服务器调用read_stream函数读取客户的请求；</li><li>处理完数据后，服务器调用write函数向客户端发送应答。</li></ol><center><br><img src="images/2012_02_07_01.jpg" alt><br></center><p>PHP的FastCGI使你的所有php应用软件通过mod_fastci运行，而不是mod_phpsusexec。FastCGI应用速度很快是因为他们持久稳定，不必对每一个请求都启动和初始化。这使得应用程序的开发成为可能，否则在CGI范例是不切实际的（例如一个大型的脚本，或者一个需要 连接单个或多个数据库的应用）。</p><p>FastCGI的优点：</p><ol><li>PHP脚本运行速度更快(3到30倍)。PHP解释程序被载入内存而不用每次需要时从存储器读取，极大的提升了依靠脚本运行的站点的性能。</li><li>需要使用更少的系统资源。由于服务器不用每次需要时都载入PHP解释程序，你可以将站点的传输速度提升很高而不必增加cpu负担。</li><li>不需要对现有的代码作任何改变。现有的一切都适用于PHP的FastCGI。</li></ol><p>但是也会有潜在问题：</p><ul><li>对所有的子目录（/home/USERNAME/public_html/php.ini）你只有一个可用的php.ini文件。这是优化网站代码所必需的。如果你需要多个php.ini文件以适应不同的脚本需要，你可以在任何子目录禁用PHP的快速CGI，而其余的地方则继续有效。如果你需要这样做请联系support。</li><li>你对PHP环境做的任何升级（如php.ini文件的改变）都有几分钟的延迟。这是因为为了更快的速度你的php.ini文件已经被载入内存，而不是每次需要时再从存储器重新读取。</li></ul>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-嵌入式PHP</title>
      <link href="/posts/5cd78f2.html"/>
      <url>/posts/5cd78f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="11-嵌入式PHP"><a href="#11-嵌入式PHP" class="headerlink" title="11-嵌入式PHP"></a>11-嵌入式PHP</h1><p>从PHP源码目录结构的介绍以及PHP生命周期可知：嵌入式PHP类似CLI，也是SAPI接口的另一种实现。 一般情况下，它的一个请求的生命周期也会和其它的SAPI一样：模块初始化=&gt;请求初始化=&gt;处理请求=&gt;关闭请求=&gt;关闭模块。 当然，这只是理想情况。因为特定的应用由自己特殊的需求，只是在处理PHP脚本这个环节基本一致。</p><p>对于嵌入式PHP或许我们了解比较少，或者说根本用不到，甚至在网上相关的资料也不多， 例如很多游戏中使用Lua语言作为粘合语言，或者作为扩展游戏的脚本语言，类似的， 浏览器中的Javascript语言就是嵌入在浏览器中的。只是目前很少有应用将PHP作为嵌入语言来使用， PHP的强项目前还是在Web开发方面。</p><p>PHP对于嵌入式PHP的支持以及PHP为嵌入式提供了哪些接口或功能呢？首先我们看下所要用到的示例源码：</p><pre><code>#include &lt;sapi/embed/php_embed.h&gt;#ifdef ZTS    void ***tsrm_ls;#endif/* Extension bits */zend_module_entry php_mymod_module_entry = {    STANDARD_MODULE_HEADER,    &quot;mymod&quot;, /* extension name */    NULL, /* function entries */    NULL, /* MINIT */    NULL, /* MSHUTDOWN */    NULL, /* RINIT */    NULL, /* RSHUTDOWN */    NULL, /* MINFO */    &quot;1.0&quot;, /* version */    STANDARD_MODULE_PROPERTIES};/* Embedded bits */static void startup_php(void){    int argc = 1;    char *argv[2] = { &quot;embed5&quot;, NULL };    php_embed_init(argc, argv PTSRMLS_CC);    zend_startup_module(&amp;php_mymod_module_entry);}static void execute_php(char *filename){    zend_first_try {        char *include_script;        spprintf(&amp;include_script, 0, &quot;include &apos;%s&apos;&quot;, filename);        zend_eval_string(include_script, NULL, filename TSRMLS_CC);        efree(include_script);    } zend_end_try();}int main(int argc, char *argv[]){    if (argc &lt;= 1) {        printf(&quot;Usage: embed4 scriptfile&quot;;);        return -1;    }    startup_php();    execute_php(argv[1]);    php_embed_shutdown(TSRMLS_CC);    return 0;}</code></pre><p>以上的代码可以在《Extending and Embedding PHP》在第20章找到（原始代码有一个符号错误，有兴趣的童鞋可以去围观下）。 上面的代码是一个嵌入式PHP运行器（我们权当其为运行器吧），在这个运行器上我们可以运行PHP代码。 这段代码包括了对于PHP嵌入式支持的声明，启动嵌入式PHP运行环境，运行PHP代码，关闭嵌入式PHP运行环境。 下面我们就这段代码分析PHP对于嵌入式的支持做了哪些工作。 首先看下第一行：</p><pre><code>#include &lt;sapi/embed/php_embed.h&gt;</code></pre><p>在sapi目录下的embed目录是PHP对于嵌入式的抽象层所在。在这里有我们所要用到的函数或宏定义。 如示例中所使用的php_embed_init，php_embed_shutdown等函数。</p><p>第2到4行：</p><pre><code>#ifdef ZTS    void ***tsrm_ls;#endif</code></pre><p>ZTS是Zend Thread Safety的简写，与这个相关的有一个TSRM（线程安全资源管理）的东东，这个后面的章节会有详细介绍，这里就不再作阐述。</p><p>第6到17行：</p><pre><code>zend_module_entry php_mymod_module_entry = {    STANDARD_MODULE_HEADER,    &quot;mymod&quot;, /* extension name */    NULL, /* function entries */    NULL, /* MINIT */    NULL, /* MSHUTDOWN */    NULL, /* RINIT */    NULL, /* RSHUTDOWN */    NULL, /* MINFO */    &quot;1.0&quot;, /* version */    STANDARD_MODULE_PROPERTIES};</code></pre><p>以上PHP内部的模块结构声明，此处对于模块初始化，请求初始化等函数指针均为NULL， 也就是模块在初始化及请求开始结束等事件发生的时候不执行任何操作。 不过这些操作在sapi/embed/php_embed.c文件中的php_embed_shutdown等函数中有体现。 关于模块结构的定义在zend/zend_modules.h中。</p><p>startup_php函数：</p><pre><code>static void startup_php(void){    int argc = 1;    char *argv[2] = { &quot;embed5&quot;, NULL };    php_embed_init(argc, argv PTSRMLS_CC);    zend_startup_module(&amp;php_mymod_module_entry);}</code></pre><p>这个函数调用了两个函数php_embed_init和zend_startup_module完成初始化工作。 php_embed_init函数定义在sapi/embed/php_embed.c文件中。它完成了PHP对于嵌入式的初始化支持。 zend_startup_module函数是PHP的内部API函数，它的作用是注册定义的模块，这里是注册mymod模块。 这个注册过程仅仅是将所定义的zend_module_entry结构添加到注册模块列表中。</p><p>execute_php函数：</p><pre><code>static void execute_php(char *filename){    zend_first_try {        char *include_script;        spprintf(&amp;include_script, 0, &quot;include &apos;%s&apos;&quot;, filename);        zend_eval_string(include_script, NULL, filename TSRMLS_CC);        efree(include_script);    } zend_end_try();}</code></pre><p>从函数的名称来看，这个函数的功能是执行PHP代码的。 它通过调用sprrintf函数构造一个include语句，然后再调用zend_eval_string函数执行这个include语句。 zend_eval_string最终是调用zend_eval_stringl函数，这个函数是流程是一个编译PHP代码， 生成zend_op_array类型数据，并执行opcode的过程。 这段程序相当于下面的这段php程序，这段程序可以用php命令来执行，虽然下面这段程序没有实际意义， 而通过嵌入式PHP中，你可以在一个用C实现的系统中嵌入PHP，然后用PHP来实现功能。</p><pre><code>&lt;?phpif($argc &lt; 2) die(&quot;Usage: embed4 scriptfile&quot;);include $argv[1];?&gt;</code></pre><p>main函数：</p><pre><code>int main(int argc, char *argv[]){    if (argc &lt;= 1) {        printf(&quot;Usage: embed4 scriptfile&quot;;);        return -1;    }    startup_php();    execute_php(argv[1]);    php_embed_shutdown(TSRMLS_CC);    return 0;}</code></pre><p>这个函数是主函数，执行初始化操作，根据输入的参数执行PHP的include语句，最后执行关闭操作，返回。 其中php_embed_shutdown函数定义在sapi/embed/php_embed.c文件中。它完成了PHP对于嵌入式的关闭操作支持。 包括请求关闭操作，模块关闭操作等。</p><p>以上是使用PHP的嵌入式方式开发的一个简单的PHP代码运行器，它的这些调用的方式都基于PHP本身的一些实现， 而针对嵌入式的SAPI定义是非常简单的，没有Apache和CGI模式的复杂，或者说是相当简陋，这也是由其所在环境决定。 在嵌入式的环境下，很多的网络协议所需要的方法都不再需要。如下所示，为嵌入式的模块定义。</p><pre><code>sapi_module_struct php_embed_module = {    &quot;embed&quot;,                       /* name */    &quot;PHP Embedded Library&quot;,        /* pretty name */    php_embed_startup,              /* startup */    php_module_shutdown_wrapper,   /* shutdown */    NULL,                          /* activate */    php_embed_deactivate,           /* deactivate */    php_embed_ub_write,             /* unbuffered write */    php_embed_flush,                /* flush */    NULL,                          /* get uid */    NULL,                          /* getenv */    php_error,                     /* error handler */    NULL,                          /* header handler */    NULL,                          /* send headers handler */    php_embed_send_header,          /* send header handler */    NULL,                          /* read POST data */    php_embed_read_cookies,         /* read Cookies */    php_embed_register_variables,   /* register server variables */    php_embed_log_message,          /* Log message */    NULL,                           /* Get request time */    NULL,                           /* Child terminate */    STANDARD_SAPI_MODULE_PROPERTIES};/* }}} */</code></pre><p>在这个定义中我们看到了若干的NULl定义，在前面一小节中说到SAPI时，我们是以cookie的读取为例， 在这里也有读取cookie的实现——php_embed_read_cookies函数，但是这个函数的实现是一个空指针NULL。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-Apache运行与钩子函数</title>
      <link href="/posts/c2139b22.html"/>
      <url>/posts/c2139b22.html</url>
      
        <content type="html"><![CDATA[<h1 id="10-Apache运行与钩子函数"><a href="#10-Apache运行与钩子函数" class="headerlink" title="10-Apache运行与钩子函数"></a>10-Apache运行与钩子函数</h1><p>Apache是目前世界上使用最为广泛的一种Web Server，它以跨平台、高效和稳定而闻名。按照去年官方统计的数据，Apache服务器的装机量占该市场60%以上的份额。尤其是在X（Unix/Linux）平台上，Apache是最常见的选择。其它的Web Server产品，比如IIS，只能运行在Windows平台上，是基于微软.Net架构技术的不二选择。</p><p>Apache并不是没有缺点，它最为诟病的一点就是变得越来越重，被普遍认为是重量级的WebServer。所以，近年来又涌现出了很多轻量级的替代产品，比如lighttpd,nginx等等，这些WebServer的优点是运行效率很高，但缺点也很明显，成熟度往往要低于Apache，通常只能用于某些特定场合。</p><h2 id="Apache的运行过程"><a href="#Apache的运行过程" class="headerlink" title="Apache的运行过程"></a>Apache的运行过程</h2><p>Apache的运行分为启动阶段和运行阶段。 在启动阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root（*nix系统）或超级管理员Administrator(Windows系统)完成启动， 并且整个过程处于一个单进程单线程的环境中。 这个阶段包括配置文件解析(如http.conf文件)、模块加载(如mod_php，mod_perl)和系统资源初始化（例如日志文件、共享内存段、数据库连接等）等工作。</p><p>Apache的启动阶段执行了大量的初始化操作，并且将许多比较慢或者花费比较高的操作都集中在这个阶段完成，以减少了后面处理请求服务的压力。</p><p>在运行阶段，Apache主要工作是处理用户的服务请求。 在这个阶段，Apache放弃特权用户级别，使用普通权限，这主要是基于安全性的考虑，防止由于代码的缺陷引起的安全漏洞。 Apache对HTTP的请求可以分为连接、处理和断开连接三个大的阶段。同时也可以分为11个小的阶段，依次为： Post-Read-Request，URI Translation，Header Parsing，Access Control，Authentication，Authorization， MIME Type Checking，FixUp，Response，Logging，CleanUp</p><h2 id="Apache-Hook机制"><a href="#Apache-Hook机制" class="headerlink" title="Apache Hook机制"></a>Apache Hook机制</h2><p>Apache的Hook机制是指：Apache 允许模块(包括内部模块和外部模块，例如mod_php5.so,mod_perl.so等)将自定义的函数注入到请求处理循环中。换句话说，模块可以在Apache的任何一个处理阶段中挂接(Hook)上自己的处理函数，从而参与Apache的请求处理过程。</p><p>mod_php5.so/ php5apache2.dll就是将所包含的自定义函数，通过Hook机制注入到Apache中，在Apache处理流程的各个阶段负责处理php请求。</p><p>关于Hook机制在Windows系统开发也经常遇到，在Windows开发既有系统级的钩子，又有应用级的钩子。常见的翻译软件（例如金山词霸等等）的屏幕取词功能，大多数是通过安装系统级钩子函数完成的，将自定义函数替换gdi32.dll中的屏幕输出的绘制函数。</p><p>Apache 服务器的体系结构的最大特点，就是高度模块化。如果你为了追求处理效率，可以把这些dso模块在apache编译的时候静态链入，这样会提高Apache 5%左右的处理性能。</p><h2 id="Apache请求处理循环"><a href="#Apache请求处理循环" class="headerlink" title="Apache请求处理循环"></a>Apache请求处理循环</h2><p>Apache请求处理循环的11个阶段都做了哪些事情呢？</p><ol><li>Post-Read-Request阶段。在正常请求处理流程中，这是模块可以插入钩子的第一个阶段。对于那些想很早进入处理请求的模块来说，这个阶段可以被利用。</li><li>URI Translation阶段。Apache在本阶段的主要工作：将请求的URL映射到本地文件系统。模块可以在这阶段插入钩子，执行自己的映射逻辑。mod_alias就是利用这个阶段工作的。</li><li>Header Parsing阶段。Apache在本阶段的主要工作：检查请求的头部。由于模块可以在请求处理流程的任何一个点上执行检查请求头部的任务，因此这个钩子很少被使用。mod_setenvif就是利用这个阶段工作的。</li><li>Access Control阶段。 Apache在本阶段的主要工作：根据配置文件检查是否允许访问请求的资源。Apache的标准逻辑实现了允许和拒绝指令。mod_authz_host就是利用这个阶段工作的。</li><li>Authentication阶段。Apache在本阶段的主要工作：按照配置文件设定的策略对用户进行认证，并设定用户名区域。模块可以在这阶段插入钩子，实现一个认证方法。</li><li>Authorization阶段。 Apache在本阶段的主要工作：根据配置文件检查是否允许认证过的用户执行请求的操作。模块可以在这阶段插入钩子，实现一个用户权限管理的方法。</li><li>MIME Type Checking阶段。Apache在本阶段的主要工作：根据请求资源的MIME类型的相关规则，判定将要使用的内容处理函数。标准模块mod_negotiation和mod_mime实现了这个钩子。</li><li>FixUp阶段。这是一个通用的阶段，允许模块在内容生成器之前，运行任何必要的处理流程。和Post_Read_Request类似，这是一个能够捕获任何信息的钩子，也是最常使用的钩子。</li><li>Response阶段。Apache在本阶段的主要工作：生成返回客户端的内容，负责给客户端发送一个恰当的回复。这个阶段是整个处理流程的核心部分。</li><li>Logging阶段。Apache在本阶段的主要工作：在回复已经发送给客户端之后记录事务。模块可能修改或者替换Apache的标准日志记录。</li><li>CleanUp阶段。 Apache在本阶段的主要工作：清理本次请求事务处理完成之后遗留的环境，比如文件、目录的处理或者Socket的关闭等等，这是Apache一次请求处理的最后一个阶段。</li></ol>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-通过mod_php5支持PHP</title>
      <link href="/posts/3317d45a.html"/>
      <url>/posts/3317d45a.html</url>
      
        <content type="html"><![CDATA[<h1 id="09-通过mod-php5支持PHP"><a href="#09-通过mod-php5支持PHP" class="headerlink" title="09-通过mod_php5支持PHP"></a>09-通过mod_php5支持PHP</h1><p>Apache对PHP的支持是通过Apache的模块mod_php5来支持的。如果希望Apache支持PHP的话，在./configure步骤需要指定–with-apxs2=/usr/local/apache2/bin/apxs 表示告诉编译器通过Apache的mod_php5/apxs来提供对PHP5的解析。</p><p>在最后一步make install的时候我们会看到将动态链接库libphp5.so(Apache模块)拷贝到apache2的安装目录的modules目录下，并且还需要在httpd.conf配置文件中添加LoadModule语句来动态将libphp5.so 模块加载进来，从而实现Apache对php的支持。</p><p>由于该模式实在太经典了，因此这里关于安装部分不准备详述了，相对来说比较简单。我们知道nginx一般包括两个用途HTTP Server和Reverse Proxy Server(反向代理服务器)。在前端可以部署nginx作为reverse proxy server，后端布置多个Apache来实现机群系统server cluster架构的。</p><p>因此，实际生产中，我们仍旧能够保留Apache+mod_php5的经典App Server，而仅仅使用nginx来当做前端的reverse proxy server来实现代理和负载均衡。 因此，建议nginx(1个或者多个)+多个apache的架构继续使用下去。</p><p>Apache2的mod_php5模块包括sapi/apache2handler和sapi/apache2filter两个目录 在apache2_handle/mod_php5.c文件中，模块定义的相关代码如下：</p><pre><code>AP_MODULE_DECLARE_DATA module php5_module = {    STANDARD20_MODULE_STUFF,        /* 宏，包括版本，小版本，模块索引，模块名，下一个模块指针等信息，其中模块名以__FILE__体现 */    create_php_config,      /* create per-directory config structure */    merge_php_config,       /* merge per-directory config structures */    NULL,                   /* create per-server config structure */    NULL,                   /* merge per-server config structures */    php_dir_cmds,           /* 模块定义的所有的指令 */    php_ap2_register_hook        /* 注册钩子，此函数通过ap_hoo_开头的函数在一次请求处理过程中对于指定的步骤注册钩子 */};</code></pre><p>它所对应的是Apache的module结构，module的结构定义如下：</p><pre><code>typedef struct module_struct module;struct module_struct {    int version;    int minor_version;    int module_index;    const char *name;    void *dynamic_load_handle;    struct module_struct *next;    unsigned long magic;    void (*rewrite_args) (process_rec *process);    void *(*create_dir_config) (apr_pool_t *p, char *dir);    void *(*merge_dir_config) (apr_pool_t *p, void *base_conf, void *new_conf);    void *(*create_server_config) (apr_pool_t *p, server_rec *s);    void *(*merge_server_config) (apr_pool_t *p, void *base_conf, void *new_conf);    const command_rec *cmds;    void (*register_hooks) (apr_pool_t *p);}</code></pre><p>上面的模块结构与我们在mod_php5.c中所看到的结构有一点不同，这是由于STANDARD20_MODULE_STUFF的原因， 这个宏它包含了前面8个字段的定义。STANDARD20_MODULE_STUFF宏的定义如下：</p><pre><code>/** Use this in all standard modules */#define STANDARD20_MODULE_STUFF MODULE_MAGIC_NUMBER_MAJOR, \                MODULE_MAGIC_NUMBER_MINOR, \                -1, \                __FILE__, \                NULL, \                NULL, \                MODULE_MAGIC_COOKIE, \                                NULL      /* rewrite args spot */</code></pre><p>在php5_module定义的结构中，php_dir_cmds是模块定义的所有的指令集合，其定义的内容如下：</p><pre><code>const command_rec php_dir_cmds[] ={    AP_INIT_TAKE2(&quot;php_value&quot;, php_apache_value_handler, NULL,        OR_OPTIONS, &quot;PHP Value Modifier&quot;),    AP_INIT_TAKE2(&quot;php_flag&quot;, php_apache_flag_handler, NULL,        OR_OPTIONS, &quot;PHP Flag Modifier&quot;),    AP_INIT_TAKE2(&quot;php_admin_value&quot;, php_apache_admin_value_handler,        NULL, ACCESS_CONF|RSRC_CONF, &quot;PHP Value Modifier (Admin)&quot;),    AP_INIT_TAKE2(&quot;php_admin_flag&quot;, php_apache_admin_flag_handler,        NULL, ACCESS_CONF|RSRC_CONF, &quot;PHP Flag Modifier (Admin)&quot;),    AP_INIT_TAKE1(&quot;PHPINIDir&quot;, php_apache_phpini_set, NULL,        RSRC_CONF, &quot;Directory containing the php.ini file&quot;),    {NULL}};</code></pre><p>这是mod_php5模块定义的指令表。它实际上是一个command_rec结构的数组。 当Apache遇到指令的时候将逐一遍历各个模块中的指令表，查找是否有哪个模块能够处理该指令， 如果找到，则调用相应的处理函数，如果所有指令表中的模块都不能处理该指令，那么将报错。 如上可见，mod_php5模块仅提供php_value等5个指令。</p><p>php_ap2_register_hook函数的定义如下：</p><pre><code>void php_ap2_register_hook(apr_pool_t *p){    ap_hook_pre_config(php_pre_config, NULL, NULL, APR_HOOK_MIDDLE);    ap_hook_post_config(php_apache_server_startup, NULL, NULL, APR_HOOK_MIDDLE);    ap_hook_handler(php_handler, NULL, NULL, APR_HOOK_MIDDLE);    ap_hook_child_init(php_apache_child_init, NULL, NULL, APR_HOOK_MIDDLE);}</code></pre><p>以上代码声明了pre_config，post_config，handler和child_init 4个挂钩以及对应的处理函数。 其中pre_config，post_config，child_init是启动挂钩，它们在服务器启动时调用。 handler挂钩是请求挂钩，它在服务器处理请求时调用。其中在post_config挂钩中启动php。 它通过php_apache_server_startup函数实现。php_apache_server_startup函数通过调用sapi_startup启动sapi， 并通过调用php_apache2_startup来注册sapi module struct（此结构在本节开头中有说明）， 最后调用php_module_startup来初始化PHP， 其中又会初始化ZEND引擎，以及填充zend_module_struct中 的treat_data成员(通过php_startup_sapi_content_types)等。</p><p>到这里，我们知道了Apache加载mod_php5模块的整个过程，可是这个过程与我们的SAPI有什么关系呢？ mod_php5也定义了属于Apache的sapi_module_struct结构：</p><pre><code>static sapi_module_struct apache2_sapi_module = {&quot;apache2handler&quot;,&quot;Apache 2.0 Handler&quot;,php_apache2_startup,                /* startup */php_module_shutdown_wrapper,            /* shutdown */NULL,                       /* activate */NULL,                       /* deactivate */php_apache_sapi_ub_write,           /* unbuffered write */php_apache_sapi_flush,              /* flush */php_apache_sapi_get_stat,           /* get uid */php_apache_sapi_getenv,             /* getenv */php_error,                  /* error handler */php_apache_sapi_header_handler,         /* header handler */php_apache_sapi_send_headers,           /* send headers handler */NULL,                       /* send header handler */php_apache_sapi_read_post,          /* read POST data */php_apache_sapi_read_cookies,           /* read Cookies */php_apache_sapi_register_variables,php_apache_sapi_log_message,            /* Log message */php_apache_sapi_get_request_time,       /* Request Time */NULL,                       /* Child Terminate */STANDARD_SAPI_MODULE_PROPERTIES};</code></pre><p>这些方法都专属于Apache服务器。以读取cookie为例，当我们在Apache服务器环境下，在PHP中调用读取Cookie时， 最终获取的数据的位置是在激活SAPI时。它所调用的方法是read_cookies。</p><pre><code>SG(request_info).cookie_data = sapi_module.read_cookies(TSRMLS_C);</code></pre><p>对于每一个服务器在加载时，我们都指定了sapi_module，而Apache的sapi_module是apache2_sapi_module。 其中对应read_cookies方法的是php_apache_sapi_read_cookies函数。 这也是定义SAPI结构的理由：统一接口，面向接口的编程，具有更好的扩展性和适应性。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-Apache模块介绍</title>
      <link href="/posts/1ef75498.html"/>
      <url>/posts/1ef75498.html</url>
      
        <content type="html"><![CDATA[<h1 id="08-Apache模块介绍"><a href="#08-Apache模块介绍" class="headerlink" title="08-Apache模块介绍"></a>08-Apache模块介绍</h1><h2 id="Apache概述"><a href="#Apache概述" class="headerlink" title="Apache概述"></a>Apache概述</h2><p>Apache是目前世界上使用最为广泛的一种Web Server，它以跨平台、高效和稳定而闻名。按照去年官方统计的数据，Apache服务器的装机量占该市场60%以上的份额。尤其是在X（Unix/Linux）平台上，Apache是最常见的选择。其它的Web Server产品，比如IIS，只能运行在Windows平台上，是基于微软.Net架构技术的不二选择。</p><p>Apache支持许多特性，大部分通过模块扩展实现。常见的模块包括mod_auth（权限验证）、mod_ssl（SSL和TLS支持） mod_rewrite（URL重写）等。一些通用的语言也支持以Apache模块的方式与Apache集成。 如Perl，Python，Tcl，和PHP等。</p><p>Apache并不是没有缺点，它最为诟病的一点就是变得越来越重，被普遍认为是重量级的WebServer。所以，近年来又涌现出了很多轻量级的替代产品，比如lighttpd，nginx等等，这些WebServer的优点是运行效率很高，但缺点也很明显，成熟度往往要低于Apache，通常只能用于某些特定场合。</p><h2 id="Apache组件逻辑图"><a href="#Apache组件逻辑图" class="headerlink" title="Apache组件逻辑图"></a>Apache组件逻辑图</h2><p>Apache是基于模块化设计的，总体上看起来代码的可读性高于php的代码，它的核心代码并不多，大多数的功能都被分散到各个模块中，各个模块在系统启动的时候按需载入。你如果想要阅读Apache的源代码，建议你直接从main.c文件读起，系统最主要的处理逻辑都包含在里面。</p><p>MPM（Multi -Processing Modules，多重处理模块）是Apache的核心组件之一，Apache通过MPM来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得最好的运行性能，针对不同的平台(Unix/Linux、Window)做了优化，为不同的平台提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有prefork和worker两种。至于您的服务器正以哪种方式运行，取决于安装Apache过程中指定的MPM编译参数，在X系统上默认的编译参数为prefork。由于大多数的Unix都不支持真正的线程，所以采用了预派生子进程(prefork)方式，象Windows或者Solaris这些支持线程的平台，基于多进程多线程混合的worker模式是一种不错的选择。对此感兴趣的同学可以阅读有关资料，此处不再多讲。Apache中还有一个重要的组件就是APR（Apache portable Runtime Library），即Apache可移植运行库，它是一个对操作系统调用的抽象库，用来实现Apache内部组件对操作系统的使用，提高系统的可移植性。Apache对于php的解析，就是通过众多Module中的php Module来完成的。</p><p><center><br><img src="images/2012_02_02_11.jpg" alt><br></center></p><p><center><br>Apache的逻辑构成以及与操作系统的关系<br></center></p><h2 id="PHP与Apache"><a href="#PHP与Apache" class="headerlink" title="PHP与Apache"></a>PHP与Apache</h2><p>当PHP需要在Apache服务器下运行时，一般来说，它可以mod_php5模块的形式集成， 此时mod_php5模块的作用是接收Apache传递过来的PHP文件请求，并处理这些请求， 然后将处理后的结果返回给Apache。如果我们在Apache启动前在其配置文件中配置好了PHP模块（mod_php5）， PHP模块通过注册apache2的ap_hook_post_config挂钩，在Apache启动的时候启动此模块以接受PHP文件的请求。</p><p>除了这种启动时的加载方式，Apache的模块可以在运行的时候动态装载， 这意味着对服务器可以进行功能扩展而不需要重新对源代码进行编译，甚至根本不需要停止服务器。 我们所需要做的仅仅是给服务器发送信号HUP或者AP_SIG_GRACEFUL通知服务器重新载入模块。 但是在动态加载之前，我们需要将模块编译成为动态链接库。此时的动态加载就是加载动态链接库。 Apache中对动态链接库的处理是通过模块mod_so来完成的，因此mod_so模块不能被动态加载， 它只能被静态编译进Apache的核心。这意味着它是随着Apache一起启动的。</p><p>Apache是如何加载模块的呢？我们以前面提到的mod_php5模块为例。 首先我们需要在Apache的配置文件httpd.conf中添加一行：</p><pre><code>LoadModule php5_module modules/mod_php5.so</code></pre><p>这里我们使用了LoadModule命令，该命令的第一个参数是模块的名称，名称可以在模块实现的源码中找到。 第二个选项是该模块所处的路径。如果需要在服务器运行时加载模块， 可以通过发送信号HUP或者AP_SIG_GRACEFUL给服务器，一旦接受到该信号，Apache将重新装载模块， 而不需要重新启动服务器。</p><p>在配置文件中添加了所上所示的指令后，Apache在加载模块时会根据模块名查找模块并加载， 对于每一个模块，Apache必须保证其文件名是以“mod_”开始的，如PHP的mod_php5.c。 如果命名格式不对，Apache将认为此模块不合法。Apache的每一个模块都是以module结构体的形式存在， module结构的name属性在最后是通过宏STANDARD20_MODULE_STUFF以<strong>FILE</strong>体现。 关于这点可以在后面介绍mod_php5模块时有看到。这也就决定了我们的文件名和模块名是相同的。 通过之前指令中指定的路径找到相关的动态链接库文件后，Apache通过内部的函数获取动态链接库中的内容， 并将模块的内容加载到内存中的指定变量中。</p><p>在真正激活模块之前，Apache会检查所加载的模块是否为真正的Apache模块， 这个检测是通过检查module结构体中的magic字段实现的。 而magic字段是通过宏STANDARD20_MODULE_STUFF体现，在这个宏中magic的值为MODULE_MAGIC_COOKIE， MODULE_MAGIC_COOKIE定义如下：</p><pre><code>#define MODULE_MAGIC_COOKIE 0x41503232UL /* &quot;AP22&quot; */</code></pre><p>最后Apache会调用相关函数(ap_add_loaded_module)将模块激活， 此处的激活就是将模块放入相应的链表中(ap_top_modules链表： ap_top_modules链表用来保存Apache中所有的被激活的模块，包括默认的激活模块和激活的第三方模块。）</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-再次探讨SAPI</title>
      <link href="/posts/772ca8bd.html"/>
      <url>/posts/772ca8bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="07-再次探讨SAPI"><a href="#07-再次探讨SAPI" class="headerlink" title="07-再次探讨SAPI"></a>07-再次探讨SAPI</h1><p>在PHP的生命周期的各个阶段，一些与服务相关的操作都是通过SAPI接口实现。 这些内置实现的物理位置在PHP源码的SAPI目录。这个目录存放了PHP对各个服务器抽象层的代码， 例如命令行程序的实现，Apache的mod_php模块实现以及fastcgi的实现等等。</p><p>在各个服务器抽象层之间遵守着相同的约定，这里我们称之为SAPI接口。 每个SAPI实现都是一个_sapi_module_struct结构体变量。（SAPI接口）。 在PHP的源码中，当需要调用服务器相关信息时，全部通过SAPI接口中对应方法调用实现， 而这对应的方法在各个服务器抽象层实现时都会有各自的实现。</p><p>下面是为SAPI的简单示意图：</p><center><br><img src="images/2012_02_02_10.png" alt><br></center><p>以cgi模式和apache2服务器为例，它们的启动方法如下：</p><pre><code>cgi_sapi_module.startup(&amp;cgi_sapi_module)   //  cgi模式 cgi/cgi_main.c文件apache2_sapi_module.startup(&amp;apache2_sapi_module); //  apache2服务器  apache2handler/sapi_apache2.c文件</code></pre><p>这里的cgi_sapi_module是sapi_module_struct结构体的静态变量。 它的startup方法指向php_cgi_startup函数指针。在这个结构体中除了startup函数指针，还有许多其它方法或字段。 其部分定义如下：</p><pre><code>struct _sapi_module_struct {    char *name;         //  名字（标识用）    char *pretty_name;  //  更好理解的名字（自己翻译的）    int (*startup)(struct _sapi_module_struct *sapi_module);    //  启动函数    int (*shutdown)(struct _sapi_module_struct *sapi_module);   //  关闭方法    int (*activate)(TSRMLS_D);  // 激活    int (*deactivate)(TSRMLS_D);    //  停用    int (*ub_write)(const char *str, unsigned int str_length TSRMLS_DC);     //  不缓存的写操作(unbuffered write)    void (*flush)(void *server_context);    //  flush    struct stat *(*get_stat)(TSRMLS_D);     //  get uid    char *(*getenv)(char *name, size_t name_len TSRMLS_DC); //  getenv    void (*sapi_error)(int type, const char *error_msg, ...);   /* error handler */    int (*header_handler)(sapi_header_struct *sapi_header, sapi_header_op_enum op,        sapi_headers_struct *sapi_headers TSRMLS_DC);   /* header handler */     /* send headers handler */    int (*send_headers)(sapi_headers_struct *sapi_headers TSRMLS_DC);    void (*send_header)(sapi_header_struct *sapi_header,            void *server_context TSRMLS_DC);   /* send header handler */    int (*read_post)(char *buffer, uint count_bytes TSRMLS_DC); /* read POST data */    char *(*read_cookies)(TSRMLS_D);    /* read Cookies */    /* register server variables */    void (*register_server_variables)(zval *track_vars_array TSRMLS_DC);    void (*log_message)(char *message);     /* Log message */    time_t (*get_request_time)(TSRMLS_D);   /* Request Time */    void (*terminate_process)(TSRMLS_D);    /* Child Terminate */    char *php_ini_path_override;    //  覆盖的ini路径    ...    ...};</code></pre><p>以上的这些结构在各服务器的接口实现中都有定义。如Apache2的定义：</p><pre><code>static sapi_module_struct apache2_sapi_module = {    &quot;apache2handler&quot;,    &quot;Apache 2.0 Handler&quot;,    php_apache2_startup,                /* startup */    php_module_shutdown_wrapper,            /* shutdown */    ...}</code></pre><p>目前PHP内置的很多SAPI实现都已不再维护或者变的有些非主流了，PHP社区目前正在考虑将一些SAPI移出代码库。 社区对很多功能的考虑是除非真的非常必要，或者某些功能已近非常通用了，否则就在PECL库中， 例如非常流行的APC缓存扩展将进入核心代码库中。</p><p>整个SAPI类似于一个面向对象中的模板方法模式的应用。 SAPI.c和SAPI.h文件所包含的一些函数就是模板方法模式中的抽象模板， 各个服务器对于sapi_module的定义及相关实现则是一个个具体的模板。</p><p>这样的结构在PHP的源码中有多处使用， 比如在PHP扩展开发中，每个扩展都需要定义一个zend_module_entry结构体。 这个结构体的作用与sapi_module_struct结构体类似，都是一个类似模板方法模式的应用。 在PHP的生命周期中如果需要调用某个扩展，其调用的方法都是zend_module_entry结构体中指定的方法， 如在上一小节中提到的在执行各个扩展的请求初始化时，都是统一调用request_startup_func方法， 而在每个扩展的定义时，都通过宏PHP_RINIT指定request_startup_func对应的函数。 以VLD扩展为例：其请求初始化为PHP_RINIT(vld),与之对应在扩展中需要有这个函数的实现：</p><pre><code>PHP_RINIT_FUNCTION(vld) {}</code></pre><p>所以， 我们在写扩展时也需要实现扩展的这些接口，同样，当实现各服务器接口时也需要实现其对应的SAPI。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-Zend引擎</title>
      <link href="/posts/586857d2.html"/>
      <url>/posts/586857d2.html</url>
      
        <content type="html"><![CDATA[<h1 id="06-Zend引擎"><a href="#06-Zend引擎" class="headerlink" title="06-Zend引擎"></a>06-Zend引擎</h1><p>相信很多人都听说过 Zend Engine 这个名词，也有很多人知道 Zend Engine 就是 PHP 语言的核心，但若要问一句：Zend Engine 到底存在于何处？或者说，Zend Engine 究竟是在什么时候怎么发挥作用让 PHP 源码输出我们想要的东西的？</p><p>Zend引擎是PHP实现的核心，提供了语言实现上的基础设施。例如：PHP的语法实现，脚本的编译运行环境， 扩展机制以及内存管理等，当然这里的PHP指的是官方的PHP实现（除了官方的实现， 目前比较知名的有facebook的hiphop实现，不过到目前为止，PHP还没有一个标准的语言规范），而PHP则提供了请求处理和其他Web服务器的接口(SAPI)。</p><p>要理解 Zend Engine 的作用，就不能不理解为什么会出现，PHP 为什么需要 Zend Engine, Zend Engine 的出现为 PHP 解决了什么问题。PHP 发展到 3.0 版本的时候，此时 PHP 已经很普及了。“在 PHP3 的顶峰，Internet 上 10% 的 web 服务器上都安装了它”，PHP Manual 如是说。广泛的应用必然带来更高的要求。但此时的 PHP3 却有些力不从心了，这主要是因为 PHP3 采用的是边解释边执行的运行方式，运行效率很受其影响。其次，代码整体耦合度比较高，可扩展性也不够好，不利于应付各种各样需求。因此，此时在 PHP 界里已经有点中流砥柱作用的 Zeev Suraski 和 Andi Gutmans 决定重写代码以解决这两个问题。最终他们俩把该项技术的核心引擎命名为 Zend Engine，Zend 的意思即为 Zeev + Andi 。</p><p>Zend Engine 最主要的特性就是把 PHP 的边解释边执行的运行方式改为先进行预编译(Compile)，然后再执行(Execute)。这两者的分开给 PHP 带来了革命性的变化：执行效率大幅提高；由于实行了功能分离，降低了模块间耦合度，可扩展性也大大增强。此时 PHP 已经能很方便的应付各种各样的 BT 需求了，而伴随 PHP 4.4.x ―可能是 PHP4 系列的最后一个分支―的发布，PHP 的大部分开发人员已经将注意力放在了 PHP5 或者 PHP6 上面，以后发布的基本上就是一些 Bug Fix Release。可以说第一代的 Zend Engine 是已经在站最后一班岗了。</p><p>2004 年 7 月，PHP 5 发布，支持 PHP5 的是 Zend Engine 2.0 版本。这个版本主要是对 PHP 的 OO 功能进行了改进（我没有提集成 SQLite、PDO 等特性是因为我们现在谈的主要是 Zend Engine 而非 PHP）。核心执行方式（非 OO 部分）较PHP4 的1.0 版本变动不大，所以 PHP5 纯粹的执行速度相对于 PHP4 没有大的提高。而预计将于本月中旬发布的 PHP 5.1 版本则会携带 Zend Engine 2.1 版本，这个版本将提供新的执行方式，执行速度也会快上许多，至少要比 PHP5.0 相对于 PHP4.x 的差别要大很多，所以，PHP 5.1 将会是一个很了很令人期待的版本。</p><p>但并非 PHP5 系列的 Zend Engine 2 就完美无缺了。前面已经提到过，Zend Engine 将代码分成编译和执行两大部分。一般情况下，我们的代码完成以后就很少再去改变了。但执行时 PHP 却不得不还得一次又一次的重复编译，这根本就是毫无必要的。而且通常情况下，编译的所花费的时间并不比执行少多少，说是五五开并不为过，因此这极大的浪费了机器的 CPU。基于 Zend Engine 3.0 的 PHP6 将试图解决这个问题。除此之外，目前的 PHP 对多字节的字符处理也是 PHP 的一大致命缺陷。这在人们联系日益国际化的今天几乎是不可忍受的。而无数人在抨击 PHP 或 比较 ASP 等同类语言时总是不可避免的要提到这一点。同时受到 IBM 方面的压力，PHP6 也将会把对多字节字符的处理提到首要日程。这在 PHP6 的 Dev 版本中已经得到体现。</p><p>目前PHP的实现和Zend引擎之间的关系非常紧密，甚至有些过于紧密了，例如很多PHP扩展都是使用的Zend API， 而Zend正是PHP语言本身的实现，PHP只是使用Zend这个内核来构建PHP语言的，而PHP扩展大都使用Zend API， 这就导致PHP的很多扩展和Zend引擎耦合在一起了，后来才有PHP核心开发者就提出将这种耦合解开的建议。</p><p>目前PHP的受欢迎程度是毋庸置疑的，但凡流行的语言通常都会出现这个语言的其他实现版本， 这在Java社区里就非常明显，目前已经有非常多基于JVM的语言了，例如IBM的Project Zero就实现了一个基于JVM的PHP实现， .NET也有类似的实现，通常他们这样做的原因无非是因为：他们喜欢这个语言，但又不想放弃原有的平台， 或者对现有的语言实现不满意，处于性能或者语言特性等（HipHop就是这样诞生的）。</p><p>很多脚本语言中都会有语言扩展机制，PHP中的扩展通常是通过Pear库或者原生扩展，在Ruby中则这两者的界限不是很明显， 他们甚至会提供两套实现，一个主要用于在无法编译的环境下使用，而在合适的环境则使用C实现的原生扩展， 这样在效率和可移植性上都可以保证。目前这些为PHP编写的扩展通常都无法在其他的PHP实现中实现重用， HipHop的做法是对最为流行的扩展进行重写。如果PHP扩展能和ZendAPI解耦，则在其他语言中重用这些扩展也将更加容易了。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-多进程⁄线程的SAPI生命周期</title>
      <link href="/posts/d22489dc.html"/>
      <url>/posts/d22489dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="05-多进程⁄线程的SAPI生命周期"><a href="#05-多进程⁄线程的SAPI生命周期" class="headerlink" title="05-多进程⁄线程的SAPI生命周期"></a>05-多进程⁄线程的SAPI生命周期</h1><h2 id="多进程的SAPI生命周期"><a href="#多进程的SAPI生命周期" class="headerlink" title="多进程的SAPI生命周期"></a>多进程的SAPI生命周期</h2><p>通常PHP是编译为apache的一个模块来处理PHP请求。Apache一般会采用多进程模式， Apache启动后会fork出多个子进程，每个进程的内存空间独立，每个子进程都会经过开始和结束环节， 不过每个进程的开始阶段只在进程fork出来以来后进行，在整个进程的生命周期内可能会处理多个请求。 只有在Apache关闭或者进程被结束之后才会进行关闭阶段，在这两个阶段之间会随着每个请求重复请求开始-请求关闭的环节。</p><center><br><img src="/images/2012_02_02_07.jpg" alt><br></center><br><center><br>多进程SAPI生命周期<br></center><h2 id="多线程的SAPI生命周期"><a href="#多线程的SAPI生命周期" class="headerlink" title="多线程的SAPI生命周期"></a>多线程的SAPI生命周期</h2><p>多线程模式和多进程中的某个进程类似，不同的是在整个进程的生命周期内会并行的重复着 请求开始-请求关闭的环节。</p><center><br><img src="/images/2012_02_02_08.jpg" alt><br></center><center><br>多线程SAPI生命周期<br></center>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-单进程SAPI生命周期</title>
      <link href="/posts/d2c293a1.html"/>
      <url>/posts/d2c293a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="04-单进程SAPI生命周期"><a href="#04-单进程SAPI生命周期" class="headerlink" title="04-单进程SAPI生命周期"></a>04-单进程SAPI生命周期</h1><p>CLI/CGI模式的PHP属于单进程的SAPI模式。这类的请求在处理一次请求后就关闭。也就是只会经过如下几个环节： 开始 - 请求开始 - 请求关闭 - 结束 SAPI接口实现就完成了其生命周期。</p><center><br><img src="/images/2012_02_02_05.jpg" alt><br></center><p>单进程多请求则如下图所示：</p><center><br><img src="/images/2012_02_02_06.jpg" alt><br></center>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-一次请求生命周期</title>
      <link href="/posts/bae39ea2.html"/>
      <url>/posts/bae39ea2.html</url>
      
        <content type="html"><![CDATA[<h1 id="03-一次请求生命周期"><a href="#03-一次请求生命周期" class="headerlink" title="03-一次请求生命周期"></a>03-一次请求生命周期</h1><p>我们从未手动开启过PHP的相关进程，它是随着Apache的启动而运行的。PHP通过mod_php5.so模块和Apache相连（具体说来是SAPI，即服务器应用程序编程接口）。</p><p>PHP总共有三个模块：内核、Zend引擎、以及扩展层。</p><ul><li>PHP内核用来处理请求、文件流、错误处理等相关操作；</li><li>Zend引擎（ZE）用以将源文件转换成机器语言，然后在虚拟机上运行它；</li><li>扩展层是一组函数、类库和流，PHP使用它们来执行一些特定的操作。</li></ul><p>比如，我们需要mysql扩展来连接MySQL数据库； 当ZE执行程序时可能会需要连接若干扩展，这时ZE将控制权交给扩展，等处理完特定任务后再返还；最后，ZE将程序运行结果返回给PHP内核，它再将结果传送给SAPI层，最终输出到浏览器上。</p><h2 id="深入探讨"><a href="#深入探讨" class="headerlink" title="深入探讨"></a>深入探讨</h2><p>真正的内部运行过程没有这么简单。以上过程只是个简略版，让我们再深入挖掘一下，看看幕后还发生了些什么。</p><p>Apache启动后，PHP解释程序也随之启动。PHP的启动过程有两步：</p><ul><li>第一步是初始化一些环境变量，这将在整个SAPI生命周期中发生作用；</li><li>第二步是生成只针对当前请求的一些变量设置。</li></ul><h2 id="PHP启动第一步"><a href="#PHP启动第一步" class="headerlink" title="PHP启动第一步"></a>PHP启动第一步</h2><p>不清楚什么第一第二步是什么？别担心，我们接下来详细讨论一下。让我们先看看第一步，也是最主要的一步。要记住的是，第一步的操作在任何请求到达之前就发生了。</p><p>启动Apache后，PHP解释程序也随之启动。PHP调用各个扩展的MINIT方法，从而使这些扩展切换到可用状态。看看php.ini文件里打开了哪些扩展吧。 MINIT的意思是“模块初始化”。各个模块都定义了一组函数、类库等用以处理其他请求。</p><p>一个典型的MINIT方法如下：</p><pre><code>PHP_MINIT_FUNCTION(extension_name){    /*    Initialize functions, classes etc    */}</code></pre><h2 id="PHP启动第二步"><a href="#PHP启动第二步" class="headerlink" title="PHP启动第二步"></a>PHP启动第二步</h2><p>当一个页面请求发生时，SAPI层将控制权交给PHP层。于是PHP设置了用于回复本次请求所需的环境变量。同时，它还建立一个变量表，用来存放执行过程 中产生的变量名和值。PHP调用各个模块的RINIT方法，即“请求初始化”。一个经典的例子是Session模块的RINIT，如果在php.ini中 启用了Session模块，那在调用该模块的RINIT时就会初始化$_SESSION变量，并将相关内容读入；RINIT方法可以看作是一个准备过程， 在程序执行之间就会自动启动。 一个典型的RINIT方法如下：</p><pre><code>PHP_RINIT_FUNCTION(extension_name) {    /* Initialize session variables,pre-populate variables,    redefine global variables etc */}</code></pre><h2 id="PHP关闭第一步"><a href="#PHP关闭第一步" class="headerlink" title="PHP关闭第一步"></a>PHP关闭第一步</h2><p>如同PHP启动一样，PHP的关闭也分两步。一旦页面执行完毕（无论是执行到了文件末尾还是用exit或die函数中止），PHP就会启动清理程序。它会按顺序调用各个模块的RSHUTDOWN方法。 RSHUTDOWN用以清除程序运行时产生的符号表，也就是对每个变量调用unset函数。</p><p>一个典型的RSHUTDOWN方法如下：</p><pre><code>PHP_RSHUTDOWN_FUNCTION(extension_name) {    /*    Do memory management,    unset all variables used in the last PHP call etc    */}</code></pre><h2 id="PHP关闭第二步"><a href="#PHP关闭第二步" class="headerlink" title="PHP关闭第二步"></a>PHP关闭第二步</h2><p>最后，所有的请求都已处理完毕，SAPI也准备关闭了，PHP开始执行第二步：PHP调用每个扩展的MSHUTDOWN方法，这是各个模块最后一次释放内存的机会。</p><p>一个典型的RSHUTDOWN方法如下：</p><pre><code>PHP_MSHUTDOWN_FUNCTION(extension_name) {    /*    Free handlers and persistent memory etc    */}</code></pre><p>这样，整个PHP生命周期就结束了。要注意的是，只有在服务器没有请求的情况下才会执行“启动第一步”和“关闭第二步”。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-一次请求的开始与结束</title>
      <link href="/posts/8daf10d3.html"/>
      <url>/posts/8daf10d3.html</url>
      
        <content type="html"><![CDATA[<h1 id="02-一次请求的开始与结束"><a href="#02-一次请求的开始与结束" class="headerlink" title="02-一次请求的开始与结束"></a>02-一次请求的开始与结束</h1><p>PHP开始执行以后会经过两个主要的阶段：</p><ul><li>处理请求之前的开始阶段</li><li>请求之后的结束阶段</li></ul><p>开始阶段有两个过程：</p><p>第一个过程是模块初始化阶段（MINIT）， 在整个SAPI生命周期内（例如Apache启动以后的整个生命周期内或者命令行程序整个执行过程中）， 该过程只进行一次。</p><p>第二个过程是模块激活阶段（RINIT），该过程发生在请求阶段， 例如通过url请求某个页面，则在每次请求之前都会进行模块激活（RINIT请求开始）。 例如PHP注册了一些扩展模块，则在MINIT阶段会回调所有模块的MINIT函数。 模块在这个阶段可以进行一些初始化工作，例如注册常量，定义模块使用的类等等。</p><p>模块在实现时可以通过如下宏来实现这些回调函数：</p><pre><code>PHP_MINIT_FUNCTION(myphpextension){    // 注册常量或者类等初始化操作    return SUCCESS;}</code></pre><p>请求到达之后PHP初始化执行脚本的基本环境，例如创建一个执行环境，包括保存PHP运行过程中变量名称和值内容的符号表， 以及当前所有的函数以及类等信息的符号表。然后PHP会调用所有模块的RINIT函数， 在这个阶段各个模块也可以执行一些相关的操作，模块的RINIT函数和MINIT回调函数类似：</p><pre><code>PHP_RINIT_FUNCTION(myphpextension){    // 例如记录请求开始时间    // 随后在请求结束的时候记录结束时间。这样我们就能够记录下处理请求所花费的时间了    return SUCCESS;}</code></pre><p>请求处理完后就进入了结束阶段，一般脚本执行到末尾或者通过调用exit()或die()函数， PHP都将进入结束阶段。和开始阶段对应，结束阶段也分为两个环节，一个在请求结束后停用模块(RSHUWDOWN，对应RINIT)， 一个在SAPI生命周期结束（Web服务器退出或者命令行脚本执行完毕退出）时关闭模块(MSHUTDOWN，对应MINIT)。</p><pre><code>PHP_RSHUTDOWN_FUNCTION(myphpextension){    // 例如记录请求结束时间，并把相应的信息写入到日至文件中。    return SUCCESS;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-从SAPI接口开始</title>
      <link href="/posts/21c95273.html"/>
      <url>/posts/21c95273.html</url>
      
        <content type="html"><![CDATA[<h1 id="01-从SAPI接口开始"><a href="#01-从SAPI接口开始" class="headerlink" title="01-从SAPI接口开始"></a>01-从SAPI接口开始</h1><p>SAPI:Server Application Programming Interface 服务器端应用编程端口。研究过PHP架构的同学应该知道这个东东的重要性，它提供了一个接口，使得PHP可以和其他应用进行交互数据。 本文不会详细介绍每个PHP的SAPI，只是针对最简单的CGI SAPI，来说明SAPI的机制。</p><p>我们先来看看PHP的架构图：</p><center><br><img src="images/2012_02_02_01.jpg" alt><br></center><p>SAPI指的是PHP具体应用的编程接口， 就像PC一样，无论安装哪些操作系统，只要满足了PC的接口规范都可以在PC上正常运行， PHP脚本要执行有很多种方式，通过Web服务器，或者直接在命令行下，也可以嵌入在其他程序中。</p><p>通常，我们使用Apache或者Nginx这类Web服务器来测试PHP脚本，或者在命令行下通过PHP解释器程序来执行。 脚本执行完后，Web服务器应答，浏览器显示应答信息，或者在命令行标准输出上显示内容。</p><p>我们很少关心PHP解释器在哪里。虽然通过Web服务器和命令行程序执行脚本看起来很不一样， 实际上它们的工作流程是一样的。命令行参数传递给PHP解释器要执行的脚本， 相当于通过url请求一个PHP页面。脚本执行完成后返回响应结果，只不过命令行的响应结果是显示在终端上。</p><p>脚本执行的开始都是以SAPI接口实现开始的。只是不同的SAPI接口实现会完成他们特定的工作， 例如Apache的mod_php SAPI实现需要初始化从Apache获取的一些信息，在输出内容是将内容返回给Apache， 其他的SAPI实现也类似。</p><p>SAPI提供了一个和外部通信的接口， 对于PHP5.2，默认提供了很多种SAPI， 常见的给apache的mod_php5，CGI，给IIS的ISAPI，还有Shell的CLI，本文就从CGI SAPI入手 ，介绍SAPI的机制。 虽然CGI简单，但是不用担心，它包含了绝大部分内容，足以让你深刻理解SAPI的工作原理。</p><p>要定义个SAPI，首先要定义个sapi_module_struct, 查看 PHP-SRC/sapi/cgi/cgi_main.c：</p><pre><code>static sapi_module_struct cgi_sapi_module = {#if PHP_FASTCGI    &quot;cgi-fcgi&quot;,                     /* name */    &quot;CGI/FastCGI&quot;,                  /* pretty name */#else    &quot;cgi&quot;,                          /* name */    &quot;CGI&quot;,                          /* pretty name */#endif    php_cgi_startup,                /* startup */    php_module_shutdown_wrapper,    /* shutdown */    NULL,                           /* activate */    sapi_cgi_deactivate,            /* deactivate */    sapi_cgibin_ub_write,           /* unbuffered write */    sapi_cgibin_flush,              /* flush */    NULL,                           /* get uid */    sapi_cgibin_getenv,             /* getenv */    php_error,                      /* error handler */    NULL,                           /* header handler */    sapi_cgi_send_headers,          /* send headers handler */    NULL,                           /* send header handler */    sapi_cgi_read_post,             /* read POST data */    sapi_cgi_read_cookies,          /* read Cookies */    sapi_cgi_register_variables,    /* register server variables */    sapi_cgi_log_message,           /* Log message */    NULL,                           /* Get request time */    STANDARD_SAPI_MODULE_PROPERTIES};</code></pre><p>这个结构，包含了一些常量，比如name, 这个会在我们调用php_info()的时候被使用。一些初始化，收尾函数，以及一些函数指针，用来告诉Zend，如何获取，和输出数据。</p><p>1.php_cgi_startup， 当一个应用要调用PHP的时候，这个函数会被调用，对于CGI来说，它只是简单的调用了PHP的初始化函数：</p><pre><code>static int php_cgi_startup(sapi_module_struct *sapi_module){    if (php_module_startup(sapi_module, NULL, 0) == FAILURE) {        return FAILURE;    }    return SUCCESS;}</code></pre><p>2.php_module_shutdown_wrapper ， 一个对PHP关闭函数的简单包装。只是简单的调用php_module_shutdown;</p><p>3.PHP会在每个request的时候，处理一些初始化，资源分配的事务。这部分就是activate字段要定义的，从上面的结构我们可以看出，对于CGI来说，它并没有提供初始化处理句柄。对于mod_php来说，那就不同了，他要在apache的pool中注册资源析构函数， 申请空间， 初始化环境变量，等等。</p><p>4.sapi_cgi_deactivate, 这个是对应与activate的函数，顾名思义，它会提供一个handler, 用来处理收尾工作，对于CGI来说，他只是简单的刷新缓冲区，用以保证用户在Zend关闭前得到所有的输出数据：</p><pre><code>static int sapi_cgi_deactivate(TSRMLS_D){    /* flush only when SAPI was started. The reasons are:        1. SAPI Deactivate is called from two places: module init and request shutdown        2. When the first call occurs and the request is not set up, flush fails on            FastCGI.    */    if (SG(sapi_started)) {        sapi_cgibin_flush(SG(server_context));    }    return SUCCESS;}</code></pre><p>5.sapi_cgibin_ub_write, 这个hanlder告诉了Zend，如何输出数据，对于mod_php来说，这个函数提供了一个向response数据写的接口，而对于CGI来说，只是简单的写到stdout：</p><pre><code>static inline size_t sapi_cgibin_single_write(const char *str, uint str_length TSRMLS_DC){#ifdef PHP_WRITE_STDOUT    long ret;#else    size_t ret;#endif#if PHP_FASTCGI    if (fcgi_is_fastcgi()) {        fcgi_request *request = (fcgi_request*) SG(server_context);        long ret = fcgi_write(request, FCGI_STDOUT, str, str_length);        if (ret &lt;= 0) {            return 0;        }        return ret;    }#endif#ifdef PHP_WRITE_STDOUT    ret = write(STDOUT_FILENO, str, str_length);    if (ret &lt;= 0) return 0;    return ret;#else    ret = fwrite(str, 1, MIN(str_length, 16384), stdout);    return ret;#endif}static int sapi_cgibin_ub_write(const char *str, uint str_length TSRMLS_DC){    const char *ptr = str;    uint remaining = str_length;    size_t ret;    while (remaining &gt; 0) {        ret = sapi_cgibin_single_write(ptr, remaining TSRMLS_CC);        if (!ret) {            php_handle_aborted_connection();            return str_length - remaining;        }        ptr += ret;        remaining -= ret;    }    return str_length;}</code></pre><p>把真正的写的逻辑剥离出来，就是为了简单实现兼容fastcgi的写方式。</p><p>6.sapi_cgibin_flush, 这个是提供给zend的刷新缓存的函数句柄，对于CGI来说，只是简单的调用系统提供的fflush;</p><p>7.NULL， 这部分用来让Zend可以验证一个要执行脚本文件的state，从而判断文件是否据有执行权限等等，CGI没有提供。</p><p>8.sapi_cgibin_getenv, 为Zend提供了一个根据name来查找环境变量的接口，对于mod_php5来说，当我们在脚本中调用getenv的时候，就会间接的调用这个句柄。而对于CGI来说，因为他的运行机制和CLI很类似，直接调用父级是Shell， 所以，只是简单的调用了系统提供的genenv:</p><pre><code>static char *sapi_cgibin_getenv(char *name, size_t name_len TSRMLS_DC){#if PHP_FASTCGI    /* when php is started by mod_fastcgi, no regular environment       is provided to PHP.  It is always sent to PHP at the start       of a request.  So we have to do our own lookup to get env       vars.  This could probably be faster somehow.  */    if (fcgi_is_fastcgi()) {        fcgi_request *request = (fcgi_request*) SG(server_context);        return fcgi_getenv(request, name, name_len);    }#endif    /*  if cgi, or fastcgi and not found in fcgi env        check the regular environment */    return getenv(name);}</code></pre><p>9.php_error, 错误处理函数, 到这里，说几句题外话，上次看到php maillist 提到的使得PHP的错误处理机制完全OO化， 也就是，改写这个函数句柄，使得每当有错误发生的时候，都throw一个异常。而CGI只是简单的调用了PHP提供的错误处理函数。</p><p>10.这个函数会在我们调用PHP的header()函数的时候被调用，对于CGI来说，不提供。</p><p>11.sapi_cgi_send_headers, 这个函数会在要真正发送header的时候被调用，一般来说，就是当有任何的输出要发送之前：</p><pre><code>static int sapi_cgi_send_headers(sapi_headers_struct *sapi_headers TSRMLS_DC){    char buf[SAPI_CGI_MAX_HEADER_LENGTH];    sapi_header_struct *h;    zend_llist_position pos;    if (SG(request_info).no_headers == 1) {        return  SAPI_HEADER_SENT_SUCCESSFULLY;    }    if (cgi_nph || SG(sapi_headers).http_response_code != 200)    {        int len;        if (rfc2616_headers &amp;&amp; SG(sapi_headers).http_status_line) {            len = snprintf(buf, SAPI_CGI_MAX_HEADER_LENGTH,                           &quot;%s\r\n&quot;, SG(sapi_headers).http_status_line);            if (len &gt; SAPI_CGI_MAX_HEADER_LENGTH) {                len = SAPI_CGI_MAX_HEADER_LENGTH;            }        } else {            len = sprintf(buf, &quot;Status: %d\r\n&quot;, SG(sapi_headers).http_response_code);        }        PHPWRITE_H(buf, len);    }    h = (sapi_header_struct*)zend_llist_get_first_ex(&amp;sapi_headers-&gt;headers, &amp;pos);    while (h) {        /* prevent CRLFCRLF */        if (h-&gt;header_len) {            PHPWRITE_H(h-&gt;header, h-&gt;header_len);            PHPWRITE_H(&quot;\r\n&quot;, 2);        }        h = (sapi_header_struct*)zend_llist_get_next_ex(&amp;sapi_headers-&gt;headers, &amp;pos);    }    PHPWRITE_H(&quot;\r\n&quot;, 2);    return SAPI_HEADER_SENT_SUCCESSFULLY;   }</code></pre><p>12.NULL, 这个用来单独发送每一个header, CGI没有提供</p><p>13.sapi_cgi_read_post, 这个句柄指明了如何获取POST的数据，如果做过CGI编程的话，我们就知道CGI是从stdin中读取POST DATA的：</p><pre><code>static int sapi_cgi_read_post(char *buffer, uint count_bytes TSRMLS_DC){    uint read_bytes=0, tmp_read_bytes;#if PHP_FASTCGI    char *pos = buffer;#endif    count_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));    while (read_bytes &lt; count_bytes) {#if PHP_FASTCGI        if (fcgi_is_fastcgi()) {            fcgi_request *request = (fcgi_request*) SG(server_context);            tmp_read_bytes = fcgi_read(request, pos, count_bytes - read_bytes);            pos += tmp_read_bytes;        } else {            tmp_read_bytes = read(0, buffer + read_bytes, count_bytes - read_bytes);        }#else        tmp_read_bytes = read(0, buffer + read_bytes, count_bytes - read_bytes);#endif        if (tmp_read_bytes &lt;= 0) {            break;        }        read_bytes += tmp_read_bytes;    }    return read_bytes;}</code></pre><p>14.sapi_cgi_read_cookies, 这个和上面的函数一样，只不过是去获取cookie值：</p><pre><code>static char *sapi_cgi_read_cookies(TSRMLS_D){    return sapi_cgibin_getenv((char *) &quot;HTTP_COOKIE&quot;, sizeof(&quot;HTTP_COOKIE&quot;)-1 TSRMLS_CC);}</code></pre><p>15.sapi_cgi_register_variables, 这个函数给了一个接口，用以给$_SERVER变量中添加变量，对于CGI来说，注册了一个PHP_SELF,这样我们就可以在脚本中访问$_SERVER[‘PHP_SELF’]来获取本次的request_uri：</p><pre><code>static void sapi_cgi_register_variables(zval *track_vars_array TSRMLS_DC){    /* In CGI mode, we consider the environment to be a part of the server     * variables     */    php_import_environment_variables(track_vars_array TSRMLS_CC);    /* Build the special-case PHP_SELF variable for the CGI version */    php_register_variable(&quot;PHP_SELF&quot;, (SG(request_info).request_uri ? SG(request_info).request_uri : &quot;&quot;), track_vars_array TSRMLS_CC);}</code></pre><p>16.sapi_cgi_log_message ，用来输出错误信息，对于CGI来说，只是简单的输出到stderr：</p><pre><code>static void sapi_cgi_log_message(char *message){#if PHP_FASTCGI    if (fcgi_is_fastcgi() &amp;&amp; fcgi_logging) {        fcgi_request *request;        TSRMLS_FETCH();        request = (fcgi_request*) SG(server_context);        if (request) {            int len = strlen(message);            char *buf = malloc(len+2);            memcpy(buf, message, len);            memcpy(buf + len, &quot;\n&quot;, sizeof(&quot;\n&quot;));            fcgi_write(request, FCGI_STDERR, buf, len+1);            free(buf);        } else {            fprintf(stderr, &quot;%s\n&quot;, message);        }        /* ignore return code */    } else#endif /* PHP_FASTCGI */    fprintf(stderr, &quot;%s\n&quot;, message);}</code></pre><p>经过分析，我们已经了解了一个SAPI是如何实现的了， 分析过CGI以后，我们也就可以想象mod_php, embed等SAPI的实现机制。</p>]]></content>
      
      
      <categories>
          
          <category> php_internal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php_internal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
