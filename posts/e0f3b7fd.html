<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="baidu-site-verification" content="vgpRFHlTIC"><meta name="google-site-verification" content="BnECCcP14gKaNCZHg-CJxMD4dRHmp6DlDMAfoXftVjU"><meta name="msvalidate.01" content="FD9F235D89800A839E28F52E0F487AFA"><script src="https://cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"6.3.0",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,fastclick:!0,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="8 使用HashTable与{数组}在C语言中，我们可以自定义各种各样的数据结构，用来把很多数据保存在一个变量里面，但是每种数据结构都有自己的优缺点，PHP内核规模如此庞大，是否已经找到了一些非常棒的解决方法呢？8.1 使用HashTable与{数组}我们在评选各种数据结构时，往往会考虑我们需要处理的数据规模以及需要的性能。下面让我们简要的看一下看C语言中数组和链表的一些事情。数组作者这里用的不是"><meta name="keywords" content="php_ext"><meta property="og:type" content="article"><meta property="og:title" content="8 使用HashTable与{数组}"><meta property="og:url" content="https://phantom9999.github.io/posts/e0f3b7fd.html"><meta property="og:site_name" content="phantom9999的博客"><meta property="og:description" content="8 使用HashTable与{数组}在C语言中，我们可以自定义各种各样的数据结构，用来把很多数据保存在一个变量里面，但是每种数据结构都有自己的优缺点，PHP内核规模如此庞大，是否已经找到了一些非常棒的解决方法呢？8.1 使用HashTable与{数组}我们在评选各种数据结构时，往往会考虑我们需要处理的数据规模以及需要的性能。下面让我们简要的看一下看C语言中数组和链表的一些事情。数组作者这里用的不是"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2018-02-01T20:07:08.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="8 使用HashTable与{数组}"><meta name="twitter:description" content="8 使用HashTable与{数组}在C语言中，我们可以自定义各种各样的数据结构，用来把很多数据保存在一个变量里面，但是每种数据结构都有自己的优缺点，PHP内核规模如此庞大，是否已经找到了一些非常棒的解决方法呢？8.1 使用HashTable与{数组}我们在评选各种数据结构时，往往会考虑我们需要处理的数据规模以及需要的性能。下面让我们简要的看一下看C语言中数组和链表的一些事情。数组作者这里用的不是"><link rel="canonical" href="https://phantom9999.github.io/posts/e0f3b7fd.html"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>8 使用HashTable与{数组} | phantom9999的博客</title><style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}::selection{background:#262a30;color:#fff}body{position:relative;font-family:Lato,"PingFang SC","Microsoft YaHei",sans-serif;font-size:14px;line-height:2;color:#555;background:#eee}@media (max-width:767px){body{padding-right:0!important}}@media (min-width:768px) and (max-width:991px){body{padding-right:0!important}}@media (min-width:1600px){body{font-size:16px}}h1,h2,h3,h4,h5,h6{margin:0;padding:0;font-weight:700;line-height:1.5;font-family:Lato,"PingFang SC","Microsoft YaHei",sans-serif}h1,h2,h3,h4,h5,h6{margin:20px 0 15px}h1{font-size:22px}@media (max-width:767px){h1{font-size:18px}}h2{font-size:20px}@media (max-width:767px){h2{font-size:16px}}h3{font-size:18px}@media (max-width:767px){h3{font-size:14px}}h4{font-size:16px}@media (max-width:767px){h4{font-size:12px}}h5{font-size:14px}@media (max-width:767px){h5{font-size:10px}}h6{font-size:12px}@media (max-width:767px){h6{font-size:8px}}p{margin:0 0 20px 0}a{color:#555;text-decoration:none;outline:0;border-bottom:1px solid #999;word-wrap:break-word}a:hover{color:#222;border-bottom-color:#222}blockquote{margin:0;padding:0}img{display:block;margin:auto;max-width:100%;height:auto}hr{margin:40px 0;height:3px;border:none;background-color:#ddd;background-image:repeating-linear-gradient(-45deg,#fff,#fff 4px,transparent 4px,transparent 8px)}blockquote{padding:0 15px;color:#666;border-left:4px solid #ddd}blockquote cite::before{content:"-";padding:0 5px}dt{font-weight:700}dd{margin:0;padding:0}kbd{border:1px solid #ccc;border-radius:.2em;box-shadow:.1em .1em .2em rgba(0,0,0,.1);background-color:#f9f9f9;font-family:inherit;background-image:-webkit-linear-gradient(top,#eee,#fff,#eee);padding:.1em .3em;white-space:nowrap}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.center-block{display:block;margin-left:auto;margin-right:auto}.clearfix:after,.clearfix:before{content:" ";display:table}.clearfix:after{clear:both}.pullquote{width:45%}.pullquote.left{float:left;margin-left:5px;margin-right:10px}.pullquote.right{float:right;margin-left:10px;margin-right:5px}.affix.affix.affix{position:fixed}.translation{margin-top:-20px;font-size:14px;color:#999}.scrollbar-measure{width:100px;height:100px;overflow:scroll;position:absolute;top:-9999px}.use-motion .motion-element{opacity:0}table{margin:20px 0;width:100%;border-collapse:collapse;border-spacing:0;border:1px solid #ddd;font-size:14px;word-wrap:break-all}table>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}table>tbody>tr:hover{background-color:#f5f5f5}caption,td,th{padding:8px;text-align:left;vertical-align:middle;font-weight:400}td,th{border-bottom:3px solid #ddd;border-right:1px solid #eee}th{padding-bottom:10px;font-weight:700}td{border-bottom-width:1px}body,html{height:100%}.container{position:relative;min-height:100%}.header-inner{margin:0 auto;padding:100px 0 70px;width:calc(100% - 252px)}@media (min-width:1600px){.container .header-inner{width:900px}}.main{padding-bottom:150px}.main-inner{margin:0 auto;width:calc(100% - 252px)}@media (min-width:1600px){.container .main-inner{width:900px}}.footer{position:absolute;left:0;bottom:0;width:100%;min-height:50px}.footer-inner{box-sizing:border-box;margin:20px auto;width:calc(100% - 252px)}@media (min-width:1600px){.container .footer-inner{width:900px}}.highlight,pre{overflow:auto;margin:20px 0;padding:0;font-size:14px;color:#ccc;background:#2d2d2d;line-height:1.6}code,pre{font-family:consolas,Menlo,"PingFang SC","Microsoft YaHei",monospace}code{padding:2px 4px;word-wrap:break-word;color:#555;background:#eee;border-radius:3px;font-size:14px}pre{padding:10px}pre code{padding:0;color:#ccc;background:0 0;text-shadow:none}.highlight{border-radius:1px}.highlight pre{border:none;margin:0;padding:10px 0}.highlight table{margin:0;width:auto;border:none}.highlight td{border:none;padding:0}.highlight figcaption{font-size:1em;color:#ccc;line-height:1em;margin-bottom:1em;margin:0;padding:.5em;background:#eee;border-bottom:1px solid #e9e9e9}.highlight figcaption:after,.highlight figcaption:before{content:" ";display:table}.highlight figcaption:after{clear:both}.highlight figcaption a{float:right;color:#ccc}.highlight figcaption a:hover{border-bottom-color:#ccc}.highlight .gutter pre{padding-left:10px;padding-right:10px;color:#999;text-align:right;background-color:#1b1b1b}.highlight .code pre{width:100%;padding-left:10px;padding-right:10px;background-color:#2d2d2d}.highlight .line{height:20px}.gutter{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.gist table{width:auto}.gist table td{border:none}pre .deletion{background:green}pre .addition{background:maroon}pre .meta{color:#c9c}pre .comment{color:#999}pre .attribute,pre .css .class,pre .css .id,pre .css .pseudo,pre .html .doctype,pre .regexp,pre .ruby .constant,pre .tag,pre .variable,pre .xml .doctype,pre .xml .pi,pre .xml .tag .title{color:#f2777a}pre .built_in,pre .command,pre .constant,pre .literal,pre .number,pre .params,pre .preprocessor{color:#f99157}pre .css .rules .attribute,pre .formula,pre .header,pre .inheritance,pre .number,pre .ruby .class .title,pre .ruby .symbol,pre .special,pre .string,pre .value,pre .xml .cdata{color:#9c9}pre .css .hexcolor,pre .title{color:#6cc}pre .coffeescript .title,pre .function,pre .javascript .title,pre .perl .sub,pre .python .decorator,pre .python .title,pre .ruby .function .title,pre .ruby .title .keyword{color:#69c}pre .javascript .function,pre .keyword{color:#c9c}.full-image.full-image.full-image.full-image{border:none;max-width:100%;width:auto;margin:20px auto 25px}.blockquote-center,.page-home .post-type-quote blockquote,.page-post-detail .post-type-quote blockquote{position:relative;margin:40px 0;padding:0;border-left:none;text-align:center}.blockquote-center::after,.blockquote-center::before,.page-home .post-type-quote blockquote::after,.page-home .post-type-quote blockquote::before,.page-post-detail .post-type-quote blockquote::after,.page-post-detail .post-type-quote blockquote::before{position:absolute;content:' ';display:block;width:100%;height:24px;opacity:.2;background-repeat:no-repeat;background-position:0 -6px;background-size:22px 22px}.blockquote-center::before,.page-home .post-type-quote blockquote::before,.page-post-detail .post-type-quote blockquote::before{top:-20px;background-image:url(../images/quote-l.svg);border-top:1px solid #ccc}.blockquote-center::after,.page-home .post-type-quote blockquote::after,.page-post-detail .post-type-quote blockquote::after{bottom:-20px;background-image:url(../images/quote-r.svg);border-bottom:1px solid #ccc;background-position:100% 8px}.blockquote-center div,.blockquote-center p,.page-home .post-type-quote blockquote div,.page-home .post-type-quote blockquote p,.page-post-detail .post-type-quote blockquote div,.page-post-detail .post-type-quote blockquote p{text-align:center}.post .post-body .group-picture img{box-sizing:border-box;padding:0 3px;border:none}.post .group-picture-row{overflow:hidden;margin-top:6px}.post .group-picture-row:first-child{margin-top:0}.post .group-picture-column{float:left}.page-post-detail .post-body .group-picture-column{float:none;margin-top:10px;width:auto!important}.page-post-detail .post-body .group-picture-column img{margin:0 auto}.page-archive .group-picture-container{overflow:hidden}.page-archive .group-picture-row{float:left}.page-archive .group-picture-row:first-child{margin-top:6px}.page-archive .group-picture-column{max-width:150px;max-height:150px}.post-body .note{position:relative;padding:15px;margin-bottom:20px;border:1px solid transparent;background-color:#f5f5f5;border-radius:3px}.post-body .note h2,.post-body .note h3,.post-body .note h4,.post-body .note h5,.post-body .note h6{margin-top:0;margin-bottom:0;border-bottom:initial;padding-top:0!important}.post-body .note blockquote:first-child,.post-body .note ol:first-child,.post-body .note p:first-child,.post-body .note pre:first-child,.post-body .note table:first-child,.post-body .note ul:first-child{margin-top:0}.post-body .note blockquote:last-child,.post-body .note ol:last-child,.post-body .note p:last-child,.post-body .note pre:last-child,.post-body .note table:last-child,.post-body .note ul:last-child{margin-bottom:0}.post-body .note.default{background-color:#f3f3f3;border-color:#e1e1e1;color:#666}.post-body .note.default a:not(.btn){color:#666;border-bottom:1px solid #666}.post-body .note.default a:not(.btn):hover{color:#454545;border-bottom:1px solid #454545}.post-body .note.primary{background-color:#f3daff;border-color:#e1c2ff;color:#6f42c1}.post-body .note.primary a:not(.btn){color:#6f42c1;border-bottom:1px solid #6f42c1}.post-body .note.primary a:not(.btn):hover{color:#453298;border-bottom:1px solid #453298}.post-body .note.info{background-color:#d9edf7;border-color:#b3e5ef;color:#31708f}.post-body .note.info a:not(.btn){color:#31708f;border-bottom:1px solid #31708f}.post-body .note.info a:not(.btn):hover{color:#215761;border-bottom:1px solid #215761}.post-body .note.success{background-color:#dff0d8;border-color:#d0e6be;color:#3c763d}.post-body .note.success a:not(.btn){color:#3c763d;border-bottom:1px solid #3c763d}.post-body .note.success a:not(.btn):hover{color:#32562c;border-bottom:1px solid #32562c}.post-body .note.warning{background-color:#fcf4e3;border-color:#fae4cd;color:#8a6d3b}.post-body .note.warning a:not(.btn){color:#8a6d3b;border-bottom:1px solid #8a6d3b}.post-body .note.warning a:not(.btn):hover{color:#714f30;border-bottom:1px solid #714f30}.post-body .note.danger{background-color:#f2dfdf;border-color:#ebcdd2;color:#a94442}.post-body .note.danger a:not(.btn){color:#a94442;border-bottom:1px solid #a94442}.post-body .note.danger a:not(.btn):hover{color:#84333f;border-bottom:1px solid #84333f}.post-body .label{display:inline;padding:0 2px;white-space:nowrap}.post-body .label.default{background-color:#f0f0f0}.post-body .label.primary{background-color:#efe6f7}.post-body .label.info{background-color:#e5f2f8}.post-body .label.success{background-color:#e7f4e9}.post-body .label.warning{background-color:#fcf6e1}.post-body .label.danger{background-color:#fae8eb}.post-body .tabs{position:relative;display:block;margin-bottom:20px;padding-top:10px}.post-body .tabs ul.nav-tabs{margin:0;padding:0;display:flex;margin-bottom:-1px}@media (max-width:413px){.post-body .tabs ul.nav-tabs{display:block;margin-bottom:5px}}.post-body .tabs ul.nav-tabs li.tab{list-style-type:none!important;margin:0 .25em 0 0;border-top:3px solid transparent;border-left:1px solid transparent;border-right:1px solid transparent}@media (max-width:413px){.post-body .tabs ul.nav-tabs li.tab{margin:initial;border-top:1px solid transparent;border-left:3px solid transparent;border-right:1px solid transparent;border-bottom:1px solid transparent}}.post-body .tabs ul.nav-tabs li.tab a{outline:0;border-bottom:initial;display:block;line-height:1.8em;padding:.25em .75em;transition-duration:.2s;transition-timing-function:ease-out;transition-delay:0s}.post-body .tabs ul.nav-tabs li.tab a i{width:1.285714285714286em}.post-body .tabs ul.nav-tabs li.tab.active{border-top:3px solid #fc6423;border-left:1px solid #ddd;border-right:1px solid #ddd;background-color:#fff}@media (max-width:413px){.post-body .tabs ul.nav-tabs li.tab.active{border-top:1px solid #ddd;border-left:3px solid #fc6423;border-right:1px solid #ddd;border-bottom:1px solid #ddd}}.post-body .tabs ul.nav-tabs li.tab.active a{cursor:default;color:#555}.post-body .tabs .tab-content{background-color:#fff}.post-body .tabs .tab-content .tab-pane{border:1px solid #ddd;padding:20px 20px 0 20px}.post-body .tabs .tab-content .tab-pane:not(.active){display:none!important}.post-body .tabs .tab-content .tab-pane.active{display:block!important}.btn{display:inline-block;padding:0 20px;font-size:14px;color:#555;background:#fff;border:2px solid #555;text-decoration:none;border-radius:2px;transition-property:background-color;transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s;line-height:2}.btn:hover{border-color:#222;color:#fff;background:#222}.btn+.btn{margin:0 0 8px 8px}.btn .fa-fw{width:1.285714285714286em;text-align:left}.btn-bar{display:block;width:22px;height:2px;background:#555;border-radius:1px}.btn-bar+.btn-bar{margin-top:4px}.pagination{margin:120px 0 40px;text-align:center;border-top:1px solid #eee}.page-number-basic,.pagination .next,.pagination .page-number,.pagination .prev,.pagination .space{display:inline-block;position:relative;top:-1px;margin:0 10px;padding:0 11px}@media (max-width:767px){.page-number-basic,.pagination .next,.pagination .page-number,.pagination .prev,.pagination .space{margin:0 5px}}.pagination .next,.pagination .page-number,.pagination .prev{border-bottom:0;border-top:1px solid #eee;transition-property:border-color;transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s}.pagination .next:hover,.pagination .page-number:hover,.pagination .prev:hover{border-top-color:#222}.pagination .space{padding:0;margin:0}.pagination .prev{margin-left:0}.pagination .next{margin-right:0}.pagination .page-number.current{color:#fff;background:#ccc;border-top-color:#ccc}@media (max-width:767px){.pagination{border-top:none}.pagination .next,.pagination .page-number,.pagination .prev{margin-bottom:10px;border-top:0;border-bottom:1px solid #eee;padding:0 10px}.pagination .next:hover,.pagination .page-number:hover,.pagination .prev:hover{border-bottom-color:#222}}.comments{margin:60px 20px 0}.tag-cloud{text-align:center}.tag-cloud a{display:inline-block;margin:10px}.back-to-top{display:none;margin:20px -10px -20px;background:#eee;font-size:12px;opacity:.6;cursor:pointer;text-align:center;-webkit-transform:translateZ(0);transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s}.back-to-top:hover{opacity:.8}@media (min-width:768px) and (max-width:991px){.back-to-top{display:none!important}}@media (max-width:767px){.back-to-top{display:none!important}}.back-to-top.back-to-top-on{display:block}.header{background:0 0}.header-inner{position:relative}.headband{height:3px;background:#222}.site-meta{margin:0;text-align:center}@media (max-width:767px){.site-meta{text-align:center}}.brand{position:relative;display:inline-block;padding:0 40px;color:#fff;background:#222;border-bottom:none}.brand:hover{color:#fff}.logo{display:inline-block;margin-right:5px;line-height:36px;vertical-align:top}.site-title{display:inline-block;vertical-align:top;line-height:36px;font-size:20px;font-weight:400;font-family:Lato,"PingFang SC","Microsoft YaHei",sans-serif}.site-subtitle{margin-top:10px;font-size:13px;color:#ddd}.use-motion .brand{opacity:0}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:0;position:relative;top:-10px}.site-nav-toggle{display:none;position:absolute;top:10px;left:10px}@media (max-width:767px){.site-nav-toggle{display:block}}.site-nav-toggle button{margin-top:2px;padding:9px 10px;background:0 0;border:none}@media (max-width:767px){.site-nav{display:none;margin:0 -10px;padding:0 10px;clear:both;border-top:1px solid #ddd}}@media (min-width:768px) and (max-width:991px){.site-nav{display:block!important}}@media (min-width:992px){.site-nav{display:block!important}}.menu{margin-top:20px;padding-left:0;text-align:center}.menu .menu-item{display:inline-block;margin:0 10px;list-style:none}@media screen and (max-width:767px){.menu .menu-item{margin-top:10px}}.menu .menu-item a{display:block;font-size:13px;line-height:inherit;border-bottom:1px solid transparent;transition-property:border-color;transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s}.menu .menu-item a:hover,.menu-item-active a{border-bottom-color:#222}.menu .menu-item .fa{margin-right:5px}.use-motion .menu-item{opacity:0}.post-body{font-family:Lato,"PingFang SC","Microsoft YaHei",sans-serif}@media (max-width:767px){.post-body{word-break:break-word}}.post-body .fancybox img{display:block!important;margin:0 auto;cursor:pointer;cursor:zoom-in;cursor:-webkit-zoom-in}.post-body .figure .caption,.post-body .image-caption{margin:-20px auto 15px;text-align:center;font-size:14px;color:#999;font-weight:700;line-height:1}.post-sticky-flag{display:inline-block;font-size:16px;-ms-transform:rotate(30deg);-webkit-transform:rotate(30deg);-moz-transform:rotate(30deg);-ms-transform:rotate(30deg);-o-transform:rotate(30deg);transform:rotate(30deg)}.use-motion .comments,.use-motion .pagination,.use-motion .post-block{opacity:0}.use-motion .post-header{opacity:0}.use-motion .post-body{opacity:0}.use-motion .collection-title{opacity:0}.posts-expand{padding-top:40px}@media (max-width:767px){.posts-expand{margin:0 20px}.post-body pre .gutter pre{padding-right:10px}.post-body .highlight{margin-left:0;margin-right:0;padding:0}.post-body .highlight .gutter pre{padding-right:10px}}@media (min-width:992px){.posts-expand .post-body{text-align:justify}}.posts-expand .post-body h2,.posts-expand .post-body h3,.posts-expand .post-body h4,.posts-expand .post-body h5,.posts-expand .post-body h6{padding-top:10px}.posts-expand .post-body h2 .header-anchor,.posts-expand .post-body h3 .header-anchor,.posts-expand .post-body h4 .header-anchor,.posts-expand .post-body h5 .header-anchor,.posts-expand .post-body h6 .header-anchor{float:right;margin-left:10px;color:#ccc;border-bottom-style:none;visibility:hidden}.posts-expand .post-body h2 .header-anchor:hover,.posts-expand .post-body h3 .header-anchor:hover,.posts-expand .post-body h4 .header-anchor:hover,.posts-expand .post-body h5 .header-anchor:hover,.posts-expand .post-body h6 .header-anchor:hover{color:inherit}.posts-expand .post-body h2:hover .header-anchor,.posts-expand .post-body h3:hover .header-anchor,.posts-expand .post-body h4:hover .header-anchor,.posts-expand .post-body h5:hover .header-anchor,.posts-expand .post-body h6:hover .header-anchor{visibility:visible}.posts-expand .post-body ul li{list-style:circle}.posts-expand .post-body img{box-sizing:border-box;margin:auto;padding:3px;border:1px solid #ddd}.posts-expand .post-body .fancybox img{margin:0 auto 25px}.posts-expand .post-body img{margin:0 auto 25px}@media (max-width:767px){.posts-collapse{margin:0 20px}.posts-collapse .post-meta,.posts-collapse .post-title{display:block;width:auto;text-align:left}}.posts-collapse{position:relative;z-index:1010;margin-left:55px}.posts-collapse::after{content:" ";position:absolute;top:20px;left:0;margin-left:-2px;width:4px;height:100%;background:#f5f5f5;z-index:-1}@media (max-width:767px){.posts-collapse{margin:0 20px}}.posts-collapse .collection-title{position:relative;margin:60px 0}.posts-collapse .collection-title h1,.posts-collapse .collection-title h2{margin-left:20px}.posts-collapse .collection-title small{color:#bbb;margin-left:5px}.posts-collapse .collection-title::before{content:" ";position:absolute;left:0;top:50%;margin-left:-4px;margin-top:-4px;width:8px;height:8px;background:#bbb;border-radius:50%}.posts-collapse .post{margin:30px 0}.posts-collapse .post-header{position:relative;transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s;transition-property:border;border-bottom:1px dashed #ccc}.posts-collapse .post-header::before{content:" ";position:absolute;left:0;top:12px;width:6px;height:6px;margin-left:-4px;background:#bbb;border-radius:50%;border:1px solid #fff;transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s;transition-property:background}.posts-collapse .post-header:hover{border-bottom-color:#666}.posts-collapse .post-header:hover::before{background:#222}.posts-collapse .post-meta{position:absolute;font-size:12px;left:20px;top:5px}.posts-collapse .post-comments-count{display:none}.posts-collapse .post-title{margin-left:60px;font-size:16px;font-weight:400;line-height:inherit}.posts-collapse .post-title::after{margin-left:3px;opacity:.6}.posts-collapse .post-title a{color:#666;border-bottom:none}.page-home .post-type-quote .post-header,.page-home .post-type-quote .post-tags,.page-post-detail .post-type-quote .post-header,.page-post-detail .post-type-quote .post-tags{display:none}.posts-expand .post-title{text-align:center;word-break:break-word;font-weight:400}.posts-expand .post-title-link{display:inline-block;position:relative;color:#555;border-bottom:none;line-height:1.2;vertical-align:top}.posts-expand .post-title-link::before{content:"";position:absolute;width:100%;height:2px;bottom:0;left:0;background-color:#000;visibility:hidden;-webkit-transform:scaleX(0);-moz-transform:scaleX(0);-ms-transform:scaleX(0);-o-transform:scaleX(0);transform:scaleX(0);transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s}.posts-expand .post-title-link:hover::before{visibility:visible;-webkit-transform:scaleX(1);-moz-transform:scaleX(1);-ms-transform:scaleX(1);-o-transform:scaleX(1);transform:scaleX(1)}.posts-expand .post-title-link .fa{font-size:16px}.posts-expand .post-meta{margin:3px 0 60px 0;color:#999;font-family:Lato,"PingFang SC","Microsoft YaHei",sans-serif;font-size:12px;text-align:center}.posts-expand .post-meta .post-category-list{display:inline-block;margin:0;padding:3px}.posts-expand .post-meta .post-category-list-link{color:#999}.posts-expand .post-meta .post-description{font-size:14px;margin-top:2px}.posts-expand .post-meta time{border-bottom:1px dashed #999;cursor:help}.post-meta-divider{margin:0 .5em}.post-meta-item-icon{margin-right:3px}@media (min-width:768px) and (max-width:991px){.post-meta-item-icon{display:inline-block}}@media (max-width:767px){.post-meta-item-icon{display:inline-block}}@media (min-width:768px) and (max-width:991px){.post-meta-item-text{display:none}}@media (max-width:767px){.post-meta-item-text{display:none}}.post-button{margin-top:40px}.posts-expand .post-tags{margin-top:40px;text-align:center}.posts-expand .post-tags a{display:inline-block;margin-right:10px;font-size:13px}.post-nav{display:table;margin-top:15px;width:100%;border-top:1px solid #eee}.post-nav-divider{display:table-cell;width:10%}.post-nav-item{display:table-cell;padding:10px 0 0 0;width:45%;vertical-align:top}.post-nav-item a{position:relative;display:block;line-height:25px;font-size:14px;color:#555;border-bottom:none}.post-nav-item a:hover{color:#222;border-bottom:none}.post-nav-item a:active{top:2px}.post-nav-item .fa{position:absolute;top:8px;left:0;font-size:12px}.post-nav-next a{padding-left:15px}.post-nav-prev{text-align:right}.post-nav-prev a{padding-right:15px}.post-nav-prev .fa{right:0;left:auto}.posts-expand .post-eof{display:block;margin:80px auto 60px;width:8%;height:1px;background:#ccc;text-align:center}.post:last-child .post-eof.post-eof.post-eof{display:none}.post-gallery{display:table;table-layout:fixed;width:100%;border-collapse:separate}.post-gallery-row{display:table-row}.post-gallery .post-gallery-img{display:table-cell;text-align:center;vertical-align:middle;border:none}.post-gallery .post-gallery-img img{max-width:100%;max-height:100%;border:none}.fancybox-close,.fancybox-close:hover{border:none}.rtl.post-body a,.rtl.post-body h1,.rtl.post-body h2,.rtl.post-body h3,.rtl.post-body h4,.rtl.post-body h5,.rtl.post-body h6,.rtl.post-body li,.rtl.post-body ol,.rtl.post-body p,.rtl.post-body ul{direction:rtl;font-family:UKIJ Ekran}.rtl.post-title{font-family:UKIJ Ekran}.reading-progress-bar{position:fixed;top:0;left:0;z-index:9999;display:block;width:0;height:2px;background:#37c6c0}.sidebar{position:fixed;right:0;top:0;bottom:0;width:0;z-index:1040;box-shadow:inset 0 2px 6px #000;background:#222;-webkit-transform:translateZ(0)}.sidebar .exturl,.sidebar a{color:#999;border-bottom-color:#555}.sidebar .exturl:hover,.sidebar a:hover{color:#eee}@media (min-width:768px) and (max-width:991px){.sidebar{display:none!important}}@media (max-width:767px){.sidebar{display:none!important}}.sidebar-inner{position:relative;padding:20px 10px;color:#999;text-align:center}.site-overview-wrap{overflow:hidden}.site-overview{overflow-y:auto;overflow-x:hidden}.sidebar-toggle{position:fixed;right:30px;bottom:45px;width:14px;height:14px;padding:5px;background:#222;line-height:0;z-index:1050;cursor:pointer;-webkit-transform:translateZ(0)}@media (min-width:768px) and (max-width:991px){.sidebar-toggle{display:none!important}}@media (max-width:767px){.sidebar-toggle{display:none!important}}.sidebar-toggle-line{position:relative;display:inline-block;vertical-align:top;height:2px;width:100%;background:#fff;margin-top:3px}.sidebar-toggle-line:first-child{margin-top:0}.site-author-image{display:block;margin:0 auto;padding:2px;max-width:120px;height:auto;border:1px solid #eee;opacity:1}img:hover{-webkit-transform:rotateZ(360deg);-moz-transform:rotateZ(360deg);-ms-transform:rotate(360deg);-webkit-transform:rotateZ(360deg);-moz-transform:rotateZ(360deg);-ms-transform:rotateZ(360deg);-o-transform:rotateZ(360deg);transform:rotateZ(360deg)}.site-author-name{margin:0;text-align:center;color:#222;font-weight:600}.site-description{margin-top:0;text-align:center;font-size:13px;color:#999}.site-state{overflow:hidden;line-height:1.4;white-space:nowrap;text-align:center}.site-state-item{display:inline-block;padding:0 15px;border-left:1px solid #eee}.site-state-item:first-child{border-left:none}.site-state-item a{border-bottom:none}.site-state-item-count{display:block;text-align:center;color:inherit;font-weight:600;font-size:16px}.site-state-item-name{font-size:13px;color:#999}.feed-link{margin-top:20px}.feed-link a{display:inline-block;padding:0 15px;color:#fc6423;border:1px solid #fc6423;border-radius:4px}.feed-link a i{color:#fc6423;font-size:14px}.feed-link a:hover{color:#fff;background:#fc6423}.feed-link a:hover i{color:#fff}.links-of-author{margin-top:20px}.links-of-author .exturl,.links-of-author a{display:inline-block;vertical-align:middle;margin-right:10px;margin-bottom:10px;border-bottom-color:#555;font-size:13px}.links-of-author .exturl:before,.links-of-author a:before{display:inline-block;vertical-align:middle;margin-right:3px;content:" ";width:4px;height:4px;border-radius:50%;background:#24fff9}.links-of-blogroll{font-size:13px}.links-of-blogroll-title{margin-top:20px;font-size:14px;font-weight:600}.links-of-blogroll-list{margin:0;padding:0;list-style:none}.links-of-blogroll-item{padding:2px 10px}.links-of-blogroll-item a{max-width:280px;box-sizing:border-box;display:inline-block;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.sidebar-nav{margin:0 0 20px;padding-left:0}.sidebar-nav li{display:inline-block;cursor:pointer;border-bottom:1px solid transparent;font-size:14px;color:#555}.sidebar-nav li:hover{color:#fc6423}.page-post-detail .sidebar-nav-toc{padding:0 5px}.page-post-detail .sidebar-nav-overview{margin-left:10px}.sidebar-nav .sidebar-nav-active{color:#fc6423;border-bottom-color:#fc6423}.sidebar-nav .sidebar-nav-active:hover{color:#fc6423}.sidebar-panel{display:none}.sidebar-panel-active{display:block}.post-toc-empty{font-size:14px;color:#666}.post-toc-wrap{overflow:hidden}.post-toc{overflow:auto}.post-toc ol{margin:0;padding:0 2px 5px 10px;text-align:left;list-style:none;font-size:14px}.post-toc ol>ol{padding-left:0}.post-toc ol a{transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s;transition-property:all;color:#666;border-bottom-color:#ccc}.post-toc ol a:hover{color:#000;border-bottom-color:#000}.post-toc .nav-item{overflow:hidden;text-overflow:ellipsis;line-height:1.8}.post-toc .nav .nav-child{display:none}.post-toc .nav .active>.nav-child{display:block}.post-toc .nav .active-current>.nav-child{display:block}.post-toc .nav .active-current>.nav-child>.nav-item{display:block}.post-toc .nav .active>a{color:#fc6423;border-bottom-color:#fc6423}.post-toc .nav .active-current>a{color:#fc6423}.post-toc .nav .active-current>a:hover{color:#fc6423}.footer{font-size:14px;color:#999}.footer img{border:none}.footer-inner{text-align:center}.with-love{display:inline-block;margin:0 5px;color:grey}.powered-by,.theme-info{display:inline-block}.cc-license{margin-top:10px;text-align:center}.cc-license .cc-opacity{opacity:.7;border-bottom:none}.cc-license .cc-opacity:hover{opacity:.9}.cc-license img{display:inline-block}@-moz-keyframes iconAnimate{0%,100%{-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);-o-transform:scale(1);transform:scale(1)}10%,30%{-webkit-transform:scale(.9);-moz-transform:scale(.9);-ms-transform:scale(.9);-o-transform:scale(.9);transform:scale(.9)}20%,40%,60%,80%{-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}50%,70%{-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}}@-webkit-keyframes iconAnimate{0%,100%{-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);-o-transform:scale(1);transform:scale(1)}10%,30%{-webkit-transform:scale(.9);-moz-transform:scale(.9);-ms-transform:scale(.9);-o-transform:scale(.9);transform:scale(.9)}20%,40%,60%,80%{-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}50%,70%{-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}}@-o-keyframes iconAnimate{0%,100%{-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);-o-transform:scale(1);transform:scale(1)}10%,30%{-webkit-transform:scale(.9);-moz-transform:scale(.9);-ms-transform:scale(.9);-o-transform:scale(.9);transform:scale(.9)}20%,40%,60%,80%{-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}50%,70%{-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}}@keyframes iconAnimate{0%,100%{-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);-o-transform:scale(1);transform:scale(1)}10%,30%{-webkit-transform:scale(.9);-moz-transform:scale(.9);-ms-transform:scale(.9);-o-transform:scale(.9);transform:scale(.9)}20%,40%,60%,80%{-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}50%,70%{-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}}.post-spread{margin-top:20px;text-align:center}.jiathis_style{display:inline-block}.jiathis_style a{border:none}.fa{font-family:FontAwesome!important}.post-spread{margin-top:20px;text-align:center}.bdshare-slide-button-box a{border:none}.bdsharebuttonbox{display:inline-block}.bdsharebuttonbox a{border:none}.local-search-pop-overlay{position:fixed;width:100%;height:100%;top:0;left:0;z-index:2080;background-color:rgba(0,0,0,.3)}.local-search-popup{display:none;position:fixed;top:10%;left:50%;margin-left:-350px;width:700px;height:80%;padding:0;background:#fff;color:#333;z-index:9999;border-radius:5px}@media (max-width:767px){.local-search-popup{padding:0;top:0;left:0;margin:0;width:100%;height:100%;border-radius:0}}.local-search-popup ul.search-result-list{padding:0;margin:0 5px}.local-search-popup p.search-result{border-bottom:1px dashed #ccc;padding:5px 0}.local-search-popup a.search-result-title{font-weight:700;font-size:16px}.local-search-popup .search-keyword{border-bottom:1px dashed red;font-weight:700;color:red}.local-search-popup .local-search-header{padding:5px;height:36px;background:#f5f5f5;border-top-left-radius:5px;border-top-right-radius:5px}.local-search-popup #local-search-result{overflow:auto;position:relative;padding:5px 25px;height:calc(100% - 55px)}.local-search-popup .local-search-input-wrapper{display:inline-block;width:calc(100% - 90px);height:36px;line-height:36px;padding:0 5px}.local-search-popup .local-search-input-wrapper input{padding:8px 0;height:20px;display:block;width:100%;outline:0;border:none;background:0 0;vertical-align:middle}.local-search-popup .popup-btn-close,.local-search-popup .search-icon{display:inline-block;font-size:18px;color:#999;height:36px;width:18px;padding-left:10px;padding-right:10px}.local-search-popup .search-icon{float:left}.local-search-popup .popup-btn-close{border-left:1px solid #eee;float:right;cursor:pointer}.local-search-popup #no-result{position:absolute;left:50%;top:50%;-webkit-transform:translate(-50%,-50%);-webkit-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);-o-transform:translate(-50%,-50%);transform:translate(-50%,-50%);color:#ccc}.page-pv,.site-pv,.site-uv{display:inline-block}.page-pv .busuanzi-value,.site-pv .busuanzi-value,.site-uv .busuanzi-value{margin:0 5px}.popular-posts-header{margin-top:60px;margin-bottom:10px;font-size:24px;border-bottom:1px solid #eee;display:block}ul.popular-posts{padding:0}ul.popular-posts .popular-posts-item{margin-left:2em}ul.popular-posts .popular-posts-item .popular-posts-title{font-weight:400;font-size:14px;margin:0;line-height:2.4}.page-archive .archive-page-counter{position:relative;top:3px;left:20px}@media (max-width:767px){.page-archive .archive-page-counter{top:5px}}.page-archive .posts-collapse .archive-move-on{position:absolute;top:11px;left:0;margin-left:-6px;width:10px;height:10px;opacity:.5;background:#555;border:1px solid #fff;border-radius:50%}.category-all-page .category-all-title{text-align:center}.category-all-page .category-all{margin-top:20px}.category-all-page .category-list{margin:0;padding:0;list-style:none}.category-all-page .category-list-item{margin:5px 10px}.category-all-page .category-list-count{color:#bbb}.category-all-page .category-list-count:before{display:inline;content:" ("}.category-all-page .category-list-count:after{display:inline;content:") "}.category-all-page .category-list-child{padding-left:10px}#schedule ul#event-list{padding-left:30px}#schedule ul#event-list hr{margin:20px 0 45px 0!important;background:#222}#schedule ul#event-list hr:after{display:inline-block;content:'NOW';background:#222;color:#fff;font-weight:700;text-align:right;padding:0 5px}#schedule ul#event-list li.event{margin:20px 0;background:#f9f9f9;padding-left:10px;min-height:40px}#schedule ul#event-list li.event h2.event-summary{margin:0;padding-bottom:3px}#schedule ul#event-list li.event h2.event-summary:before{display:inline-block;font-family:FontAwesome;font-size:8px;content:'\f111';vertical-align:middle;margin-right:25px;color:#bbb}#schedule ul#event-list li.event span.event-relative-time{display:inline-block;font-size:12px;font-weight:400;padding-left:12px;color:#bbb}#schedule ul#event-list li.event span.event-details{display:block;color:#bbb;margin-left:56px;padding-top:3px;padding-bottom:6px;text-indent:-24px;line-height:18px}#schedule ul#event-list li.event span.event-details:before{text-indent:0;display:inline-block;width:14px;font-family:FontAwesome;text-align:center;margin-right:9px;color:#bbb}#schedule ul#event-list li.event span.event-details.event-location:before{content:'\f041'}#schedule ul#event-list li.event span.event-details.event-duration:before{content:'\f017'}#schedule ul#event-list li.event-past{background:#fcfcfc}#schedule ul#event-list li.event-past>*{opacity:.6}#schedule ul#event-list li.event-past h2.event-summary{color:#bbb}#schedule ul#event-list li.event-past h2.event-summary:before{color:#dfdfdf}#schedule ul#event-list li.event-now{background:#222;color:#fff;padding:15px 0 15px 10px}#schedule ul#event-list li.event-now h2.event-summary:before{-webkit-transform:scale(1.2);-moz-transform:scale(1.2);-ms-transform:scale(1.2);-o-transform:scale(1.2);transform:scale(1.2);color:#fff;animation:dot-flash 1s alternate infinite ease-in-out}#schedule ul#event-list li.event-now *{color:#fff!important}@-moz-keyframes dot-flash{from{opacity:1;-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}to{opacity:0;-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);-o-transform:scale(1);transform:scale(1)}}@-webkit-keyframes dot-flash{from{opacity:1;-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}to{opacity:0;-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);-o-transform:scale(1);transform:scale(1)}}@-o-keyframes dot-flash{from{opacity:1;-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}to{opacity:0;-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);-o-transform:scale(1);transform:scale(1)}}@keyframes dot-flash{from{opacity:1;-webkit-transform:scale(1.1);-moz-transform:scale(1.1);-ms-transform:scale(1.1);-o-transform:scale(1.1);transform:scale(1.1)}to{opacity:0;-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);-o-transform:scale(1);transform:scale(1)}}.page-post-detail .sidebar-toggle-line{background:#fc6423}.page-post-detail .comments{overflow:hidden}ul.breadcrumb{list-style:none;margin:1em 0;padding:0 2em;text-align:center;font-size:12px}ul.breadcrumb li{display:inline}ul.breadcrumb li+li:before{padding:.5em;font-weight:400;content:"/\00a0"}ul.breadcrumb li+li:last-child{font-weight:700}.header{position:relative;margin:0 auto;width:75%}@media (min-width:768px) and (max-width:991px){.header{width:auto}}@media (max-width:767px){.header{width:auto}}.header-inner{position:absolute;top:0;overflow:hidden;padding:0;width:240px;background:#fff;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12);border-radius:initial}@media (min-width:1600px){.container .header-inner{width:240px}}@media (min-width:768px) and (max-width:991px){.header-inner{position:relative;width:auto;border-radius:initial}}@media (max-width:767px){.header-inner{position:relative;width:auto;border-radius:initial}}.main:after,.main:before{content:" ";display:table}.main:after{clear:both}@media (min-width:768px) and (max-width:991px){.main{padding-bottom:100px}}@media (max-width:767px){.main{padding-bottom:100px}}.container .main-inner{width:75%}@media (min-width:768px) and (max-width:991px){.container .main-inner{width:auto}}@media (max-width:767px){.container .main-inner{width:auto}}.content-wrap{float:right;box-sizing:border-box;padding:40px;width:calc(100% - 252px);background:#fff;min-height:700px;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12);border-radius:initial}@media (min-width:768px) and (max-width:991px){.content-wrap{width:100%;padding:20px;border-radius:initial}}@media (max-width:767px){.content-wrap{width:100%;padding:20px;min-height:auto;border-radius:initial}}.sidebar{position:static;float:left;margin-top:300px;width:240px;background:#eee;box-shadow:none}@media (min-width:768px) and (max-width:991px){.sidebar{display:none}}@media (max-width:767px){.sidebar{display:none}}.sidebar-toggle{display:none}.footer-inner{width:75%;padding-left:260px}@media (min-width:768px) and (max-width:991px){.footer-inner{width:auto;padding-left:0!important;padding-right:0!important}}@media (max-width:767px){.footer-inner{width:auto;padding-left:0!important;padding-right:0!important}}.sidebar-position-right .header-inner{right:0}.sidebar-position-right .content-wrap{float:left}.sidebar-position-right .sidebar{float:right}.sidebar-position-right .footer-inner{padding-left:0;padding-right:260px}.site-brand-wrapper{position:relative}.site-meta{padding:20px 0;color:#fff;background:#222}@media (min-width:768px) and (max-width:991px){.site-meta{box-shadow:0 0 16px rgba(0,0,0,.5)}}@media (max-width:767px){.site-meta{box-shadow:0 0 16px rgba(0,0,0,.5)}}.brand{padding:0;background:0 0}.brand:hover{color:#fff}.site-subtitle{margin:10px 10px 0;font-weight:initial}.site-search form{display:none}.site-nav{border-top:none}@media (min-width:768px) and (max-width:991px){.site-nav{display:none!important}}@media (min-width:768px) and (max-width:991px){.site-nav-on{display:block!important}}.menu .menu-item{display:block;margin:0}.menu .menu-item a{position:relative;box-sizing:border-box;padding:5px 20px;text-align:left;line-height:inherit;transition-property:background-color;transition-duration:.2s;transition-timing-function:ease-in-out;transition-delay:0s}.menu .menu-item a:hover,.menu-item-active a{background:#f9f9f9;border-bottom-color:#fff}.menu .menu-item .badge{display:inline-block;padding:2px 5px;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:middle;background-color:#ccc;border-radius:10px;float:right;margin:.35em 0 0 0;text-shadow:1px 1px 0 rgba(0,0,0,.1)}.menu .menu-item br{display:none}.btn-bar{background-color:#fff}.site-nav-toggle{left:20px;top:50%;-webkit-transform:translateY(-50%);-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);-o-transform:translateY(-50%);transform:translateY(-50%)}@media (min-width:768px) and (max-width:991px){.site-nav-toggle{display:block}}.sub-menu{margin:0;padding:6px 0;background:#fff!important;border-bottom:1px solid #ddd}.sub-menu .menu-item{display:inline-block!important}.sub-menu .menu-item a{padding:initial!important;margin:5px 10px}.sub-menu .menu-item a:hover{background:initial!important;color:#fc6423}.sub-menu .menu-item-active a{background:#fff!important;color:#fc6423;border-bottom-color:#fc6423}.sub-menu .menu-item-active a:hover{background:#fff!important;border-bottom-color:#fc6423}.use-motion .sidebar .motion-element{opacity:1}.sidebar{margin-left:-100%;right:auto;bottom:auto;-webkit-transform:none}.sidebar-inner{box-sizing:border-box;width:240px;color:#555;background:#fff;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12),0 -1px .5px 0 rgba(0,0,0,.09);border-radius:initial;opacity:0}.sidebar-inner.affix{position:fixed;top:12px}.sidebar-inner.affix-bottom{position:absolute}.site-overview{text-align:left}.site-author:after,.site-author:before{content:" ";display:table}.site-author:after{clear:both}.sidebar .exturl,.sidebar a{color:#555}.sidebar .exturl:hover,.sidebar a:hover{color:#222}.site-state-item{padding:0 10px}.links-of-author-item .exturl:before,.links-of-author-item a:before{display:none}.links-of-author-item .exturl,.links-of-author-item a{border-bottom:none;text-decoration:underline}.feed-link{border-top:1px dotted #ccc;border-bottom:1px dotted #ccc;text-align:center}.feed-link a{display:block;color:#fc6423;border:none}.feed-link a:hover{background:0 0;color:#e34603}.feed-link a:hover i{color:#e34603}.links-of-author{display:flex;flex-wrap:wrap;justify-content:center}.links-of-author .exturl{font-size:13px}.links-of-author-item{margin:5px 0 0;width:50%}.links-of-author-item .exturl,.links-of-author-item a{max-width:216px;box-sizing:border-box;display:inline-block;margin-right:0;margin-bottom:0;padding:0 5px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.links-of-author-item .exturl,.links-of-author-item a{display:block;text-decoration:none}.links-of-author-item .exturl:hover,.links-of-author-item a:hover{border-radius:4px;background:#eee}.links-of-author-item .fa{margin-right:2px;font-size:16px}.links-of-author-item .fa-globe{font-size:15px}.links-of-blogroll{text-align:center;margin-top:20px;padding:3px 0 0;border-top:1px dotted #ccc}.links-of-blogroll-title{margin-top:0}.links-of-blogroll-item{padding:0}.links-of-blogroll-inline:after,.links-of-blogroll-inline:before{content:" ";display:table}.links-of-blogroll-inline:after{clear:both}.links-of-blogroll-inline .links-of-blogroll-item{margin:5px 0 0;width:50%;display:inline-block;width:unset}.links-of-blogroll-inline .links-of-blogroll-item .exturl,.links-of-blogroll-inline .links-of-blogroll-item a{max-width:216px;box-sizing:border-box;display:inline-block;margin-right:0;margin-bottom:0;padding:0 5px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.content-wrap{padding:initial;background:initial;box-shadow:initial;border-radius:initial}.post-block{padding:40px;background:#fff;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12);border-radius:initial}#posts>article+article .post-block{margin-top:12px;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12),0 -1px .5px 0 rgba(0,0,0,.09);border-radius:initial}.comments{padding:40px;margin:initial;margin-top:12px;background:#fff;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12),0 -1px .5px 0 rgba(0,0,0,.09);border-radius:initial}.posts-expand{padding-top:initial}.post-nav-divider{width:4%}.post-nav-item{width:48%}.post-eof,.post-spread{display:none!important}.pagination{margin:12px 0 0;border-top:initial;background:#fff;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12),0 -1px .5px 0 rgba(0,0,0,.09);border-radius:initial;padding:10px 0 10px}.pagination .next,.pagination .page-number,.pagination .prev{margin-bottom:initial;top:initial}.main{padding-bottom:initial}.footer{bottom:auto}.sub-menu{border-bottom:initial!important;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12)}.sub-menu+#content>#posts .post-block{box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12),0 -1px .5px 0 rgba(0,0,0,.09);margin-top:12px}@media (min-width:768px) and (max-width:991px){.sub-menu+#content>#posts .post-block{margin-top:10px}}@media (max-width:767px){.sub-menu+#content>#posts .post-block{margin-top:8px}}.post-header h1,.post-header h2{margin:initial}.posts-expand .post-title-link{line-height:inherit}.posts-expand .post-title{font-size:1.7em}.post-body h1{font-size:1.6em;border-bottom:1px solid #eee}.post-body h2{font-size:1.45em;border-bottom:1px solid #eee}.post-body h3{font-size:1.3em;border-bottom:1px solid #eee}.post-body h4{font-size:1.2em;border-bottom:1px dotted #eee}.post-body h5{font-size:1.07em}.post-body h6{font-size:1.03em}@media (min-width:768px) and (max-width:991px){.content-wrap{padding:10px}.posts-expand{margin:initial}.posts-expand .post-button{margin-top:20px}.post-block{padding:20px;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12),0 -1px .5px 0 rgba(0,0,0,.09);border-radius:initial}#posts>article+article .post-block{margin-top:10px}.comments{margin-top:10px;padding:10px 20px}.pagination{margin:10px 0 0}}@media (max-width:767px){.content-wrap{padding:8px}.posts-expand{margin:initial}.posts-expand .post-button{margin-top:12px}.posts-expand img{padding:initial!important}.post-block{padding:12px;min-height:auto;box-shadow:0 2px 2px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.06),0 1px 5px 0 rgba(0,0,0,.12),0 -1px .5px 0 rgba(0,0,0,.09);border-radius:initial}#posts>article+article .post-block{margin-top:8px}.comments{margin-top:8px;padding:0 12px}.pagination{margin:8px 0 0}}</style><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript><script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('https://cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css');loadCss('https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css');loadCss('https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css');</script><noscript><link rel="stylesheet" href="https://cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"></noscript></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">phantom9999的博客</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-php-devel"><a href="/categories/php-devel" rel="section"><i class="menu-item-icon fa fa-fw fa-university"></i><br>php开发</a></li><li class="menu-item menu-item-cpp-devel"><a href="/categories/cpp-devel" rel="section"><i class="menu-item-icon fa fa-fw fa-university"></i><br>c++开发</a></li><li class="menu-item menu-item-essay"><a href="/categories/essay" rel="section"><i class="menu-item-icon fa fa-fw fa-university"></i><br>随笔</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签<span class="badge">24</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档<span class="badge">131</span></a></li><li class="menu-item menu-item-php-internal"><a href="/categories/php-internal/" rel="section"><i class="menu-item-icon fa fa-fw fa-university"></i><br>php内核解析收集</a></li><li class="menu-item menu-item-php-ext"><a href="/categories/php-ext/" rel="section"><i class="menu-item-icon fa fa-fw fa-university"></i><br>php拓展开发收集</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://phantom9999.github.io/posts/e0f3b7fd.html"><span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="phantom9999"><meta itemprop="description" content="cpp,php相关的个人博客"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="phantom9999的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">8 使用HashTable与{数组}</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-02-01 20:07:08" itemprop="dateCreated datePublished" datetime="2018-02-01T20:07:08+00:00">2018-02-01</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/php-ext/" itemprop="url" rel="index"><span itemprop="name">php_ext</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="8-使用HashTable与-数组"><a href="#8-使用HashTable与-数组" class="headerlink" title="8 使用HashTable与{数组}"></a>8 使用HashTable与{数组}</h1><p>在C语言中，我们可以自定义各种各样的数据结构，用来把很多数据保存在一个变量里面，但是每种数据结构都有自己的优缺点，PHP内核规模如此庞大，是否已经找到了一些非常棒的解决方法呢？</p><h1 id="8-1-使用HashTable与-数组"><a href="#8-1-使用HashTable与-数组" class="headerlink" title="8.1 使用HashTable与{数组}"></a>8.1 使用HashTable与{数组}</h1><p>我们在评选各种数据结构时，往往会考虑我们需要处理的数据规模以及需要的性能。下面让我们简要的看一下看C语言中数组和链表的一些事情。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>作者这里用的不是Array，而是Vector，可能指的是C++里的Vector，<br>它与数组几乎是完全一样的，唯一的不同便是可以实现动态存储。<br>本节下文都是用数组一词代替之，请各位注意。数组是内存中一块连续的区域，其每一个元素都具有一个唯一的下标值。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>]=<span class="number">3</span>;</span><br></pre></td></tr></tbody></table></figure><p>不仅是整数，其它类型的变量也可以保存在数组中，比如我们上一章用到的zend_get_parameters_array_ex()，便把很多zval**类型的变量保存到一个数组里，为了使其正常工作，我们提前向系统申请了相应大小的内存空间。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zval ***args = safe_emalloc(ZEND_NUM_ARGS(), <span class="keyword">sizeof</span>(zval**), <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p>这里我们仍然可以用一个整数来当作下标去数组中取出我们想要的数据，就像var_dump()的实现中通过args[i]来获取参数并把它传递给php_var_dump()函数那样。<br>使用数组最大的好处便是速度！读写都可以在O(1)内完成，因为它每个元素的大小都是一致的，只要知道下标，便可以瞬间计算出其对应的元素在内存中的位置，从而直接取出或者写入。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表也是一种经常被使用的一种数据结构。链表中的每一个元素都至少有两个元素，一个指向它的下一个元素，一个用来存放它自己的数据，就像下面定义的那样：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">namelist</span> <span class="title">namelist</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">namelist</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">namelist</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>我们可以声明一个其类型的元素：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> namelist *people;</span><br></pre></td></tr></tbody></table></figure><p></p><p>假设每一个元素都代表一个人，元素中的name属性便是这个人的名字，我们通过这样的语句来得到它：people-&gt;name; 第二个属性指向后面的一个元素，那我们便可以这样来访问下一个人的名字：people-&gt;next-&gt;name, 或者下一个人的下一个人的名字：people-&gt;next-&gt;next-&gt;name,一次类推，直到next的值是NULL，代表结束。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过一个循环来遍历这个链表中的所有人～</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_show</span><span class="params">(namelist *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Name: %s\n"</span>, p-&gt;name);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>链表可以被用来实现FIFO模式，达到先进者先出的目的！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> namelist *people = <span class="literal">NULL</span>, *last_person = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_add</span><span class="params">(namelist *person)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    person-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!last_person) {</span><br><span class="line">        <span class="comment">/* No one in the list yet */</span></span><br><span class="line">        people = last_person = person;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* Append new person to the end of the list */</span></span><br><span class="line">    last_person-&gt;next = person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the list tail */</span></span><br><span class="line">    last_person = person;</span><br><span class="line">}</span><br><span class="line"><span class="function">namelist *<span class="title">name_pop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    namelist *first_person = people;</span><br><span class="line">    <span class="keyword">if</span> (people) {</span><br><span class="line">    	people = people-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> first_person;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样，我们便可以随意的向这个链表中添加或者删除数据，而不像数组那样，谨慎的考虑是否越界等问题。<br>上面实现的结构的学名叫做单向链表，也有地方叫单链表，反正是比较简单的意思～。它有一个致命的缺点，就是我们在插入或者读取某条数据的时候，都需要从这个链表的开始，一个个元素的向下寻找，直到找到这个元素为止。如果链表中的元素比较多，那它很容易成为我们程序中的CPU消耗大户，进而引起性能问题。为了解决这个问题，先人们发明了双向链表：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">namelist</span> <span class="title">namelist</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	namelist *next, *prev;</span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line">} _namelist;</span><br></pre></td></tr></tbody></table></figure><p>改动其实不大，就是在每个元素中都添加了一个prev属性，用来指向它的上一个元素。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_add</span><span class="params">(namelist *person)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	person-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!last_person)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">/* No one in the list yet */</span></span><br><span class="line">		people = last_person = person;</span><br><span class="line">		person-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* Append new person to the end of the list */</span></span><br><span class="line">	last_person -&gt;next = person;</span><br><span class="line">	person-&gt;prev = last_person;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update the list tail */</span></span><br><span class="line">	last_person = person;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>单单通过上面的程序你还体会不到它的好处，但是设想一下，如果现在你有这个链表中其中一个元素的地址，并且想把它从链表中删除，那我们该怎么做呢？如果是单向链表的话，我们只能这样做：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_remove</span><span class="params">(namelist *person)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    namelist *p;</span><br><span class="line">    <span class="keyword">if</span> (person == people) {</span><br><span class="line">        <span class="comment">/* Happens to be the first person in the list */</span></span><br><span class="line">        people = person-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (last_person == person) {</span><br><span class="line">            <span class="comment">/* Also happens to be the last person */</span></span><br><span class="line">            last_person = <span class="literal">NULL</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* Search for prior person */</span></span><br><span class="line">    p = people;</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next == person) {</span><br><span class="line">            <span class="comment">/* unlink */</span></span><br><span class="line">            p-&gt;next = person-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (last_person == person) {</span><br><span class="line">                <span class="comment">/* This was the last element */</span></span><br><span class="line">                last_person = p;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/* Not found in list */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在让我们来看看双向链表是怎样来处理这个问题的：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">name_remove</span><span class="params">(namelist *person)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (people == person) {</span><br><span class="line">        people = person-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (last_person == person) {</span><br><span class="line">        last_person = person-&gt;prev;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (person-&gt;prev) {</span><br><span class="line"></span><br><span class="line">        person-&gt;prev-&gt;next = person-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (person-&gt;next) {</span><br><span class="line">        person-&gt;next-&gt;prev = person-&gt;prev;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对元素的遍历查找不见了，取而代之的是一个O(1)的运算，这将极大的提升我们程序的性能。</p><h3 id="王者归来：HashTable才是我们的银弹！"><a href="#王者归来：HashTable才是我们的银弹！" class="headerlink" title="王者归来：HashTable才是我们的银弹！"></a>王者归来：HashTable才是我们的银弹！</h3><p>也许你已经非常喜欢使用数组或者链表了，但我还是要向你推荐一种威力极大的数据结构，有了它之后，你可能会立即抛弃前两者，它就是HashTable.<br>HashTable既具有双向链表的优点，同时具有能与数据匹敌的操作性能，这个数据结构几乎是PHP内核实现的基础，我们在内核代码的任何地方都发现它的痕迹。</p><p>第二章我们接触过，所有的用户端定义的变量保存在一个符号表里，而这个符号表其实就是一个HashTable，它的每一个元素都是一个zval*类型的变量。不仅如此，保存用户定义的函数、类、资源等的容器都是以HashTable的形式在内核中实现的。<br>Zend Engine中HashTable的元素其实是指针，对其的这个改进使得HashTable能够包容各种类型的数据，从小小的标量，到复杂的PHP5中实现的类等复合数据。本章接下来的内容，我们将详细的研究如何使用zend内置的API来操作HashTable这个数据结构。</p><h1 id="8-2-使用HashTable与-数组"><a href="#8-2-使用HashTable与-数组" class="headerlink" title="8.2 使用HashTable与{数组}"></a>8.2 使用HashTable与{数组}</h1><p>Zend把与HashTable有关的API分成了好几类以便于我们寻找，这些API的返回值大多都是常量SUCCESS或者FAILURE。</p><h3 id="创建HashTable"><a href="#创建HashTable" class="headerlink" title="创建HashTable"></a>创建HashTable</h3><blockquote><p>下面在介绍函数原型的时候都使用了ht名称，但是我们在编写扩展的时候，<br>一定不要使用这个名称，因为一些PHP宏展开后会声明这个名称的变量，<br>进而引发命名冲突。</p></blockquote><p>创建并初始化一个HashTable非常简单，只要使用zend_hash_init函数即可，它的定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">hash_func_t</span> pHashFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">dtor_func_t</span> pDestructor,</span></span></span><br><span class="line"><span class="function"><span class="params">	zend_bool persistent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>*ht是指针</strong>，指向一个HashTable，我们既可以&amp;一个已存在的HashTable变量，<br>也可以通过emalloc()、pemalloc()等函数来直接申请一块内存，<br>不过最常用的方法还是用ALLOC_HASHTABLE(ht)宏来让内核自动的替我们完成这项工作。<br>ALLOC_HASHTABLE(ht)所做的工作相当于ht = emalloc(sizeof(HashTable));</li><li><strong>nSize</strong>代表着这个HashTable可以拥有的元素的最大数量(HashTable能够包含任意数量的元素，<br>这个值只是为了提前申请好内存，提高性能，省的不停的进行rehash操作)。<br>在我们添加新的元素时，这个值会根据情况决定是否自动增长，有趣的是，<br>这个值永远都是2的次方，如果你给它的值不是一个2的次方的形式，<br>那它将自动调整成大于它的最小的2的次方值。<br>它的计算方法就像这样：nSize = pow(2, ceil(log(nSize, 2)));</li><li><strong>pHashFunction</strong>是早期的Zend Engine中的一个参数，为了兼容没有去掉它，<br>但它已经没有用处了，所以我们直接赋成NULL就可以了。在原来，<br>它其实是一个钩子，用来让用户自己hook一个散列函数，替换php默认的DJBX33A算法实现。</li><li><strong>pDestructor</strong>也代表着一个回调函数，当我们删除或者修改HashTable中其中一个元素时候便会调用，<br>它的函数原型必须是这样的：void method_name(void <em>pElement);这里的</em>pElement是一个指针，指向HashTable中那么将要被删除或者修改的那个数据，而数据的类型往往也是个指针。</li><li><strong>persistent</strong>是最后一个参数，它的含义非常简单。<br>如果它为true，那么这个HashTable将永远存在于内存中，而不会在RSHUTDOWN阶段自动被注销掉。<br>此时第一个参数ht所指向的地址必须是通过pemalloc()函数申请的。</li></ul><p>举个例子，PHP内核在每个Request请求的头部都调用了这个函数来初始化symbol_table。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_init(&amp;EG(symbol_table), <span class="number">50</span>, <span class="literal">NULL</span>, ZVAL_PTR_DTOR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define ZVAL_PTR_DTOR (void (*)(void *)) zval_ptr_dtor_wrapper</span></span><br></pre></td></tr></tbody></table></figure><p>如你所见，每个元素在从符号表里删除的时候(比如执行”&lt;?php unset($foo);”操作)，都会触发ZVAL_PTR_DTOR宏代表的函数来对其进行与引用计数有关的操作。<br>因为50不是2的整数幂形式，所以它会在函数执行时被调成成64。</p><h3 id="添加-amp-amp-修改"><a href="#添加-amp-amp-修改" class="headerlink" title="添加&amp;&amp;修改"></a>添加&amp;&amp;修改</h3><p>我们有四个常用的函数来完成这项操作，它们的原型分别如下：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_add</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,		<span class="comment">//待操作的ht</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *arKey,			<span class="comment">//索引，如"my_key"</span></span></span></span><br><span class="line"><span class="function"><span class="params">	uint nKeyLen,		<span class="comment">//字符串索引的长度，如6</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **pData,		<span class="comment">//要插入的数据，注意它是void **类型的。int *p,i=1;p=&amp;i,pData=&amp;p;。</span></span></span></span><br><span class="line"><span class="function"><span class="params">	uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *pDest			<span class="comment">//如果操作成功，则pDest=*pData;</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_update</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_index_update</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">	ulong h,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_next_index_insert</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>前两个函数用户添加带字符串索引的数据到HashTable中，就像我们在PHP中使用的那样:$foo[‘bar’] = ‘baz’;用C来完成便是：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_add(fooHashTbl, <span class="string">"bar"</span>, <span class="keyword">sizeof</span>(<span class="string">"bar"</span>), &amp;barZval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br></pre></td></tr></tbody></table></figure><p></p><p>zend_hash_add()和zend_hash_update()唯一的区别就是如果这个key已经存在了，那么zend_hash_add()将返回FAILURE，而不会修改原有数据。<br>接下来的两个函数用于像HT中添加数字索引的数据，zend_hash_next_index_insert()函数则不需要索引值参数，而是自己直接计算出下一个数字索引值.<br>但是如果我们想获取下一个元素的数字索引值，也是有办法的，可以使用zend_hash_next_free_element()函数：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulong nextid = zend_hash_next_free_element(ht);</span><br><span class="line">zend_hash_index_update(ht, nextid, &amp;data, <span class="keyword">sizeof</span>(data), <span class="literal">NULL</span>);</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>所有这些函数中，如果pDest不为NULL，内核便会修改其值为被操作的那个元素的地址。在下面的代码中这个参数也有同样的功能。</code></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>因为HashTable中有两种类型的索引值，所以需要两个函数来执行find操作。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_find</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *arKey, uint nKeyLength,<span class="keyword">void</span> **pData)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_index_find</span><span class="params">(HashTable *ht, ulong h, <span class="keyword">void</span> **pData)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>第一种就是我们处理PHP语言中字符串索引数组时使用的，第二种是我们处理PHP语言中数字索引数组使用的。Recall from Chapter 2 that when data is added to a HashTable, a new memory block is allocated for it and the data passed in is copied; when the data is extracted back out it is the pointer to that data which is returned. The following code fragment adds data1 to the HashTable, and then extracts it back out such that at the end of the routine, <em>data2 contains the same contents as </em>data1 even though the pointers refer to different memory addresses.<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_sample</span><span class="params">(HashTable *ht, sample_data *data1)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	sample_data *data2;</span><br><span class="line">	ulong targetID = zend_hash_next_free_element(ht);</span><br><span class="line">	<span class="keyword">if</span> (zend_hash_index_update(ht, targetID,</span><br><span class="line">			data1, <span class="keyword">sizeof</span>(sample_data), <span class="literal">NULL</span>) == FAILURE) {</span><br><span class="line">			<span class="comment">/* Should never happen */</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(zend_hash_index_find(ht, targetID, (<span class="keyword">void</span> **)&amp;data2) == FAILURE) {</span><br><span class="line">		<span class="comment">/* Very unlikely since we just added this element */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* data1 != data2, however *data1 == *data2 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>除了读取，我们还需要检测某个key是否存在：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_exists</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *arKey, uint nKeyLen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_index_exists</span><span class="params">(HashTable *ht, ulong h)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>这两个函数返回SUCCESS或者FAILURE，分别代表着是否存在：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( zend_hash_exists(EG(active_symbol_table),<span class="string">"foo"</span>, <span class="keyword">sizeof</span>(<span class="string">"foo"</span>)) == SUCCESS )</span><br><span class="line">{</span><br><span class="line">	<span class="comment">/* $foo is set */</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">/* $foo does not exist */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="提速"><a href="#提速" class="headerlink" title="提速!"></a>提速!</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ulong <span class="title">zend_get_hash_value</span><span class="params">(<span class="keyword">char</span> *arKey, uint nKeyLen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>当我们需要对同一个字符串的key进行许多操作时候，比如先检测有没，然后插入，然后修改等等，这时我们便可以使用zend_get_hash_value函数来对我们的操作进行加速！这个函数的返回值可以和quick系列函数使用，达到加速的目的(就是不再重复计算这个字符串的散列值，而直接使用已准备好的)！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_quick_add</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">	ulong hashval,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_quick_update</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">	ulong hashval,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *pData,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nDataSize,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **pDest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_quick_find</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">	ulong hashval,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> **pData</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_quick_exists</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *ht,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">char</span> *arKey,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint nKeyLen,</span></span></span><br><span class="line"><span class="function"><span class="params">	ulong hashval</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>虽然很意外，但你还是要接受没有zend_hash_quick_del()这个函数。quick类函数会在下面这种场合中用到：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample_hash_copy</span><span class="params">(HashTable *hta, HashTable *htb,<span class="keyword">char</span> *arKey, uint nKeyLen TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ulong hashval = zend_get_hash_value(arKey, nKeyLen);</span><br><span class="line">    zval **copyval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_quick_find(hta, arKey, nKeyLen,hashval, (<span class="keyword">void</span>**)&amp;copyval) == FAILURE)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//标明不存在这个索引</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个zval已经被其它的Hashtable使用了，这里我们进行引用计数操作。</span></span><br><span class="line">    (*copyval)-&gt;refcount__gc++;</span><br><span class="line">    zend_hash_quick_update(htb, arKey, nKeyLen, hashval,copyval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="复制与合并-Copy-And-Merge"><a href="#复制与合并-Copy-And-Merge" class="headerlink" title="复制与合并(Copy And Merge)"></a>复制与合并(Copy And Merge)</h3><p>在PHP语言中，我们经常需要进行数组间的Copy与Merge操作，所以php语言中的数组在C语言中的实现HashTable也肯定会经常碰到这种情况。为了简化这一类操作，内核中早已准备好了相应的API供我们使用。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_copy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *target,</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *source,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">copy_ctor_func_t</span> pCopyConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *tmp,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint <span class="built_in">size</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>*source中的所有元素都会通过pCopyConstructor函数Copy到*target中去，我们还是以PHP语言中的数组举例，pCopyConstructor这个hook使得我们可以在copy变量的时候对他们的ref_count进行加一操作。target中原有的与source中索引位置的数据会被替换掉，而其它的元素则会被保留，原封不动。</li><li>tmp参数是为了兼容PHP4.0.3以前版本的，现在赋值为NULL即可。</li><li>size参数代表每个元素的大小，对于PHP语言中的数组来说，这里的便是sizeof(zval*)了。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_merge</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *target,</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *source,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">copy_ctor_func_t</span> pCopyConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *tmp,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> overwrite</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>zend_hash_merge()与zend_hash_copy唯一的不同便是多了个int类型的overwrite参数，当其值非0的时候，两个函数的工作是完全一样的；如果overwrite参数为0，则zend_hash_merge函数就不会对target中已有索引的值进行替换了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">zend_bool</span> <span class="params">(*<span class="keyword">merge_checker_func_t</span>)</span><span class="params">(HashTable *target_ht,<span class="keyword">void</span> *source_data, zend_hash_key *hash_key, <span class="keyword">void</span> *pParam)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_merge_ex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *target,</span></span></span><br><span class="line"><span class="function"><span class="params">	HashTable *source,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">copy_ctor_func_t</span> pCopyConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">	uint <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">merge_checker_func_t</span> pMergeSource,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">void</span> *pParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>这个函数又繁琐了些，与zend_hash_copy相比，其多了两个参数，多出来的pMergeSoure回调函数允许我们选择性的进行merge，而不是全都merge。The final form of this group of functions allows for selective copying using a merge checker function. The following example shows zend_hash_merge_ex() in use to copy only the associatively indexed members of the source HashTable (which happens to be a userspace variable array):<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zend_bool <span class="title">associative_only</span><span class="params">(HashTable *ht, <span class="keyword">void</span> *pData,zend_hash_key *hash_key, <span class="keyword">void</span> *pParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//如果是字符串索引</span></span><br><span class="line">    <span class="keyword">return</span> (hash_key-&gt;arKey &amp;&amp; hash_key-&gt;nKeyLength);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_associative</span><span class="params">(HashTable *target, HashTable *source)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    zend_hash_merge_ex(target, source, zval_add_ref,<span class="keyword">sizeof</span>(zval*), associative_only, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>在PHP语言中，我们有很多方法来遍历一个数组，对于数组的本质HashTable，我们也有很多办法来对其进行遍历操作。首先最简单的一种办法便是使用一种与PHP语言中foreach语句功能类似的函数——zend_hash_apply，它接收一个回调函数，并将HashTable的每一个元素都传递给它。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">apply_func_t</span>)</span><span class="params">(<span class="keyword">void</span> *pDest TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_apply</span><span class="params">(HashTable *ht,<span class="keyword">apply_func_t</span> apply_func TSRMLS_DC)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>下面是另外一种遍历函数：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">apply_func_arg_t</span>)</span><span class="params">(<span class="keyword">void</span> *pDest,<span class="keyword">void</span> *argument TSRMLS_DC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_apply_with_argument</span><span class="params">(HashTable *ht,<span class="keyword">apply_func_arg_t</span> apply_func, <span class="keyword">void</span> *data TSRMLS_DC)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>通过上面的函数可以在执行遍历时向回调函数传递任意数量的值，这在一些diy操作中非常有用。</p><p>上述函数对传给它们的回调函数的返回值有一个共同的约定，详细介绍下下表：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">表格 <span class="number">8.1</span>. 回调函数的返回值</span><br><span class="line">Constant						Meaning</span><br><span class="line"></span><br><span class="line">ZEND_HASH_APPLY_KEEP		结束当前请求，进入下一个循环。与PHP语言foreach语句中的一次循环执行完毕或者遇到<span class="keyword">continue</span>关键字的作用一样。</span><br><span class="line">ZEND_HASH_APPLY_STOP		跳出，与PHP语言foreach语句中的<span class="keyword">break</span>关键字的作用一样。</span><br><span class="line">ZEND_HASH_APPLY_REMOVE		删除当前的元素，然后继续处理下一个。相当于在PHP语言中：unset($foo[$key]);<span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure><p>我们来一下PHP语言中的foreach循环：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $val) {</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"The value is: $val\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>那我们的回调函数在C语言中应该这样写：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_sample_print_zval</span><span class="params">(zval **val TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//重新copy一个zval，防止破坏原数据</span></span><br><span class="line">    zval tmpcopy = **val;</span><br><span class="line">    zval_copy_ctor(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换为字符串</span></span><br><span class="line">    INIT_PZVAL(&amp;tmpcopy);</span><br><span class="line">    convert_to_string(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//开始输出</span></span><br><span class="line">    php_printf(<span class="string">"The value is: "</span>);</span><br><span class="line">    PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));</span><br><span class="line">    php_printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//毁尸灭迹</span></span><br><span class="line">    zval_dtor(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//返回，继续遍历下一个～</span></span><br><span class="line">	<span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>遍历我们的HashTable：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个名为arrht、元素为zval*类型的HashTable</span></span><br><span class="line">zend_hash_apply(arrht, php_sample_print_zval TSRMLS_CC);</span><br></pre></td></tr></tbody></table></figure><p></p><blockquote><p>再次提醒，保存在HashTable中的元素并不是真正的最终变量，而是指向它的一个指针。我们的上面的遍历函数接收的是一个zval**类型的参数。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">apply_func_args_t</span>)</span><span class="params">(<span class="keyword">void</span> *pDest,<span class="keyword">int</span> num_args, va_list args, zend_hash_key *hash_key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_apply_with_arguments</span><span class="params">(HashTable *ht,<span class="keyword">apply_func_args_t</span> apply_func, <span class="keyword">int</span> numargs, ...)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><p>为了能在遍历时同时接收索引的值，我们必须使用第三种形式的zend_hash_apply！就像PHP语言中这样的功能：<br></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $key =&gt; $val)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"The value of $key is: $val\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>为了配合zend_hash_apply_with_arguments()函数，我们需要对我们的遍历执行函数做一下小小的改动，使其接受索引作为一个参数：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">php_sample_print_zval_and_key</span><span class="params">(zval **val,<span class="keyword">int</span> num_args,va_list args,zend_hash_key *hash_key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//重新copy一个zval，防止破坏原数据</span></span><br><span class="line">	zval tmpcopy = **val;</span><br><span class="line">	<span class="comment">/* tsrm_ls is needed by output functions */</span></span><br><span class="line">	TSRMLS_FETCH();</span><br><span class="line">	zval_copy_ctor(&amp;tmpcopy);</span><br><span class="line">	INIT_PZVAL(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转换为字符串</span></span><br><span class="line">	convert_to_string(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//执行输出</span></span><br><span class="line">	php_printf(<span class="string">"The value of "</span>);</span><br><span class="line">	<span class="keyword">if</span> (hash_key-&gt;nKeyLength)</span><br><span class="line">	{</span><br><span class="line">        <span class="comment">//如果是字符串类型的key</span></span><br><span class="line">		PHPWRITE(hash_key-&gt;arKey, hash_key-&gt;nKeyLength);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//如果是数字类型的key</span></span><br><span class="line">		php_printf(<span class="string">"%ld"</span>, hash_key-&gt;h);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	php_printf(<span class="string">" is: "</span>);</span><br><span class="line">	PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));</span><br><span class="line">	php_printf(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//毁尸灭迹</span></span><br><span class="line">	zval_dtor(&amp;tmpcopy);</span><br><span class="line">	<span class="comment">/* continue; */</span></span><br><span class="line">	<span class="keyword">return</span> ZEND_HASH_APPLY_KEEP;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>执行遍历：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_apply_with_arguments(arrht,php_sample_print_zval_and_key, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><div class="tip-common">这个函数通过C语言中的可变参数特性来接收参数。This particular example required no arguments to be passed; for information on extracting variable argument lists from va_list args, see the POSIX documentation pages for va_start(), va_arg(), and va_end().</div><p>当我们检查这个hash_key是字符串类型还是数字类型时，是通过nKeyLength属性来检测的,而不是arKey属性。这是因为内核有时候会留在arKey属性里些脏数据，但nKeyLength属性是安全的，可以安全的使用。甚至对于空字符串索引，它也照样能处理。比如：$foo[‘’] =”Bar”;索引的值是NULL字符，但它的长度却是包括最后这个NULL字符的，所以为1。</p><h3 id="向前遍历HashTable"><a href="#向前遍历HashTable" class="headerlink" title="向前遍历HashTable"></a>向前遍历HashTable</h3><p>有时我们希望不用回调函数也能遍历一个数组的数据，为了实现这个功能，内核特意的为每个HashTable加了个属性：The internal pointer（内部指针）。&lt;/p?<br>我们还是以PHP语言中的数组举例，有以下函数来处理它所对应的那个HashTable的内部指针：reset(), key(), current(), next(), prev(), each(), and end()。</p><p><br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $arr = <span class="built_in">array</span>(<span class="string">'a'</span>=&gt;<span class="number">1</span>, <span class="string">'b'</span>=&gt;<span class="number">2</span>, <span class="string">'c'</span>=&gt;<span class="number">3</span>);</span><br><span class="line">    reset($arr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span>($key, $val) = each($arr)) {</span><br><span class="line">        <span class="comment">/* Do something with $key and $val */</span></span><br><span class="line">    }</span><br><span class="line">    reset($arr);</span><br><span class="line">    $firstkey = key($arr);</span><br><span class="line">    $firstval = current($arr);</span><br><span class="line">    $bval = next($arr);</span><br><span class="line">    $cval = next($arr);</span><br><span class="line">?&gt;</span><br></pre></td></tr></tbody></table></figure><p></p><p>ZEND内核中有一组操作HashTable的功能与以上函数功能类似的函数：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reset() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_internal_pointer_reset</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* key() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_get_current_key</span><span class="params">(HashTable *ht,<span class="keyword">char</span> **strIdx, unit *strIdxLen,ulong *numIdx, zend_bool duplicate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* current() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_get_current_data</span><span class="params">(HashTable *ht, <span class="keyword">void</span> **pData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* next()/each() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_move_forward</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prev() */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_move_backwards</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* end() */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_internal_pointer_end</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他的...... */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_get_current_key_type</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_has_more_elements</span><span class="params">(HashTable *ht)</span></span>;</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;div class="tip-common"&gt;PHP语言中的next()、prev()、end()函数在移动完指针之后，都通过调用zend_hash_get_current_data()函数来获取当前所指的元素并返回。而each()虽然和next()很像，却是使用zend_hash_get_current_key()函数的返回值来作为它的返回值。&lt;/div&gt;
</code></pre><p>现在我们用另外一种方法来实现上面的foreach：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample_print_var_hash</span><span class="params">(HashTable *arrht)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(</span><br><span class="line">    	zend_hash_internal_pointer_reset(arrht);</span><br><span class="line">    	zend_hash_has_more_elements(arrht) == SUCCESS;</span><br><span class="line">    	zend_hash_move_forward(arrht))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">char</span> *key;</span><br><span class="line">        uint keylen;</span><br><span class="line">        ulong idx;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        zval **ppzval, tmpcopy;</span><br><span class="line"></span><br><span class="line">        type = zend_hash_get_current_key_ex(arrht, &amp;key, &amp;keylen,&amp;idx, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (zend_hash_get_current_data(arrht, (<span class="keyword">void</span>**)&amp;ppzval) == FAILURE)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* Should never actually fail</span></span><br><span class="line"><span class="comment">             * since the key is known to exist. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新copy一个zval，防止破坏原数据</span></span><br><span class="line">        tmpcopy = **ppzval;</span><br><span class="line">        zval_copy_ctor(&amp;tmpcopy);</span><br><span class="line">        INIT_PZVAL(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">        convert_to_string(&amp;tmpcopy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Output */</span></span><br><span class="line">        php_printf(<span class="string">"The value of "</span>);</span><br><span class="line">        <span class="keyword">if</span> (type == HASH_KEY_IS_STRING)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* String Key / Associative */</span></span><br><span class="line">            PHPWRITE(key, keylen);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/* Numeric Key */</span></span><br><span class="line">            php_printf(<span class="string">"%ld"</span>, idx);</span><br><span class="line">        }</span><br><span class="line">        php_printf(<span class="string">" is: "</span>);</span><br><span class="line">        PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));</span><br><span class="line">        php_printf(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">/* Toss out old copy */</span></span><br><span class="line">        zval_dtor(&amp;tmpcopy);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>上面的代码你应该都能看懂了，唯一还没接触到的可能是zend_hash_get_current_key()函数的返回值，它的返回值见表8.2。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constant							Meaning</span><br><span class="line"></span><br><span class="line">HASH_KEY_IS_STRING				当前元素的索引是字符串类型的。therefore, a pointer to the element's key name will be populated into strIdx, and its length will be populated into stdIdxLen. If the duplicate flag is set to a nonzero value, the key will be estrndup()'d before being populated into strIdx. The calling application is expected to free this duplicated string.</span><br><span class="line"></span><br><span class="line">HASH_KEY_IS_LONG				当前元素的索引是数字型的。</span><br><span class="line">HASH_KEY_NON_EXISTANT			HashTable中的内部指针已经移动到尾部，不指向任何元素。</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="Preserving-the-Internal-Pointer"><a href="#Preserving-the-Internal-Pointer" class="headerlink" title="Preserving the Internal Pointer"></a>Preserving the Internal Pointer</h3><p>在我们遍历一个HashTable时，一般是很难陷入死循环的。When iterating through a HashTable, particularly one containing userspace variables, it’s not uncommon to encounter circular references, or at least self-overlapping loops. If one iteration context starts looping through a HashTable and the internal pointer reachesfor examplethe halfway mark, a subordinate iterator starts looping through the same HashTable and would obliterate the current internal pointer position, leaving the HashTable at the end when it arrived back at the first loop.</p><p>The way this is resolvedboth within the zend_hash_apply implementation and within custom move forward usesis to supply an external pointer in the form of a HashPosition variable.</p><p>Each of the zend_hash_<em>() functions listed previously has a zend_hash_</em>_ex() counterpart that accepts one additional parameter in the form of a pointer to a HashPostion data type. Because the HashPosition variable is seldom used outside of a short-lived iteration loop, it’s sufficient to declare it as an immediate variable. You can then dereference it on usage such as in the following variation on the php_sample_print_var_hash() function you saw earlier:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample_print_var_hash</span><span class="params">(HashTable *arrht)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HashPosition pos;</span><br><span class="line">    <span class="keyword">for</span>(zend_hash_internal_pointer_reset_ex(arrht, &amp;pos);</span><br><span class="line">    zend_hash_has_more_elements_ex(arrht, &amp;pos) == SUCCESS;</span><br><span class="line">    zend_hash_move_forward_ex(arrht, &amp;pos)) {</span><br><span class="line">        <span class="keyword">char</span> *key;</span><br><span class="line">        uint keylen;</span><br><span class="line">        ulong idx;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">        zval **ppzval, tmpcopy;</span><br><span class="line"></span><br><span class="line">        type = zend_hash_get_current_key_ex(arrht,</span><br><span class="line">                                &amp;key, &amp;keylen,</span><br><span class="line">                                &amp;idx, <span class="number">0</span>, &amp;pos);</span><br><span class="line">        <span class="keyword">if</span> (zend_hash_get_current_data_ex(arrht,</span><br><span class="line">                    (<span class="keyword">void</span>**)&amp;ppzval, &amp;pos) == FAILURE) {</span><br><span class="line">            <span class="comment">/* Should never actually fail</span></span><br><span class="line"><span class="comment">             * since the key is known to exist. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/* Duplicate the zval so that</span></span><br><span class="line"><span class="comment">         * the original's contents are not destroyed */</span></span><br><span class="line">        tmpcopy = **ppzval;</span><br><span class="line">        zval_copy_ctor(&amp;tmpcopy);</span><br><span class="line">        <span class="comment">/* Reset refcount &amp; Convert */</span></span><br><span class="line">        INIT_PZVAL(&amp;tmpcopy);</span><br><span class="line">        convert_to_string(&amp;tmpcopy);</span><br><span class="line">        <span class="comment">/* Output */</span></span><br><span class="line">        php_printf(<span class="string">"The value of "</span>);</span><br><span class="line">        <span class="keyword">if</span> (type == HASH_KEY_IS_STRING) {</span><br><span class="line">            <span class="comment">/* String Key / Associative */</span></span><br><span class="line">            PHPWRITE(key, keylen);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/* Numeric Key */</span></span><br><span class="line">            php_printf(<span class="string">"%ld"</span>, idx);</span><br><span class="line">        }</span><br><span class="line">        php_printf(<span class="string">" is: "</span>);</span><br><span class="line">        PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));</span><br><span class="line">        php_printf(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">/* Toss out old copy */</span></span><br><span class="line">        zval_dtor(&amp;tmpcopy);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">With these very slight additions, the HashTable's true internal pointer is preserved in whatever state it was initially in on entering the function. When it comes to working with internal pointers of userspace variable HashTables (that is, arrays), this extra step will very likely make the difference between whether the scripter's code works as expected.</span><br><span class="line">### 删除</span><br><span class="line">内核中一共预置了四个删除HashTable元素的函数，头两个是用户删除某个确定索引的数据：</span><br><span class="line">&lt;code c&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_del</span><span class="params">(HashTable *ht, <span class="keyword">char</span> *arKey, uint nKeyLen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_index_del</span><span class="params">(HashTable *ht, ulong h)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>它们两个分别用来删除字符串索引和数字索引的数据，操作完成后都返回SUCCESS或者FAILURE表示成功or失败。<br>回顾一下最上面的叙述，当一个元素被删除时，会激活HashTable的destructor回调函数。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_clean</span><span class="params">(HashTable *ht)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zend_hash_destroy</span><span class="params">(HashTable *ht)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>前者用于将HashTable中的元素全部删除，而后者是将这个HashTable自身也毁灭掉。<br>现在让我们来完整的回顾一下HashTable的创建、添加、删除操作。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sample_strvec_handler</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HashTable *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配内存</span></span><br><span class="line">    ALLOC_HASHTABLE(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span> (zend_hash_init(ht, argc, <span class="literal">NULL</span>,ZVAL_PTR_DTOR, <span class="number">0</span>) == FAILURE) {</span><br><span class="line">        FREE_HASHTABLE(ht);</span><br><span class="line">        <span class="keyword">return</span> FAILURE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充数据</span></span><br><span class="line">    <span class="keyword">while</span> (argc) {</span><br><span class="line">        zval *value;</span><br><span class="line">        MAKE_STD_ZVAL(value);</span><br><span class="line">        ZVAL_STRING(value, argv[argc], <span class="number">1</span>);</span><br><span class="line">        argv++;</span><br><span class="line">        <span class="keyword">if</span> (zend_hash_next_index_insert(ht, (<span class="keyword">void</span>**)&amp;value,</span><br><span class="line">                            <span class="keyword">sizeof</span>(zval*)) == FAILURE) {</span><br><span class="line">            <span class="comment">/* Silently skip failed additions */</span></span><br><span class="line">            zval_ptr_dtor(&amp;value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成工作</span></span><br><span class="line">    process_hashtable(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//毁尸灭迹</span></span><br><span class="line">    zend_hash_destroy(ht);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放ht 为什么不在destroy里free呢，求解释！</span></span><br><span class="line">    FREE_HASHTABLE(ht);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="排序、比较and-Going-to-the-Extreme-s"><a href="#排序、比较and-Going-to-the-Extreme-s" class="headerlink" title="排序、比较and Going to the Extreme(s)"></a>排序、比较and Going to the Extreme(s)</h3><p>针对HashTable操作的Zend Api中有很多都需要回调函数。首先让我们来处理一下对HashTable中元素大小比较的问题：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">compare_func_t</span>)</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b TSRMLS_DC)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>这很像PHP语言中usort函数需要的参数，它将比较两个值<em>a与</em>b，如果<em>a&gt;</em>b,则返回1，相等则返回0，否则返回-1。下面是zend_hash_minmax函数的声明，它就需要我们上面声明的那个类型的函数作为回调函数：<br>int zend_hash_minmax(HashTable *ht, compare_func_t compar,int flag, void **pData TSRMLS_DC);<br>这个函数的功能我们从它的名称中便能肯定，它用来比较HashTable中的元素大小。如果flag==0则返回最小值，否则返回最大值！</p><p>下面让我们来利用这个函数来对用户端定义的所有函数根据函数名找到最大值与最小值(大小写不敏感～)。<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个比较函数，作为zend_hash_minmax的回调函数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fname_compare</span><span class="params">(zend_function *a, zend_function *b TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> strcasecmp(a-&gt;common.function_name, b-&gt;common.function_name);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_sample_funcname_sort</span><span class="params">(TSRMLS_D)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    zend_function *fe;</span><br><span class="line">    <span class="keyword">if</span> (zend_hash_minmax(EG(function_table), fname_compare,<span class="number">0</span>, (<span class="keyword">void</span> **)&amp;fe) == SUCCESS)</span><br><span class="line">    {</span><br><span class="line">        php_printf(<span class="string">"Min function: %s\n"</span>, fe-&gt;common.function_name);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (zend_hash_minmax(EG(function_table), fname_compare,<span class="number">1</span>, (<span class="keyword">void</span> **)&amp;fe) == SUCCESS)</span><br><span class="line">    {</span><br><span class="line">        php_printf(<span class="string">"Max function: %s\n"</span>, fe-&gt;common.function_name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>zend_hash_compare()也许要回调函数，它的功能是将HashTable看作一个整体与另一个HashTable做比较，如果前者大于后者返回1，相等返回0，否则返回-1。</p><p></p><p>int zend_hash_compare(HashTable <em>hta, HashTable </em>htb,compare_func_t compar, zend_bool ordered TSRMLS_DC);</p><p>默认情况下它往往是先判断各个HashTable元素的个数，个数多的最大！<br>如果两者的元素一样多，然后就比较它们各自的第一个元素，If the ordered flag is set, it compares keys/indices with the first element of htb string keys are compared first on length, and then on binary sequence using memcmp(). If the keys are equal, the value of the element is compared with the first element of htb using the comparison callback function.<br>If the ordered flag is not set, the data portion of the first element of hta is compared against the element with a matching key/index in htb using the comparison callback function. If no matching element can be found for htb, then hta is considered greater than htb and 1 is returned.<br>If at the end of a given loop, hta and htb are still considered equal, comparison continues with the next element of hta until a difference is found or all elements have been exhausted, in which case 0 is returned.<br>另外一个重要的需要回调函数的API便是排序函数，它需要的回调函数形式是这样的：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sort_func_t</span>)</span><span class="params">(<span class="keyword">void</span> **Buckets, <span class="keyword">size_t</span> numBuckets,<span class="keyword">size_t</span> sizBucket, <span class="keyword">compare_func_t</span> comp TSRMLS_DC)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>This callback will be triggered once, and receive a vector of all the Buckets (elements) in the HashTable as a series of pointers. These Buckets may be swapped around within the vector according to the sort function’s own logic with or without the use of the comparison callback. In practice, sizBucket will always be sizeof(Bucket*).</p><p>Unless you plan on implementing your own alternative bubblesort method, you won’t need to implement a sort function yourself. A predefined sort methodzend_qsortalready exists for use as a callback to zend_hash_sort() leaving you to implement the comparison function only.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zend_hash_sort</span><span class="params">(HashTable *ht, <span class="keyword">sort_func_t</span> sort_func,<span class="keyword">compare_func_t</span> compare_func, <span class="keyword">int</span> renumber TSRMLS_DC)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>最后一个参数如果为TRUE，则会抛弃HashTable中原有的索引-键关系，将对排列好的新值赋予新的数字键值。PHP语言中的sort函数实现如下：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_hash_sort(target_hash, zend_qsort,array_data_compare, <span class="number">1</span> TSRMLS_CC);</span><br></pre></td></tr></tbody></table></figure><p></p><p>array_data_compare是一个返回compare_func_t类型数据的函数，它将按照HashTable中zval*值的大小进行排序。</p><h1 id="8-3-使用HashTable与-数组"><a href="#8-3-使用HashTable与-数组" class="headerlink" title="8.3 使用HashTable与{数组}"></a>8.3 使用HashTable与{数组}</h1><p>当你在扩展中使用HashTable时候，95%是要存储用户端的变量，就像PHP语言中数组那样。为此，内核中已经准备好了相应的工具，来让我们更加的方便的操作HashTable存储zval*，也就是PHP语言中的数组，即IS_ARRAY常量代表的zval，以下用{数组}来代替PHP语言中的数组这个词。</p><h3 id="创建-数组"><a href="#创建-数组" class="headerlink" title="创建{数组}"></a>创建{数组}</h3><p>创建HashTable有些繁琐，虽然有辅助的宏但还是不能一步完成，而创建{数组}便简单多了，直接使用array_init(zval <em>arrval)函数即可，注意它的参数是zval</em>类型的！<br>这样，我们像用户端返回数组便简单多了：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_array)</span><br><span class="line">{</span><br><span class="line">	array_init(return_value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//return_value是zval*类型的，所以我们直接对它调用array_init()函数即可，即把它初始化成了一个空数组。</span></span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="增！"><a href="#增！" class="headerlink" title="增！"></a>增！</h3><p>将{数组}初始化后，接下来就要向其添加元素了。因为PHP语言中有多种类型的变量，所以也对应的有多种类型的add_assoc_<em>()、add_index_</em>、add_next_index_*()函数。如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array_init(arrval);</span><br><span class="line"></span><br><span class="line">add_assoc_long(zval *arrval, <span class="keyword">char</span> *key, <span class="keyword">long</span> lval);</span><br><span class="line">add_index_long(zval *arrval, ulong idx, <span class="keyword">long</span> lval);</span><br><span class="line">add_next_index_long(zval *arrval, <span class="keyword">long</span> lval);</span><br></pre></td></tr></tbody></table></figure><p>这三个函数的第一个参数都要被操作的{数组}指针，然后是索引值，最后是变量，唯一不同的是add_next_index_long()函数的索引值是其自己计算出来的。根据上一节的内容我们可以知道，这三个函数分别在内部使用了zend_hash_update()、zend_hash_index_update()与zend_hash_next_index_insert函数。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add_assoc_*系列函数：</span></span><br><span class="line">add_assoc_null(zval *aval, <span class="keyword">char</span> *key);</span><br><span class="line">add_assoc_bool(zval *aval, <span class="keyword">char</span> *key, zend_bool bval);</span><br><span class="line">add_assoc_long(zval *aval, <span class="keyword">char</span> *key, <span class="keyword">long</span> lval);</span><br><span class="line">add_assoc_double(zval *aval, <span class="keyword">char</span> *key, <span class="keyword">double</span> dval);</span><br><span class="line">add_assoc_string(zval *aval, <span class="keyword">char</span> *key, <span class="keyword">char</span> *strval, <span class="keyword">int</span> dup);</span><br><span class="line">add_assoc_stringl(zval *aval, <span class="keyword">char</span> *key,<span class="keyword">char</span> *strval, uint <span class="built_in">strlen</span>, <span class="keyword">int</span> dup);</span><br><span class="line">add_assoc_zval(zval *aval, <span class="keyword">char</span> *key, zval *value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//备注：其实这些函数都是宏，都是对add_assoc_*_ex函数的封装。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add_index_*系列函数：</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_long</span>		<span class="params">(zval *arg, ulong idx, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_null</span>		<span class="params">(zval *arg, ulong idx			)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_bool</span>		<span class="params">(zval *arg, ulong idx, <span class="keyword">int</span> b	)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_resource</span>	<span class="params">(zval *arg, ulong idx, <span class="keyword">int</span> r	)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_double</span>	<span class="params">(zval *arg, ulong idx, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_string</span>	<span class="params">(zval *arg, ulong idx, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> duplicate)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_stringl</span>	<span class="params">(zval *arg, ulong idx, <span class="keyword">const</span> <span class="keyword">char</span> *str, uint length, <span class="keyword">int</span> duplicate)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_index_zval</span>		<span class="params">(zval *arg, ulong index, zval *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add_next_index_long函数：</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_long</span>		<span class="params">(zval *arg, <span class="keyword">long</span> n	)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_null</span>		<span class="params">(zval *arg			)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_bool</span>		<span class="params">(zval *arg, <span class="keyword">int</span> b	)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_resource</span>	<span class="params">(zval *arg, <span class="keyword">int</span> r	)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_double</span>		<span class="params">(zval *arg, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_string</span>		<span class="params">(zval *arg, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> duplicate)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_stringl</span>		<span class="params">(zval *arg, <span class="keyword">const</span> <span class="keyword">char</span> *str, uint length, <span class="keyword">int</span> duplicate)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">add_next_index_zval</span>		<span class="params">(zval *arg, zval *value)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>每组函数最后的一个，即zend…_zval()函数，允许我们向这个{数组}中添加资源、对象、{数组}等复合类型的PHP变量。下面让我们通过一个例子来演示下它们的用法：<br></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(sample_array)</span><br><span class="line">{</span><br><span class="line">	zval *subarray;</span><br><span class="line"></span><br><span class="line">	array_init(return_value);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add some scalars */</span></span><br><span class="line">	add_assoc_long(return_value, <span class="string">"life"</span>, <span class="number">42</span>);</span><br><span class="line">	add_index_bool(return_value, <span class="number">123</span>, <span class="number">1</span>);</span><br><span class="line">	add_next_index_double(return_value, <span class="number">3.1415926535</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Toss in a static string, dup'd by PHP */</span></span><br><span class="line">	add_next_index_string(return_value, <span class="string">"Foo"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now a manually dup'd string */</span></span><br><span class="line">	add_next_index_string(return_value, estrdup(<span class="string">"Bar"</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a subarray */</span></span><br><span class="line">	MAKE_STD_ZVAL(subarray);</span><br><span class="line">	array_init(subarray);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Populate it with some numbers */</span></span><br><span class="line">	add_next_index_long(subarray, <span class="number">1</span>);</span><br><span class="line">	add_next_index_long(subarray, <span class="number">20</span>);</span><br><span class="line">	add_next_index_long(subarray, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Place the subarray in the parent */</span></span><br><span class="line">	add_index_zval(return_value, <span class="number">444</span>, subarray);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>这时如果我们用户端var_dump这个函数的返回值便会得到：<br></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(sample_array());</span><br></pre></td></tr></tbody></table></figure><p></p><p>输出：<br></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">6</span>)</span><br><span class="line">{</span><br><span class="line">	[<span class="string">"life"</span>]=&gt; int(<span class="number">42</span>)</span><br><span class="line">	[<span class="number">123</span>]=&gt; bool(<span class="keyword">true</span>)</span><br><span class="line">	[<span class="number">124</span>]=&gt; float(<span class="number">3.1415926535</span>)</span><br><span class="line">	[<span class="number">125</span>]=&gt; string(<span class="number">3</span>) <span class="string">"Foo"</span></span><br><span class="line">	[<span class="number">126</span>]=&gt; string(<span class="number">3</span>) <span class="string">"Bar"</span></span><br><span class="line">	[<span class="number">444</span>]=&gt; <span class="keyword">array</span>(<span class="number">3</span>)</span><br><span class="line">	{</span><br><span class="line">		[<span class="number">0</span>]=&gt; int(<span class="number">1</span>)</span><br><span class="line">		[<span class="number">1</span>]=&gt; int(<span class="number">20</span>)</span><br><span class="line">		[<span class="number">2</span>]=&gt; int(<span class="number">300</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="8-4-使用HashTable与-数组"><a href="#8-4-使用HashTable与-数组" class="headerlink" title="8.4 使用HashTable与{数组}"></a>8.4 使用HashTable与{数组}</h1><p>我们用了很长的篇幅在这一章描述内核中的HashTable结构以及PHP中的数组实现。在接下来的时间中，我们会在它的基础上学习一下内核是怎样实现与管理PHP语言中的资源与类的。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/php-ext/" rel="tag"># php_ext</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/bb08f365.html" rel="next" title="7 函数的参数"><i class="fa fa-chevron-left"></i> 7 函数的参数</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/3610f3f6.html" rel="prev" title="9 PHP中的资源类型">9 PHP中的资源类型 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">phantom9999</p><p class="site-description motion-element" itemprop="description">cpp,php相关的个人博客</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">131</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">24</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/phantom9999" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#8-使用HashTable与-数组"><span class="nav-number">1.</span> <span class="nav-text">8 使用HashTable与{数组}</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-1-使用HashTable与-数组"><span class="nav-number">2.</span> <span class="nav-text">8.1 使用HashTable与{数组}</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">2.0.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number">2.0.2.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#王者归来：HashTable才是我们的银弹！"><span class="nav-number">2.0.3.</span> <span class="nav-text">王者归来：HashTable才是我们的银弹！</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#8-2-使用HashTable与-数组"><span class="nav-number">3.</span> <span class="nav-text">8.2 使用HashTable与{数组}</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建HashTable"><span class="nav-number">3.0.1.</span> <span class="nav-text">创建HashTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加-amp-amp-修改"><span class="nav-number">3.0.2.</span> <span class="nav-text">添加&amp;&amp;修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找"><span class="nav-number">3.0.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提速"><span class="nav-number">3.0.4.</span> <span class="nav-text">提速!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制与合并-Copy-And-Merge"><span class="nav-number">3.0.5.</span> <span class="nav-text">复制与合并(Copy And Merge)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历"><span class="nav-number">3.0.6.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向前遍历HashTable"><span class="nav-number">3.0.7.</span> <span class="nav-text">向前遍历HashTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Preserving-the-Internal-Pointer"><span class="nav-number">3.0.8.</span> <span class="nav-text">Preserving the Internal Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序、比较and-Going-to-the-Extreme-s"><span class="nav-number">3.0.9.</span> <span class="nav-text">排序、比较and Going to the Extreme(s)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-3-使用HashTable与-数组"><span class="nav-number">4.</span> <span class="nav-text">8.3 使用HashTable与{数组}</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-数组"><span class="nav-number">4.0.1.</span> <span class="nav-text">创建{数组}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增！"><span class="nav-number">4.0.2.</span> <span class="nav-text">增！</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-4-使用HashTable与-数组"><span class="nav-number">5.</span> <span class="nav-text">8.4 使用HashTable与{数组}</span></a></li></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">© <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">phantom9999</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 — <a class="theme-link" target="_blank" rel="external nofollow" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.3.0</div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script type="text/javascript" src="/bundle.js"></script><script type="text/javascript">// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });;
L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":true,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>